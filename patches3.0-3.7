Index: ./doc/Amiga.doc
diff -r ../vim3.0/doc/Amiga.doc ./doc/Amiga.doc
50a51,54
> 
> Commands that accept a single file name allow for embedded spaces in the file
> name. However, when using commands that accept several file names, embedded
> spaces need to be escaped with a backslash.
Index: ./doc/Makefile
diff -r ../vim3.0/doc/Makefile ./doc/Makefile
0a1,7
> doctags: doctags.c
> 	cc doctags.c -o doctags
> 
> DOCS = reference.doc windows.doc
> 
> tags: $(DOCS)
> 	./doctags $(DOCS) | sort >tags
Index: ./doc/difference.doc
diff -r ../vim3.0/doc/difference.doc ./doc/difference.doc
238a239,242
> In Vi when entering a CR in replace mode deletes a character only when 'ai'
> is set (but does not show it until you hit ESC). Vim always deletes a
> character (and shows it immediately).
> 
274a279,283
> When a mapping starts with number, vi looses the count typed before it (e.g.
> when using the mapping ":map g 4G" the command "7g" goes to line 4). This is
> considered a vi bug. Vim concatenates the counts (in the example it becomes
> "74G"), as most people would expect.
> 
385a395,398
> 
> A count to the 'i' or 'a' command is used for all the text. Vi uses the count
> only for one line. "3iabc<NL>def<ESC>" would insert "abcabcacc<NL>def" in Vi
> but "abc<NL>defabc<NL>defabc<NL>def" in Vim.
Index: ./doc/doctags.c
diff -r ../vim3.0/doc/doctags.c ./doc/doctags.c
0a1,63
> /* vim:set ts=4 sw=4:
>  * this program makes a tags file for reference.doc
>  *
>  * Usage: doctags reference.doc windows.doc ... >tags
>  *
>  * A tag in this context is an identifier between minus signs, e.g. *c_files*
>  */
> 
> #include <stdio.h>
> #include <string.h>
> #include <ctype.h>
> 
> #define LINELEN 200
> 
> main(argc, argv)
>     int     argc;
>     char    **argv;
> {
>     char    line[LINELEN];
>     char    *p1, *p2;
>     char    *p;
>     FILE    *fd;
> 
>     if (argc <= 1)
>     {
>         fprintf(stderr, "Usage: doctags docfile ... >tags\n");
>         exit(1);
>     }
>     while (--argc > 0)
>     {
>         ++argv;
>         fd = fopen(argv[0], "r");
>         if (fd == NULL)
>         {
>             fprintf(stderr, "Unable to open %s for reading\n", argv[0]);
>             continue;
>         }
>         while (fgets(line, LINELEN, fd) != NULL)
>         {
>             p1 = strchr(line, '*');             /* find first '*' */
>             while (p1 != NULL)
>             {
>                 p2 = strchr(p1 + 1, '*');       /* find second '*' */
>                 if (p2 != NULL)
>                 {
>                     for (p = p1 + 1; p < p2; ++p)
>                         if (!isalnum(*p) && *p != '_')
>                             break;
>                     if (p == p2)                /* if it is all id-characters
> */
>                     {
>                         *p2 = '\0';
>                         printf("%s\t%s\t/\\*%s\\*\n", p1 + 1, argv[0], p1 +
> 1);
>                     }
>                     p2 = strchr(p2 + 1, '*');
>                 }
>                 p1 = p2;
>             }
>         }
>         fclose(fd);
>     }
> }
Index: ./doc/index
diff -r ../vim3.0/doc/index ./doc/index
38a39,40
> ^X		enter CTRL-X sub mode, with several commands for keyword
> 		completion and scrolling
Index: ./doc/msdos.doc
diff -r ../vim3.0/doc/msdos.doc ./doc/msdos.doc
150a151,154
> The line length is limited to about 32000 characters. When reading a file the
> lines are automatically split. But when editing a line in such a way that
> it becomes too long may give unexpected results.
> 
Index: ./doc/reference.doc
diff -r ../vim3.0/doc/reference.doc ./doc/reference.doc
5c5
< 				      
---
> 
7,9c7,9
< 				      
< 				version 3.0
< 				      
---
> 
> 				version 3.6
> 
15a16,25
> You can use tags to jump to the explanation of a subject.  Position the
> cursor on an item name between bars (e.g. |intro|) or quotes (e.g.
> `textwidth`) and hit CTRL-]. Special characters in the names of the tags are
> not allowed, therefore they have been replaced by letters, e.g. "ctrl_e" for
> CTRL-E, "star" for "*".
> 	  mode 		    tag starts with	example
> 	Normal			nothing		"x"
> 	Command line		"c_"		"c_quit"
> 	Insert mode		"i_"		"i_esc"
> 	Command line editing	"e_"		"e_del"
18c28
< 	1. Introduction
---
> 	1. Introduction					*intro*
22c32
< commands from the Unix program "Vi" (and a lot new ones). It is very useful
---
> commands from the Unix program "Vi" and a lot of new ones. It is very useful
24,26c34,36
< keyboard. There is no mouse support and there are no menus. This gives the
< advantage that you can keep your fingers on the keyboard and your eyes on
< the screen.
---
> keyboard. There is only limited mouse support and there are no menus. This
> gives the advantage that you can keep your fingers on the keyboard and your
> eyes on the screen.
43c53
< 	2. Notation
---
> 	2. Notation					*notation*
54c64,66
< 		window. You can use <DEL> to erase the last digit.
---
> 		window. You can use <DEL> to erase the last digit. (Note: if
> 		you like to use <BS> for this, add this mapping to your
> 		.vimrc:   :map! CTRL-V <BS>   CTRL-V <DEL>  )
65c77
< 		text".
---
> 		text" |copy_move|.
76c88,90
< 		multiplied. For example: "2d3w" deletes six words.
---
> 		multiplied. For example: "2d3w" deletes six words. The
> 		motion can also be a mouse click. The mouse is currently
> 		only supported for MSDOS and xterm under UNIX.
81c95
< 		operated upon. See the chapter on Visual mode.
---
> 		operated upon. See the chapter on Visual mode |visual_mode|.
96c110
< 		enclosed in single quotes. See chapter 19.
---
> 		enclosed in single quotes. See chapter 19 |options|.
101,102c115,116
< 
< notation	meaning		     equivalent decimal value
---
> 								*key_notation*
> notation	meaning		    equivalent  decimal value(s)
104,125c118,145
< <NUL>		zero			CTRL_@  000 (internally 010)
< <BELL>  	bell			CTRL-G	007
< <BS>    	backspace		CTRL-H	008
< <TAB>   	tab			CTRL-I	009
< <LF>    	linefeed		CTRL-J	010
< <FF>    	formfeed		CTRL-L	012
< <CR>    	carriage return		CTRL-M	013
< <ESC>   	escape			CTRL-[	027
< <SPACE>    	space				032
< <DEL>   	delete				127
< <C_UP>		cursor-up			128 (msdos: 176)
< <C_DOWN>	cursor-down			129 (msdos: 177)
< <C_LEFT>	cursor-left			130 (msdos: 178)
< <C_RIGHT>	cursor-right			131 (msdos: 179)
< <SC_UP>		shift-cursor-up			132 (msdos: 180)
< <SC_DOWN>	shift-cursor-down		133 (msdos: 181)
< <SC_LEFT>	shift-cursor-left		134 (msdos: 182)
< <SC_RIGHT>	shift-cursor-right		135 (msdos: 183)
< <F1> - <F10>	function keys 1 to 10		136 - 145 (msdos: 184 - 193)
< <SF1> - <SF10>	shift-function keys 1 to 10	146 - 155 (msdos: 194 - 203)
< HELP>		help key			156 (msdos: 204)
< <UNDO>		undo key			157 (msdos: 205)
---
> <NUL>		zero			CTRL_@    0 (stored as 10)
> <BELL>		bell			CTRL-G	  7
> <BS>		backspace		CTRL-H	  8
> <TAB>		tab			CTRL-I	  9
> <LF>		linefeed		CTRL-J	 10 (used for <NUL>)
> <FF>		formfeed		CTRL-L	 12
> <CR>		carriage return		CTRL-M	 13
> <ESC>		escape			CTRL-[	 27
> <SPACE>		space				 32
> <DEL>		delete				127
> <C_UP>		cursor-up			128  1
> <C_DOWN>	cursor-down			128  2
> <C_LEFT>	cursor-left			128  3
> <C_RIGHT>	cursor-right			128  4
> <SC_UP>		shift-cursor-up			128  5
> <SC_DOWN>	shift-cursor-down		128  6
> <SC_LEFT>	shift-cursor-left		128  7
> <SC_RIGHT>	shift-cursor-right		128  8
> <F1> - <F10>	function keys 1 to 10		128  9  to  128 18
> <SF1> - <SF10>	shift-function keys 1 to 10	128 19  to  128 28
> <HELP>		help key			128 29
> <UNDO>		undo key			128 30
> <INSERT>	insert key			128 31
> <DELETE>	delete key			128 32
> <HOME>		home				128 33
> <END>		end				128 34
> <PAGE_UP>	page-up				128 35
> <PAGE_DOWN>	page-down			128 36
132a153,157
> Note: There are two codes for the delete key. 127 is the ASCII value for the
> delete key, which is always recognized. Some delete keys send another value,
> in which case this value is obtained from the termcap entry "kD" and
> translated into "128 32". Both codes have the same effect.
> 
134c159
< 	3. Starting Vim
---
> 	3. Starting Vim					*starting*
136c161
< 3.1 Command line
---
> 3.1 Command line					*command_line*
160c185
< 		section "tag searches").
---
> 		section on tags |tags|).
166c191,192
< 		systems). See section 5.5: "using the QuickFix mode".
---
> 		systems). See section 5.5: "using the QuickFix mode"
> 		|quickfix|.
177c203,204
< 		"pattern searches" for the available search patterns).
---
> 		"pattern searches" for the available search patterns
> 		|search_pattern|).
186,188c213,216
< -r		Recovery mode. The swap file is read to recover a 
< 		crashed editing session. See the chapter "Recovery after a
< 		crash".
---
> -r		Recovery mode. Without a file name argument a list of
> 		existing swap files is given. With a file name a swap file
> 		is read to recover a crashed editing session. See the
> 		chapter "Recovery after a crash" |crash_recovery|.
197,200c225,229
< 		(see the options chapter). Calling the executable "view" 
< 		has the same effect as the -v option. If your system does 
< 		not support links and you do not want to have the executable 
< 		twice you could make an alias: "alias view vim -v".
---
> 		(see the options chapter |options|). Calling the executable
> 		"view" has the same effect as the -v option. If your system
> 		does not support links and you do not want to have the
> 		executable twice you could make an alias: "alias view vim
> 		-v".
206c235
< 		a file. See also 5.6: "Editing binary files".
---
> 		a file. See also 5.6: "Editing binary files" |edit_binary|.
224c253
< 		of terminal you are using (See chapter 20).
---
> 		of terminal you are using (See chapter 20) |terminal_info|.
235c264
< 		readnews). See section 3.3.
---
> 		readnews). See section 3.3 |amiga_window|.
242c271
< 		"complex repeats".
---
> 		"complex repeats" |complex_repeat|.
247c276,277
< 		":source!". See also the section "complex repeats".
---
> 		":source!". See also the section "complex repeats"
> 		|complex_repeat|.
266c296
< 3.2 Workbench (Amiga only)
---
> 3.2 Workbench (Amiga only)				*workbench*
284c314
< 3.3 Vim window (Amiga only)
---
> 3.3 Vim window (Amiga only)				*amiga_window*
313c343
< 3.4 Initialization
---
> 3.4 Initialization					*initialization*
320c350,358
< 1.  Four places are searched for initializations. The first that exists is 
---
> 1.  The environment variable SHELL, if it exists, is used to set the 
>     'shell' option. With MSDOS the COMPSPEC variable is used if SHELL does
>     not exist. The 'shellpipe' and 'shellredir' options are set according to
>     the name of the shell.
> 
> 2.  The environment variable TERM, if it exists, is used to set the 'term'
>     option.
> 
> 3.  Four places are searched for initializations. The first that exists is 
327c365
< 2.  If the 'exrc' option is set (default is 'noexrc'), the current directory
---
> 4.  If the 'exrc' option is set (default is 'noexrc'), the current directory
333,339c371,372
< 3.  The environment variable SHELL, if it exists, is used to set the 
<     'shell' option. With MSDOS the COMPSPEC variable is used if SHELL does
<     not exist. The 'shellpipe' option is set according to the name of the
<     shell.
< 
< 4.  The environment variable TERM, if it exists, is used to set the 'term'
<     option.
---
> 5.  If the 'viminfo' option is set to non-zero by the previous
>     initializations, the viminfo file is read. See |viminfo_file|.
341,344c374,377
< The first can be used to set your default settings and mappings for all edit 
< sessions. The second one for sessions in a certain directory (note that the
< 'exrc' option is default off). See the section "Saving settings" for how to
< create a file with commands to recreate the current settings.
---
> The third can be used to set your default settings and mappings for all edit 
> sessions. The fourth one for sessions in a certain directory (note that the
> 'exrc' option is default off). See |save_settings| for how to create a file
> with commands to recreate the current settings.
379c412
< 3.5 Suspending
---
> 3.5 Suspending						*suspend*
381c414,417
< CTRL-Z				Suspend the editor. Same as ":stop".
---
> 							*ctrl_z*
> CTRL-Z			On Unix systems: Suspend Vim. On other systems: 
> 			start a new shell (like ":sh"). Same as ":stop".
> 
383,387c419,422
< :sus[pend][!]		or
< :st[op][!]			Suspend the editor. If the <!> is not given,
< 				the buffer was changed, autowrite is set and 
< 				a filename is known, the buffer will be 
< 				written.
---
> :sus[pend][!]	or				*c_suspend* *c_stop*
> :st[op][!]		Suspend the editor. If the <!> is not given, the
> 			buffer was changed, autowrite is set and a filename
> 			is known, the buffer will be written.
390,393c425,470
< possible in Command mode (see next chapter). Vim will continue if you make it 
< the foreground job again. On other systems CTRL-Z will start a new shell. 
< This is the same as the ":sh" command. Vim will continue if you exit from the 
< shell.
---
> possible in Command mode (see next chapter |edit_modes|). Vim will continue
> if you make it the foreground job again. On other systems CTRL-Z will start
> a new shell.   This is the same as the ":sh" command. Vim will continue if
> you exit from the shell.
> 
> 
> 3.6 The viminfo file					*viminfo_file*
> 
> The viminfo file is used to store:
> - The command line history.
> - The search string history.
> - Contents of registers.
> - Marks in several files.
> 
> When Vim is started and the 'viminfo' option is non-zero, the contents of
> the viminfo file is read and the info can be used at the appropriate places.
> The marks are not read in at startup. See |initialization| for how to set
> the 'viminfo' option upon startup.
> 
> When Vim is exited and 'viminfo' is non-zero, the info is stored in the
> viminfo file. The 'viminfo' option gives the number of files for which the
> marks are remembered.
> 
> Marks are stored for each file separately. When a file is read and 'viminfo'
> is set, the marks for that file are read from the viminfo file. NOTE: The
> marks are only written when exiting Vim. If you want to save the marks for a
> file that you are about to abandon, use ":wv".
> 
> The default name of the viminfo file is $HOME/.viminfo for Unix, s:.viminfo
> for Amiga, $VIM\viminfo for MSDOS. For the commands below another file name
> can be given.
> 
> Two commands can be used to read and write the viminfo file manually. This
> can be used to exchange registers between two running Vim programs: First
> type ":wv" in one and then ":rv" in the other.
> 
> :rviminfo[!] [file]	Read from viminfo file [file] (default see above).
> 			If [!] is given, registers that are already in use
> 			are overwritten. {not in Vi}
> 
> :wviminfo[!] [file]	Write to viminfo file [file] (default see above).
> 			The information in the file is first read in to make
> 			a merge between old and new info. When [!] is used
> 			the information is not read first, only the internal
> 			info is written. If 'viminfo' is zero, marks for up
> 			to 100 files will be written. {not in Vi}
396c473
< 	4. Modes
---
> 	4. Modes					*edit_modes*
429c506
< 4.2 Switching from mode to mode
---
> 4.2 Switching from mode to mode				*mode_switching*
442a520
> 							*i_esc*
460c538
< 4.3 Insert and Replace mode
---
> 4.3 Insert and Replace mode				*mode_ins_repl*
462c540
< 4.3.1 special keys
---
> 4.3.1 special keys					*ins_special_keys*
471a550
> 						*i_ctrl_at*
473a553
> 						*i_ctrl_a*
474a555
> 						*i_ctrl_b*
475a557
> 						*i_ctrl_c*
477a560
> 						*i_ctrl_d*
483a567
> 						*i_ctrl_e*
484a569
> 						*i_ctrl_h* *i_bs*
486a572
> 						*i_ctrl_i* *i_tab*
489,490c575,577
< 		avoid the expansion). See also the 'smarttab' option, section
< 		4.3.4.
---
> 		avoid the expansion). See also the 'smarttab' option and
> 		section 4.3.4 |ins_expandtab|.
> 						*i_ctrl_j* *i_lf*
491a579
> 						*i_ctrl_k*
493c581,582
< 		Enter digraph (see 4.7). {not in Vi}
---
> 		Enter digraph (see 4.7 |digraphs|). {not in Vi}
> 						*i_ctrl_m* *i_cr*
495,498c584,589
< CTRL-N		Find next keyword (see 4.3.7). {not in Vi}
< CTRL-O		Execute one Command mode command. See below. {not in Vi}
< CTRL-P		Find previous keyword (see 4.3.7). {not in Vi}
< CTRL-R <0-9a-z"%:>
---
> CTRL-N		Find next keyword (see 4.3.7 |i_ctrl_n|). {not in Vi}
> CTRL-O		Execute one Command mode command. See below |i_ctrl_o|. {not
> 		in Vi}
> CTRL-P		Find previous keyword (see 4.3.7 |i_ctrl_p|). {not in
> 		Vi}
> CTRL-R <0-9a-z"%:>				*i_ctrl_r*
505,507c596,599
< 		the current file name.  Use <:> for the last command line. See
< 		the chapter on copying and moving text about registers. {<%>,
< 		<"> and <:> not in Vi}
---
> 		the current file name.  Use <:> for the last command line.
> 		See the chapter on copying |copy_move| and moving text about
> 		registers.  {<%>, <"> and <:> not in Vi}
> 						*i_ctrl_t*
510a603
> 						*i_ctrl_u*
512a606
> 						*i_ctrl_v*
514,516c608,611
< 		decimal value of a single byte. The non-digit and the three
< 		digits are not considered for mapping. {Vi: no decimal byte
< 		entry}
---
> 		decimal value of a single byte (see below |i_ctrl_v_digit|.
> 		The non-digit and the three digits are not considered for
> 		mapping. {Vi: no decimal byte entry}
> 						*i_ctrl_w*
518c613,618
< 		section "word motions" for the definition of a word.
---
> 		section "word motions" |word_motions| for the definition of
> 		a word.
> CTRL-X		Enter CTRL-X mode. This is a sub mode where a commands can
> 		be given to complete words or scroll the window. See below
> 		|i_ctrl_x| and in 4.3.7 |ins_completion|. {not in Vi}
> 						*i_ctrl_y*
519a620
> 						*i_ctrl_l_sbracket* *i_esc*
521c622,628
< <DEL>		Same as CTRL-H <BS>
---
> 						*i_del*
> <DEL>		Delete the character under the cursor. If the cursor is at
> 		the end of the line, and the 'backspace' option is non-zero,
> 		delete the newline. The next line is appended after the
> 		current one. {not in Vi}
> 						*i_insert*
> <INSERT>	Toggle between insert and replace mode. {not in Vi}
524,525c631,632
< The effect of the <BS>, <DEL>, CTRL-W and CTRL-U depends on the 'backspace' 
< option (unless 'revins' is set):
---
> The effect of the <BS>, CTRL-W and CTRL-U depends on the 'backspace' option
> (unless 'revins' is set):
532c639
<    	   insert
---
> 	   insert
538a646
> 						*i_ctrl_v_digit*
550a659,673
> 						*i_ctrl_x*
> CTRL-X enters a sub-mode, where several commands can be used. Most of these
> commands do keyword completion, see 4.3.7 |ins_completion|. Two commands can
> be used to scroll the window up or down, without exiting insert mode:
> 
> 						*i_ctrl_x_ctrl_e*
> CTRL-X CTRL-E		scroll window one line up.
> 
> 						*i_ctrl_x_ctrl_y*
> CTRL-X CTRL-Y		scroll window one line down.
> 
> The scrolling is not done if this makes the cursor scroll of the window or
> end of file is reached. Further CTRL-E or CTRL-Y can be given to scroll more
> or back. As soon as another key is hit, CTRL-X mode is exited and that key
> is handled as in normal insert mode.
552d674
< 4.3.2 special special keys
553a676,677
> 4.3.2 special special keys				*ins_special_special*
> 
567,575c691,704
< <C_UP>		cursor one line up
< <C_DOWN>	cursor one line down
< <C_LEFT>	cursor one character left
< <C_RIGHT>	cursor one character right
< <SC_UP>		move window one page up
< <SC_DOWN>	move window one page down
< <SC_LEFT>	cursor one word back (like "b" command)
< <SC_RIGHT>	cursor one word forward (like "w" command)
< CTRL-O		execute one command and return to Insert mode
---
> <C_UP>		cursor one line up			     *i_cur_up*
> <C_DOWN>	cursor one line down			     *i_cur_down*
> <C_LEFT>	cursor one character left		     *i_cur_left*
> <C_RIGHT>	cursor one character right		     *i_cur_right*
> <SC_LEFT>	cursor one word back (like "b" command)	     *i_scur_left*
> <SC_RIGHT>	cursor one word forward (like "w" command)   *i_scur_right*
> <HOME>		cursor to first char in the line	     *i_home*
> <END>		cursor to after last char in the line	     *i_end*
> mouse-click	cursor to position of mouse click.           *i_mouse_click*
> <SC_UP>		move window one page up			     *i_scur_up*
> <PAGE_UP>	move window one page up			     *i_page_up*
> <SC_DOWN>	move window one page down		     *i_scur_down*
> <PAGE_DOWN>	move window one page down		     *i_page_down*
> CTRL-O		execute one command and return to Insert mode*i_ctrl_o*
587c716
< 4.3.3 'textwidth' and 'wrapmargin' option
---
> 4.3.3 'textwidth' and 'wrapmargin' option		*ins_textwidth*
611c740
< block and hit "Q".
---
> block and hit "Q". See also |Q|.
614c743
< 4.3.4 'expandtab' and 'smarttab' options
---
> 4.3.4 'expandtab' and 'smarttab' options		*ins_expandtab*
621,622c750,752
< space at a time. The original text will be put back in a place where you
< would not expect it. {not in Vi}
---
> space at a time. The original character will be put back for only one space
> that you backspace over (the last one). {Vi does not have the 'expandtab'
> option}
631c761
< 4.3.5 typing backwards
---
> 4.3.5 typing backwards					*ins_reverse*
640,641c770
< In Replace mode the cursor is moved leftwards. <BS> will restore the
< character right of the cursor.
---
> In insert mode the 'revins' option can be toggled with CTRL-B.
643c772
< In insert or Replace mode the 'revins' option can be toggled with CTRL-B.
---
> There is no reverse replace mode.
645,646c774,775
< If the 'showmode' option is set, "-- REVERSE INSERT --" or
< "-- REVERSE REPLACE --" will be shown in the status line.
---
> If the 'showmode' option is set, "-- REVERSE INSERT --" will be shown in the
> status line.
649c778
< 4.3.6 Replace mode
---
> 4.3.6 Replace mode					*replace_mode*
653c782
< typed character is appended (as in Insert mode). Thus the number of 
---
> typed character is appended (as in Insert mode). Thus the number of
654a784
> If a <LF> is typed, a line break is inserted and no character is deleted.
660,661c790,791
< If you delete characters in Replace mode (with <BS>, <DEL>, CTRL-W or
< CTRL-U), you really delete your changes. The characters that were replaced
---
> If you delete characters in Replace mode (with <BS>, CTRL-W or CTRL-U), what
> happens is that you delete the changes. The characters that were replaced
663,669c793
< added are deleted.
<     All this only works in the current line. If you have started a new line
< (replaced a character with a <CR>) Vim no longer remembers what happened in
< the previous line. If you backspace over the newline (only possible if the
< 'backspace' option is non-zero), the two lines will be joined again, but
< typing further backspaces will not restore the original text. Only the
< cursor is moved.
---
> added are deleted. This is effectively a character-at-a-time undo.
671,680c795,856
< with several spaces. When backspacing over these spaces, the original text
< will appear in a position where you would not expect it.
< 
< 
< 4.3.7 Keyword completion
< 
< In insert and replace mode the keys CTRL-N and CTRL-P can be used to
< complete the keyword that is in front of the cursor. This is useful if you
< are writing a program that has complicated variable names, and you want to
< copy a name from the text before of after the cursor.
---
> with several spaces. The result of this is that the
> number of characters in the line increases. Backspacing will delete one
> space at a time. The original character will be put back for only one space
> that you backspace over (the last one). {Vi does not have the 'expandtab'
> option}
> 
> 
> 4.3.7 Insert mode completion				*ins_completion*
> 
> In insert and replace mode there are several commands to complete part of a
> word or line that has been typed. This is useful if you are using
> complicated words (e.g. function names with capitals and underscores).
> Completion can be done for:
> 
> 1. Whole lines						|compl_whole_line|
> 2. identifiers in the current file			|compl_current|
> 3. identifiers in the current and included files	|compl_ident|
> 4. tags							|compl_tag|
> 5. file names						|compl_filename|
> 6. definitions or macros				|compl_define|
> 
> All these, except 2., are done in CTRL-X mode. This is a sub-mode from
> insert/replace mode. You enter CTRL-X mode by typing CTRL-X and one of the
> CTRL-X commands. You exit CTRL-X mode by typing a key that is not a valid
> CTRL-X mode command. Valid keys are the CTRL-X command itself, CTRL-N (next)
> and CTRL-P (previous).
> 
> Also see the 'infercase' option if you wnat to adjust the case of the match.
> 
> Note: The keys that are valid in CTRL-X mode are not mapped. This allows for
> ":map CTRL-F CTRL-X CTRL-F" to work. The key that ends CTRL-X mode (a key
> that is not a valid CTRL-X mode command) is mapped.
> 
> The following mappings are suggested to make typing the completion commands
> a bit easier:
>     :inoremap ^] ^X^]
>     :inoremap ^F ^X^F
>     :inoremap ^G ^X^G
>     :inoremap ^L ^X^L
> 
> 
> Completing whole lines:					*compl_whole_line*
> 							*i_ctrl_x_ctrl_l*
> CTRL-X CTRL-L		Search backwards for a line that starts with the
> 			same characters as in the current line before the
> 			cursor. Indent is ignored. The found line is
> 			inserted in front of the cursor.
> 	CTRL-L	or
> 	CTRL-P		Search backwards for next matching line. This line
> 			replaces the previous matching line.
> 
> 	CTRL-N		Search forward for next matching line. This line
> 			replaces the previous matching line.
> 
> Completing identifiers in current file:			*compl_current*
> 
> 							*i_ctrl_p*
> 							*i_ctrl_n*
> The keys CTRL-N and CTRL-P can be used to complete the keyword that is in
> front of the cursor. This is useful if you are writing a program that has
> complicated variable names, and you want to copy a name from the text before
> of after the cursor.
683,685c859,862
< alphanumeric characters and <_>) it is used as the search pattern, with "\<"
< prepended (meaning: start of a word). Otherwise "\<[a-zA-Z_]" is used as
< search pattern (start of any identifier).
---
> alphanumeric characters and characters in 'identchars') it is used as the
> search pattern, with "\<" prepended (meaning: start of a word). Otherwise
> "\<[a-zA-Z%s][a-zA-Z0-9%s]" is used as search pattern: Start of any
> identifier of at least two characters (%s is replaced with 'idenchars').
695a873,876
> In replace mode the number of characters that is replaced depends on the
> length of the matched string. This works like typing the characters of the
> matched string in replace mode.
> 
703c884,886
< Multiple repeats of the same completion are skipped.
---
> Multiple repeats of the same completion are skipped, thus a different match
> will be inserted at each CTRL-N and CTRL-P (unless there is only one
> matching identifier).
711a895,899
> After CTRL-N and/or CTRL-P have been used to find all the matches in the
> file, any files given in the 'dictionary' option will also be searched.
> This could potentially be pretty slow, since all matches are found before
> the user may cycle through them.  By default, there is no dictionary.
> 
724c912,980
< 4.4 Command_line mode
---
> Completing identifiers in the current and included files:	*compl_ident*
> 
> The 'include' option is used to specify a line that contains an include file
> name. The 'path' option is used to search for include files.
> 
> 							*i_ctrl_x_ctrl_g*
> CTRL-X CTRL-G		Search for the first identifier in the current and
> 			included files that starts with the same characters
> 			as before the cursor. The found identifier is
> 			inserted in front of the cursor.
> 	CTRL-G	or
> 	CTRL-N		Search forwards for next matching identifier. This
> 			This identifier replaces the previous matching
> 			identifier.
> 
> 	CTRL-P		Search backward for previous matching macro name.
> 			This identifier replaces the previous matching
> 			identifier.
> 
> 
> Completing tags:					*compl_tag*
> 						*i_ctrl_x_ctrl_r_sbracket*
> CTRL-X CTRL-]		Search for the first tag that starts with the same
> 			characters as before the cursor. The found tag is
> 			inserted in front of the cursor.
> 	CTRL-]	or
> 	CTRL-N		Search forwards for next matching tag. This tag
> 			replaces the previous matching tag.
> 
> 	CTRL-P		Search backward for previous matching tag. This tag
> 			replaces the previous matching tag.
> 
> 
> Completing file names:					*compl_filename*
> 							*i_ctrl_x_ctrl_f*
> CTRL-X CTRL-F		Search for the first file name that starts with the
> 			same characters as before the cursor. The found file
> 			name is inserted in front of the cursor.
> 	CTRL-F	or
> 	CTRL-N		Search forwards for next matching file name. This
> 			file name replaces the previous matching file name.
> 
> 	CTRL-P		Search backward for previous matching file name.
> 			This file name replaces the previous matching file
> 			name.
> 
> 
> Completing definitions or macros:			*compl_define*
> 
> The 'define' option is used to specify a line that contains a definition.
> The 'include' option is used to specify a line that contains an include file
> name. The 'path' option is used to search for include files.
> 
> 							*i_ctrl_x_ctrl_d*
> CTRL-X CTRL-D		Search in the current and included files for the
> 			first definition (or macro) name that starts with
> 			the same characters as before the cursor. The found
> 			definition name is inserted in front of the cursor.
> 	CTRL-D	or
> 	CTRL-N		Search forwards for next matching macro name. This
> 			macro name replaces the previous matching macro
> 			name.
> 
> 	CTRL-P		Search backward for previous matching macro name.
> 			This macro name replaces the previous matching macro
> 			name.
> 
> 
> 4.4 Command_line mode					*mode_cmdline*
730c986
< 4.4.1 Command line editing
---
> 4.4.1 Command line editing			*cmdline_editing*
732,734c988,991
< Normal characters are inserted in front of the cursor position. You can move
< around in the command line with the left and right cursor keys. {Vi: can 
< only alter the last character in the line}
---
> Normally characters are inserted in front of the cursor position. You can
> move around in the command line with the left and right cursor keys. With
> the <INSERT> key you can toggle between inserting and overstriking
> characters. {Vi: can only alter the last character in the line}
737,738c994,1004
< recall them with the up and down cursor keys. Use the 'history' option to 
< set the number of lines that are remembered (default 20).
---
> recall them with the up and down cursor keys. There are actually two history
> tables: One for ':' commands and one for search strings. These are
> completely separate. The search strings history can only be accessed when
> entering a search string, same for the ':' commands. Use the 'history'
> option to set the number of lines that are remembered (default 20). Note
> that when you enter a command line that is excactly the same as an older
> one, the old one is removed (to avoid repeated commands moving older
> commands out of the history). Only commands that are typed are remembered.
> Ones that come from mappings are not put in the history (detail: the
> descision is made from the last key that was typed for the line, normally
> <CR>). {Vi: no history}
740c1006,1007
< There is an automatic completion of names on the command line, see 4.4.2.
---
> There is an automatic completion of names on the command line, see 4.4.2
> |cmdline_completion|.
741a1009
> 						*e_ctrl_v*
745c1013,1014
< 		way as in Insert mode (see above).
---
> 		way as in Insert mode (see above |i_ctrl_v|).
> 						*e_cur_left*
746a1016
> 						*e_cur_right*
747a1018
> 						*e_scur_left*
748a1020
> 						*e_scur_right*
750,751c1022,1025
< CTRL-B		cursor to begin of command line
< CTRL-E		cursor to end of command line
---
> CTRL-B or <HOME>				*e_ctrl_b* *e_home*
> 		cursor to begin of command line
> CTRL-E or <END>					*e_ctrl_e* *e_end*
> 		cursor to end of command line
752a1027,1030
> 						*e_mouse_click*
> mouse-click	cursor to position of mouse click.
> 
> 						*e_bs*
753a1032
> 						*e_del*
755a1035
> 						*e_ctrl_w*
756a1037
> 						*e_ctrl_u*
760a1042,1043
> 						*e_insert*
> <INSERT>	Toggle between insert and overstrike. {not in Vi}
762,764c1045,1047
< {char1} <BS> {char2}	or
< CTRL-K {char1} {char2}
< 		enter digraph (see 4.7). {not in Vi}
---
> {char1} <BS> {char2}	or			*e_digraph*
> CTRL-K {char1} {char2}				*e_ctrl_k*
> 		enter digraph (see 4.7 |digraphs|). {not in Vi}
765a1049
> 						*e_lf* *e_cr*
766a1051
> 						*e_esc*
768a1054
> 						*e_ctrl_c*
770a1057
> 						*e_cur_up*
771a1059
> 						*e_cur_down*
774c1062,1064
< <SC_UP>		recall older command line from history, which begin matches 
---
> 						*e_scur_up* *e_page_up*
> <SC_UP> or <PAGE_UP>
> 		recall older command line from history, which begin matches 
776c1066,1068
< <SC_DOWN>	recall more recent command line from history, which begin 
---
> 						*e_scur_down* *e_page_down*
> <SC_DOWN> or <PAGE_DOWN>
> 		recall more recent command line from history, which begin 
779c1071
< CTRL-D		command line completion (see 4.4.2)
---
> CTRL-D		command line completion (see 4.4.2 |cmdline_completion|)
781,794c1073,1086
< 		command line completion (see 4.4.2)
< CTRL-N		command line completion (see 4.4.2)
< CTRL-P		command line completion (see 4.4.2)
< CTRL-A		command line completion (see 4.4.2)
< CTRL-L		command line completion (see 4.4.2)
< 
< The <SC_UP> and <SC_DOWN> keys take the current command line as search 
< string. The beginning of the next/previous command lines are compared against 
< this string. The fist line that matches is the new command line. When typing 
< these two keys repeatedly, the same string is used again. For example this 
< can be used to find the previous substitute command: Type ":s" and then 
< <SC_UP>. The same could be done by typing <C_UP> a number of times until the 
< desired command line is shown. (Note: the shifted arrow keys do not work on
< all terminals) 
---
> 		command line completion (see 4.4.2 |cmdline_completion|)
> CTRL-N		command line completion (see 4.4.2 |cmdline_completion|)
> CTRL-P		command line completion (see 4.4.2 |cmdline_completion|)
> CTRL-A		command line completion (see 4.4.2 |cmdline_completion|)
> CTRL-L		command line completion (see 4.4.2 |cmdline_completion|)
> 
> The <SC_UP>, <PAGE_UP>, <SC_DOWN> and <PAGE_DOWN> keys take the current
> command line as search string. The beginning of the next/previous command
> lines are compared against this string. The fist line that matches is the
> new command line. When typing these two keys repeatedly, the same string is
> used again. For example this can be used to find the previous substitute
> command: Type ":s" and then <SC_UP>. The same could be done by typing <C_UP>
> a number of times until the desired command line is shown. (Note: the
> shifted arrow keys do not work on all terminals) 
797c1089
< 4.4.2 Command line completion
---
> 4.4.2 Command line completion				*cmdline_completion*
810a1103
> 							*e_ctrl_d*
813a1107
> 							*e_wildchar*
822a1117
> 							*e_ctrl_n*
824a1120
> 							*e_ctrl_p*
827a1124
> 							*e_ctrl_a*
829a1127
> 							*e_ctrl_l*
843,845c1141,1143
< The default is ".bak.o.h.info.swp", which means that files with the
< extensions ".bak", ".o", ".h", ".info" and ".swp" are sometimes ignored. It
< is impossible to ignore suffixes with two dots. Examples:
---
> The default is ".bak.~.o.h.info.swp", which means that files with the
> extensions ".bak", ".~", ".o", ".h", ".info" and ".swp" are sometimes
> ignored. It is impossible to ignore suffixes with two dots. Examples:
858a1157,1161
> The old value of an option can be obtained by hitting 'wildchar' just after
> the '='. For example, typing 'wildchar' after ":set dir=" will insert the
> current value of 'dir'. This overrules filename completion for the options
> that take a file name.
> 
860c1163
< 4.4.3 Ex command lines
---
> 4.4.3 Ex command lines					*cmdline_lines*
863a1167
> 							*c_quotes*
867c1171
< 	:set ai 	"set 'autoindent' option
---
> 	:set ai		"set 'autoindent' option
871a1176
> 							*c_bar*
888c1193
< files").
---
> files" |c_percent| |c_pound|).
902c1207
< 4.4.4 Ex command line ranges
---
> 4.4.4 Ex command line ranges				*cmdline_ranges*
919a1225,1230
> 	\/		the next line where the previously used search
> 			pattern matches
> 	\?		the previous line where the previously used search
> 			pattern matches
> 	\&		the next line where the previously used substitute
> 			pattern matches
960c1271
< 4.5 The window contents
---
> 4.5 The window contents					*window_contents*
969c1280
< <@> 	The next line is too long to fit in the window.
---
> <@>	The next line is too long to fit in the window.
1023c1334
< current mode 			'showmode'	on	    on
---
> current mode			'showmode'	on	    on
1052c1363
< 4.6 Abbreviations
---
> 4.6 Abbreviations					*abbreviations*
1100a1412
> 						*c_abbreviate*
1112a1425
> 						*c_unabbreviate*
1114a1428
> 						*c_noreabbrev*
1118a1433
> 						*c_cabbrev*
1121a1437
> 						*c_cunabbrev*
1124a1441
> 						*c_cnoreabbrev*
1128a1446
> 						*c_iabbrev*
1130a1449
> 						*c_iunabbrev*
1133a1453
> 						*c_inoreabbrev*
1139c1459
< 4.7 Digraphs
---
> 4.7 Digraphs						*digraphs*
1140a1461
> 						*c_digraphs*
1178,1181c1499,1502
< If you accidently typed an <a> that should be an <e>, you will type <a> <BS> 
< <e>. But that is a digraph, so you will not get what you want. To avoid this, 
< use <DEL> instead of <BS>. Or don't set the 'digraph' option and use CTRL-K
< to enter digraphs.
---
> If you accidently typed an <a> that should be an <e>, you will type <a> <BS>
> <e>. But that is a digraph, so you will not get what you want. To correct
> this, you will have to type <BS> e again. To avoid this don't set the
> 'digraph' option and use CTRL-K to enter digraphs.
1184c1505
< 	5. Editing files
---
> 	5. Editing files				*edit_files*
1186c1507
< 5.1 Introduction
---
> 5.1 Introduction					*edit_intro*
1205a1527
> 						*c_percent* *c_pound*
1219c1541
< CTRL-G		or
---
> CTRL-G		or					*ctrl_g* *c_file*
1221c1543,1545
< 			cursor position. {vi does not include column number}
---
> 			cursor position (unless the 'ruler' option is set).
> 			See also 'shortmess' option. {vi does not include
> 			column number}
1229,1230c1553,1556
< :files			List all the currently known file names. See
< 			'windows.doc'. {not in vi}
---
> :files
> :ls			List all the currently known file names. See
> 			'windows.doc' |c_files| |c_buffers| |c_ls|. {not in
> 			Vi}
1234c1560
< the full path name is being used if you used the ":cd" command.
---
> the full path name is being used if you used the ":cd" command |c_cd|.
1256,1258c1582,1586
< file with ".bak" appended. Any <.> is replaced by <_> on MSDOS machines, when
< Vim has detected that an MSDOS-like filesystem is being used (e.g. messydos or
< crossdos) and when the 'shortname' option is set.
---
> file with 'backupext' appended. The default ".~" is a bit strange to avoid
> accidently overwriting existing files. If you prefer ".bak" change the
> 'backupext' option. Any <.> is replaced by <_> on MSDOS machines, when Vim
> has detected that an MSDOS-like filesystem is being used (e.g. messydos or
> crossdos) or when the 'shortname' option is set.
1267c1595
< 	   ".swp" and ".bak" files for the current file. But when you are 
---
> 	   ".swp" and ".~" files for the current file. But when you are 
1270c1598
< 	   creation of the ".bak" file may fail and you will get an error 
---
> 	   creation of the ".~" file may fail and you will get an error 
1294c1622
< 5.2 Editing a file
---
> 5.2 Editing a file					*edit_a_file*
1295a1624
> 							*c_edit*
1308a1638
> 							*c_ex*
1310a1641
> 							*c_visual*
1312a1644
> 							*ctrl_hat*
1320,1321c1652,1653
< ]f
< [f
---
> ]f							*r_sbracket_f*
> [f							*l_sbracket_f* *gf*
1323,1324c1655,1659
< 			cursor. Mnemonic: "goto file". This fails if the
< 			current file cannot be abandoned. {not in Vi}
---
> 			cursor. Mnemonic: "goto file". Uses the 'path'
> 			variable as a list of directory names to look for
> 			the file. Also looks for the file relative to the
> 			current file. This command fails if the current file
> 			cannot be abandoned. {not in Vi}
1325a1661
> 							*c_cd*
1333a1670
> 							*c_chdir*
1335a1673
> 							*c_pwd*
1350a1689,1696
> Note for systems other than Unix and MS-DOS: When using a command that
> accepts a single file name (like ":edit file") spaces in the file name are
> allowed, but trailing spaces are ignored.  This is useful on systems that
> allow file names with embedded spaces (like the Amiga). Example: The command
> ":e   Long File Name " will edit the file "Long File Name". When using a
> command that accepts more than one file name (like ":next file1 file2")
> embedded spaces must be escaped with a backslash.
> 
1354a1701,1707
> Note that ":e file" will fail if there are changes in the current buffer,
> also when the 'autowrite' option is set. This is unlogical, because with
> other commands (e.g. ":next") the current buffer would be written and
> abandoned, but this behaviour is compatible with vi. If you encounter this
> problem, you can use CTRL-^ to jump to the file, because the alternate file
> name is set to the argument of the ":e" command.
> 
1391c1744
< 5.3 The argument list
---
> 5.3 The argument list					*argument_list*
1395,1398c1748,1751
< which you can see with the ":files" command. The argument list was already
< present in vi, the file list is new in Vim. The file names in the argument
< list will also be present in the file list (unless they were deleted with
< ":bdel").
---
> which you can see with the ":files" command |c_files|. The argument list was
> already present in vi, the file list is new in Vim. The file names in the
> argument list will also be present in the file list (unless they were
> deleted with ":bdel").
1401a1755
> 							*c_args*
1404a1759
> 							*c_argument*
1413a1769
> 							*c_next*
1432c1788
< :[count]N[ext] [count] [+cmd]
---
> :[count]N[ext] [count] [+cmd]				*c_Next*
1441c1797
< :[count]pre[vious] [count] [+cmd]
---
> :[count]pre[vious] [count] [+cmd]			*c_previous*
1443a1800
> 							*c_rewind*
1450a1808
> 							*c_last*
1457a1816
> 							*c_wnext*
1470,1471c1829,1830
< :[count]wN[ext][!] [+cmd] [file]
< :[count]wp[revous][!] [+cmd] [file]
---
> :[count]wN[ext][!] [+cmd] [file]			*c_wNext*
> :[count]wp[revous][!] [+cmd] [file]			*c_wprevious*
1478c1837
< For [+cmd] see 5.2.
---
> For [+cmd] see 5.2 |edit_a_file|.
1484,1488c1843,1848
< You are protected from leaving Vim if you are not editing the last file in 
< the argument list. This prevents you from forgetting that you were editing one 
< out of several files. To exit anyway try to exit twice. If there are changes
< in the current buffer this will fail. You can exit anyway, and save any
< changes, with the ":wq!" command. To lose any changes use the ":q!" command.
---
> You are protected from leaving Vim if you have not been editing the last
> file in the argument list. This prevents you from forgetting that you were
> editing one out of several files. To exit anyway try to exit twice. If there
> are changes in the current buffer this will fail. You can exit anyway, and
> save any changes, with the ":wq!" command. To lose any changes use the ":q!"
> command.
1491c1851
< 5.4 Writing and quitting
---
> 5.4 Writing and quitting				*write_quit*
1492a1853
> 							*c_write*
1515c1876,1877
< :q[uit] 		Quit, unless changes have been made or not editing 
---
> 							*c_quit*
> :q[uit]			Quit, unless changes have been made or not editing 
1519a1882
> 							*c_cq*
1521c1884,1885
< 			code. Used for Manx's QuickFix mode (see 5.5).
---
> 			code. Used for Manx's QuickFix mode (see 5.5
> 			|quickfix|).
1522a1887
> 							*c_wq*
1532a1898
> 							*c_xit*
1535a1902
> 							*c_exit*
1537a1905
> 							*ZZ*
1547,1551c1915,1920
< 'backup'	'writebackup'		action
<    off		     off		no backup made
<    off		     on			backup made, deleted afterwards
<    on		     off		backup made, not deleted
<    on		     on			backup made, not deleted (default)
---
> 						*backup_table*
> 'backup'	'writebackup'	action
>    off		     off	no backup made
>    off		     on		backup made, deleted afterwards (default)
>    on		     off	backup made, not deleted
>    on		     on		backup made, not deleted
1563a1933,1941
> If the writing of the new file fails, you have to be careful not to loose
> your changes AND the original file. If there is no backup file and writing
> the new file failed, you have already lost the original file. Don't exit Vim
> until you wrote out the file! If a backup was made, it is put back in place
> of the original file (if possible). If you exit Vim, and loose the changes
> you made, the original file will still be there. If putting back the
> original file fails, there will be an error message telling you that you
> lost the original file.
> 
1571c1949
< 5.5 Using the QuickFix mode
---
> 5.5 Using the QuickFix mode				*quickfix*
1597a1976
> 							*c_cc*
1601c1980,1981
< :[count]cn		Display the [count] next error in the list that
---
> 							*c_cnext*
> :[count]cn[ext]		Display the [count] next error in the list that
1605c1985,1986
< :[count]cp		Display the [count] previous error in the list that
---
> 							*c_cprevious*
> :[count]cp[revious]	Display the [count] previous error in the list that
1609c1990,1991
< :cq			Quit Vim with an error code, so that the compiler
---
> 							*c_cquit*
> :cq[uit]		Quit Vim with an error code, so that the compiler
1612c1994,1995
< :cf [errorfile]		Read the error file and jump to the first error.
---
> 							*c_cfile*
> :cf[ile] [errorfile]	Read the error file and jump to the first error.
1619c2002,2003
< :cl			List all errors. {not in Vi}
---
> 							*c_clist*
> :cl[ist]		List all errors that inlcude a file name. {not in Vi}
1620a2005,2007
> :cl[ist]!		List all errors. {not in Vi}
> 
> 							*c_make*
1665c2052
< "%f:%l:%m"				for GCC
---
> "%f:%l:\ %m"				for GCC
1692a2080
> 						*c_make_makeprg*
1732c2120
< 5.6 Editing binary files
---
> 5.6 Editing binary files				*edit_binary*
1770c2158,2181
< 	6. Cursor motions
---
> 5.7 Automatic commands					*autocommand*
> 
> When starting to edit a file whose name matches a particular pattern,
> certain commands can be executed.  For example, tw=0 can be set for
> files matching *.c, and tw=76 can be set otherwise. These commands are
> normally put in your .vimrc or .exrc file. {All this is not in Vi}
> 
> The auto-commands are executed just before reading the file. Any modelines
> in the file overrule the auto-commands.
> 
> Note: Any <|> and <LF> in this command must be escaped by a backslash,
> otherwise it will be seen as the start of another command (see |c_bar|).
> 
> 							*c_autocmd*
> :au[tocmd] {pat} {cmd}	Add {cmd} to the list of commands that will be
> 			automatically executed when editing a file
> 			matching {pat}.
> 
> :au[tocmd] {pat}	Show the auto-commands associated with {pat}.
> 
> :au[tocmd]		Show all auto-commands.
> 
> :au[tocmd]! {pat} {cmd} Remove all auto-commands associated with {pat}, and
> 			add the command {cmd}.
1771a2183,2216
> :au[tocmd]! {pat}   	Remove all auto-commands associated with {pat}.
> 
> :au[tocmd]!     	Remove ALL auto-commands.
> 
> 							*c_doautocmd*
> :do[autocmd] [fname]	Apply the autocommands matching [fname] (default:
> 			current file name) to the current buffer. This can
> 			be used when the current file name does not match
> 			the right pattern, or after changing settings.
> 
> {pat} may be "default" for commands that should be used when no other
> pattern matches.  Multiple patterns may be given separated by commas.  Here
> are some examples:
> 
>   :autocmd *.c,*.h  set tw=0 smartindent noic
>   :autocmd default  set tw=79 nosmartindent ic infercase
> 
> For makefiles (makefile, Makefile, imakefile, makefile.unix, etc):
> 
>   :autocmd *akefile*    set include=^s\=include
>   :autocmd *.c,*.h  abbr FOR for(i = 0; i < 3; i++)^M{^M}^[O
> 
> To always start editing C files at the first function:
> 
>   :autocmd *.c,*.h  1;/^{
> 
> Without the "1;" above, the search would start from wherever the file was
> entered, rather than from the start of the file.  When entering :autocmd on
> the command line, completion of command names may be done (with tab etc)
> where appropriate.
> 
> 
> 	6. Cursor motions				*cursor_motions*
> 
1807c2252,2253
< strokes and has limited redo functionality. See the chapter on Visual mode.
---
> strokes and has limited redo functionality. See the chapter on Visual mode
> |visual_mode|.
1818c2264,2265
< 6.1 Left-right motions
---
> 
> 6.1 Left-right motions					*left_right_motions*
1820,1822c2267,2269
< h		or
< <C_LEFT>	or
< CTRL-H		or
---
> h		or					*h*
> <C_LEFT>	or					*cur_left*
> CTRL-H		or					*ctrl_h* *bs*
1823a2271,2276
> 			Note: If you prefer <BS> and <DEL> to delete a
> 			character, use the mappings:
> 				:map CTRL-V<BS>		X
> 				:map CTRL-V<DEL>	x
> 			(to enter "CTRL-V<BS>" type the CTRL-V key, followed
> 			by the <BS> key)
1825,1826c2278,2279
< l		or
< <C_RIGHT>	or
---
> l		or					*l*
> <C_RIGHT>	or					*cur_right* *space*
1829c2282,2283
< 0			To the first character of the line (exclusive).
---
> 							*zero* *home*
> 0 or <HOME>		To the first character of the line (exclusive).
1830a2285
> 							*hat*
1834c2289,2290
< $			To the end of line [count] from the cursor
---
> 							*dollar* *end*
> $  or <END>		To the end of line [count] from the cursor
1837c2293,2294
< |			To column [count] (inclusive).
---
> 							*bar*
> |			To column [count] (exclusive).
1838a2296
> 							*f*
1841a2300
> 							*F*
1844a2304
> 							*t*
1848a2309
> 							*T*
1852a2314
> 							*semicolon*
1854a2317
> 							*comma*
1863c2326
< 6.2 Up-down motions
---
> 6.2 Up-down motions					*up_down_motions*
1865,1866c2328,2329
< k		or
< <C_UP>		or
---
> k		or					*k*
> <C_UP>		or					*cur_up* *ctrl_p*
1869,1872c2332,2335
< j		or
< <C_DOWN>	or
< CTRL-J		or
< <LF>		or
---
> j		or					*j*
> <C_DOWN>	or					*cur_down*
> CTRL-J		or					*ctrl_j*
> <LF>		or					*linefeed* *ctrl_n*
1874a2338
> 							*minus*
1878,1879c2342,2343
< +		or
< CTRL-M		or
---
> +		or					*plus*
> CTRL-M		or					*ctrl_m* *cr*
1882a2347
> 							*underscore*
1885a2351
> 							*G*
1887c2353,2354
< 			non-blank character (linewise).
---
> 			non-blank character (linewise). If 'startofline' not
> 			set, keep the same column.
1891a2359
> 							*count_percent*
1895c2363,2364
< 			number-of-lines / 100. {not in Vi}
---
> 			number-of-lines / 100. See also 'startofline'
> 			option. {not in Vi}
1904c2373
< 6.3 Word motions
---
> 6.3 Word motions					*word_motions*
1906c2375
< <SC_RIGHT>	or
---
> <SC_RIGHT>	or					*scur_right* *w*
1908a2378
> 							*W*
1910a2381
> 							*e*
1912a2384
> 							*E*
1915c2387
< <SC_LEFT>	or
---
> <SC_LEFT>	or					*scur_left* *b*
1917a2390
> 							*B*
1944c2417
< 6.4 Text object motions
---
> 6.4 Text object motions					*object_motions*
1945a2419
> 							*l_paren*
1947a2422
> 							*r_paren*
1949a2425
> 							*l_bracket*
1951a2428
> 							*r_bracket*
1953a2431
> 						*r_sbracket_r_sbracket*
1957a2436
> 						*r_sbracket_l_sbracket*
1960a2440
> 						*l_sbracket_l_sbracket*
1963a2444
> 						*l_sbracket_r_sbracket*
1992c2473
< 6.5 Pattern searches
---
> 6.5 Pattern searches					*pattern_searches*
1993a2475
> 							*slash*
2007a2490
> 							*star*
2014a2498
> 							*hatch*
2016a2501,2523
> 							*gd*
> gd			Goto local Declaration. When the cursor is on a
> 			local variable, this command will jump to its
> 			declaration.  First a search is made for the end of
> 			the previous function, just like "[]". If it is not
> 			found the search stops in line 1. From this position
> 			a search is made for the identifier under the
> 			cursor, like with "*", but lines that look like a
> 			comment are ignored (see 'comments' option). Note
> 			that this is not guaranteed to work, Vim does not
> 			really check the syntax, it only searches for a
> 			match with the identifier. If included files also
> 			need to be searched use the commands listed in
> 			|include_search|. {not in Vi}
> 
> 							*gD*
> gD			Goto global Declaration. When the cursor is on a
> 			global variable that is defined in the file, this
> 			command will jump to its declaration. This works
> 			just like "gd", except that the search for the
> 			identifier always starts in line 1. {not in Vi}
> 
> 							*question*
2030a2538
> 							*n*
2033a2542
> 							*N*
2036a2546
> 							*ctrl_c*
2038a2549,2551
> While typing the search pattern the current match will be shown if the
> 'incsearch' option is on.
> 
2095,2100c2608,2614
< underscores. Note that if you type with ten fingers, the characters are easy
< to remember: the "#" is under your left hand middle finger (search to the
< left and up) and the "*" is under your right hand middle finger (search to
< the right and down). If there is no identifier under or after the cursor, a
< search is done for any word under or after the cursor. Blanks (<TAB>s and/or
< <SPACE>s) are recognized as delimiters for this word.
---
> characters in 'identchars'. Note that if you type with ten fingers, the
> characters are easy to remember: the "#" is under your left hand middle
> finger (search to the left and up) and the "*" is under your right hand
> middle finger (search to the right and down). If there is no identifier
> under or after the cursor, a search is done for any word under or after the
> cursor. Blanks (<TAB>s and/or <SPACE>s) are recognized as delimiters for
> this word.
2103c2617
< The definition of a pattern:
---
> The definition of a pattern:				*search_pattern*
2184c2698
< 6.6 Various motions
---
> 6.6 Various motions				*various_motions*
2185a2700
> 						*m*
2188a2704
> 						*c_mark*
2191a2708
> 						*c_k*
2194a2712
> 						*quote*
2202a2721
> 						*backquote*
2208a2728
> 						*c_marks*
2233a2754
> 						*quote_l_sbracket*
2237a2759
> 						*backquote_l_sbracket*
2240a2763
> 						*quote_r_sbracket*
2244a2768
> 						*backquote_r_sbracket*
2261a2786
> 						*quote_quote*
2264a2790
> 						*backquote_backquote*
2273a2800
> 							*ctrl_o*
2276a2804
> 							*ctrl_i*
2279a2808
> 							*c_jumps*
2336a2866
> 							*percent*
2341c2871
< 			 /* */		start or end of C-style comment
---
> 			/* */		start or end of C-style comment
2345,2347c2875,2878
< 			ignored. Parens and braces inside quotes are ignored,
< 			unless the number of parens/braces in a line is uneven
< 			and this line and the previous one does not end in a
---
> 			ignored. When the 'smartmatch' option is set, Parens
> 			and braces inside quotes are ignored, unless the
> 			number of parens/braces in a line is uneven and this
> 			line and the previous one does not end in a
2352a2884
> 						*l_sbracket_l_paren*
2354a2887
> 						*l_sbracket_l_bracket*
2356a2890
> 						*r_sbracket_r_paren*
2358a2893
> 						*r_sbracket_r_bracket*
2367c2902,2903
< H			To line [count] from top (Home) of screen (default:
---
> 						*H*
> H 			To line [count] from top (Home) of screen (default:
2369c2905
< 			character (linewise).
---
> 			character (linewise). See also 'startofline' option.
2370a2907
> 						*M*
2372c2909
< 			character (linewise).
---
> 			character (linewise). See also 'startofline' option.
2373a2911
> 						*L*
2376c2914
< 			(linewise).
---
> 			(linewise). See also 'startofline' option.
2377a2916,2924
> left-mouse-click	Moves to the position on the screen where the mouse
> 			click is (inclusive). If the position is in the last
> 			line on the screen the text is scrolled up. If the
> 			position is in the first line on the screen the text
> 			is scrolled down. See also |visual_mode|. If the
> 			position is in a status line, that window is made
> 			the active window and the cursor is not moved. {not
> 			in Vi}
> 
2379c2926
< 	7. Scrolling
---
> 	7. Scrolling					*scrolling*
2383a2931
> 							*ctrl_e*
2385a2934
> 							*ctrl_d*
2389c2938
< 			to [count].
---
> 			to [count]. See also 'startofline' option.
2391c2940,2941
< <SC_DOWN>	or
---
> <SC_DOWN>	or					*scur_down*
> <PAGE_DOWN>	or					*page_down* *ctrl_f*
2393c2943
< 			buffer.
---
> 			buffer. See also 'startofline' option.
2397a2948
> 							*ctrl_y*
2399a2951
> 							*ctrl_u*
2403c2955
< 			to [count].
---
> 			to [count]. See also 'startofline' option.
2405c2957,2958
< <SC_UP>		or
---
> <SC_UP>		or					*scur_up*
> <PAGE_UP>	or					*page_up* *ctrl_b*
2407c2960
< 			buffer.
---
> 			buffer. See also 'startofline' option.
2410a2964
> 							*z*
2414a2969
> 							*zt*
2422a2978
> 							*z_dot*
2426a2983
> 							*zz*
2429a2987
> 							*z_min*
2433a2992
> 							*zb*
2445c3004,3006
< 	8. Tags
---
> 	8. Tags and special searches			*tags_and_searches*
> 
> 8.1 Tags						*tag_commands*
2446a3008
> 							*c_tag*
2450a3013
> 							*ctrl_r_sbracket*
2454a3018
> 							*ctrl_t*
2457a3022
> 							*c_pop*
2463a3029
> 							*c_tags*
2477a3044,3048
> {In Vi jumping to a tag sets the current search pattern.  This means that
> hitting 'n' after jumping to a tag does not search for the same pattern that
> it did before jumping to the tag.  Vim does not do this as we consider it to
> be a bug.}
> 
2488c3059
<     				  tag
---
> 				  tag
2490c3061
<     				  tag
---
> 				  tag
2527a3099,3106
> The identifier normally is the name of a function, but it can be any
> identifier. There is one special form for local (static) functions:
> {filename}:{identifier}. In this case the identifier is only valid if the
> name of the current file matches the filename before the colon. In other
> files this identifier will be ignored. Some ctags programs make use of this
> to separate local (static) functions from global functions. (Detail: Vim
> compares only the last part of the filename and ignores any path before it).
> 
2555a3135,3138
> When the tag could not been found in the tags file specified by the 'tags'
> option, another try is done in the file "tags" in the same directory as the
> current file.
> 
2583c3166
< 	":pop" or CTRL-T 	to position before previous tag
---
> 	":pop" or CTRL-T	to position before previous tag
2586c3169
< 	":0tag" 		to last used tag
---
> 	":0tag"			to last used tag
2613c3196,3360
< 	9. Inserting text
---
> 8.2 Include file searches				*include_search*
> 
> These commands look for a string in the current file and in all encountered
> included files (recursively). This can be used to find the definition of a
> variable, function or macro. If you don't want to search in included files,
> use the commands listed in |pattern_searches|.
> 
> When a line is encountered that includes another file, that file is searched
> before continuing in the current file. Files included in included files are
> also searched. When an include file could not be found it is silently
> ignored. Use the ":checkpath" command to discover which files could not be
> found.
> 
> The string can be any identifier or a defined macro. For the identifier any
> match will be found. For defined macros only lines that match with the
> 'define' optionwill be found. The default is "\^#[ \t]*define", which is for
> C programs.  Also, when a match is found for a defined macro, the displaying
> of lines continues with the next line when a line ends in a backslash.
> 
> The commands that start with "[" start searching from the start of the
> current file. The commands that start with "]" start at the current cursor
> position.
> 
> The 'include' option is used to define a line that includes another file.
> The default is "\^#[ \t]*include", which is for C programs.  Note: Vim does
> not recognize C syntax. If the 'include' option matches a line inside
> "#ifdef/#endif" or inside a comment, it is searched anyway.
> 
> The 'path' option is used to find the directory for the include files that
> do not have an absolute path.
> 
> The 'comments' option is used for the commands that display a single line or
> jump to a line. It defines that patterns that start a comment. Those lines
> are ignored for the search.
> 
> 							*l_sbracket_i*
> [i			Display the first line that contains the identifier
> 			under the cursor. The search starts at the beginning
> 			of the file. Lines that look like a comment are
> 			ignored (see 'comments' option). If a count is
> 			given, the count'th matching line is displayed. {not
> 			in Vi}
> 
> 							*r_sbracket_i*
> ]i			like "[i", but start at the current cursor position.
> 			{not in Vi}
> 
> 							*c_isearch*
> :[range]is[earch][!] ident
> 			Like "[i"  and "]i", but search in [range] lines
> 			(default: whole file).  Without [!] only whole words
> 			are matched. {not in Vi}
> 
> 							*l_sbracket_I*
> [I			Display all lines that contain the identifier under
> 			the cursor. File names and line numbers are
> 			displayed for the found lines. The search starts at
> 			the beginning of the file. {not in Vi}
> 
> 							*r_sbracket_I*
> ]I			like "[I", but start at the current cursor position.
> 			{not in Vi}
> 
> 							*c_ilist*
> :[range]il[ist][!] ident
> 			Like "[I" and "]I", but search in [range] lines
> 			(default: whole file). Without [!] only whole words
> 			are matched. {not in Vi}
> 
> 							*l_sbracket_ctrl_i*
> [ CTRL-I		Jump to the first line that contains the identifier
> 			under the cursor. The search starts at the beginning
> 			of the file. Lines that look like a comment are
> 			ignored (see 'comments' option). If a count is
> 			given, the count'th matching line is jumped to. {not
> 			in Vi}
> 
> 							*r_sbracket_ctrl_i*
> ] CTRL-I		like "[ CTRL-I", but start at the current cursor
> 			position.  {not in Vi}
> 
> 							*c_ijump*
> :[range]ij[ump][!] ident
> 			Like "[ CTRL-I"  and "] CTRL-I", but search in
> 			[range] lines (default: whole file).  Without [!]
> 			only whole words are matched. {not in Vi}
> 
> 							*ctrl_w_g*
> CTRL-W g		Open a new window, with the cursor on the first line
> 			that contains the identifier under the cursor. The
> 			search starts at the beginning of the file. Lines
> 			that look like a comment line are ignored (see
> 			'comments' option). If a count is given, the
> 			count'th matching line is jumped to. {not in Vi}
> 
> 							*c_isplit*
> :[range]isp[lit][!] ident
> 			Like "CTRL-W i"  and "CTRL-W i", but search in
> 			[range] lines (default: whole file).  Without [!]
> 			only whole words are matched. {not in Vi}
> 
> 							*l_sbracket_d*
> [d			Display the first macro definition that contains the
> 			macro under the cursor. The search starts from the
> 			beginning of the file. {not in Vi}
> 
> 							*r_sbracket_d*
> ]d			like "[d", but start at the current cursor position.
> 			{not in Vi}
> 
> 							*c_dsearch*
> :[range]ds[earch][!] ident
> 			Like "[d"  and "]d", but search in [range] lines
> 			(default: whole file).  Without [!] only whole words
> 			are matched. {not in Vi}
> 
> 							*l_sbracket_D*
> [D			Display all macro definitions that contain the macro
> 			under the cursor. File names and line numbers are
> 			displayed for the found lines. The search starts
> 			from the beginning of the file. {not in Vi}
> 
> 							*r_sbracket_D*
> ]D			like "[D", but start at the current cursor position.
> 			{not in Vi}
> 
> 							*c_dlist*
> :[range]dl[ist][!] ident
> 			Like "[D"  and "]D", but search in [range] lines
> 			(default: whole file).  Without [!] only whole words
> 			are matched. {not in Vi}
> 
> 							*l_sbracket_ctrl-d*
> [ CTRL-D		Jump to the first macro definition that contains the
> 			identifier under the cursor. The search starts from
> 			the beginning of the file. {not in Vi}
> 
> 							*r_sbracket_ctrl_d*
> ] CTRL-D		like "[ CTRL-D", but start at the current cursor
> 			position.  {not in Vi}
> 
> 							*c_djump*
> :[range]dj[ump][!] ident
> 			Like "[ CTRL-D"  and "] CTRL-D", but search  in
> 			[range] lines (default: whole file).  Without [!]
> 			only whole words are matched. {not in Vi}
> 
> 							*ctrl_w_d*
> CTRL-W d		Open a new window, with the cursor on the first
> 			macro definition line that contains the identifier
> 			under the cursor. The search starts from the
> 			beginning of the file. {not in Vi}
> 
> 							*c_dsplit*
> :[range]dsp[lit][!] ident
> 			Like "CTRL-W d", but search in [range] lines
> 			(default: whole file).  Without [!] only whole words
> 			are matched. {not in Vi}
> 
> 							*c_checkpath*
> :che[ckpath]		List all the included files that could not be found.
> 			{not in Vi}
> 
> 
> 	9. Inserting text				*inserting*
2617a3365
> 							*a*
2619a3368
> 							*A*
2621a3371
> <INSERT>	or					*i* *insert*
2623a3374
> 							*I*
2626a3378
> 							*o*
2630a3383
> 							*O*
2637,2638c3390,3391
< Replace mode" for the other special characters in Insert mode. The effect of
< [count] takes place after Insert mode is exited.
---
> Replace mode" |mode_ins_repl| for the other special characters in Insert
> mode. The effect of [count] takes place after Insert mode is exited.
2639a3393
> 							*c_read*
2647c3401,3405
< 			the cursor.
---
> 			the cursor. A temporary file is used to store the
> 			output of the command which is then read into the
> 			buffer. 'shellredir' is used to save the output of
> 			the command, which can be set to include stderr or
> 			not.
2660,2662c3418,3420
< end-of-line marker (see 5.2 how this is done). However, the 'textmode'
< option will not be changed. Only while reading one file the text mode is
< used or not.
---
> end-of-line marker (see 5.2 how this is done |edit_a_file|). However, the
> 'textmode' option will not be changed. Only while reading one file the text
> mode is used or not.
2669c3427
< 	10. Deleting text
---
> 	10. Deleting text				*deleting*
2670a3429
> ["x]<DEL>	or					*del* *x*
2673a3433
> 							*X*
2676a3437
> 							*d*
2679a3441
> 							*dd*
2681a3444
> 							*D*
2686c3449
< {visual}["x]x	or
---
> {visual}["x]x	or					*v_x* *v_d*
2688c3451,3452
< 			the chapter on Visual mode). {not in Vi}
---
> 			the chapter on Visual mode |visual_mode|). {not in
> 			Vi}
2690c3454
< {visual}["x]X	or
---
> {visual}["x]X	or					*v_X* *v_D*
2692c3456,3457
< 			the chapter on Visual mode). {not in Vi}
---
> 			the chapter on Visual mode |visual_mode|). {not in
> 			Vi}
2693a3459
> 							*c_delete*
2699,2700c3465,3466
< 			(default: current line, see 4.4.4) [into register
< 			x].
---
> 			(default: current line |cmdline_ranges|) [into
> 			register x].
2704c3470
< "Copying and moving text" for an explanation of registers.
---
> "Copying and moving text" |copy_move| for an explanation of registers.
2711a3478
> 							*J*
2713a3481
> 							*v_J*
2716a3485
> 							*c_join*
2725,2727c3494,3496
< 			current line, see 4.4.4). Same as "J", except when
< 			[!] is given, then no spaces will be inserted or 
< 			deleted.
---
> 			current line |cmdline_ranges|). Same as "J", except
> 			when [!] is given, then no spaces will be inserted
> 			or deleted.
2738c3507
< 	11. Changing text
---
> 	11. Changing text				*changing*
2745c3514
< 11.1 Delete and insert
---
> 11.1 Delete and insert					*delete_insert*
2746a3516
> 							*R*
2751a3522
> 							*c*
2754a3526
> 							*cc*
2758a3531
> 							*C*
2762a3536
> 							*s*
2766a3541
> 							*S*
2770,2771c3545,3546
< {visual}["x]c	or
< {visual}["x]r	or
---
> {visual}["x]c	or					*v_c*
> {visual}["x]r	or					*v_r* *v_s*
2773,2774c3548,3549
< 			start insert (see the chapter on Visual mode). {not
< 			in Vi}
---
> 			start insert (see the chapter on Visual mode
> 			|visual_mode|). {not in Vi}
2776,2777c3551,3552
< {visual}["x]C	or
< {visual}["x]R	or
---
> {visual}["x]C	or					*v_C*
> {visual}["x]R	or					*v_R* *v_S*
2779,2780c3554,3555
< 			start insert (see the chapter on Visual mode). {not
< 			in Vi}
---
> 			start insert (see the chapter on Visual mode
> 			|visual_mode|). {not in Vi}
2783,2786c3558,3562
< Replace mode" for the other special characters in these modes. The effect of
< [count] takes place after Insert or Replace mode is exited. {Vi: does not
< directly delete the text, but puts a <$> at the last deleted character}
< See "Copying and moving text" for an explanation of registers.
---
> Replace mode" |mode_ins_repl| for the other special characters in these
> modes. The effect of [count] takes place after Insert or Replace mode is
> exited. {Vi: does not directly delete the text, but puts a <$> at the last
> deleted character} See "Copying and moving text" |copy_move| for an
> explanation of registers.
2792c3568
< "Insert and Replace mode").
---
> "Insert and Replace mode" |mode_ins_repl|).
2801c3577
< 11.2 Simple changes
---
> 11.2 Simple changes					*simple_change*
2802a3579
> 							*r*
2805,2808c3582,3589
< 			replaced by a line break. If a [count] is given that
< 			many characters will be replaced by [count] <char>s
< 			or line breaks {Vi: "5r<CR>" replaces five
< 			characters with a single line break}
---
> 			replaced by a line break. Replacing with a real <CR>
> 			can be done by using CTRL-V <CR>. CTRL-V <LF> will
> 			replace with a <NUL>.
> 			If a [count] is given that many characters will be
> 			replaced by [count] <char>s or line breaks {Vi:
> 			"5r<CR>" replaces five characters with a single line
> 			break; CTRL-V <CR> still replaces with a line break,
> 			cannot replace something with a <CR>}
2809a3591
> 							*tilde*
2817a3600
> 							*v_tilde*
2819c3602
< 			Visual mode). {not in Vi}
---
> 			Visual mode |visual_mode|). {not in Vi}
2820a3604
> 							*v_U*
2822c3606
< 			Visual mode). {not in Vi}
---
> 			Visual mode |visual_mode|). {not in Vi}
2823a3608
> 							*v_u*
2825c3610
< 			Visual mode). {not in Vi}
---
> 			Visual mode |visual_mode|). {not in Vi}
2826a3612
> 							*ctrl_a*
2829a3616
> 							*ctrl_x*
2854a3642
> 							*smaller*
2856a3645
> 							*smaller_smaller*
2858a3648
> 							*v_smaller*
2860,2861c3650,3651
< 			leftwards (see the chapter on Visual mode). {not in
< 			Vi} 
---
> 			leftwards (see the chapter on Visual mode
> 			|visual_mode|). {not in Vi} 
2862a3653
> 							*greater*
2864a3656
> 							*greater_greater*
2866a3659
> 							*v_greater*
2868,2869c3661,3662
< 			rightwards (see the chapter on Visual mode). {not in
< 			Vi}
---
> 			rightwards (see the chapter on Visual mode
> 			|visual_mode|). {not in Vi}
2870a3664
> 							*c_smaller*
2875,2876c3669,3670
< 			(default current line, see 4.4.4). Repeat '<' for
< 			multiple shifts.
---
> 			(default current line |cmdline_ranges|). Repeat '<'
> 			for multiple shifts.
2880a3675
> 							*c_greater*
2885,2886c3680,3681
< 			(default current line, see 4.4.4). Repeat '>' for
< 			multiple shifts.
---
> 			(default current line |cmdline_ranges|). Repeat '>'
> 			for multiple shifts.
2913,2933d3707
< Q{motion}		Format the lines that were moved over. The length of 
< 			each line will be restricted to the width set with 
< 			the 'textwidth' option. If the 'textwidth' option is
< 			0, all lines will be joined together. If the
< 			'autoindent' option is set, the indent of the first
< 			line is used for the following lines. The
< 			'formatprg' option can be set to the name of an
< 			external program, which will be used instead of the
< 			internal function. The 'textwidth' option will then
< 			not be used. {not in Vi}
< 
< :[range]ce[nter] [width]
< 			Center lines in [range] between [width] columns
< 			(default 'textwidth' or 80 when 'textwidth' is 0).
< 			{not in Vi}
< 
< :[range]ri[ght] [width]
< 			right align lines in [range] at [width] columns
< 			(default 'textwidth' or 80 when 'textwidth' is 0).
< 			{not in Vi}
< 
2935c3709
< 11.3 Complex changes
---
> 11.3 Complex changes					*complex_change*
2936a3711
> 							*bang*
2939a3715
> 							*bang_bang*
2942a3719
> 							*v_bang*
2944,2945c3721,3722
< 			program {filter} (see the chapter on Visual mode).
< 			{not in Vi}
---
> 			program {filter} (see the chapter on Visual mode
> 			|visual_mode|).  {not in Vi}
2947c3724
< :{range}![!]{filter} [!][arg]
---
> :{range}![!]{filter} [!][arg]				*c_bang*
2950c3727,3731
< 			latest given command. The optional [arg] is appended.
---
> 			latest given command. The optional [arg] is
> 			appended. The output of the filter command is
> 			temporaryly saved in a file and then read into the
> 			buffer. The 'shellredir' option is used to write the
> 			output of the filter in the temporary file.
2951a3733
> 							*equal*
2956a3739
> 							*equal_equal*
2960a3744
> 							*v_equal*
2963,2964c3747,3748
< 			indent) (see the chapter on Visual mode). {not in
< 			Vi}
---
> 			indent) (see the chapter on Visual mode
> 			|visual_mode|). {not in Vi}
2976a3761
> 						*c_substitute*
2982c3767
< :[range]&[g][c][r] [count]
---
> :[range]&[g][c][r] [count]			*c_and*
2987c3772
< :[range]~[g][c][r] [count]
---
> :[range]~[g][c][r] [count]			*c_tilde*
2991a3777
> 						*and*
3001,3004c3787,3796
< 	matching string. You can type <y> to substitute, <n> to skip, <q> to
< 	quit substituting. If the 'edcompatible' option is set this flag is
< 	remembered and toggled each time it is used. It is reset when a new
< 	search pattern is given.
---
> 	matching string. You can type:
> 		<y> to substitute this match
> 		<n> to skip this match
> 		<a> to substitute this and all remaining matches {not in Vi}
> 		<q> to quit substituting {not in Vi}
> 		CTRL-E to scroll the screen up {not in Vi}
> 		CTRL-Y to scroll the screen down {not in Vi}.
> 	If the 'edcompatible' option is set the [c] flag is remembered and
> 	toggled each time it is used. It is reset when a new search pattern
> 	is given.
3011c3803
< 	in [range] (default current line, see 4.4.4).
---
> 	in [range] (default current line |cmdline_ranges|).
3016a3809,3812
> For compatibility with vi these two execptions are allowed:
> "\/{string}/" and "\?{string}?" do the same as "//{string}/r".
> "\&{string}&" does the same as "//{string}/".
> 
3022c3818,3819
< For the definition of a pattern see 6.5, "Pattern searches".
---
> For the definition of a pattern see 6.5, "Pattern searches"
> |search_pattern|.
3064a3862,3891
> 							*c_retab*
> :[range]ret[ab] [!] [new_tabstop]
> 			All sequences of white-space containing a tab are
> 			replaced by new strings of white-space using the new
> 			tabstop value given.  If no new tabstop size is
> 			given, the current value of 'tabstop' is used.  With
> 			!, strings of normal spaces will also be replace by
> 			tabs where appropriate.  With 'expandtab' set, all
> 			tabs will be replaced with the appropriate number of
> 			spaces.  This command sets 'tabstop' to the new
> 			value given, and if performed on the whole file,
> 			which is default, should not make any visible
> 			change. {not in Vi}
> 
> 
> 11.4 Formatting text						*formatting*
> 
> :[range]ce[nter] [width]				*c_center*
> 			Center lines in [range] between [width] columns
> 			(default 'textwidth' or 80 when 'textwidth' is 0).
> 			{not in Vi}
> 
> :[range]ri[ght] [width]					*c_right*
> 			right align lines in [range] at [width] columns
> 			(default 'textwidth' or 80 when 'textwidth' is 0).
> 			{not in Vi}
> 
> 							*c_left*
> :[range]le[ft] [indent]	left align lines in [range]. Sets the indent in the
> 			lines to [indent] (default 0). {not in Vi}
3066c3893,3898
< 	12. Copying and moving text
---
> 							*Q*
> Q{motion}		Format the lines that were moved over. The length of 
> 			each line will be restricted to the width set with
> 			the 'textwidth' option. If the 'textwidth' option is
> 			0, all lines will be joined together. See below.
> 			{not in Vi}
3068,3070c3900,3994
< "<a-zA-Z0-9.%:">	Use register <a-zA-Z0-9.%"> for next delete, yank or
< 			put (use uppercase character to append with delete
< 			and yank) (<.> only works with put).
---
> 							*v_Q*
> {visual}Q		Format the highlighted text. (see the chapter on
> 			Visual mode |visual_mode|). {not in Vi}
> 
> Example: To format the current paragraph use "{Q}".
> 
> If the 'autoindent' option is set, the indent of the first line is used for
> the following lines.
> 
> Empty lines are left unchanged (but lines with spaces are!).
> 
> The 'formatprg' option can be set to the name of an external program, which
> will be used instead of the internal function. The 'textwidth' and other
> options will not be used then.
> 
> Comments are formatted in a special way. Normally a comment starts with 
> special characters, ends with special characters, and each line in between
> can start with special characters.
> 
> The 'comments' option can be set to a comma separated list of patterns that
> can start a comment line. A pattern can include spaces, but not at the start
> of the pattern. If a pattern ends in a space, this means that the pattern
> can be followed by the end-of-line or any non-zero amount of white space,
> which is reproduced on the new line.  By default "* " is included, but "*"
> is not. This means that "*" must be followed by some white space or
> end-of-line for it to be accepted. This avoids a pointer dereference like
> "*str" to be recognized as a comment. Also, "# " is included. This means
> that a line that starts with "#include" is not recognized as a comment line.
> But a line that starts with "# define" is recognized. In C code this is
> good, because somewhere after this a "#endif" is needed.
> 
> The 'nestedcomments' option can be set to a comma separated list of patterns
> that can start a comment line when they occur at least one time. For example
> '>' is often used in e-mail reply to show a part that is included from the
> original message. In a reply to a reply it becomes "> >".
> 
> The 'formatoptions' option can be set to influence the way how comments are
> formatted. It is a string option, that may contain any of these letters. The
> default is "tcq".
> 
> letter   meaning when present in 'formatoptions'
> 
> t	Do text autowrapping using textwidth
> c	Do comment autowrapping using textwidth, inserting the current
> 	comment leader automatically.
> r	Automatically insert the current comment leader after hitting
> 	<return> in insert mode.
> o	Automatically insert the current comment leader after hitting 'o' or
> 	'O' in normal mode.
> q	Allow formatting of comments with Q.  Note that blank lines, or
> 	lines containing only the comment leader will be left untouched.  A
> 	new paragraph starts after such a line, or when the comment leader
> 	changes.
> 
> With 't' and 'c' you can decide when auto-wrapping is done:
> value	action
> ""	no automatic formatting, "Q" can be used for manual formatting
> "t"	automatic formatting of text, not for comments
> "c"	automatic formatting for comments, not for text (good for C code)
> "tc"	automatic formatting for text and comments
> 
> Note that when 'textwidth' is 0, no formatting is done anyway.
> Note that now 'textwidth' can be non-zero even though auto-wrapping never
> occurs.  This is good because it can be used for formatting only in this
> case (with "Q").
> 
> If "/*", "*" and "*/" are in the 'comments' variable, then vim has some
> built in stuff to treat these types of comments a bit more cleverly.
> Opening a new line before or after "/*" or "*/" (with 'r' or 'o' present in
> 'formatoptions'), should work properly, as should formatting and
> auto-wrapping.  Opening a line after a line starting with "/*" or "*" and
> containing "*/", will cause no comment leader to be inserted, and the indent
> of the new line is taken from the line containing the start of the comment.
> Eg:
>     /*
>      * Your typical comment.
>      */
>     The indent on this line is the same as the start of the above
>     comment.
> 
> All this should be really cool, especially in conjunction with the new
> :autocmd command to prepare different settings for different types of file.
> 
> Some examples:
>   for C code:       fo="croq"	(only format comments)
>   for Mail/news:    fo="tcrq"	(format all, don't start comment with "o"
> 				  command)
> 
> 
> 	12. Copying and moving text			*copy_move*
> 
> 							*double_quote*
> "<a-zA-Z0-9.%:-">	Use register <a-zA-Z0-9.%:-"> for next delete, yank
> 			or put (use uppercase character to append with
> 			delete and yank) (<.> only works with put).
3071a3996
> 							*c_display*
3074a4000
> 							*y*
3076a4003
> 							*yy*
3079,3082c4006,4010
< ["x]Y			With 'noyankendofline' option: yank [count] lines 
< 			[into register x] (synonym for yy, linewise); with 
< 			'yankendofline' option: yank until end of line 
< 			(synonym for y$, not linewise).
---
> 							*Y*
> ["x]Y			yank [count] lines [into register x] (synonym for
> 			yy, linewise). If you like "Y" to work from the
> 			cursor to the end of line (which is more logical,
> 			but not vi-compatible) use ":map Y y$".
3083a4012
> 							*v_y*
3085c4014
< 			chapter on Visual mode). {not in Vi}
---
> 			chapter on Visual mode |visual_mode|). {not in Vi}
3086a4016
> 							*v_Y*
3088c4018
< 			chapter on Visual mode). {not in Vi}
---
> 			chapter on Visual mode |visual_mode|). {not in Vi}
3089a4020
> 							*c_yank*
3094,3095c4025,4026
< 			in [range] (default: current line, see 4.4.4), [into 
< 			register x].
---
> 			in [range] (default: current line |cmdline_ranges|),
> 			[into register x].
3096a4028
> 							*p*
3098,3099c4030
< [count]
< 			times. {Vi: no count}
---
> 			[count] times. {Vi: no count}
3100a4032
> 							*P*
3103a4036
> 							*c_put*
3109a4043
> 							*r_sbracket_p*
3112a4047,4048
> ["x][P		or					*l_sbracket_P*
> ["x]]P		or			*r_sbracket_P* *l_sbracket_p*
3144,3145c4080,4086
< There are four types of registers: The unnamed register, 10 numbered
< registers, 26 named registers and two read-only registers.
---
> There are five types of registers:
> - The unnamed register ""
> - 10 numbered registers "0 to "9
> - The small delete register "-
> - 26 named registers "a to "z or "A to "Z
> - three read-only registers ":, ". and "%
> 
3158c4099
< "x" or "dw" will not be put in a numbered register). The contents of
---
> "x" or "dw" will be put in the small delete register). The contents of
3161a4103,4104
> 	The small delete register is filled with delete commands that delete
> less than one line, except when a register was specified with ["x].
3181c4124
< :[range]co[py] {address}
---
> :[range]co[py] {address}				*c_copy*
3184a4128
> 							*c_t*
3187c4131
< :[range]m[ove] {address}
---
> :[range]m[ove] {address}				*c_move*
3192c4136
< 	13. Visual mode
---
> 	13. Visual mode					*visual_mode*
3195c4139,4140
< operator. It is the only way to select a block of text.
---
> operator. It is the only way to select a block of text. {Vi has no visual
> mode}
3197c4142,4143
< v			start/stop Visual mode per character. {not in Vi}
---
> 							*v*
> v			start Visual mode per character. {not in Vi}
3199c4145,4146
< V			start/stop Visual mode linewise. {not in Vi}
---
> 							*V*
> V			start Visual mode linewise. {not in Vi}
3201c4148,4149
< CTRL-V			start/stop Visual mode blockwise. {not in Vi}
---
> 							*ctrl_v*
> CTRL-V			start Visual mode blockwise. {not in Vi}
3202a4151
> 							*v_o*
3207a4157,4173
> 							*left_mouse_click*
> left-mouse-click	Set the current cursor position. If visual mode is
> 			active it is stopped. If the position is in the last
> 			line on the screen the text is scrolled up.  If the
> 			position is in the first line on the screen the text
> 			is scrolled down. {not in Vi}
> 
> 							*right_mouse_click*
> right-mouse-click	Start visual mode if it is not active. The text from
> 			the cursor position to the position of the click is
> 			highlighted. If visual mode was already active move
> 			the start or end of the highlighted text, which ever
> 			is closest, to the position of the click. If the
> 			position is in the last line on the screen the text
> 			is scrolled up. If the position is in the first line
> 			on the screen the text is scrolled down.
> 
3242,3245c4208,4211
< If you use "v", "V", CTRL-V, ESC or any command that does a jump to another
< window while in Visual mode, the highlighting stops and no text is affected.
< If you hit CTRL-Z the highlighting stops and the editor is suspended or a new
< shell is started.
---
> If you use ESC, click the left mouse button or use any command that does a
> jump to another buffer while in Visual mode, the highlighting stops and no
> text is affected.  If you hit CTRL-Z the highlighting stops and the editor
> is suspended or a new shell is started |ctrl_z|.
3252,3255c4218,4221
< If the "v", "V" or CTRL-V is preceded with a count, the previously
< highlighted area is used for a start. You can then move the end of the
< highlighted area and give an operator. The type of the old area is used
< (character, line or blockwise).
---
> If visual mode is not active and the "v", "V" or CTRL-V is preceded with a
> count, the previously highlighted area is used for a start. You can then
> move the end of the highlighted area and give an operator. The type of the
> old area is used (character, line or blockwise).
3269,3277c4235,4243
< 	~	switch case
< 	d	delete
< 	c	change
< 	y	yank
< 	>	shift right (1)(*)
< 	<	shift left (1)(*)
< 	!	filter through external command (1)
< 	=	filter through 'equalprg' option command (1)
< 	Q	format lines to 'textwidth' length (1)
---
> 	~	switch case					|v_tilde|
> 	d	delete						|v_d|
> 	c	change						|v_c|
> 	y	yank						|v_y|
> 	>	shift right (1)(*)				|v_greater|
> 	<	shift left (1)(*)				|v_smaller|
> 	!	filter through external command (1)		|v_bang|
> 	=	filter through 'equalprg' option command (1)	|v_equal|
> 	Q	format lines to 'textwidth' length (1)		|v_Q|
3280,3292c4246,4258
< 	:	start ex command for highlighted lines (1)
< 	r	change
< 	s	change
< 	C	change (2)
< 	R	change (2)
< 	S	change (2)
< 	x	delete
< 	D	delete (2)
< 	X	delete (2)
< 	Y	yank (2)
< 	J	join (1)
< 	U	make uppercase
< 	u	make lowercase
---
> 	:	start ex command for highlighted lines (1)	|v_colon|
> 	r	change						|v_r|
> 	s	change						|v_s|
> 	C	change (2)					|v_C|
> 	R	change (2)					|v_R|
> 	S	change (2)					|v_S|
> 	x	delete						|v_x|
> 	D	delete (2)					|v_D|
> 	X	delete (2)					|v_X|
> 	Y	yank (2)					|v_Y|
> 	J	join (1)					|v_J|
> 	U	make uppercase					|v_U|
> 	u	make lowercase					|v_u|
3317c4283
< 	14. Various commands
---
> 	14. Various commands				*various*
3318a4285
> 							*ctrl_l*
3321,3324c4288
< CTRL-Z			On Unix systems: Suspend Vim. On other systems: 
< 			start a new shell (like ":sh").
< 
< <HELP>		or
---
> <HELP>		or					*help* *c_help*
3333a4298
> 							*del*
3334a4300,4302
> 			Note: if you like to use <BS> for this, add this
> 			mapping to your .vimrc:
> 				:map! CTRL-V <BS>   CTRL-V <DEL>
3335a4304
> 							*c_print*
3340c4309
< 			current line, see 4.4.4).
---
> 			current line |cmdline_ranges|).
3341a4311
> 							*c_list*
3345a4316
> 							*c_number*
3348c4319
< 			number.
---
> 			number. (See also 'highlight' option).
3349a4321
> 							*c_hatch*
3351a4324
> 							*c_equal*
3353a4327
> 							*c_shell*
3355a4330
> 							*c_bang*
3360a4336
> 							*c_version*
3365a4342
> 							*K*
3368c4345
< 			'keywordprg' (kp) option (default is "ref"). The
---
> 			'keywordprg' (kp) option (default is "man"). The
3370,3372c4347,4349
< 			underscore. The identifier under or right of the
< 			cursor is used. The same can be done with the
< 			command
---
> 			characters in 'identchars'. The identifier under or
> 			right of the cursor is used. The same can be done
> 			with the command
3378c4355,4356
< [N]gs
---
> [N]gs							*gs*
> 							*c_sleep*
3384c4362
< 	15. Repeating commands
---
> 	15. Repeating commands				*repeating*
3386c4364
< 15.1 Single repeats
---
> 15.1 Single repeats					*single_repeat*
3394c4372
< and redo for an example how to use this.
---
> and redo for an example how to use this |undo_redo|.
3397c4375
< 15.2 Multiple repeats
---
> 15.2 Multiple repeats					*multi_repeat*
3398a4377
> 							*c_global*
3427c4406
< 15.3 Complex repeats
---
> 15.3 Complex repeats					*complex_repeat*
3428a4408
> 							*q*
3437a4418
> 							*at*
3440a4422
> 							*at_colon*
3442a4425
> 							*at_at*
3444a4428
> 							*c_at*
3453a4438
> 							*c_at_at*
3457a4443
> 							*c_source*
3498,3538c4484,4488
< terminal-independent single character codes. In the MSDOS version the values
< are 48 (0x30) higher. Any of these codes can be entered with CTRL-V followed
< by the three digit decimal code.
< 
< 	code	hex	meaning
< 
< 	128	0x80	up-arrow
< 	129	0x81	down-arrow
< 	130	0x82	left-arrow
< 	131	0x83	right-arrow
< 	132	0x84	shift up-arrow
< 	133	0x85	shift down-arrow
< 	134	0x86	shift left-arrow
< 	135	0x87	shift right-arrow
< 
< 	136	0x88	function key 1
< 	137	0x89	function key 2
< 	138	0x8a	function key 3
< 	139	0x8b	function key 4
< 	140	0x8c	function key 5
< 	141	0x8d	function key 6
< 	142	0x8e	function key 7
< 	143	0x8f	function key 8
< 	144	0x90	function key 9
< 	145	0x91	function key 10
< 
< 	146	0x92	shifted function key 1
< 	147	0x93	shifted function key 2
< 	148	0x94	shifted function key 3
< 	149	0x95	shifted function key 4
< 	150	0x96	shifted function key 5
< 	151	0x97	shifted function key 6
< 	152	0x98	shifted function key 7
< 	153	0x99	shifted function key 8
< 	154	0x9a	shifted function key 9
< 	155	0x9b	shifted function key 10
< 
< 	156	0x9c	help key
< 	157	0x9d	undo key
< 	158	0x9e	special-function key follows (MSDOS)
< 	159	0x9f	CTRL-@
---
> terminal-independent two character codes. This means that they can be used
> in the same way on different kinds of terminals. The first character of a
> key code is 0x80 or 128, shown on the screen as "~@". The second one can be
> found in the list |key_notation|.  Any of these codes can also be entered
> with CTRL-V followed by the three digit decimal code.
3541c4491
< 	16. Undo and redo
---
> 	16. Undo and redo				*undo_redo*
3543c4493
< <UNDO>		or
---
> <UNDO>		or					*undo* *u*
3545a4496
> 							*c_undo*
3547a4499
> 							*ctrl_r*
3550a4503
> 							*c_redo*
3552a4506
> 							*U*
3596c4550
< 	17. Key mapping
---
> 	17. Key mapping					*key_mapping*
3597a4552
> 							*c_map*
3602a4558
> 							*c_noremap*
3609a4566
> 							*c_unmap*
3625a4583
> 							*c_cmap*
3628a4587
> 							*c_cunmap*
3631a4591
> 							*c_cnoremap*
3634a4595
> 							*c_imap*
3636a4598
> 							*c_iunmap*
3639a4602
> 							*c_inoremap*
3646c4609
< to save and restore the current mapping.
---
> to save and restore the current mapping |options|.
3679,3681c4642,4645
< Note that the second character (argument) of the commands @zZtTfF[]rm'`"v is
< not mapped. This was done to be able to use all the named registers and
< marks, even when the command with the same name has been mapped.
---
> Note that the second character (argument) of the commands @zZtTfF[]rm'`"v
> and CTRL-X is not mapped. This was done to be able to use all the named
> registers and marks, even when the command with the same name has been
> mapped.
3698c4662
< might want to set the 'ttimeout' option. See the "Options" chapter.
---
> might want to set the 'ttimeout' option. See the "Options" chapter |options|.
3699a4664,4675
> If you include the {lhs} in the {rhs} you have a recursive mapping. When
> {lhs} is typed, it will be replaced by {rhs}. When the {lhs} which is
> included in {rhs} is encountered it will be replaced by {rhs}, and so on.
> This makes it possible to repeat a command an infinite number of times. The
> only problem is that the only way to stop this is by causing an error. The
> macros to solve a maze uses this, look there for an example. There is one
> exception: If the {rhs} starts with {lhs}, that part is not mapped again.
> For example:
> 	:map a ab
> will execute the "a" command and insert a 'b' in the text. The 'a' in the
> {rhs} will not be mapped again.
> 
3724c4700,4703
<    you have to type CTRL-V before hitting the function key.
---
>    you have to type CTRL-V before hitting the function key. Note that when
>    the key code for the key is in the termcap (the t_ options), it will
>    automatically be translated into the internal code and become the second
>    way of mapping.
3727,3730c4706,4712
<    the form "#1", "#2", .. "#9", "#0". Only the first ten function keys can
<    be used this way ("#0" refers to function key 10, defined with option
<    't_f10', which may be function key zero on some keyboards).
< The advantage of the second method is that the mapping will mostly work on
---
>    the form "#1", "#2", .. "#9", "#0", "<C_UP>", "<SC_DOWN>", "<SF_7>", etc.
>    (see table of keys |key_notation|, all keys from <C_UP> can be used). The
>    first ten function keys can be defined in two ways: Just the number, like
>    "#2", and with "<F_>", like "<F_2>". Both stand for function key 2. "#0"
>    refers to function key 10, defined with option 't_f10', which may be
>    function key zero on some keyboards.
> The advantage of the second method is that the mapping will work on
3737,3743c4719,4726
< isn't the terminal key codes are tried (see section 20.2). If a terminal
< code is found it is replaced by the internal code. Then the check for a
< mapping is done again (so you can map an internal code to something else).
< What is written into the script file depends on what is recognized. If the
< terminal key code was recognized as a mapping the key code itself is written
< to the script file. If it was recognized as a terminal code the internal
< code is written to the script file.
---
> isn't the terminal key codes are tried (see section 20.2
> |terminal_options|). If a terminal code is found it is replaced by the
> internal code. Then the check for a mapping is done again (so you can map an
> internal code to something else).  What is written into the script file
> depends on what is recognized. If the terminal key code was recognized as a
> mapping the key code itself is written to the script file. If it was
> recognized as a terminal code the internal code is written to the script
> file.
3746c4729
< 	18. Recovery after a crash.
---
> 	18. Recovery after a crash.			*crash_recovery*
3754c4737
< 18.1 The swap file
---
> 18.1 The swap file					*swap_file*
3757,3758c4740,4742
< you started from plus the swap file you can mostly recover your work. You
< can see the name of the current swap file being used with the command:
---
> you started from plus the swap file you can mostly recover your work.
> 
> You can see the name of the current swap file being used with the command:
3760c4744
< 	:sw[apname]
---
> 	:sw[apname]					*c_swapname*
3809c4793,4795
< :pres[erve]		Write all text for all buffers into swap file. {Vi:
---
> 							*c_preserve*
> :pres[erve]		Write all text for all buffers into swap file. The
> 			original file is no longer needed for recovery. {Vi:
3816c4802
< 18.2 Recovery
---
> 18.2 Recovery						*recovery*
3828c4814
< Example:	Vim -r reference.doc.swp
---
> Example:	Vim -r reference.doc.swo
3832c4818,4819
< files accordingly. 
---
> files accordingly. Check the 'directory' option to see where Vim may have
> put the swap file.
3834c4821,4835
< There is some intelligence about what to do if the swap file is corrupt in
---
> Another way to do recovery is to start Vim and use the ":recover" command.
> This is easy when you start Vim to edit a file and you get the "ATTENTION:
> Found a swap file ..." message. In this case the single command ":preserve"
> will do the work. You can also give the name of the file or the swap file to
> the preserve command:
> 							*c_recover*
> :recover [file]		Try to recover [file] from the swap file. If [file]
> 			is not given use the file name for the current
> 			buffer. The current contents of the buffer are lost.
> 			This command fails if the buffer was modified.
> 
> :recover! [file]	Like ":recover", but any changes in the current
> 			buffer are lost.
> 
> Vim has some intelligence about what to do if the swap file is corrupt in
3851c4852
< 	19. Options
---
> 	19. Options					*options*
3859c4860
< 19.1 Setting options
---
> 19.1 Setting options					*set_option*
3860a4862
> 							*c_set*
3874c4876,4882
< :se[t] {option}={value} Set string or number option to {value}.
---
> :se[t] {option}={value} Set string or number option to {value}. For numeric
> 			options the value can be given in decimal, hex
> 			(preceded with 0x) or octal (preceded with '0')
> 			(hex and octal are only available for machines which
> 			have the strtol() function). The old value can be
> 			inserted by typing TAB (or whatever the value of
> 			'wildchar' is). See 4.4.2 |cmdline_completion|.
3889,3895c4897,4903
< An environment variable in most string options will be expanded. This
< happens only when the string starts with a <$>. If the environment variable
< exists the <$> and the following environment variable name is replaced by
< its value. If it does not exist the <$> and the name are not modified. Any
< non-id character (not a letter, digit or <_>) may follow the environment
< variable name. That character and what follows is appended to the value of
< the environment variable. Example:
---
> Environment variables in most string options will be expanded. This
> happens only when the string starts with a <$> or has a <$> after a space.
> If the environment variable exists the <$> and the following environment
> variable name is replaced by its value. If it does not exist the <$> and the
> name are not modified. Any non-id character (not a letter, digit or <_>) may
> follow the environment variable name. That character and what follows is
> appended to the value of the environment variable. Example:
3900c4908
< Besides changing options with the ":set" command, there are four 
---
> Besides changing options with the ":set" command, there are seven 
3902,3905c4910,4913
< and second ones are used for all files. The third is used to set options for 
< the files in one directory. The last is used to set options for a single 
< file. The first three are done when you start Vim, in the given order. The 
< last is done whenever you start editing a new file.
---
> four are used for all files. The fifth is used to set options for 
> the files in one directory. The last two are used to set options for a
> single file. The first five are done when you start Vim, in the given
> order. The last two are done whenever you start editing a new file.
3919c4927,4930
< 6. If you start editing a new file, and the 'modeline' option is set, a
---
> 6. If you start editing a new file, the automatic commands are executed.
>    This can be used to set options for files matching a particular pattern.
>    See the section "Automatic commands" |autocommand|.
> 7. If you start editing a new file, and the 'modeline' option is set, a
3924c4935
<    		"vi:noai:sw=3 ts=6"
---
> 		"vi:noai:sw=3 ts=6"
3932c4943
<    		"/* vi:ts=4: */"
---
> 		"/* vi:ts=4: */"
3939c4950
<    		"/* vi:set ts=4: */"
---
> 		"/* vi:set ts=4: */"
3944c4955
< 19.2 Saving settings
---
> 19.2 Saving settings					*save_settings*
3945a4957
> 							*c_mkexrc*
3952a4965
> 							*c_mkvimrc*
3963c4976
< 19.3 Options summary
---
> 19.3 Options summary				*option_summary*
3969a4983,4994
> Most options are the same in all windows and buffers. There are a few that
> are specific to how the text is presented in a window. These can be set to a
> different value in each window. For example the 'list' option can be set in
> one window and reset in another for the same text, giving both types of view
> at the same time. There are a few options that are specific to a certain
> file. These can have a different value for each file or buffer. For example
> the 'textwith' option can be 78 for a normal text file and 0 for a C
> program. When creating a new window or buffer the option values from the
> currently active window or buffer are used as a default value.
> 
> 
> 						*autoindent*
3977c5002,5006
< 	option is reset when the 'paste' option is set.
---
> 	option is reset when the 'paste' option is set. {small difference
> 	from vi: After the indent is deleted when typing <ESC> or <CR>, the
> 	cursor position when moving up or down is after the deleted indent;
> 	vi puts the cursor somewhere in the deleted indent}. Each buffer has
> 	its own copy of this option.
3978a5008
> 						*autowrite*
3984a5015
> 						*backspace*
3992c5023,5024
< backup (bk)		toggle	(default on)
---
> 						*backup*
> backup (bk)		toggle	(default off)
3996,3998c5028,5031
< 	written, reset this option and set the 'writebackup' option. If you
< 	do not want a backup file at all reset both options (See the table
< 	in section 5.4 for another explanation.). {not in Vi}
---
> 	written, reset this option and set the 'writebackup' option (this is
> 	the default). If you do not want a backup file at all reset both
> 	options (use this if your file system is almost full). See the table
> 	in section 5.4 for another explanation |backup_table|. {not in Vi}
3999a5033
> 						*backupdir*
4007a5042,5050
> 						*backupext*
> backupext (bex)		string	(default ".~")
> 	String which is appended to a file name to make the name of the
> 	backup file. The default is quite unusual, because this avoids
> 	accidently overwriting existing files with a backup file. You might
> 	prefer using ".bak", but make sure that you don't have files with
> 	".bak" that you want to keep. {not in Vi}
> 
> 						*binary*
4016c5059,5060
< 	the 'endofline' option. {not in Vi}
---
> 	the 'endofline' option. Each buffer has its own copy of this option.
> 	{not in Vi}
4017a5062
> 						*bioskey*
4023a5069
> 						*cmdheight*
4028a5075
> 						*columns*
4033a5081,5086
> 						*comments*
> comments (com)		string	(default "/* ,* ,*/,//,# ,%,XCOMM")
>         Represents patterns that can start a comment line. See |formatting|.
> 	Each buffer has its own copy of this option. {not in Vi}
> 
> 						*compatible*
4047a5101,5102
> 	identchars	"_"		identifiers contain alphanumeric
> 						characters and '_'
4057a5113,5114
> 	smartmatch	off		no smart paren matching
> 	startofline	on		goto startofline with some commands
4065d5121
< 	yankendofline	off		do not Yank to end of line
4066a5123,5136
> 						*define*
> define (def)		string	(default "^#[ \t]*define")
> 	Pattern to be used to find a macro definition. It is a search
> 	pattern, just like for the "/" command. The default value is for C
> 	programs. This option is used for the commands like "[g"
> 	|include_search| and "[d" |include_search|. {not in Vi}
> 
> 						*dictionary*
> dictionary (dict)	string	(default "")
> 	List of file names, separated by spaces. Each file should contain a
> 	list of words, one per line. This option is used for keyword
> 	completion. {not in Vi}
> 
> 						*digraph*
4071a5142
> 						*directory*
4080,4082c5151,5153
< 	<\> characters, type two to get one in the option, ":set
< 	dir=c:\\tmp". {Vi: directory to put temp file in, defaults to
< 	"/tmp"}
---
> 	<\> characters, type two to get one in the option,
> 		":set dir=c:\\tmp".
> 	{Vi: directory to put temp file in, defaults to "/tmp"}
4083a5155
> 						*edcompatible*
4086,4087c5158,5159
< 	toggled each time the flag is given. See 11.3. See also 'gdefault'
< 	option.
---
> 	toggled each time the flag is given. See 11.3 |complex_change|. See
> 	also 'gdefault' option.
4088a5161
> 						*endofline*
4090,4100c5163,5174
< 	When writing a file and this option is off and the 'binary' option is
< 	set, no end of line (newline) character will be written for the last
< 	line in the file. This option is automatically set when starting to
< 	edit a new file, unless the 'binary' options is set and the file does
< 	not have an end of line (newline) for the last line in the file, in
< 	which case it is reset. Normally you don't have to set or reset this
< 	option. When 'binary' is not set the value is not used. When 'binary'
< 	is set it is used to remember the presence of a newline for the last
< 	line in the file, so that when you write the file the situation from
< 	the original file can be kept. But you can change it when you want to.
< 	{not in Vi}
---
> 	When writing a file and this option is off and the 'binary' option
> 	is set, no end of line (newline) character will be written for the
> 	last line in the file. This option is automatically set when
> 	starting to edit a new file, unless the 'binary' options is set and
> 	the file does not have an end of line (newline) for the last line in
> 	the file, in which case it is reset. Normally you don't have to set
> 	or reset this option. When 'binary' is not set the value is not
> 	used. When 'binary' is set it is used to remember the presence of a
> 	newline for the last line in the file, so that when you write the
> 	file the situation from the original file can be kept. But you can
> 	change it when you want to. Each buffer has its own copy of this
> 	option. {not in Vi}
4101a5176
> 						*equalalways*
4108a5184
> 						*equalprg*
4112a5189
> 						*errorbells*
4116a5194
> 						*errorfile*
4118,4119c5196,5197
< 	Name of the error file for the QuickFix mode (see 5.5). Environment
< 	variables are expanded. {not in Vi}
---
> 	Name of the error file for the QuickFix mode (see 5.5
> 	|c_make_makeprg|). Environment variables are expanded. {not in Vi}
4120a5199
> 						*errorformat*
4124c5203
< 	(see 5.5). {not in Vi}
---
> 	(see 5.5 |quickfix|). {not in Vi}
4125a5205
> 						*esckeys*
4132a5213
> 						*expandtab*
4137c5218,5220
< 	set, use CTRL-V<TAB>. {not in Vi}
---
> 	set, use CTRL-V<TAB>. See also ":retab" command in 11.3 |c_retab|
> 	and section 4.3.4 |ins_expandtab|. Each buffer has its own copy of
> 	this option. {not in Vi}
4138a5222
> 						*exrc*
4142c5226,5232
< 	'secure' option (see 3.4). {not in Vi}
---
> 	'secure' option (see 3.4 |initialization|). {not in Vi}
> 
> 						*formatoptions*
> formatoptions (fo)	string (default "tcqs")
> 	This is a sequence of letters which describes how automatic
> 	formatting is to be done.  See |formatting|. Each buffer has its own
> 	copy of this option. {not in Vi}
4143a5234
> 						*formatprg*
4151a5243
> 						*gdefault*
4154,4155c5246,5247
< 	all matches in a line are substituted instead of one. See 11.3. {not
< 	in Vi} 
---
> 	all matches in a line are substituted instead of one. See 11.3
> 	|complex_change|. {not in Vi} 
4156a5249
> 						*graphic*
4163a5257
> 						*helpfile*
4169a5264
> 						*hidden*
4178c5273,5274
< highlight (hl)		string	(default "db,es,hs,rs,vi,si")
---
> 						*highlight*
> highlight (hl)		string	(default "8b,db,es,hs,mb,nu,rs,si,tb,vi")
4183c5279
< 		v	visual mode
---
> 		8	Meta & special keys listed with ":map"
4186d5281
< 		s	status lines
4187a5283,5284
> 		m	"More?" message
> 		n	line number for ":number" and ":#" commands
4188a5286,5288
> 		s	status lines
> 		t	Titles for output from ":set all" and ":autocmd" etc.
> 		v	visual mode
4198a5299
> 						*history*
4201a5303
> 						*icon*
4208a5311,5321
> 						*identchars*
> identchars (id)		string	(default "_")
> 	The characters in this option are included in identifiers.
> 	Identifiers are used in searching and recognizing words with many
> 	commands: "*", "[g", etc. Some characters need a backslash before
> 	them: '"' and ']'. If you use '-' it will be moved to the end of the
> 	option automatically (to avoid problems with CTRL-N in insert mode).
> 	Each buffer has its own copy of this option. For C programs you
> 	could use "_.->". {not in Vi}
> 
> 						*ignorecase*
4212a5326,5351
> 						*include*
> include (inc)		string	(default "^#[ \t]*include")
> 	Pattern to be used to find an include command. It is a search
> 	pattern, just like for the "/" command (See 6.5, "Pattern
> 	searches" |search_pattern|). The default value is for C programs.
> 	This option is used for the commands "[g", "]g", "[d", etc.  {not in
> 	Vi}
> 
> 						*incsearch*
> incsearch (is)		toggle	(default off)
> 	While typing a search pattern, show immediately where the so far
> 	typed pattern matches. The matched string is highlighted. If the
> 	pattern is invalid or not found, nothing is shown. The screen will
> 	be updated often, this is only useful on fast terminals. {not in Vi}
> 
> 						*infercase*
> infercase (inf)		toggle	(default off)
> 	When doing keyword completion in insert mode |ins_completion|, and
> 	'ignorecase' is also set, the case of the match is adjusted. If the
> 	typed text contains a lowercase letter where the match has an upper
> 	case letter, the completed part is made lower case. If the typed
> 	text has no lower case letters and the match has a lower case letter
> 	where the typed text has an upper case letter, and there is a letter
> 	before it, the completed part is made uppercase.  {not in Vi}
> 
> 						*insertmode*
4215a5355
> 						*joinspaces*
4219c5359,5360
< keywordprg (kp)		string	(default "ref")
---
> 						*keywordprg*
> keywordprg (kp)		string	(default "man")
4222a5364
> 						*laststatus*
4231a5374
> 						*lines*
4235a5379
> 						*list*
4238a5383
> 	Each window has its own copy of this option.
4239a5385
> 						*magic*
4242c5388
< 	See section "Pattern searches".
---
> 	See section "Pattern searches" |search_pattern|.
4243a5390
> 						*makeprg*
4245,4247c5392,5395
< 	Program to use for the ":make" command. This option may contain
< 	<%> and <#> characters, which are expanded like when used in a
< 	command line. Environment variables are expanded. {not in Vi}
---
> 	Program to use for the ":make" command. See |c_make_makeprg|. This
> 	option may contain <%> and <#> characters, which are expanded like
> 	when used in a command line. Environment variables are expanded.
> 	{not in Vi}
4248a5397
> 						*maxmem*
4253a5403
> 						*maxmemtot*
4258a5409
> 						*modeline*
4259a5411
> 						*modelines*
4263c5415,5416
< 	0 no lines are checked. See 19.1. {not in Vi}
---
> 	0 no lines are checked. See 19.1 |set_option|. Each buffer has its
> 	own copy of the 'modeline' option. {not in Vi}
4264a5418
> 						*more*
4266,4271c5420,5434
< 	Listings pause when the whole screen is filled. Type <CR> for one
< 	more line. Type <SPACE> for the next page. Type 'q' to stop the
< 	listing. When this option is off there are no pauses, the listing
< 	continues until finished. When Vim was compiled with COMPATIBLE
< 	defined this option is default off. When 'compatible' is set this
< 	option is off. {not in Vi}
---
> 	Listings pause when the whole screen is filled.
> 	Type <CR> or <LF> for one more line.
> 	Type <SPACE> for the next page.
> 	Type 'd' for down half a page.
> 	Type 'q' or CTRL-C to stop the listing.
> 	Any other key is ignored. When this
> 	option is off there are no pauses, the listing continues until
> 	finished. When Vim was compiled with COMPATIBLE defined this option
> 	is default off. When 'compatible' is set this option is off. Note:
> 	The key typed at the "more" prompt is not mapped {not in Vi}
> 
> nestedcomments (ncom)	string	(default ">")
> 	Contains patterns that start comments that can be nested. See
> 	|formatting|. Each buffer has its own copy of this option. {not in
> 	Vi}
4272a5436
> 						*nobuf*
4276a5441
> 						*number*
4278c5443,5444
< 	Print the line number in front of each line.
---
> 	Print the line number in front of each line. Each window has its own
> 	copy of this option.
4279a5446
> 						*paragraphs*
4282c5449
< 	of two letters (see section 6.4).
---
> 	of two letters (see section 6.4 |object_motions|).
4283a5451
> 						*paste*
4295a5464
> 						*patchmode*
4307a5477,5488
> 						*path*
> path (pa)		string  (default ". /usr/include" on unix, or ".")
> 	This is a list of directories which will be searched when using the
> 	gf, [f, ]f, ^Wf and other commands, provided that the file being
> 	searched for has a relative path (not absolute).  The directories
> 	may be relative or absolute.  When setting, \ must be used to escape
> 	spaces, eg:
> 		:set path=.\ /usr/local/include\ /usr/include
> 	Don't forget "." or files won't even be found in the current
> 	directory!  {not in Vi}
> 
> 						*readonly*
4313c5494,5495
< 	is reset if you overwrite the current file (e.g. with ":w!").
---
> 	is reset if you overwrite the current file (e.g. with ":w!"). Each
> 	buffer has its own copy of this option.
4314a5497
> 						*remap*
4318a5502
> 						*report*
4321a5506
> 						*revins*
4324,4325c5509,5511
< 	backwards". Can be toggled with the CTRL-B command in Insert mode.
< 	This option is reset when 'compatible' or 'paste' is set. {not in Vi}
---
> 	backwards" |ins_reverse|. Can be toggled with the CTRL-B command in
> 	Insert mode.  This option is reset when 'compatible' or 'paste' is
> 	set. {not in Vi}
4326a5513
> 						*ruler*
4333a5521
> 						*scroll*
4339c5527
< 	":set scroll=0".
---
> 	":set scroll=0". Each window has its own copy of this option.
4340a5529
> 						*scrolljump*
4345a5535
> 						*sections*
4348c5538
< 	two letters (See section 6.4).
---
> 	two letters (See section 6.4 |object_motions|).
4349a5540
> 						*secure*
4356a5548
> 						*shell*
4363a5556
> 						*shellpipe*
4366,4373c5559,5577
< 	error file. For the Amiga and MSDOS the default is ">". The output
< 	is directly saved in a file and not echoed to the screen. For Unix
< 	the default it "| tee". The stdout of the compiler is saved in a
< 	file and echoed to the screen. If the 'shell' option is "csh" during
< 	initializations, the default becomes "|& tee". If the 'shell' option
< 	is "sh", "ksh" or "bash" the default becomes "2>&1| tee". This means
< 	that stderr is also included. Setting the 'shell' option does not
< 	automatically change the 'shellpipe' option.
---
> 	error file. See also |c_make_makeprg|. For the Amiga and MSDOS the
> 	default is ">". The output is directly saved in a file and not
> 	echoed to the screen. For Unix the default it "| tee". The stdout of
> 	the compiler is saved in a file and echoed to the screen. If the
> 	'shell' option is "csh", "tcsh" or "zsh" during initializations, the
> 	default becomes "|& tee". If the 'shell' option is "sh", "ksh" or
> 	"bash" the default becomes "2>&1| tee". This means that stderr is
> 	also included.  Setting the 'shell' option does not automatically
> 	change the 'shellpipe' option. {not in Vi}
> 
> 						*shellredir*
> shellredir (srr)	string	(default ">", ">&" or "2>&1 1>")
> 	String to be used to put the output of a filter in a temporary file.
> 	See also |c_bang|. The default is ">".  For Unix, if the 'shell'
> 	option is "csh", "tcsh" or "zsh" during initializations, the default
> 	becomes ">&". If the 'shell' option is "sh", "ksh" or "bash" the
> 	default becomes "2>&1 1>". This means that stderr is also included.
> 	Setting the 'shell' option does not automatically change the
> 	'shellpipe' option. {not in Vi}
4374a5579
> 						*shelltype*
4385a5591
> 						*shiftround*
4389a5596
> 						*shiftwidth*
4391c5598,5616
< 	Number of spaces to use for (auto)indent.
---
> 	Number of spaces to use for (auto)indent. Each buffer has its own
> 	copy of this option.
> 
> 						*shortmess*
> shortmess (shm)		number	(default 0)
> 	This option helps to avoid all the "Hit return" messages caused by
> 	file messages, eg with ^G.  If shm=2 and the message will be too
> 	long then the start is truncated and "<" will appear in the left
> 	most column.  Also when shortmess is 1 or 2, [Modified] will be
> 	written as [+], [readonly] will be written as [RO], and "(file 3 of
> 	5)" will be written as "(3 of 5)".  All this hopefully means that
> 	changing between buffers rarely requires hitting return, but still
> 	gives as useful a message as possible for the space available.  When
> 	shm=2, to get the whole message that you would have got with shm=1,
> 	use :file!
> 	    shm=0       -- No abbreviation of message.
> 	    shm=1       -- Abbreviation, but no loss of information.
> 	    shm=2       -- Abbreviation, and truncate message when necessary.
> 	{not in Vi}
4392a5618
> 						*shortname*
4397c5623
< 	extension (".bak" or ".swp"). This option is not available for 
---
> 	extension (".~" or ".swp"). This option is not available for 
4400c5626,5627
< 	or crossdos. {not in Vi}
---
> 	or crossdos. Each buffer has its own copy of this option. {not in
> 	Vi}
4401a5629
> 						*showcmd*
4405a5634
> 						*showmatch*
4409a5639
> 						*showmode*
4412a5643
> 						*sidescroll*
4419a5651
> 						*smartindent*
4435c5667,5683
< 	'smartindent' is reset when the 'paste' option is set. {not in Vi}
---
> 	'smartindent' is reset when the 'paste' option is set. Each buffer
> 	has its own copy of this option. {not in Vi}
> 
> 						*smartmatch*
> smartmatch (sma)	toggle	(default on)
> 	When this option is off vi-compatible matching is done for the "%"
> 	command. Parens inside single and double quotes are also counted,
> 	causing a string that contains a paren to disturb the matching. For
> 	example, in a line like "if (strcmp("foo(", s))" the first paren
> 	does not match the last one.
> 	When this option is off, parens inside single and double quotes are
> 	treated specially. When matching a paren outside of quotes,
> 	everyting inside quotes is ignored. When matching a paren inside
> 	quotes, it will find the matching one (if there is one). This works
> 	very well for C programs.
> 	This option is reset when the 'compatible' option is set. {not in
> 	Vi}
4436a5685
> 						*smarttab*
4440,4441c5689,5690
< 	positions, 'shiftwidth' is only used for ">>" and the like. {not in
< 	Vi}
---
> 	positions, 'shiftwidth' is only used for ">>" and the like. See also
> 	section 4.3.4 |ins_expandtab|. {not in Vi}
4442a5692
> 						*splitbelow*
4446c5696,5706
< suffixes (su)		string	(default ".bak.o.h.info.swp")
---
> 						*startofline*
> startofline (sol)	toggle	(default on)
> 	When set the commands listed below move the cursor to the first
> 	blank of the line. If not set the cursor is kept in the same column
> 	(if possible). This applies to the commands: CTRL-D, CTRL-U, CTRL-B,
> 	CTRL-F, "G", "H", "M", "L", , and to the commands "d", "<<" and ">>"
> 	with a linewise operator and with "%" with a count. This option is
> 	set when the 'compatible' option is set. {not in Vi}
> 
> 						*suffixes*
> suffixes (su)		string	(default ".bak.~.o.h.info.swp")
4449a5710
> 						*tabstop*
4451c5712,5714
< 	Number of spaces that a <TAB> in the file counts for.
---
> 	Number of spaces that a <TAB> in the file counts for. (See also
> 	":retab" command in 11.3 |c_retab|). Each buffer has its own copy of
> 	this option.
4452a5716
> 						*taglength*
4455a5720
> 						*tagrelative*
4461a5727
> 						*tags*
4466a5733
> 						*term*
4471a5739
> 						*terse*
4474a5743
> 						*textauto*
4479a5749
> 						*textmode*
4484c5754
< 	is on. {not in Vi}
---
> 	is on. Each buffer has its own copy of this option. {not in Vi}
4485a5756
> 						*textwidth*
4490c5761,5762
< 	'textwidth' is zero, 'wrapmargin' may be used. {not in Vi} 
---
> 	'textwidth' is zero, 'wrapmargin' may be used. See |ins_textwidth|.
> 	Each buffer has its own copy of this option. {not in Vi} 
4491a5764
> 						*tildeop*
4494a5768
> 						*timeout*
4495a5770
> 						*ttimeout*
4521a5797
> 						*timeoutlen*
4525a5802
> 						*title*
4533a5811
> 						*ttyfast*
4541c5819,5820
< undolevels (ul)		number	(default 100)
---
> 						*undolevels*
> undolevels (ul)		number	(default 100, for unix 1000)
4545a5825
> 						*updatecount*
4549c5829
< 	chapter on recovery). {not in Vi}
---
> 	chapter on recovery |crash_recovery|). {not in Vi}
4550a5831
> 						*updatetime*
4553c5834,5835
< 	written to disk (see chapter on recovery). {not in Vi}
---
> 	written to disk (see chapter on recovery |crash_recovery|). {not in
> 	Vi}
4554a5837,5843
> 						*viminfo*
> viminfo (vi)		number	(default 0)
> 	When non-zero, the viminfo file is read upon startup and written
> 	when exiting Vim. The value is the maximum number of files for which
> 	the marks are remembered. See |viminfo_file|. {not in Vi}
> 
> 						*visualbell*
4557a5847
> 						*warn*
4561a5852
> 						*weirdinvert*
4567a5859
> 						*whichwrap*
4581a5874
> 						*wildchar*
4587a5881
> 						*winheight*
4595a5890
> 						*wrap*
4600c5895,5896
< 	will scroll horizontally (also see 'sidescroll' option. {not in Vi}
---
> 	will scroll horizontally (also see 'sidescroll' option. Each window
> 	has its own copy of this option. {not in Vi}
4601a5898
> 						*wrapmargin*
4604,4605c5901,5903
< 	starts. When 'textwidth' is set, this option is not used. {Vi: works
< 	differently and less useful}
---
> 	starts. When 'textwidth' is set, this option is not used. See
> 	|ins_textwidth|. Each buffer has its own copy of this option. {Vi:
> 	works differently and less useful}
4606a5905
> 						*wrapscan*
4609a5909
> 						*writeany*
4612a5913
> 						*writebackup*
4615,4620c5916,5919
< 	the file was successfully written, unless the 'backup' option is also 
< 	on. {not in Vi}
< 
< yankendofline (ye)	toggle	(default off)
< 	The Y command yanks from the cursor until the end of the line instead
< 	of whole lines. {not in Vi}
---
> 	the file was successfully written, unless the 'backup' option is
> 	also on. Reset this option if your file system is almost full. See
> 	the table in section 5.4 for another explanation |backup_table|.
> 	{not in Vi}
4623c5922
< 	20. Terminal information
---
> 	20. Terminal information			*terminal_info*
4630c5929
< stored in the terminal options, see section 20.2.
---
> stored in the terminal options, see section 20.2 |terminal_options|.
4633c5932
< 20.1 startup
---
> 20.1 startup						*startup*
4661c5960,5961
< done during initialization (see 3.4), otherwise its too late.
---
> done during initialization (see 3.4 |initialization|), otherwise its too
> late.
4691a5992,5994
> The default termcap entry for xterm on sun and other platforms does not
> contain the entry for scroll regions. Add ":cs=\E[%i%d;%dr:" to the
> xterm entry in /etc/termcap and everything should work.
4693d5995
< 20.2 terminal options
4694a5997,5998
> 20.2 terminal options					*terminal_options*
> 
4729a6034,6035
> 	t_ue	ue	underline end
> 	t_us	us	underline mode
4770a6077,6082
> 	t_ins	kI	insert key
> 	t_del	kD	delete key
> 	t_home	kh	home key
> 	t_end	@7	end key
> 	t_pu	kP	page-up key
> 	t_pd	kN	page-down key
4803,4804c6115,6116
< 		xmodmap -e "keysym Up = Up F16"
< 		xmodmap -e "keysym Down = Down F17"
---
> 		xmodmap -e "keysym Up = Up F13"
> 		xmodmap -e "keysym Down = Down F16"
4806c6118
< 		xmodmap -e "keycode Right = Right F19"
---
> 		xmodmap -e "keysym Right = Right F19"
4809,4819c6121,6133
< 		:map CTRL-V 151 CTRL-V 132
< 		:map! CTRL-V 151 CTRL-V 132
< 		:map CTRL-V 152 CTRL-V 133
< 		:map! CTRL-V 152 CTRL-V 133
< 		:map CTRL-V 153 CTRL-V 134
< 		:map! CTRL-V 153 CTRL-V 134
< 		:map CTRL-V 154 CTRL-V 135
< 		:map! CTRL-V 154 CTRL-V 135
< 
< Where 151-154 are the internal vim decimal codes for function keys F16 to
< F19 and 132-135 are the codes for the shifted arrow keys.
---
> 		:map <SF3> <SC_UP>
> 		:map! <SF3> <SC_UP>
> 		:map <SF6> <SC_DOWN>
> 		:map! <SF6> <SC_DOWN>
> 		:map <SF8> <SC_LEFT>
> 		:map! <SF8> <SC_LEFT>
> 		:map <SF9> <SC_RIGHT>
> 		:map! <SF9> <SC_RIGHT>
> 
> Instead of, say, <SC_UP> you can use any other command that you want to use
> the shift-cursor-up key for. (Note: F14 is not used because it is confused
> witht the undo key; F15 is not used, because it does a window-to-front; F17
> is not used, because it closes the window)
4822c6136
< 20.3 Window size
---
> 20.3 Window size					*window_size*
4855c6169
< 20.4 slow and fast terminals
---
> 20.4 slow and fast terminals			*slow_fast_terminal*
4871c6185
< See the "Options" chapter.
---
> See the "Options" chapter |options|.
4884c6198
< 	21. Differences from Vi and Ex
---
> 	21. Differences from Vi and Ex			*vi_differences*
4891c6205
< 21.1 Missing commands
---
> 21.1 Missing commands					*missing_commands*
4904d6217
< :rec[over]		{Vi: recover a file after a crash or :preserve}
4908c6221
< 21.2 Missing options
---
> 21.2 Missing options					*missing_options*
4915a6229
> flash (fl)		toggle  (default ??)
4919a6234
> novice			toggle	(default ??)
4939,4947c6254,6263
<  1. Introduction
<  2. Notation
<  3. Starting Vim
< 	3.1 Command line
< 	3.2 Workbench (Amiga only)
< 	3.3 Vim window (Amiga only)
< 	3.4 Initialization
< 	3.5 Suspending
<  4. Modes
---
>  1. Introduction				|intro|
>  2. Notation					|notation|
>  3. Starting Vim				|starting|
> 	3.1 Command line			|command_line|
> 	3.2 Workbench (Amiga only)		|workbench|
> 	3.3 Vim window (Amiga only)		|amiga_window|
> 	3.4 Initialization			|initialization|
> 	3.5 Suspending				|suspend|
> 	3.6 The viminfo file			|viminfo_file|
>  4. Modes					|edit_modes|
4949,5011c6265,6331
< 	4.2 Switching from mode to mode
< 	4.3 Insert and Replace mode
< 		4.3.1 special keys
< 		4.3.2 special special keys
< 		4.3.3 'textwidth' option
< 		4.3.4 'expandtab' option
< 		4.3.5 typing backwards
< 		4.3.6 Replace mode
< 		4.3.7 Keyword completion
< 	4.4 Command_line mode
< 		4.4.1 Command line editing
< 		4.4.2 Command line completion
< 		4.4.3 Ex command lines
< 		4.4.4 Ex command line ranges
< 	4.5 The window contents
< 	4.6 Abbreviations
< 	4.7 Digraphs
<  5. Editing files
< 	5.1 Introduction
< 	5.2 Editing a file
< 	5.3 The argument list
< 	5.4 Writing and quitting
< 	5.5 Using the QuickFix mode
< 	5.6 Editing binary files
<  6. Cursor motions
< 	6.1 Left-right motions
< 	6.2 Up-down motions
< 	6.3 Word motions
< 	6.4 Text object motions
< 	6.5 Pattern searches
< 	6.6 Various motions
<  7. Scrolling
<  8. Tags
<  9. Inserting text
< 10. Deleting text
< 11. Changing text
< 	11.1 Delete and insert
< 	11.2 Simple changes
< 	11.3 Complex changes
< 12. Copying and moving text
< 13. Visual mode
< 14. Various commands
< 15. Repeating commands
< 	15.1 Single repeats
< 	15.2 Multiple repeats
< 	15.3 Complex repeats
< 16. Undo and redo
< 17. Key mapping
< 18. Recovery after a crash
< 	18.1 The swap file
< 	18.2 Recovery
< 19. Options
< 	19.1 Setting options
< 	19.2 Saving settings
< 	19.3 Options summary
< 20. Terminal information
< 	20.1 startup
< 	20.2 terminal options
< 	20.3 Window size
< 	20.4 slow and fast terminals
< 21. Differences from Vi and Ex
< 	21.1 Missing commands
< 	21.2 Missing options
---
> 	4.2 Switching from mode to mode		|mode_switching|
> 	4.3 Insert and Replace mode		|mode_ins_repl|
> 		4.3.1 special keys		|ins_special_keys|
> 		4.3.2 special special keys	|ins_special_special|
> 		4.3.3 'textwidth' option	|ins_textwidth|
> 		4.3.4 'expandtab' option	|ins_expandtab|
> 		4.3.5 typing backwards		|ins_reverse|
> 		4.3.6 Replace mode		|replace_mode|
> 		4.3.7 Insert mode completion	|ins_completion|
> 	4.4 Command_line mode			|mode_cmdline|
> 		4.4.1 Command line editing	|cmdline_editing|
> 		4.4.2 Command line completion	|cmdline_completion|
> 		4.4.3 Ex command lines		|cmdline_lines|
> 		4.4.4 Ex command line ranges	|cmdline_ranges|
> 	4.5 The window contents			|window_contents|
> 	4.6 Abbreviations			|abbreviations|
> 	4.7 Digraphs				|digraphs|
>  5. Editing files				|edit_files|
> 	5.1 Introduction			|edit_intro|
> 	5.2 Editing a file			|edit_a_file|
> 	5.3 The argument list			|argument_list|
> 	5.4 Writing and quitting		|write_quit|
> 	5.5 Using the QuickFix mode		|quickfix|
> 	5.6 Editing binary files		|edit_binary|
> 	5.7 Automatic commands			|autocommand|
>  6. Cursor motions				|cursor_motions|
> 	6.1 Left-right motions			|left_right_motions|
> 	6.2 Up-down motions			|up_down_motions|
> 	6.3 Word motions			|word_motions|
> 	6.4 Text object motions			|object_motions|
> 	6.5 Pattern searches			|pattern_searches|
> 	6.6 Various motions			|various_motions|
>  7. Scrolling					|scrolling|
>  8. Tags and special searches			|tags_and_searches|
> 	8.1 Tags				|tag_commands|
> 	8.2 Identifier searches			|include_search|
>  9. Inserting text				|inserting|
> 10. Deleting text				|deleting|
> 11. Changing text				|changing|
> 	11.1 Delete and insert			|delete_insert|
> 	11.2 Simple changes			|simple_change|
> 	11.3 Complex changes			|complex_change|
> 	11.4 Formatting text			|formatting|
> 12. Copying and moving text			|copy_move|
> 13. Visual mode					|visual_mode|
> 14. Various commands				|various|
> 15. Repeating commands				|repeating|
> 	15.1 Single repeats			|single_repeat|
> 	15.2 Multiple repeats			|multi_repeat|
> 	15.3 Complex repeats			|complex_repeat|
> 16. Undo and redo				|undo_redo|
> 17. Key mapping					|key_mapping|
> 18. Recovery after a crash			|crash_recovery|
> 	18.1 The swap file			|swap_file|
> 	18.2 Recovery				|recovery|
> 19. Options					|options|
> 	19.1 Setting options			|set_option|
> 	19.2 Saving settings			|save_settings|
> 	19.3 Options summary			|option_summary|
> 20. Terminal information			|terminal_info|
> 	20.1 startup				|startup|
> 	20.2 terminal options			|terminal_options|
> 	20.3 Window size			|window_size|
> 	20.4 slow and fast terminals		|slow_fast_terminal|
> 21. Differences from Vi and Ex			|vi_differences|
> 	21.1 Missing commands			|missing_commands|
> 	21.2 Missing options			|missing_options|
Index: ./doc/vim.hlp
diff -r ../vim3.0/doc/vim.hlp ./doc/vim.hlp
205c205,206
< 
---
> :[range]ret[ab][!] [tabstop]
>                 set 'tabstop' to new value and adjust white space accordingly
316c317
< keywordprg (kp)     string    "ref" name of program for 'K' command
---
> keywordprg (kp)     string    "man" name of program for 'K' command
347a349
> shortmess (shm)     number    0     short file message when 1, truncate when 2
354a357
> smartmatch (sma)    toggle    on    with % command recognize parens in quotes
356a360
> startofline (sol)   toggle    on    cursor to startofline for some commands
391d394
< yankendofline (ye)  toggle    off   'Y' yanks from cursor to end of line
544a548,549
> CTRL-W t                Move cursor to top window
> CTRL-W b                Move cursor to bottom window
Index: ./doc/windows.doc
diff -r ../vim3.0/doc/windows.doc ./doc/windows.doc
15a16
> 					*active_buffer*
18a20
> 					*hidden_buffer*
20a23
> 					*inactive_buffer*
78a82,85
> CTRL-W CTRL-^
> 		Does ":split #", split window in two and edit alternate file.
> 		When a count is given it becomes ":split #N", split window and
> 		edit buffer N.
79a87
> 
120a129,134
> CTRL-W t
> CTRL-W CTRL-T	move cursor to top window.
> 
> CTRL-W b
> CTRL-W CTRL-B	move cursor to bottom window.
> 
123a138,140
> If visual mode is active and the new window is not for the same buffer, the
> visual mode is ended.
> 
247c264
< [N] is a count for 17, 39
---
> [N] is a count for 19, 39
304c321,324
< 		":split ]f", but window isn't split if the file does not exist.
---
> 		":split ]f", but window isn't split if the file does not
> 		exist.  Uses the 'path' variable as a list of directory names
> 		where to look for the file. Also the path for current file
> 		is used to search for the file name.
322,323c342,344
< :files
< :buffers	Show all buffers. Example:
---
> :files						*c_files*
> :buffers					*c_buffers* *c_ls*
> :ls		Show all buffers. Example:
343,344c364,366
< 		file remains unaffected. If buffer [N] is the current buffer,
< 		the next buffer becomes the current buffer.
---
> 		file remains unaffected. Any windows for this buffer are
> 		closed. If buffer [N] is the current buffer, the next buffer
> 		(displayed in a window) becomes the current buffer.
350,351c372,374
< 		lost. The file remains unaffected. If buffer [N] is the
< 		current buffer, the next buffer becomes the current buffer.
---
> 		lost. The file remains unaffected. Any windows for this buffer
> 		are closed. If buffer [N] is the current buffer, the next
> 		buffer (displayed in a window) becomes the current buffer.
362,364c385,388
< 		the buffer list. If the buffer was changed this fails. If
< 		buffer [N] is the current buffer, the next buffer becomes the
< 		current buffer.
---
> 		the buffer list. If the buffer was changed this fails. Any
> 		windows for this buffer are closed. If buffer [N] is the
> 		current buffer, the next buffer (displayed in a window)
> 		becomes the current buffer.
371c395,396
< 		lost. If buffer [N] is the current buffer, the next buffer
---
> 		lost. Any windows for this buffer are closed. If buffer [N] is
> 		the current buffer, the next buffer (displayed in a window)
Index: ./src/alloc.c
diff -r ../vim3.0/src/alloc.c ./src/alloc.c
36a37,53
> /*
>  * alloc() with check for maximum line length
>  */
> 	char_u *
> alloc_check(size)
> 	unsigned		size;
> {
> #ifndef UNIX
> 	if (sizeof(int) == 2 && size > 0x7fff)
> 	{
> 		emsg("Line is becoming too long");
> 		return NULL;
> 	}
> #endif
> 	return (lalloc((long_u)size, TRUE));
> }
> 
83c100,108
< 	if (message && p == NULL && !did_outofmem_msg)
---
> 	if (message && p == NULL)
> 		do_outofmem_msg();
> 	return (p);
> }
> 
> 	void
> do_outofmem_msg()
> {
> 	if (!did_outofmem_msg)
88d112
< 	return (p);
141c165
< del_spaces(ptr)
---
> del_trailing_spaces(ptr)
147c171
< 	while (--q > ptr && isspace(q[0]) && q[-1] != '\\' && q[-1] != Ctrl('V'))
---
> 	while (--q > ptr && iswhite(q[0]) && q[-1] != '\\' && q[-1] != Ctrl('V'))
Index: ./src/amiga.c
diff -r ../vim3.0/src/amiga.c ./src/amiga.c
187c187
< 	OUTSTR("new shell started\n");
---
> 	msg_outstr("new shell started\n");
690c690
< 	ml_close_all(); 				/* remove all memfiles */
---
> 	ml_close_all(TRUE);				/* remove all memfiles */
835,941d834
< #ifdef SETKEYMAP
< /*
<  * load and activate a new keymap for our CLI - DOES NOT WORK -
<  * The problem is that after the setting of the keymap the input blocks
<  * But the new keymap works allright in another window.
<  * Tried but no improvement:
<  * - remembering the length, data and command fields in request->io_xxx
<  * - settmode(0) first, settmode(1) afterwards
<  * - putting the keymap directly in conunit structure
<  */
< 
< #include <devices/keymap.h>
< 
< 	void
< set_keymap(name)
< 	char_u *name;
< {
<  	char					id_a[sizeof(struct InfoData) + 3];
< 	struct InfoData			*id;
< 	static struct KeyMap	*old;
< 	static BPTR				segment = (BPTR)NULL;
< 	struct IOStdReq			*request;
< 	int						c;
< 
< 	if (!term_console)
< 		return;
< 
< 	/* insure longword alignment */
<  	id = (struct InfoData *)(((long)id_a + 3L) & ~3L);
< 
< 	if (dos_packet(MP(raw_out), (long)ACTION_DISK_INFO, ((ULONG) id) >> 2) == 0)
< 	{
< 		EMSG("dos_packet failed");
< 		return;
< 	}
< 	if (id->id_InUse == (BPTR)NULL)
< 	{
< 		EMSG("not a console??");
< 		return;
< 	}
< 	request = (struct IOStdReq *) id->id_InUse;
< 
< 	if (segment != (BPTR)NULL)	/* restore old keymap */
< 	{
< 		request->io_Command = CD_SETKEYMAP;
< 		request->io_Length = sizeof(struct KeyMap);
< 		request->io_Data = (APTR)old;
< 		DoIO((struct IORequest *)request);
< 		if (request->io_Error)
< 			EMSG("Cannot reset keymap");
< 		else				/* no error, free the allocated memory */
< 		{
< 			UnLoadSeg(segment);
< 			FreeMem(old, sizeof(struct KeyMap));
< 			segment = (BPTR)NULL;
< 		}
< 	}
< 	if (name != NULL)
< 	{
< 		segment = LoadSeg(name);
< 		if (segment == (BPTR)NULL)
< 		{
< 			EMSG("Cannot open keymap file");
< 			return;
< 		}
< 		old = (struct KeyMap *)AllocMem(sizeof(struct KeyMap), MEMF_PUBLIC);
< 		if (old == NULL)
< 		{
< 			EMSG(e_outofmem);
< 			UnLoadSeg(segment);
< 			segment = (BPTR)NULL;
< 		}
< 		else
< 		{
< 			request->io_Command = CD_ASKKEYMAP;
< 			request->io_Length = sizeof(struct KeyMap);
< 			request->io_Data = (APTR)old;
< 			DoIO((struct IORequest *)request);
< 			if (request->io_Error)
< 			{
< 				EMSG("Cannot get old keymap");
< 				UnLoadSeg(segment);
< 				segment = (BPTR)NULL;
< 				FreeMem(old, sizeof(struct KeyMap));
< 			}
< 			else
< 			{
< 				request->io_Command = CD_SETKEYMAP;
< 				request->io_Length = sizeof(struct KeyMap);
< 				request->io_Data = (APTR)((segment << 2) + 18);
< 				DoIO((struct IORequest *)request);
< 				if (request->io_Error)
< 					EMSG("Cannot set keymap");
< 
< 				/* test for blocking */
< 				request->io_Command = CMD_READ;
< 				request->io_Length = 1;
< 				request->io_Data = (APTR)&c;
< 				DoIO((struct IORequest *)request);	/* BLOCK HERE! */
< 				if (request->io_Error)
< 					EMSG("Cannot set keymap");
< 			}
< 		}
< 	}
< }
< #endif
< 
1074c967
< 		outstr((char_u *)"Cannot execute ");
---
> 		msg_outstr((char_u *)"Cannot execute ");
1077,1078c970,971
< 			outstr((char_u *)"shell ");
< 			outstr(p_sh);
---
> 			msg_outstr((char_u *)"shell ");
> 			msg_outstr(p_sh);
1081,1082c974,975
< 			outstr(cmd);
< 		outchar('\n');
---
> 			msg_outstr(cmd);
> 		msg_outchar('\n');
1093d985
< #ifdef WEBB_COMPLETE
1095d986
< #endif
1097,1099c988,990
< 				outchar('\n');
< 				outnum(x);
< 				outstr((char_u *)" returned\n");
---
> 				msg_outchar('\n');
> 				msg_outnum(x);
> 				msg_outstr((char_u *)" returned\n");
1120c1011
< 			skiptospace(&shellarg);	/* find start of arguments */
---
> 			skiptowhite(&shellarg);	/* find start of arguments */
1124c1015
< 				skipspace(&shellarg);
---
> 				skipwhite(&shellarg);
1165c1056
< 		outstr((char_u *)"Cannot execute ");
---
> 		msg_outstr((char_u *)"Cannot execute ");
1169c1060
< 				outstr(p_sh);
---
> 				msg_outstr(p_sh);
1171c1062
< 				outstr(cmd);
---
> 				msg_outstr(cmd);
1175,1176c1066,1067
< 			outstr((char_u *)"shell ");
< 			outstr(shellcmd);
---
> 			msg_outstr((char_u *)"shell ");
> 			msg_outstr(shellcmd);
1178c1069
< 		outchar('\n');
---
> 		msg_outchar('\n');
1196d1086
< #ifdef WEBB_COMPLETE
1198d1087
< #endif
1200,1202c1089,1091
< 				outchar('\n');
< 				outnum((long)x);
< 				outstrn((char_u *)" returned\n");
---
> 				msg_outchar('\n');
> 				msg_outnum((long)x);
> 				msg_outstr((char_u *)" returned\n");
1298c1187,1188
< 	new = (struct onefile *)alloc((unsigned)(sizeof(struct onefile) + STRLEN(name) + isdir));
---
> 	new = (struct onefile *)alloc((unsigned)(sizeof(struct onefile) +
> 													STRLEN(name) + isdir));
1371c1261
< 			starbuf = alloc((unsigned)(2 * STRLEN(pat[i]) + 1));	/* maximum required */
---
> 			starbuf = alloc((unsigned)(2 * STRLEN(pat[i]) + 1));
Index: ./src/amiga.h
diff -r ../vim3.0/src/amiga.h ./src/amiga.h
37a38,43
> #ifdef VIMINFO
> #ifndef VIMINFO_FILE
> # define VIMINFO_FILE	"s:.viminfo"
> #endif
> #endif /* VIMINFO */
> 
Index: ./src/archie.c
diff -r ../vim3.0/src/archie.c ./src/archie.c
104c104
< 	outstr("new shell started\n");
---
> 	msg_outstr("new shell started\n");
430c430
< 		outchar('\n');
---
> 		msg_outchar('\n');
435c435
< 		outchar('\n');
---
> 		msg_outchar('\n');
Index: ./src/buffer.c
diff -r ../vim3.0/src/buffer.c ./src/buffer.c
33,34d32
< static BUF		*buflist_findname __ARGS((char_u *));
< static BUF		*buflist_findnr __ARGS((int));
69a68,73
> 	/*
> 	 * Apply the automatic commands, before reading in a new file, which can
> 	 * contain modelines. So the modelines have priority over auto commands.
> 	 */
> 	apply_autocmds(NULL);
> 
79a84
> 
86c91
<  * if 'remove' is TRUE, remove the buffer from the buffer list.
---
>  * if 'del_buf' is TRUE, remove the buffer from the buffer list.
89c94
< close_buffer(buf, free_buf, remove)
---
> close_buffer(buf, free_buf, del_buf)
92c97
< 	int		remove;
---
> 	int		del_buf;
107c112
< 	if (buf->b_filename == NULL || remove)
---
> 	if (buf->b_filename == NULL || del_buf)
110a116,119
> 		free(buf->b_p_fo);
> 		free(buf->b_p_id);
> 		free(buf->b_p_com);
> 		free(buf->b_p_ncom);
139c148
< 	buf->b_ml.ml_flags = ML_EMPTY;					/* empty buffer */
---
> 	buf->b_ml.ml_flags = ML_EMPTY;				/* empty buffer */
150c159
< 	ml_close(buf);					/* close and delete the memline/memfile */
---
> 	ml_close(buf, TRUE);			/* close and delete the memline/memfile */
166a176
> 	BUF		*delbuf;
218c228,231
< 			EMSG2("Cannot go to buffer %ld", (char_u *)count);
---
> 		{
> 			if (action != 2 && action != 3)		/* don't warn when deleting */
> 				EMSG2("Cannot go to buffer %ld", (char_u *)count);
> 		}
230,234d242
< 		if (buf->b_nwindows > 1 || (buf != curbuf && buf->b_nwindows != 0))
< 		{
< 			EMSG2("Other window editing buffer %ld", (char_u *)buf->b_fnum);
< 			return FAIL;
< 		}
247c255
< 			retval = doecmd(NULL, NULL, NULL, FALSE, (linenr_t)1);
---
> 			retval = doecmd(0, NULL, NULL, NULL, FALSE, (linenr_t)1);
251c259
< 				close_buffer(buf, TRUE, action == 3);
---
> 				close_buffer(buf, TRUE, TRUE);
257a266,280
> 		if (buf != curbuf)
> 		{
> 			close_windows(buf);
> 			close_buffer(buf, TRUE, action == 3);
> 			return OK;
> 		}
> 		/*
> 		 * Deleting the current buffer: Find a buffer to go to, preferably
> 		 * one that has an active window.
> 		 * If there is none (all other buffers are hidden), use any buffer.
> 		 */
> 		for (buf = curbuf->b_next; buf != NULL && buf->b_nwindows == 0;
> 															buf = buf->b_next)
> 			;
> 		if (buf == NULL)
259c282,285
< 			if (buf != curbuf)
---
> 			for (buf = curbuf->b_prev; buf != NULL && buf->b_nwindows == 0;
> 															buf = buf->b_prev)
> 				;
> 			if (buf == NULL)
261,262c287,290
< 				close_buffer(buf, TRUE, action == 3);
< 				return OK;
---
> 				if (curbuf->b_next != NULL)
> 					buf = curbuf->b_next;
> 				else
> 					buf = curbuf->b_prev;
264,267d291
< 			if (buf->b_next != NULL)
< 				buf = buf->b_next;
< 			else
< 				buf = buf->b_prev;
278,279c302,308
< 	buflist_altlnum();		/* remember curpos.lnum */
< 	close_buffer(curbuf, action == 2 || action == 3, action == 3);
---
> 	curwin->w_alt_fnum = curbuf->b_fnum; /* remember alternate file */
> 	buflist_altlnum();					 /* remember curpos.lnum */
> 
> 	delbuf = curbuf;		/* close_windows() may change curbuf */
> 	if (action == 2 || action == 3)
> 		close_windows(curbuf);
> 	close_buffer(delbuf, action == 2 || action == 3, action == 3);
292,293d320
< 	int		need_fileinfo = TRUE;
< 
303d329
< 	{
305,306c331,332
< 		need_fileinfo = FALSE;
< 	}
---
> 	else
> 		need_fileinfo = TRUE;			/* display file info after redraw */
310,311d335
< 	if (need_fileinfo)
< 		fileinfo(did_cd);
357c381
< 				(curbuf->b_ml.ml_mfp == NULL || curbuf->b_ml.ml_flags == ML_EMPTY))
---
> 				(curbuf->b_ml.ml_mfp == NULL || bufempty()))
383a408,411
> 			free(buf->b_p_fo);
> 			free(buf->b_p_id);
> 			free(buf->b_p_com);
> 			free(buf->b_p_ncom);
463,464c491,492
< 	RedrawingDisabled = TRUE;
< 	if (getfile(buf->b_filename, buf->b_sfilename, setpm, lnum) <= 0)
---
> 	++RedrawingDisabled;
> 	if (getfile(buf->b_fnum, NULL, NULL, setpm, lnum) <= 0)
466c494
< 		RedrawingDisabled = FALSE;
---
> 		--RedrawingDisabled;
469c497
< 	RedrawingDisabled = FALSE;
---
> 	--RedrawingDisabled;
492c520
< 	static BUF	*
---
> 	BUF *
507c535
< 	static BUF	*
---
> 	BUF	*
612d639
< 	gotocmdline(TRUE, NUL);
615,616c642
< 		if (buf != firstbuf)
< 			msg_outchar('\n');
---
> 		msg_outchar('\n');
650d675
< 	msg_end();
693a719,720
> 		free(curbuf->b_filename);
> 		free(curbuf->b_sfilename);
736a764,771
> 	/*
> 	 * If the file name changed, also change the name of the swapfile
> 	 */
> 	if (curbuf->b_ml.ml_mfp != NULL)
> 		ml_setname();
> 
> 	maketitle();				/* set window title */
> 	status_redraw_all();		/* status lines need to be redrawn */
802,809c837
< 
< #if 0		/* this message is quite useless */
< 	if (bufempty())
< 	{
< 		MSG("Buffer Empty");
< 		return;
< 	}
< #endif
---
> 	int			n;
825,828c853,870
< 						"\"%s%s%s line %ld of %ld --%d%%-- col %d",
< 			curbuf->b_changed ? " [Modified]" : "",
< 			curbuf->b_notedited ? " [Not edited]" : "",
< 			curbuf->b_p_ro ? " [readonly]" : "",
---
> 			"\"%s%s%s%s",
> 			curbuf->b_changed ? (p_shm ? " [+]" : " [Modified]") : " ",
> 			curbuf->b_notedited ? "[Not edited]" : "",
> 			curbuf->b_p_ro ? (p_shm ? "[RO]" : "[readonly]") : "",
> 			(curbuf->b_changed || curbuf->b_notedited || curbuf->b_p_ro) ? " " : "");
> 	n = (int)(((long)curwin->w_cursor.lnum * 100L) / (long)curbuf->b_ml.ml_line_count);
> 	if (p_ru)
> 	{
> 		/* Current line and column are already on the screen -- webb */
> 		sprintf((char *)IObuff + STRLEN(IObuff),
> 			"%ld lines --%d%%--",
> 			(long)curbuf->b_ml.ml_line_count,
> 			n);
> 	}
> 	else
> 	{
> 		sprintf((char *)IObuff + STRLEN(IObuff),
> 			"line %ld of %ld --%d%%-- col %d",
831c873
< 			(int)(((long)curwin->w_cursor.lnum * 100L) / (long)curbuf->b_ml.ml_line_count),
---
> 			n,
832a875
> 	}
835,836c878,880
< 		sprintf((char *)IObuff + STRLEN(IObuff), " (file %d of %d)", curwin->w_arg_idx + 1, arg_count);
< 	msg(IObuff);
---
> 		sprintf((char *)IObuff + STRLEN(IObuff), " (%s%d of %d)",
> 			p_shm ? "" : "file ", curwin->w_arg_idx + 1, arg_count);
> 	msg_trunc(IObuff);
950,951c994
< 	 * 3. start editing the first window (hide the current window contents)
< 	 * 4. stuff commands to fill the other windows
---
> 	 * 3. start editing in the windows
959c1002
< 		(void)doecmd(arg_files[i], NULL, NULL, TRUE, (linenr_t)1);
---
> 		(void)doecmd(0, arg_files[i], NULL, NULL, TRUE, (linenr_t)1);
960a1004,1005
> 		if (i == arg_count - 1)
> 			arg_had_last = TRUE;
Index: ./src/charset.c
diff -r ../vim3.0/src/charset.c ./src/charset.c
19c19,20
< 	static char_u buf[3];
---
> 	static char_u	buf[5];
> 	int				i;
20a22,29
> 	i = 0;
> 	if (c >= 0x100)		/* special key code, display as ~@ char */
> 	{
> 		buf[0] = '~';
> 		buf[1] = '@';
> 		i = 2;
> 		c = K_SECOND(c);
> 	}
25,27c34,36
< 		buf[0] = '^';
< 		buf[1] = c ^ 0x40;		/* DEL displayed as ^? */
< 		buf[2] = NUL;
---
> 		buf[i] = '^';
> 		buf[i + 1] = c ^ 0x40;		/* DEL displayed as ^? */
> 		buf[i + 2] = NUL;
31,32c40,41
< 		buf[0] = c;
< 		buf[1] = NUL;
---
> 		buf[i] = c;
> 		buf[i + 1] = NUL;
36,38c45,47
< 		buf[0] = '~';
< 		buf[1] = c - 0x80 + '@';
< 		buf[2] = NUL;
---
> 		buf[i] = '~';
> 		buf[i + 1] = c - 0x80 + '@';
> 		buf[i + 2] = NUL;
50c59,67
< 	return ((c >= ' ' && (p_gr || c <= '~')) || c > 0xa0 ? 1 : 2);
---
> 	int		len = 0;
> 
> 	if (c >= 0x100)
> 	{
> 		len = 2;
> 		c = K_SECOND(c);
> 	}
> 	len += ((c >= ' ' && (p_gr || c <= '~')) || c > 0xa0 ? 1 : 2);
> 	return len;
84a102,116
>  * return the number of characters the string 's' will take on the screen,
>  * taking into account the size of a tab
>  */
> 	int
> linetabsize(s)
> 	char_u		*s;
> {
> 	int		col = 0;
> 
> 	while (*s != NUL)
> 		col += chartabsize(*s++, col);
> 	return col;
> }
> 
> /*
90a123,124
> 		if (c > 0x100 || c == NUL)
> 			return FALSE;
97c131
< 				|| c == '_'
---
> 				|| (curbuf->b_p_id != NULL && STRCHR(curbuf->b_p_id, c) != NULL)
99c133
< 	 * we also accept alhpa's with accents
---
> 	 * we also accept alpha's with accents
Index: ./src/cmdcmds.c
diff -r ../vim3.0/src/cmdcmds.c ./src/cmdcmds.c
23a24,29
> #ifdef VIMINFO
> static char_u *viminfo_filename __ARGS((char_u 	*));
> static void do_viminfo __ARGS((FILE *fp_in, FILE *fp_out, int want_info, int want_marks, int force_read));
> static int read_viminfo_up_to_marks __ARGS((char_u *line, linenr_t *lnum, FILE *fp, int force));
> #endif /* VIMINFO */
> 
39a46,49
> 	int		new = 0;			/* init for GCC */
> 	char_u	*first;
> 	char_u	*last;
> 	int		save;
62c72
< 	if (!u_save((linenr_t)(start - 1), (linenr_t)(end + 1)))
---
> 	if (u_save((linenr_t)(start - 1), (linenr_t)(end + 1)) == FAIL)
64c74,75
< 	for (curwin->w_cursor.lnum = start; curwin->w_cursor.lnum <= end; ++curwin->w_cursor.lnum)
---
> 	for (curwin->w_cursor.lnum = start;
> 						curwin->w_cursor.lnum <= end; ++curwin->w_cursor.lnum)
66,67c77,88
< 		set_indent(indent, TRUE);				/* remove existing indent */
< 		if (type == -1)							/* left align */
---
> 			/* find the first non-blank character */
> 		first = ml_get(curwin->w_cursor.lnum);
> 		skipwhite(&first);
> 			/* find the character after the last non-blank character */
> 		for (last = first + STRLEN(first);
> 								last > first && iswhite(last[-1]); --last)
> 			;
> 		save = *last;
> 		*last = NUL;
> 		len = linetabsize(first);					/* get line lenght */
> 		*last = save;
> 		if (len == 0)								/* skip blank lines */
69,73c90,92
< 		len = strsize(ml_get(curwin->w_cursor.lnum));		/* get line lenght */
< 		if (len < width)
< 			switch (type)
< 			{
< 			case 0:		set_indent((width - len) / 2, FALSE);	/* center */
---
> 		switch (type)
> 		{
> 			case -1:	new = indent;				/* left align */
75c94
< 			case 1:		set_indent(width - len, FALSE);			/* right */
---
> 			case 0:		new = (width - len) / 2;	/* center */
77c96,101
< 			}
---
> 			case 1:		new = width - len;			/* right align */
> 						break;
> 		}
> 		if (new < 0)
> 			new = 0;
> 		set_indent(new, TRUE);			/* set indent */
83a108,226
> 	void
> do_retab(start, end, new_ts, force)
> 	linenr_t	start;
> 	linenr_t	end;
> 	int			new_ts;
> 	int			force;
> {
> 	linenr_t	lnum;
> 	int			got_tab = FALSE;
> 	long		num_spaces = 0;
> 	long		num_tabs = 0;
> 	long		len;
> 	long		col;
> 	long		vcol;
> 	long		start_col = 0;			/* For start of white-space string */
> 	long		start_vcol = 0;			/* For start of white-space string */
> 	int			temp;
> 	long		old_len;
> 	char_u		*ptr;
> 	char_u		*new_line = (char_u *)1;	/* init to non-NULL */
> 	int			did_something = FALSE;
> 	int			did_undo;				/* called u_save for current line */
> 
> 	if (new_ts == 0)
> 		new_ts = curbuf->b_p_ts;
> 	for (lnum = start; !got_int && lnum <= end; ++lnum)
> 	{
> 		ptr = ml_get(lnum);
> 		col = 0;
> 		vcol = 0;
> 		did_undo = FALSE;
> 		for(;;)
> 		{
> 			if (iswhite(ptr[col]))
> 			{
> 				if (!got_tab && num_spaces == 0)
> 				{
> 					/* First consecutive white-space */
> 					start_vcol = vcol;
> 					start_col = col;
> 				}
> 				if (ptr[col] == ' ')
> 					num_spaces++;
> 				else
> 					got_tab = TRUE;
> 			}
> 			else
> 			{
> 				if (got_tab || (force && num_spaces > 1))
> 				{
> 					/* Retabulate this string of white-space */
> 
> 					/* len is virtual length of white string */
> 					len = num_spaces = vcol - start_vcol;
> 					num_tabs = 0;
> 					if (!curbuf->b_p_et)
> 					{
> 						temp = new_ts - (start_vcol % new_ts);
> 						if (num_spaces >= temp)
> 						{
> 							num_spaces -= temp;
> 							num_tabs++;
> 						}
> 						num_tabs += num_spaces / new_ts;
> 						num_spaces -= (num_spaces / new_ts) * new_ts;
> 					}
> 					if (curbuf->b_p_et || got_tab ||
> 										(num_spaces + num_tabs < len))
> 					{
> 						if (did_undo == FALSE)
> 						{
> 							did_undo = TRUE;
> 							if (u_save((linenr_t)(lnum - 1),
> 												(linenr_t)(lnum + 1)) == FAIL)
> 							{
> 								new_line = NULL;		/* flag out-of-memory */
> 								break;
> 							}
> 						}
> 
> 						/* len is actual number of white characters used */
> 						len = num_spaces + num_tabs;
> 						old_len = STRLEN(ptr);
> 						new_line = lalloc(old_len - col + start_col + len + 1,
> 																		TRUE);
> 						if (new_line == NULL)
> 							break;
> 						if (start_col > 0)
> 							memmove((char *)new_line, (char *)ptr, start_col);
> 						memmove((char *)new_line + start_col + len,
> 										(char *)ptr + col, old_len - col + 1);
> 						ptr = new_line + start_col;
> 						for (col = 0; col < len; col++)
> 							ptr[col] = (col < num_tabs) ? '\t' : ' ';
> 						ml_replace(lnum, new_line, FALSE);
> 						did_something = TRUE;
> 						ptr = new_line;
> 						col = start_col + len;
> 					}
> 				}
> 				got_tab = FALSE;
> 				num_spaces = 0;
> 			}
> 			if (ptr[col] == NUL)
> 				break;
> 			vcol += chartabsize(ptr[col++], vcol);
> 		}
> 		if (new_line == NULL)				/* out of memory */
> 			break;
> 		breakcheck();
> 	}
> 	if (got_int)
> 		emsg(e_interr);
> 	if (did_something)
> 		CHANGED;
> 	curbuf->b_p_ts = new_ts;
> 	coladvance(curwin->w_curswant);
> }
> 
95c238,242
< 	char_u		*q;
---
> 	char_u		*str;
> 	linenr_t	l;
> 	linenr_t	extra;		/* Num lines added before line1 */
> 	linenr_t	num_lines;	/* Num lines moved */
> 	linenr_t	last_line;	/* Last line in file after adding new text */
98c245
< 	if (n >= line1 && n < line2 && line2 > line1)
---
> 	if (n >= line1 && n < line2)
103a251,252
> 	num_lines = line2 - line1 + 1;
> 
105,109c254
< 	 * adjust line marks (global marks done below)
< 	 * if the lines are moved down, the marks in the moved lines
< 	 * move down and the marks in the lines between the old and
< 	 * new position move up.
< 	 * If the lines are moved up it is just the other way round
---
> 	 * First we copy the old text to its new location -- webb
111,129c256,258
< 	if (n >= line2)			/* move down */
< 	{
< 		mark_adjust(line1, line2, n - line2);
< 		mark_adjust(line2 + 1, n,  -(line2 - line1 + 1));
< 	}
< 	else					/* move up */
< 	{
< 		mark_adjust(line1, line2, -(line1 - n - 1));
< 		mark_adjust(n + 1, line1 - 1, line2 - line1 + 1);
< 	}
< 
< 	if (n >= line1)
< 	{
< 		--n;
< 		curwin->w_cursor.lnum = n - (line2 - line1) + 1;
< 	}
< 	else
< 		curwin->w_cursor.lnum = n + 1;
< 	while (line1 <= line2)
---
> 	if (u_save(n, n + 1) == FAIL)
> 		return FAIL;
> 	for (extra = 0, l = line1; l <= line2; l++)
131,147c260,261
< 			/* this undo is not efficient, but it works */
< 		u_save(line1 - 1, line1 + 1);
< 		q = strsave(ml_get(line1));
< 		if (q != NULL)
< 		{
< 			/*
< 			 * marks from global command go with the line
< 			 */
< 			has_mark = ml_has_mark(line1);
< 			ml_delete(line1);
< 			u_save(n, n + 1);
< 			ml_append(n, q, (colnr_t)0, FALSE);
< 			free(q);
< 			if (has_mark)
< 				ml_setmarked(n + 1);
< 		}
< 		if (n < line1)
---
> 		str = strsave(ml_get(l + extra));
> 		if (str != NULL)
149,150c263,269
< 			++n;
< 			++line1;
---
> 			has_mark = ml_has_mark(l + extra);
> 			ml_append(n + l - line1, str, (colnr_t)0, FALSE);
> 			free(str);
> 			if (has_mark)
> 				ml_setmarked(n + l - line1 + 1);
> 			if (n < line1)
> 				extra++;
152,153d270
< 		else
< 			--line2;
154a272,305
> 
> 	/*
> 	 * Now we must be careful adjusting our marks so that we don't overlap our
> 	 * mark_adjust() calls.
> 	 *
> 	 * We adjust the marks within the old text so that they refer to the
> 	 * last lines of the file (temporarily), because we know no other marks
> 	 * will be set there since these line numbers did not exist until we added
> 	 * our new lines.
> 	 *
> 	 * Then we adjust the marks on lines between the old and new text positions
> 	 * (either forwards or backwards).
> 	 *
> 	 * And Finally we adjust the marks we put at the end of the file back to
> 	 * their final destination at the new text position -- webb
> 	 */
> 	last_line = curbuf->b_ml.ml_line_count;
> 	mark_adjust(line1, line2, last_line - line2);
> 	if (n >= line2)
> 		mark_adjust(line2 + 1, n, -num_lines);
> 	else
> 		mark_adjust(n + 1, line1 - 1, num_lines);
> 	mark_adjust(last_line - num_lines + 1, last_line,
> 												-(last_line - n - extra));
> 	
> 	/*
> 	 * Now we delete the original text -- webb
> 	 */
> 	if (u_save(line1 + extra - 1, line2 + extra + 1) == FAIL)
> 		return FAIL;
> 
> 	for (l = line1; l <= line2; l++)
> 		ml_delete(line1 + extra, TRUE);
> 
155a307,308
> 	if (!global_busy && num_lines > p_report)
> 		smsg((char_u *)"%ld line%s moved", num_lines, plural(num_lines));
184c337,338
< 	u_save(n, n + 1);
---
> 	if (u_save(n, n + 1) == FAIL)
> 		return;
246,247c400,401
< 	skiptospace(&trailarg);
< 	skipspace(&trailarg);
---
> 	skiptowhite(&trailarg);
> 	skipwhite(&trailarg);
299c453
< 	msg_ceol();
---
> 	msg_clr_eos();
396a551
> 	int			msg_save;
413d567
< 	/* cursupdate(); */
441a596,597
> 	msg_save = msg_scroll;
> 	msg_scroll = FALSE;
444a601
> 		msg_scroll = msg_save;
451c608
< 		outchar('\n');
---
> 		msg_outchar('\n');
463,467d619
< 	if (do_out)
< 	{
< 		STRCAT(IObuff, " > ");
< 		STRCAT(IObuff, otmp);
< 	}
489,493d640
< 	if (do_out)
< 	{
< 		STRCAT(IObuff, " > ");
< 		STRCAT(IObuff, otmp);
< 	}
494a642,643
> 	if (do_out)
> 		sprintf((char *)IObuff + STRLEN(IObuff), " %s %s", p_srr, otmp);
498,500c647,654
< 			/* errors are ignored, so you can see the error
< 			   messages from the command; use 'u' to fix the text */
< 	(void)call_shell(IObuff, 1, FALSE);
---
> 	/*
> 	 * When call_shell() fails wait_return() is called to give the user a
> 	 * chance to read the error messages. Otherwise errors are ignored, so you
> 	 * can see the error messages from the command that appear on stdout; use
> 	 * 'u' to fix the text
> 	 */
> 	if (call_shell(IObuff, 1, FALSE) == FAIL)
> 		wait_return(FALSE);
504c658
< 		if (!u_save((linenr_t)(line2), (linenr_t)(line2 + 1)))
---
> 		if (u_save((linenr_t)(line2), (linenr_t)(line2 + 1)) == FAIL)
511c665
< 			outchar('\n');
---
> 			msg_outchar('\n');
530d683
< 	updateScreen(CLEAR);		/* do this before messages below */
537c690,694
< 			smsg((char_u *)"%ld lines filtered", (long)linecount);
---
> 		{
> 			sprintf((char *)msg_buf, "%ld lines filtered", (long)linecount);
> 			if (msg(msg_buf) && !msg_scroll)
> 				keep_msg = msg_buf;		/* display message after redraw */
> 		}
538a696
> 	msg_scroll = msg_save;
541a700,1019
> 
> #ifdef VIMINFO
> /*
>  * read_viminfo() -- Read the viminfo file.  Registers etc. which are already
>  * set are not over-written unless force is TRUE. -- webb
>  */
> 	int
> read_viminfo(file, want_info, want_marks, force)
> 	char_u	*file;
> 	int		want_info;
> 	int		want_marks;
> 	int		force;
> {
> 	FILE	*fp;
> 
> 	file = viminfo_filename(file);			/* may set to default if NULL */
> 	if ((fp = fopen((char *)file, "r")) == NULL)
> 		return FAIL;
> 
> 	do_viminfo(fp, NULL, want_info, want_marks, force);
> 
> 	fclose(fp);
> 
> 	return OK;
> }
> 
> /*
>  * write_viminfo() -- Write the viminfo file.  The old one is read in first so
>  * that effectively a merge of current info and old info is done.  This allows
>  * multiple vims to run simultaneously, without losing any marks etc.  If
>  * force is TRUE, then the old file is not read in, and only internal info is
>  * written to the file. -- webb
>  */
> 	void
> write_viminfo(file, force)
> 	char_u	*file;
> 	int		force;
> {
> 	FILE	*fp_in = NULL;
> 	FILE	*fp_out = NULL;
> 	char_u	tmpname[TMPNAMELEN];
> 
> 	STRCPY(tmpname, TMPNAME2);
> 	file = viminfo_filename(file);			/* may set to default if NULL */
> 	fp_in = fopen((char *)file, "r");
> 	if (fp_in == NULL)
> 		fp_out = fopen((char *)file, "w");
> 	else if (*mktemp((char *)tmpname) != NUL)
> 		fp_out = fopen((char *)tmpname, "w");
> 	if (fp_out == NULL)
> 	{
> 		EMSG("Can't write viminfo file!");
> 		if (fp_in != NULL)
> 			fclose(fp_in);
> 		return;
> 	}
> 
> 	do_viminfo(fp_in, fp_out, !force, !force, FALSE);
> 
> 	fclose(fp_out);			/* errors are ignored !? */
> 	if (fp_in != NULL)
> 	{
> 		fclose(fp_in);
> 		if (vim_rename(tmpname, file) == -1)
> 			unlink((char *)tmpname);
> 	}
> }
> 
> 	static char_u *
> viminfo_filename(file)
> 	char_u		*file;
> {
> 	if (file == NULL || *file == NUL)
> 	{
> 		expand_env((char_u *)VIMINFO_FILE, NameBuff, MAXPATHL);
> 		return NameBuff;
> 	}
> 	return file;
> }
> 
> /*
>  * do_viminfo() -- Should only be called from read_viminfo() & write_viminfo().
>  */
> 	static void
> do_viminfo(fp_in, fp_out, want_info, want_marks, force_read)
> 	FILE	*fp_in;
> 	FILE	*fp_out;
> 	int		want_info;
> 	int		want_marks;
> 	int		force_read;
> {
> 	BUF		*buf;
> 	int		count = 0;
> 	int		eof = FALSE;
> 	int		load_marks;
> 	int		copy_marks_out;
> 	int		is_mark_set;
> 	char_u	line[LSIZE];
> 	linenr_t lnum = 0;
> 	char_u	*str;
> 	int		i;
> 
> 	if (fp_in != NULL)
> 	{
> 		if (want_info)
> 			eof = read_viminfo_up_to_marks(line, &lnum, fp_in, force_read);
> 		else
> 			/* Skip info, find start of marks */
> 			while (!(eof = vim_fgets(line, LSIZE, fp_in, &lnum)) &&
> 															line[0] != '>')
> 				;
> 	}
> 	if (fp_out != NULL)
> 	{
> 		/* Write the info: */
> 		fprintf(fp_out, "# This viminfo file was generated by vim\n");
> 		fprintf(fp_out, "# You may edit it if you're careful!\n\n");
> 		write_viminfo_search_pattern(fp_out);
> 		write_viminfo_sub_string(fp_out);
> 		write_viminfo_history(fp_out);
> 		write_viminfo_registers(fp_out);
> 		fprintf(fp_out, "\n# History of marks within files (newest to oldest):\n");
> 		count = 0;
> 		for (buf = firstbuf; buf; buf = buf->b_next)
> 		{
> 			/* Check that at least one mark is set: */
> 			if (buf->b_startop.lnum != 0 || buf->b_endop.lnum != 0)
> 				is_mark_set = TRUE;
> 			else
> 			{
> 				is_mark_set = FALSE;
> 				for (i = 0; i < NMARKS; i++)
> 					if (buf->b_namedm[i].lnum != 0)
> 					{
> 						is_mark_set = TRUE;
> 						break;
> 					}
> 			}
> 			if (is_mark_set && buf->b_filename != NULL && buf->b_filename[0] != NUL)
> 			{
> 				fprintf(fp_out, "\n> %s\n", buf->b_filename);
> 				if (buf->b_startop.lnum != 0)
> 					fprintf(fp_out, "\t[\t%ld\t%d\n", buf->b_startop.lnum,
> 						buf->b_startop.col);
> 				if (buf->b_endop.lnum != 0)
> 					fprintf(fp_out, "\t]\t%ld\t%d\n", buf->b_endop.lnum,
> 						buf->b_endop.col);
> 				for (i = 0; i < NMARKS; i++)
> 					if (buf->b_namedm[i].lnum != 0)
> 						fprintf(fp_out, "\t%c\t%ld\t%d\n", 'a' + i,
> 							buf->b_namedm[i].lnum, buf->b_namedm[i].col);
> 				count++;
> 			}
> 		}
> 	}
> 	if (fp_in != NULL && want_marks)
> 	{
> 		while (!eof && (count < p_viminfo || fp_out == NULL))
> 		{
> 			if (line[0] != '>')
> 			{
> 				if (line[0] != '\n' && line[0] != '\r' && line[0] != '#')
> 				{
> 					sprintf((char *)IObuff, "viminfo, %ld: Illegal starting char '%c'",
> 						lnum, line[0]);
> 					emsg(IObuff);
> 				}
> 				eof = vim_fgets(line, LSIZE, fp_in, &lnum);
> 				continue;			/* Skip this dud line */
> 			}
> 			str = line + 1;
> 			skipwhite(&str);
> 			buf = buflist_findname(str);
> 			load_marks = copy_marks_out = FALSE;
> 			if (fp_out == NULL && buf == curbuf)
> 				load_marks = TRUE;
> 			else if (fp_out != NULL && buf == NULL)
> 			{
> 				copy_marks_out = TRUE;
> 				fputs("\n", fp_out);
> 				fputs((char *)line, fp_out);
> 				count++;
> 			}
> 			while (!(eof = vim_fgets(line, LSIZE, fp_in, &lnum)) && line[0] == TAB)
> 			{
> 				if (load_marks)
> 				{
> 					if (line[1] == '[')
> 						sscanf((char *)line + 2, "%ld %d",
> 							&buf->b_startop.lnum, &buf->b_startop.col);
> 					else if (line[1] == ']')
> 						sscanf((char *)line + 2, "%ld %d",
> 							&buf->b_endop.lnum, &buf->b_endop.col);
> 					else if ((i = line[1] - 'a') >= 0 && i < NMARKS)
> 						sscanf((char *)line + 2, "%ld %d",
> 							&buf->b_namedm[i].lnum, &buf->b_namedm[i].col);
> 				}
> 				else if (copy_marks_out)
> 					fputs((char *)line, fp_out);
> 			}
> 			if (load_marks)
> 				return;
> 		}
> 	}
> }
> 
> /*
>  * read_viminfo_up_to_marks() -- Only called from do_viminfo().  Reads in the
>  * first part of the viminfo file which contains everything but the marks that
>  * are local to a file.  Returns TRUE when end-of-file is reached. -- webb
>  */
> 	static int
> read_viminfo_up_to_marks(line, lnum, fp, force)
> 	char_u	*line;
> 	linenr_t *lnum;
> 	FILE	*fp;
> 	int		force;
> {
> 	int		eof = FALSE;
> 
> 	prepare_viminfo_history(force ? 9999 : 0);
> 	eof = vim_fgets(line, LSIZE, fp, lnum);
> 	while (!eof && line[0] != '>')
> 	{
> 		switch (line[0])
> 		{
> 			case NUL:
> 			case '\r':
> 			case '\n':
> 			case '#':		/* A comment */
> 				eof = vim_fgets(line, LSIZE, fp, lnum);
> 				break;
> 			case '"':
> 				eof = read_viminfo_register(line, lnum, fp, force);
> 				break;
> 			case '/':		/* Search string */
> 			case '&':		/* Substitute search string */
> 			case '~':		/* Last search string, followed by '/' or '&' */
> 				eof = read_viminfo_search_pattern(line, lnum, fp, force);
> 				break;
> 			case '$':
> 				eof = read_viminfo_sub_string(line, lnum, fp, force);
> 				break;
> 			case ':':
> 			case '?':
> 				eof = read_viminfo_history(line, lnum, fp, force);
> 				break;
> #if 0
> 			case '\'':
> 				/* How do we have a file mark when the file is not in the
> 				 * buffer list?
> 				 */
> 				eof = read_viminfo_filemark(line, lnum, fp, force);
> 				break;
> 			case '+':
> 				/* eg: "+40 /path/dir file", for running vim with no args */
> 				eof = vim_fgets(line, LSIZE, fp, lnum);
> 				break;
> #endif
> 			default:
> 				sprintf((char *)IObuff, "viminfo, %ld: Illegal starting char '%c'",
> 					*lnum, line[0]);
> 				emsg(IObuff);
> 				eof = vim_fgets(line, LSIZE, fp, lnum);
> 				break;
> 		}
> 	}
> 	finish_viminfo_history();
> 	return eof;
> }
> 
> /*
>  * check string read from viminfo file
>  * remove '\n' at the end of the line
>  * - replace CTRL-V CTRL-V by CTRL-V
>  * - replace CTRL-V 'n'    by '\n'
>  */
> 	void
> viminfo_readstring(p)
> 	char_u		*p;
> {
> 	while (*p != NUL && *p != '\n')
> 	{
> 		if (*p == Ctrl('V'))
> 		{
> 			if (p[1] == 'n')
> 				p[0] = '\n';
> 			memmove(p + 1, p + 2, STRLEN(p));
> 		}
> 		++p;
> 	}
> 	*p = NUL;
> }
> 
> /*
>  * write string to viminfo file
>  * - replace CTRL-V by CTRL-V CTRL-V
>  * - replace '\n'   by CTRL-V 'n'
>  * - add a '\n' at the end
>  */
> 	void
> viminfo_writestring(fd, p)
> 	FILE	*fd;
> 	char_u	*p;
> {
> 	register int	c;
> 
> 	while ((c = *p++) != NUL)
> 	{
> 		if (c == Ctrl('V') || c == '\n')
> 		{
> 			putc(Ctrl('V'), fd);
> 			if (c == '\n')
> 				c = 'n';
> 		}
> 		putc(c, fd);
> 	}
> 	putc('\n', fd);
> }
> #endif /* VIMINFO */
Index: ./src/cmdline.c
diff -r ../vim3.0/src/cmdline.c ./src/cmdline.c
40a41,48
> /*
>  * There are two history tables:
>  * 0: colon commands
>  * 1: search commands
>  */
> static	 char_u		**(history[2]) = {NULL, NULL};	/* history tables */
> static	 int		hisidx[2] = {-1, -1};			/* last entered entry */
> static	 int		hislen = 0; 		/* actual lengt of history tables */
41a50,52
> static void		init_history __ARGS((void));
> 
> static int		is_in_history __ARGS((int, char_u *, int));
45c56
< static char_u	*DoOneCmd __ARGS((char_u *));
---
> static char_u	*DoOneCmd __ARGS((char_u *, int));
49d59
< static char_u	*checknextcomm __ARGS((char_u *));
56d65
< #ifdef WEBB_COMPLETE
59a69
> static linenr_t get_address __ARGS((char_u **));
63,68c73,181
< #else
< static void		nextwild __ARGS((char_u *, int));
< static void		showmatches __ARGS((char_u *, int));
< #endif /* WEBB_COMPLETE */
< static char_u	*addstar __ARGS((char_u *, int));
< static linenr_t get_address __ARGS((char_u **));
---
> 
> /*
>  * init_history() - initialize the command line history
>  */
> 	static void
> init_history()
> {
> 	int		newlen;			/* new length of history table */
> 	char_u	**temp;
> 	register int i;
> 	int		j = -1;
> 	int		type;
> 
> 	/*
> 	 * If size of history table changed, reallocate it
> 	 */
> 	newlen = (int)p_hi;
> 	if (newlen != hislen)						/* history length changed */
> 	{
> 		for (type = 0; type <= 1; ++type)		/* adjust both history tables */
> 		{
> 			if (newlen)
> 				temp = (char_u **)lalloc((long_u)(newlen * sizeof(char_u *)),
> 									TRUE);
> 			else
> 				temp = NULL;
> 			if (newlen == 0 || temp != NULL)
> 			{
> 				if (newlen > hislen)			/* array becomes bigger */
> 				{
> 					for (i = 0; i <= hisidx[type]; ++i)
> 						temp[i] = history[type][i];
> 					j = i;
> 					for ( ; i <= newlen - (hislen - hisidx[type]); ++i)
> 						temp[i] = NULL;
> 					for ( ; j < hislen; ++i, ++j)
> 						temp[i] = history[type][j];
> 				}
> 				else							/* array becomes smaller */
> 				{
> 					j = hisidx[type];
> 					for (i = newlen - 1; ; --i)
> 					{
> 						if (i >= 0)				/* copy newest entries */
> 							temp[i] = history[type][j];
> 						else					/* remove older entries */
> 							free(history[type][j]);
> 						if (--j < 0)
> 							j = hislen - 1;
> 						if (j == hisidx[type])
> 							break;
> 					}
> 					hisidx[type] = newlen - 1;
> 				}
> 				free(history[type]);
> 				history[type] = temp;
> 			}
> 		}
> 		hislen = newlen;
> 	}
> }
> 
> /*
>  * check if command line 'str' is already in history
>  * 'type' is 0 for ':' commands, '1' for search commands
>  * if 'move_to_front' is TRUE, matching entry is moved to end of history
>  */
> 	static int
> is_in_history(type, str, move_to_front)
> 	int		type;
> 	char_u	*str;
> 	int		move_to_front;		/* Move the entry to the front if it exists */
> {
> 	int		i;
> 	int		last_i = -1;
> 
> 	if (hisidx[type] < 0)
> 		return FALSE;
> 	i = hisidx[type];
> 	do
> 	{
> 		if (history[type][i] == NULL)
> 			return FALSE;
> 		if (STRCMP(str, history[type][i]) == 0)
> 		{
> 			if (!move_to_front)
> 				return TRUE;
> 			last_i = i;
> 			break;
> 		}
> 		if (--i < 0)
> 			i = hislen - 1;
> 	} while (i != hisidx[type]);
> 
> 	if (last_i >= 0)
> 	{
> 		str = history[type][i];
> 		while (i != hisidx[type])
> 		{
> 			if (++i >= hislen)
> 				i = 0;
> 			history[type][last_i] = history[type][i];
> 			last_i = i;
> 		}
> 		history[type][i] = str;
> 		return TRUE;
> 	}
> 	return FALSE;
> }
83c196
< 	register char_u 	c;
---
> 	register int	 	c;
85d197
< 			 int		nextc = 0;
89,93d200
< 	static	 char_u		**history = NULL;	/* history table */
< 	static	 int		hislen = 0; 		/* actual lengt of history table */
< 			 int		newlen;				/* new length of history table */
< 	static	 int		hisidx = -1;		/* last entered entry */
< 			 char_u		**temp;
97a205,210
> 			 int		type;				/* history type to be used */
> 			 FPOS		old_cursor;
> 			 colnr_t	old_curswant = curwin->w_curswant;
> 			 int		did_incsearch = FALSE;
> 			 int		incsearch_postponed = FALSE;
> 			 int		overstrike = FALSE;	/* typing mode */
98a212
> 	old_cursor = curwin->w_cursor;
107c221,222
< 	gotocmdline(TRUE, firstc);
---
> 	gotocmdline(TRUE);
> 	msg_outchar(firstc);
109,151c224
< /*
<  * if size of history table changed, reallocate it
<  */
< 	newlen = (int)p_hi;
< 	if (newlen != hislen)						/* history length changed */
< 	{
< 		if (newlen)
< 			temp = (char_u **)lalloc((long_u)(newlen * sizeof(char_u *)), TRUE);
< 		else
< 			temp = NULL;
< 		if (newlen == 0 || temp != NULL)
< 		{
< 			if (newlen > hislen)			/* array becomes bigger */
< 			{
< 				for (i = 0; i <= hisidx; ++i)
< 					temp[i] = history[i];
< 				j = i;
< 				for ( ; i <= newlen - (hislen - hisidx); ++i)
< 					temp[i] = NULL;
< 				for ( ; j < hislen; ++i, ++j)
< 					temp[i] = history[j];
< 			}
< 			else							/* array becomes smaller */
< 			{
< 				j = hisidx;
< 				for (i = newlen - 1; ; --i)
< 				{
< 					if (i >= 0)
< 						temp[i] = history[j];	/* copy newest entries */
< 					else
< 						free(history[j]);		/* remove older entries */
< 					if (--j < 0)
< 						j = hislen - 1;
< 					if (j == hisidx)
< 						break;
< 				}
< 				hisidx = newlen - 1;
< 			}
< 			free(history);
< 			history = temp;
< 			hislen = newlen;
< 		}
< 	}
---
> 	init_history();
152a226
> 	type = (firstc == ':' ? 0 : 1);
162,174c236,243
< 		if (nextc)		/* character remaining from CTRL-V */
< 		{
< 			c = nextc;
< 			nextc = 0;
< 		}
< 		else
< 		{
< 			c = vgetc();
< 			if (c == Ctrl('C'))
< 				got_int = FALSE;
< 		}
< 
< 		if (lookfor && c != K_SDARROW && c != K_SUARROW)
---
> 		c = vgetc();
> 		if (c == Ctrl('C'))
> 			got_int = FALSE;
> 
> 		if (lookfor && c != K_SDARROW && c != K_SUARROW &&
> 				c != K_DARROW && c != K_UARROW &&
> 				c != K_PAGEDOWN && c != K_PAGEUP &&
> 				(cmd_numfiles > 0 || (c != Ctrl('P') && c != Ctrl('N'))))
190,191c259,260
< 			if (ccheck_abbr(c + 0x100))
< 				continue;
---
> 			if (ccheck_abbr(c + 0x200))
> 				goto cmdline_changed;
202d270
< #ifdef WEBB_COMPLETE
210,219c278
< 				continue;
< #else
< 			if (cmd_numfiles > 0)	/* typed p_wc twice */
< 				nextwild(buff, 3);
< 			else					/* typed p_wc first time */
< 				nextwild(buff, 0);
< 			if (c == ESC)
< 				gotesc = TRUE;
< 			continue;
< #endif /* WEBB_COMPLETE */
---
> 				goto cmdline_changed;
230a290
> 		case K_DEL:
236c296
< 				if (c == DEL && cmdpos != cmdlen)
---
> 				if ((c == DEL || c == K_DEL) && cmdpos != cmdlen)
264c324,328
< 				continue;
---
> 				goto cmdline_changed;
> 
> 		case K_INS:
> 				overstrike = !overstrike;
> 				goto cmdline_not_changed;
268d331
< clearline:
273c336
< 				continue;
---
> 				goto cmdline_changed;
284,287d346
< #ifdef WEBB_COMPLETE
< 				/* set_expand_context() now finds start of the pattern, so
< 				 * don't do it here -- webb
< 				 */
290,294d348
< #else
< 				for (i = cmdpos; i > 0 && buff[i - 1] != ' '; --i)
< 						;
< 				showmatches(&buff[i], cmdpos - i);
< #endif /* WEBB_COMPLETE */
297c351
< 				continue;
---
> 				continue;		/* don't do incremental search now */
310c364
< 				continue;
---
> 				goto cmdline_not_changed;
322c376,390
< 				continue;
---
> 				goto cmdline_not_changed;
> 
> #if defined(UNIX) || defined(MSDOS)
> 		case K_MOUSE:
> 				cmdspos = 1;
> 				for (cmdpos = 0; cmdpos < cmdlen; ++cmdpos)
> 				{
> 					i = charsize(cmdbuff[cmdpos]);
> 					if (mouse_row <= cmdline_row + cmdspos / Columns &&
> 										mouse_col < cmdspos % Columns + i)
> 						break;
> 					cmdspos += i;
> 				}
> 				goto cmdline_not_changed;
> #endif
324a393
> 		case K_HOME:
327c396
< 				continue;
---
> 				goto cmdline_not_changed;
329a399
> 		case K_END:
333c403
< 				continue;
---
> 				goto cmdline_not_changed;
336d405
< #ifdef WEBB_COMPLETE
339,342c408
< #else
< 				nextwild(buff, 4);
< #endif /* WEBB_COMPLETE */
< 				continue;
---
> 				goto cmdline_changed;
345d410
< #ifdef WEBB_COMPLETE
348,351c413
< #else
< 				nextwild(buff, 5);
< #endif /* WEBB_COMPLETE */
< 				continue;
---
> 				goto cmdline_changed;
357d418
< #ifdef WEBB_COMPLETE
360,363c421
< #else
< 					nextwild(buff, (c == Ctrl('P')) ? 2 : 1);
< #endif /* WEBB_COMPLETE */
< 					continue;
---
> 					goto cmdline_changed;
369a428,429
> 		case K_PAGEUP:
> 		case K_PAGEDOWN:
371c431
< 					continue;
---
> 					goto cmdline_not_changed;
376,380c436,441
< 				if (c == K_SUARROW || c == K_SDARROW)
< 				{
< 					buff[cmdpos] = NUL;
< 					if (lookfor == NULL && (lookfor = strsave(buff)) == NULL)
< 						continue;
---
> 	/* Always save the current command line so that we can restore it later
> 	 * -- webb
> 	 */
> 				buff[cmdpos] = NUL;
> 				if (lookfor == NULL && (lookfor = strsave(buff)) == NULL)
> 					goto cmdline_not_changed;
382,383c443
< 					j = STRLEN(lookfor);
< 				}
---
> 				j = STRLEN(lookfor);
387c447,448
< 					if (c == K_UARROW || c == K_SUARROW || c == Ctrl('P'))
---
> 					if (c == K_UARROW || c == K_SUARROW || c == Ctrl('P') ||
> 							c == K_PAGEUP)
390,391c451,452
< 							hiscnt = hisidx;
< 						else if (hiscnt == 0 && hisidx != hislen - 1)
---
> 							hiscnt = hisidx[type];
> 						else if (hiscnt == 0 && hisidx[type] != hislen - 1)
393c454
< 						else if (hiscnt != hisidx + 1)
---
> 						else if (hiscnt != hisidx[type] + 1)
395a457,458
> 						{
> 							hiscnt = i;
396a460
> 						}
400c464
< 						if (hiscnt == hisidx)	/* on last entry, clear the line */
---
> 						if (hiscnt == hisidx[type])	/* on last entry, clear the line */
403c467
< 							goto clearline;
---
> 							break;
412c476
< 					if (hiscnt < 0 || history[hiscnt] == NULL)
---
> 					if (hiscnt < 0 || history[type][hiscnt] == NULL)
417,418c481,483
< 					if ((c != K_SUARROW && c != K_SDARROW) || hiscnt == i ||
< 							STRNCMP(history[hiscnt], lookfor, (size_t)j) == 0)
---
> 					if ((c != K_SUARROW && c != K_SDARROW && c != K_PAGEUP &&
> 							c != K_PAGEDOWN) || hiscnt == i ||
> 							STRNCMP(history[type][hiscnt], lookfor, (size_t)j) == 0)
424c489,492
< 					STRCPY(buff, history[hiscnt]);
---
> 					if (hiscnt == hislen)
> 						STRCPY(buff, lookfor);
> 					else
> 						STRCPY(buff, history[type][hiscnt]);
426a495
> 					goto cmdline_changed;
428c497,498
< 				continue;
---
> 				beep_flush();
> 				goto cmdline_not_changed;
432c502
< 				c = get_literal(&nextc);	/* get next (two) character(s) */
---
> 				c = get_literal();			/* get next (two) character(s) */
454,455c524,525
< 		if (do_abbr && !isidchar(c) && ccheck_abbr(c))
< 			continue;
---
> 		if (do_abbr && (c >= 0x100 || !isidchar(c)) && ccheck_abbr(c))
> 			goto cmdline_changed;
457c527
< 		if (cmdlen < CMDBUFFSIZE - 2)
---
> 		if (cmdlen < CMDBUFFSIZE - 3)
459,461c529,551
< 				for (i = cmdlen++; i > cmdpos; --i)
< 						buff[i] = buff[i - 1];
< 				buff[cmdpos] = c;
---
> 			/*
> 			 * If a special key was typed that is not used as a command,
> 			 * insert it in the buffer as two chars: K_SPECIAL, KS_..
> 			 * This is useful when mapping function keys.
> 			 */
> 			while (c > 0)
> 			{
> 				if (c >= 0x100)
> 				{
> 					i = K_SPECIAL;
> 					c = K_SECOND(c);
> 				}
> 				else
> 				{
> 					i = c;
> 					c = -1;
> 				}
> 				if (!overstrike)
> 				{
> 					memmove(buff + cmdpos + 1, buff + cmdpos, cmdlen - cmdpos);
> 					++cmdlen;
> 				}
> 				buff[cmdpos] = i;
464,465c554,555
< 				i = charsize(c);
< 				cmdspos += i;
---
> 				cmdspos += charsize(i);
> 			}
467a558,611
> 		goto cmdline_changed;
> 
> /*
>  * This part implements incremental searches for "/" and "?"
>  * Jump to cmdline_not_changed when a character has been read but the command
>  * line did not change. Then we only search and redraw if something changed in
>  * the past.
>  * Jump to cmdline_changed when the command line did change.
>  * (Sorry for the goto's, I know it is ugly).
>  */
> cmdline_not_changed:
> 		if (!incsearch_postponed)
> 			continue;
> 
> cmdline_changed:
> 		if (p_is && (firstc == '/' || firstc == '?') && KeyTyped)
> 		{
> 				/* if there is a character waiting, search and redraw later */
> 			if (char_avail())
> 			{
> 				incsearch_postponed = TRUE;
> 				continue;
> 			}
> 			incsearch_postponed = FALSE;
> 			curwin->w_cursor = old_cursor;	/* start at old position */
> 
> 				/* If there is no command line, don't do anything */
> 			if (cmdlen == 0)
> 				i = 0;
> 			else
> 			{
> 				buff[cmdlen] = NUL;
> 				emsg_off = TRUE;	/* So it doesn't beep if bad expr */
> 				keep_old_search_pattern = TRUE;
> 				tag_busy = TRUE;
> 				i = dosearch(firstc, buff, FALSE, 1, FALSE, FALSE);
> 				keep_old_search_pattern = FALSE;
> 				tag_busy = FALSE;
> 				emsg_off = FALSE;
> 			}
> 			if (i)
> 			{
> 				highlight_match = TRUE;			/* highlight position */
> 				cursupdate();
> 			}
> 			else
> 			{
> 				highlight_match = FALSE;			/* don't highlight */
> 				/* beep(); */ /* even beeps when invalid expr, e.g. "[" */
> 			}
> 			updateScreen(NOT_VALID);
> 			redrawcmdline();
> 			did_incsearch = TRUE;
> 		}
471a616,622
> 	if (did_incsearch)
> 	{
> 		curwin->w_cursor = old_cursor;
> 		curwin->w_curswant = old_curswant;
> 		highlight_match = FALSE;
> 		redraw_later(NOT_VALID);
> 	}
474c625
< 	 * put line in history buffer
---
> 	 * put line in history buffer (only when it was typed)
476c627
< 	if (cmdlen != 0)
---
> 	if (cmdlen != 0 && KeyTyped)
478c629
< 		if (hislen != 0)
---
> 		if (hislen != 0 && !is_in_history(type, buff, TRUE))
480,483c631,634
< 			if (++hisidx == hislen)
< 				hisidx = 0;
< 			free(history[hisidx]);
< 			history[hisidx] = strsave(buff);
---
> 			if (++hisidx[type] == hislen)
> 				hisidx[type] = 0;
> 			free(history[type][hisidx[type]]);
> 			history[type][hisidx[type]] = strsave(buff);
549c700
< 	msg_ceol();
---
> 	msg_clr_eos();
585a737,739
>  * 
>  * If 'sourcing' is TRUE, the command will be included in the error message.
>  * If 'repeating' is TRUE, there is no wait_return() and friends.
590c744
< docmdline(cmdline)
---
> docmdline(cmdline, sourcing, repeating)
591a746,747
> 	int			sourcing;
> 	int			repeating;
594a751
> 	static int	recursive = 0;			/* recursive depth */
601a759,762
> 		{
> 				/* don't call wait_return for aborted command line */
> 			need_wait_return = FALSE;
> 			dont_wait_return = TRUE;
602a764
> 		}
615a778,792
>  * All output from the commands is put below each other, without waiting for a
>  * return. Don't do this when executing commands from a script or when being
>  * called recursive (e.g. for ":e +command file").
>  */
> 	if (!repeating && !recursive)
> 	{
> 		msg_didany = FALSE;		/* no output yet */
> 		msg_start();
> 		msg_scroll = TRUE;		/* put messages below each other */
> 		++dont_sleep;			/* don't sleep in emsg() */
> 		++no_wait_return;		/* dont wait for return until finished */
> 		++RedrawingDisabled;
> 	}
> 
> /*
618a796
> 	++recursive;
621c799
< 		nextcomm = DoOneCmd(buff);
---
> 		nextcomm = DoOneCmd(buff, sourcing);
625a804,820
> 	--recursive;
> 
> /*
>  * if there was too much output to fit on the command line, ask the user to
>  * hit return before redrawing the screen. With the ":global" command we do
>  * this only once after the command is finished.
>  */
> 	if (!repeating && !recursive)
> 	{
> 		--RedrawingDisabled;
> 		--dont_sleep;
> 		--no_wait_return;
> 		msg_scroll = FALSE;
> 		if (need_wait_return || msg_check())
> 			wait_return(FALSE);
> 	}
> 
641a837,838
>  * If 'sourcing' is TRUE, the command will be included in the error message.
>  *
651,652c848,850
< DoOneCmd(buff)
< 	char_u *buff;
---
> DoOneCmd(buff, sourcing)
> 	char_u		*buff;
> 	int			sourcing;
671a870,871
> 	char_u				*errormsg = NULL;		/* error message */
> 	WIN					*old_curwin = NULL;		/* init for GCC */
707,708c907,908
< 		line2 = curwin->w_cursor.lnum;			/* default is current line number */
< 		skipspace(&cmd);
---
> 		line2 = curwin->w_cursor.lnum;	/* default is current line number */
> 		skipwhite(&cmd);
709a910,911
> 		if (cmd == NULL)				/* error detected */
> 			goto doend;
746c948
< 	skipspace(&cmd);
---
> 	skipwhite(&cmd);
773c975
< 			curwin->w_cursor.col = 0;
---
> 			beginline(MAYBE);
810c1012
< 			emsg(e_invcmd);
---
> 			errormsg = e_invcmd;
828c1030
< 	if (!(argt & RANGE) && addr_count)
---
> 	if (!(argt & RANGE) && addr_count)		/* no range allowed */
830c1032
< 		emsg(e_norange);
---
> 		errormsg = e_norange;
833a1036,1041
> 	if (!(argt & BANG) && forceit)			/* no <!> allowed */
> 	{
> 		errormsg = e_nobang;
> 		goto doend;
> 	}
> 
841c1049,1054
< 		if (ask_yesno((char_u *)"Backwards range given, OK to swap") != 'y')
---
> 		if (sourcing)
> 		{
> 			errormsg = (char_u *)"Backwards range given";
> 			goto doend;
> 		}
> 		else if (ask_yesno((char_u *)"Backwards range given, OK to swap", FALSE) != 'y')
854c1067
< 		emsg(e_invrange);
---
> 		errormsg = e_invrange;
877c1090
< 			emsg(e_toolong);
---
> 			errormsg = e_toolong;
888c1101
< 	skipspace(&arg);
---
> 	skipwhite(&arg);
892c1105
< 		emsg(e_argreq);
---
> 		errormsg = e_argreq;
902c1115
< 				EMSG("Use w or w>>");
---
> 				errormsg = (char_u *)"Use w or w>>";
906c1119
< 			skipspace(&arg);
---
> 			skipwhite(&arg);
934c1147
< 		skipspace(&arg);
---
> 		skipwhite(&arg);
937a1151,1157
> 	 * Check for "+command" argument, before checking for next command.
> 	 * Don't do this for ":read !cmd" and ":write !cmd".
> 	 */
> 	if ((argt & EDITCMD) && !usefilter)
> 		editcmd = getargcmd(&arg);
> 
> 	/*
948,951c1168,1171
< 				if ((argt & USECTRLV) && p[1] != NUL)	/* skip CTRL-V and next char */
< 					++p;
< 				else					/* remove CTRL-V and skip next char */
< 					STRCPY(p, p + 1);
---
> 				if ((argt & USECTRLV) && p[1] != NUL)
> 					++p;				/* skip CTRL-V and next char */
> 				else
> 					STRCPY(p, p + 1);	/* remove CTRL-V and skip next char */
953c1173,1174
< 			else if ((*p == '"' && !(argt & NOTRLCOM)) || *p == '|' || *p == '\n')
---
> 			else if ((*p == '"' && !(argt & NOTRLCOM)) ||
> 										*p == '|' || *p == '\n')
971c1192
< 			del_spaces(arg);
---
> 			del_trailing_spaces(arg);
986c1207
< 		skipspace(&arg);
---
> 		skipwhite(&arg);
992c1213
< 		skipspace(&arg);
---
> 		skipwhite(&arg);
995c1216
< 			emsg(e_zerocount);
---
> 			errormsg = e_zerocount;
1014c1235
< 		emsg(e_trailing);
---
> 		errormsg = e_trailing;
1050c1271
< 					emsg(e_noalt);
---
> 					errormsg = e_noalt;
1059c1280
< 				emsg(e_toolong);
---
> 				errormsg = e_toolong;
1093c1314
< 		if (argt & NOSPC)
---
> 		if ((argt & NOSPC) && !usefilter)
1095c1316,1334
< 			if (has_wildcard(arg) && !usefilter)
---
> #if defined(UNIX) || defined(MSDOS)
> 			/*
> 			 * Only for Unix and MSDOS we check for more than one file name.
> 			 * For other systems spaces are considered to be part
> 			 * of the file name.
> 			 */
> 			for (p = arg; *p; ++p)
> 			{
> 							/* skip escaped characters */
> 				if (p[1] && (*p == '\\' || *p == Ctrl('V')))
> 					++p;
> 				else if (iswhite(*p))
> 				{
> 					errormsg = (char_u *)"Only one file name allowed";
> 					goto doend;
> 				}
> 			}
> #endif
> 			if (has_wildcard(arg))
1131c1370
< 				close_window(TRUE);			/* may free buffer */
---
> 				close_window(curwin, TRUE);	/* may free buffer */
1149c1388
< 				close_window(FALSE);		/* don't free buffer */
---
> 				close_window(curwin, FALSE);	/* don't free buffer */
1163c1402,1403
< 				gotocmdend();
---
> 				windgoto((int)Rows - 1, 0);
> 				outchar('\n');
1170,1175c1410
< 				if (T_CVV != NULL && *T_CVV)
< 				{
< 					/* Scroll screen down before drawing over it */
< 					outstr(T_CVV);
< 					outstr(T_CV);
< 				}
---
> 				scroll_start();			/* scroll screen before redrawing */
1176a1412
> 				set_winsize(0, 0, FALSE); /* May have resized window -- webb */
1187c1423,1424
< 						(check_readonly() || dowrite(arg, FALSE) == FAIL)) ||
---
> 						(check_readonly() ||
> 								dowrite(arg, FALSE) == FAIL)) ||
1197c1434
< 				close_window(TRUE);			/* quit current window, may free buffer */
---
> 				close_window(curwin, TRUE);	/* quit current window, may free buffer */
1241a1479,1490
> 		case CMD_recover:					/* recover file */
> 				recoverymode = TRUE;
> 				if (!check_changed(curbuf, FALSE, TRUE) &&
> 							(*arg == NUL || setfname(arg, NULL, TRUE) == OK) &&
> 							check_fname() == OK)
> 				{
> 					dellines(curbuf->b_ml.ml_line_count, FALSE, FALSE);
> 					ml_recover();
> 				}
> 				recoverymode = FALSE;
> 				break;
> 
1249,1250c1498
< 				nextcomm = checknextcomm(arg);	/* check for trailing command */
< 				if (arg_count == 0)			/* no file name list */
---
> 				if (arg_count == 0)				/* no file name list */
1252c1500
< 					if (check_fname() == OK)		/* check for no file name at all */
---
> 					if (check_fname() == OK)	/* check for no file name */
1256c1504,1508
< 				gotocmdline(TRUE, NUL);
---
> 				/*
> 				 * Overwrite the command, in most cases there is no scrolling
> 				 * required and no wait_return().
> 				 */
> 				gotocmdline(TRUE);
1266,1270d1517
< 				if (msg_check())		/* if message too long */
< 				{
< 					msg_outchar('\n');
< 					wait_return(FALSE);
< 				}
1297,1298d1543
< 				editcmd = getargcmd(&arg);		/* get +command argument */
< 				nextcomm = checknextcomm(arg);	/* check for trailing command */
1315c1560
< 						EMSG2("No more than %ld files to edit", (char_u *)(long)arg_count);
---
> 						EMSG("Cannot go beyond last file");
1328,1329c1573,1574
< 					 * if 'hidden' set, only check for changed file when re-editing
< 					 * the same buffer
---
> 					 * if 'hidden' set, only check for changed file when
> 					 * re-editing the same buffer
1334c1579,1580
< 					if ((!p_hid || !other) && check_changed(curbuf, TRUE, !other))
---
> 					if ((!p_hid || !other) &&
> 										check_changed(curbuf, TRUE, !other))
1338c1584,1587
< 				(void)doecmd(arg_files[curwin->w_arg_idx], NULL, editcmd, p_hid, (linenr_t)0);
---
> 				if (i == arg_count - 1)
> 					arg_had_last = TRUE;
> 				(void)doecmd(0, arg_files[curwin->w_arg_idx],
> 										NULL, editcmd, p_hid, doecmdlnum);
1346c1595
< 				goto doargument;
---
> 				goto donextfile;
1351c1600
< 				goto doargument;
---
> 				goto donextfile;
1356c1605
< 				goto doargument;
---
> 				goto donextfile;
1364,1366d1612
< doargument:
< 				editcmd = getargcmd(&arg);		/* get +command argument */
< 				nextcomm = checknextcomm(arg);	/* check for trailing command */
1382,1383c1628,1629
< 		case CMD_bmodified:			/* :[N]bmod	[N]		 to next modified buffer */
< 		case CMD_sbmodified:		/* :[N]sbmod [N]	  to next modified buffer */
---
> 		case CMD_bmodified:			/* :[N]bmod	[N]	  to next modified buffer */
> 		case CMD_sbmodified:		/* :[N]sbmod [N]  to next modified buffer */
1388c1634
< 		case CMD_sbnext:			/* :[N]sbnext [N]	  to next buffer */
---
> 		case CMD_sbnext:			/* :[N]sbnext [N]	 to next buffer */
1424c1670,1671
< 					int do_current = FALSE;		/* delete current buffer? */
---
> 					int do_current = 0;			/* delete current buffer? */
> 					int	deleted = 0;			/* number of buffers deleted */
1439,1441c1686,1688
< 							do_current = TRUE;
< 						else
< 							(void)do_buffer(i, 1, FORWARD, (int)n, forceit);
---
> 							do_current = n;
> 						else if (do_buffer(i, 1, FORWARD, (int)n, forceit) == OK)
> 							++deleted;
1449c1696
< 							skipspace(&arg);
---
> 							skipwhite(&arg);
1460,1461c1707,1716
< 					if (!got_int && do_current)
< 						(void)do_buffer(i, 1, FORWARD, (int)curbuf->b_fnum, forceit);
---
> 					if (!got_int && do_current && do_buffer(i, 1, FORWARD, (int)do_current, forceit) == OK)
> 						++deleted;
> 
> 					if (deleted == 0)
> 						EMSG2("No buffers were %s",
> 											i == 2 ? "unloaded" : "deleted");
> 					else
> 						smsg((char_u *)"%d buffer%s %s", deleted,
> 											plural(deleted),
> 											i == 2 ? "unloaded" : "deleted");
1476a1732
> 		case CMD_ls:
1516a1773
> 				old_curwin = curwin;
1524,1525d1780
< 				editcmd = getargcmd(&arg);		/* get +command argument */
< 				nextcomm = checknextcomm(arg);	/* check for trailing command */
1527c1782
< 					(void)doecmd(NULL, NULL, editcmd, TRUE, (linenr_t)1);
---
> 					(void)doecmd(0, NULL, NULL, editcmd, TRUE, (linenr_t)1);
1529c1784
< 					(void)doecmd(arg, NULL, editcmd, p_hid, doecmdlnum);
---
> 					(void)doecmd(0, arg, NULL, editcmd, p_hid, doecmdlnum);
1531a1787,1792
> 					/* if ":split file" worked, set alternate filename in
> 					 * old window to new file */
> 				if ((cmdidx == CMD_new || cmdidx == CMD_split) &&
> 								*arg != NUL && curwin != old_curwin &&
> 								old_curwin->w_buffer != curbuf)
> 					old_curwin->w_alt_fnum = curbuf->b_fnum;
1534a1796,1798
> 				i = p_shm;
> 				if (forceit && p_shm == 2)
> 					p_shm = 1;
1536a1801,1802
> 					curwin->w_alt_fnum = curbuf->b_fnum;
> 					buflist_altlnum();
1540d1805
< 					maketitle();
1542a1808
> 				p_shm = i;
1546,1547c1812,1813
< 				p = curbuf->b_ml.ml_mfp->mf_fname;
< 				if (p == NULL)
---
> 				if (curbuf->b_ml.ml_mfp == NULL ||
> 								(p = curbuf->b_ml.ml_mfp->mf_fname) == NULL)
1563c1829
< 				if (!u_save(line2, (linenr_t)(line2 + 1)))
---
> 				if (u_save(line2, (linenr_t)(line2 + 1)) == FAIL)
1589c1855
< 					expand_env("$HOME", cmdbuf, CMDBUFFSIZE);
---
> 					expand_env((char_u *)"$HOME", cmdbuf, CMDBUFFSIZE);
1632,1633d1897
< 				gotocmdline(TRUE, NUL);
< 				cursor_off();
1635a1900
> 					msg_outchar('\n');
1638a1904,1905
> 						set_highlight('n');		/* Highlight line numbers */
> 						start_highlight();
1639a1907
> 						stop_highlight();
1644d1911
< 					msg_outchar('\n');
1646a1914,1915
> 				setpcmark();
> 				curwin->w_cursor.lnum = line2;	/* put cursor at last line */
1651,1661d1919
< 					/*
< 					 * if we have one line that runs into the shown command,
< 					 * or more than one line, call wait_return()
< 					 * also do this when global_busy, so we remember to call
< 					 * wait_return at the end of the global command.
< 					 */
< 				if (msg_check() || global_busy)
< 				{
< 					msg_outchar('\n');
< 					wait_return(FALSE);
< 				}
1671a1930,1932
> 		case CMD_stag:
> 				postponed_split = TRUE;
> 				/*FALLTHROUGH*/
1691a1953,1957
> 		case CMD_checkpath:
> 				find_pattern_in_path(NULL, 0, FALSE, CHECK_PATH, 1, 1,
> 											(linenr_t)1, (linenr_t)MAXLNUM);
> 				break;
> 
1706a1973,1980
> 		case CMD_autocmd:
> 				do_autocmd(arg, forceit);	/* manipulate the auto commands */
> 				break;
> 
> 		case CMD_doautocmd:
> 				apply_autocmds(arg);		/* apply the automa commands */
> 				break;
> 
1779c2053
< 				skipspace(&arg);
---
> 				skipwhite(&arg);
1821a2096,2100
> 				if (arg == NULL)			/* error detected */
> 				{
> 					nextcomm = NULL;
> 					goto doend;
> 				}
1839c2118
< 				curwin->w_cursor.col = 0;
---
> 				beginline(MAYBE);
1859c2138
< 						beep();
---
> 						beep_flush();
1876,1877c2155,2157
< 				if (doexecbuf(*arg) == FAIL)			/* put the register in mapbuf */
< 					beep();
---
> 									/* put the register in mapbuf */
> 				if (doexecbuf(*arg) == FAIL)
> 					beep_flush();
1879c2159,2160
< 					(void)docmdline((char_u *)NULL);	/* execute from the mapbuf */
---
> 									/* execute from the mapbuf */
> 					(void)docmdline((char_u *)NULL, TRUE, TRUE);
1895c2176
< 				if (forceit)	/* :so! read vi commands */
---
> 				if (forceit)					/* :so! read vi commands */
1897,1905c2178,2179
< 				else
< 				{
< 					++no_wait_return;
< 					if (dosource(arg) == FAIL)		/* :so read ex commands */
< 						emsg2(e_notopen, arg);
< 					--no_wait_return;
< 					if (need_wait_return)
< 						wait_return(FALSE);
< 				}
---
> 				else if (dosource(arg) == FAIL)	/* :so read ex commands */
> 					emsg2(e_notopen, arg);
1907a2182,2200
> #ifdef VIMINFO
> 		case CMD_rviminfo:
> 				n = p_viminfo;
> 				if (!p_viminfo)
> 					p_viminfo = 100;
> 				if (read_viminfo(arg, TRUE, TRUE, forceit) == FAIL)
> 					emsg("Cannot open viminfo file for reading");
> 				p_viminfo = n;
> 				break;
> 
> 		case CMD_wviminfo:
> 				n = p_viminfo;
> 				if (!p_viminfo)
> 					p_viminfo = 100;
> 				write_viminfo(arg, forceit);
> 				p_viminfo = n;
> 				break;
> #endif /* VIMINFO */
> 
1945c2238
< 					qf_jump(0, atoi((char *)arg));
---
> 					qf_jump(0, addr_count ? (int)line2 : 0);
1948c2241
< 		case CMD_cf:
---
> 		case CMD_cfile:
1964,1965c2257,2258
< 		case CMD_cl:
< 					qf_list();
---
> 		case CMD_clist:
> 					qf_list(forceit);
1968,1969c2261,2262
< 		case CMD_cn:
< 					qf_jump(FORWARD, *arg == NUL ? 1 : atoi((char *)arg));
---
> 		case CMD_cnext:
> 					qf_jump(FORWARD, addr_count ? (int)line2 : 1);
1972,1973c2265,2266
< 		case CMD_cp:
< 					qf_jump(BACKWARD, *arg == NUL ? 1 : atoi((char *)arg));
---
> 		case CMD_cprevious:
> 					qf_jump(BACKWARD, addr_count ? (int)line2 : 1);
1976c2269
< 		case CMD_cq:
---
> 		case CMD_cquit:
1983c2276
< 					curwin->w_cursor.col = 0;
---
> 					beginline(MAYBE);
1988,1993d2280
< #ifdef SETKEYMAP
< 		case CMD_setkeymap:
< 					set_keymap(arg);
< 					break;
< #endif
< 
2000a2288,2294
> 		case CMD_retab:
> 				n = getdigits(&arg);
> 				do_retab(line1, line2, n, forceit);
> 				u_clearline();
> 				updateScreen(NOT_VALID);
> 				break;
> 
2002,2003c2296,2323
< 					domake(arg);
< 					break;
---
> 				domake(arg);
> 				break;
> 
> 		case CMD_isearch:
> 		case CMD_dsearch:
> 				n = ACTION_SHOW;
> 				goto find_pat;
> 
> 		case CMD_ilist:
> 		case CMD_dlist:
> 				n = ACTION_SHOW_ALL;
> 				goto find_pat;
> 
> 		case CMD_ijump:
> 		case CMD_djump:
> 				n = ACTION_GOTO;
> 				goto find_pat;
> 
> 		case CMD_isplit:
> 		case CMD_dsplit:
> 				n = ACTION_SPLIT;
> find_pat:
> 				find_pattern_in_path(arg, STRLEN(arg), !forceit,
> 					*cmd == 'd' ?  FIND_DEFINE : FIND_ANY,
> 					1L,
> 					n,
> 					line1, line2);
> 				break;
2006c2326,2327
< 					emsg(e_invcmd);
---
> 					/* Normal illegal commands have already been handled */
> 					emsg((char_u *)"Sorry, this command is not implemented");
2010a2332,2341
> 	if (errormsg != NULL)
> 	{
> 		if (sourcing)
> 		{
> 			sprintf((char *)IObuff, "%s: %s", errormsg, buff);
> 			emsg(IObuff);
> 		}
> 		else
> 			emsg(errormsg);
> 	}
2055c2386,2387
< 	return (buf_write(buf, buf->b_filename, buf->b_sfilename, (linenr_t)1, buf->b_ml.ml_line_count, 0, 0, TRUE));
---
> 	return (buf_write(buf, buf->b_filename, buf->b_sfilename,
> 						(linenr_t)1, buf->b_ml.ml_line_count, 0, 0, TRUE));
2105c2437,2438
< 	 * write to other file or b_notedited set: overwriting only allowed with '!'
---
> 	 * write to other file or b_notedited set or not writing the whole file:
> 	 * overwriting only allowed with '!'
2107c2440,2442
< 	if ((other || curbuf->b_notedited) && !forceit && !append && !p_wa && (fd = fopen((char *)fname, "r")) != NULL)
---
> 	if ((other || curbuf->b_notedited || line1 != 1 ||
> 			line2 != curbuf->b_ml.ml_line_count) && !forceit &&
> 			!append && !p_wa && (fd = fopen((char *)fname, "r")) != NULL)
2119c2454,2455
< 	return (buf_write(curbuf, fname, sfname, line1, line2, append, forceit, TRUE));
---
> 	return (buf_write(curbuf, fname, sfname, line1, line2,
> 													append, forceit, TRUE));
2124a2461
>  *     fnum: file number; if zero use fname/sfname
2139c2476,2477
< doecmd(fname, sfname, command, hide, newlnum)
---
> doecmd(fnum, fname, sfname, command, hide, newlnum)
> 	int			fnum;
2150,2154c2488,2491
< 		/* if no short name given, use fname for short name */
< 	if (sfname == NULL)
< 		sfname = fname;
< 
< 	if (fname == NULL)
---
> 	if (fnum != 0)
> 	{
> 		if (fnum == curbuf->b_fnum)		/* file is already being edited */
> 			return OK;					/* nothing to do */
2156,2157c2493
< 	else if (*fname == NUL && curbuf->b_filename == NULL)	/* there is no file name */
< 		other_file = FALSE;
---
> 	}
2160c2496,2505
< 		if (*fname == NUL)				/* re-edit with same file name */
---
> 			/* if no short name given, use fname for short name */
> 		if (sfname == NULL)
> 			sfname = fname;
> 
> 		if (fname == NULL)
> 			other_file = TRUE;
> 											/* there is no file name */
> 		else if (*fname == NUL && curbuf->b_filename == NULL)
> 			other_file = FALSE;
> 		else
2162,2163c2507,2513
< 			fname = curbuf->b_filename;
< 			sfname = curbuf->b_sfilename;
---
> 			if (*fname == NUL)				/* re-edit with same file name */
> 			{
> 				fname = curbuf->b_filename;
> 				sfname = curbuf->b_sfilename;
> 			}
> 			fname = fix_fname(fname);		/* may expand to full path name */
> 			other_file = otherfile(fname);
2165,2166d2514
< 		fname = fix_fname(fname);		/* may expand to full path name */
< 		other_file = otherfile(fname);
2176c2524
< 		if (other_file && fname != NULL)
---
> 		if (fnum == 0 && other_file && fname != NULL)
2189c2537,2540
< 		buf = buflist_new(fname, sfname, 1L, TRUE);
---
> 		if (fnum)
> 			buf = buflist_findnr(fnum);
> 		else
> 			buf = buflist_new(fname, sfname, 1L, TRUE);
2252c2603,2604
< 		curwin->w_cursor.col = 0;
---
> 		check_cursor();
> 		beginline(MAYBE);
2264c2616
< 		docmdline(command);
---
> 		docmdline(command, TRUE, FALSE);
2295c2647
< 			skiptospace(&arg);
---
> 			skiptowhite(&arg);
2300c2652
< 		skipspace(&arg);	/* skip over spaces */
---
> 		skipwhite(&arg);	/* skip over spaces */
2306,2330d2657
< /*
<  * look for command separator '|' or '\n'
<  */
< 	static char_u *
< checknextcomm(arg)
< 	char_u *arg;
< {
< 	char_u *p;
< 	char_u *nextcomm = NULL;
< 
< 	for (p = arg; *p; ++p)
< 	{
< 		if (*p == '\\' && p[1])
< 			++p;
< 		else if (*p == '|' || *p == '\n')
< 		{
< 			nextcomm = p + 1;	/* remember start of next command */
< 			*p = NUL;			/* delete '|' or '\n' */
< 			del_spaces(arg);	/* delete spaces in front of '|' or '\n' */
< 			break;
< 		}
< 	}
< 	return nextcomm;
< }
< 
2343,2344c2670,2671
< 	outchar(':');
< 	outstr(arg);		/* show what we are doing */
---
> 	msg_outchar(':');
> 	msg_outstr(arg);		/* show what we are doing */
2349c2676,2677
< 	vpeekc();		/* read window status report and redraw before message */
---
> 				/* read window status report and redraw before message */
> 	(void)char_avail();
2399c2727,2728
< 			if (*str == '\\' && (str[1] == '"' || str[1] == ' ' || str[1] == '\t'))
---
> 			if (*str == '\\' && (str[1] == '"' || str[1] == ' ' ||
> 														str[1] == '\t'))
2414c2743
< 		skipspace(&str);
---
> 		skipwhite(&str);
2418c2747,2748
< 	i = ExpandWildCards(new_count, new_files, &exp_count, &exp_files, FALSE, TRUE);
---
> 	i = ExpandWildCards(new_count, new_files, &exp_count,
> 												&exp_files, FALSE, TRUE);
2432a2763
> 	arg_had_last = FALSE;
2444c2775
< gotocmdline(clr, firstc)
---
> gotocmdline(clr)
2446d2776
< 	int				firstc;
2449,2450c2779,2780
< 	if (clr)			/* clear the bottom line(s) */
< 		msg_ceol();		/* will reset clear_cmdline */
---
> 	if (clr)				/* clear the bottom line(s) */
> 		msg_clr_eos();		/* will reset clear_cmdline */
2452,2460d2781
< 	if (firstc)
< 		msg_outchar(firstc);
< }
< 
< 	void
< gotocmdend()
< {
< 	windgoto((int)Rows - 1, 0);
< 	outchar('\n');
2481c2802
< 	int		mult_win;		/* check also when several windows for this buffer */
---
> 	int		mult_win;		/* check also when several windows for the buffer */
2509c2830,2831
< 						buf->b_xfilename == NULL ? (char_u *)"No File" : buf->b_xfilename);
---
> 						buf->b_xfilename == NULL ?
> 									(char_u *)"No File" : buf->b_xfilename);
2544c2866
< 	if (!forceit && firstwin == lastwin && curwin->w_arg_idx + 1 < arg_count &&
---
> 	if (!forceit && firstwin == lastwin && arg_count > 1 && !arg_had_last &&
2549c2871,2872
< 			emsg2((char_u *)"%ld more files to edit", (char_u *)(long)(arg_count - curwin->w_arg_idx - 1));
---
> 			emsg2((char_u *)"%ld more files to edit",
> 						(char_u *)(long)(arg_count - curwin->w_arg_idx - 1));
2558c2881,2883
<  * try to abandon current file and edit "fname"
---
>  * try to abandon current file and edit a new or existing file
>  * 'fnum' is the number of the file, if zero use fname/sfname
>  *
2564c2889,2890
< getfile(fname, sfname, setpm, lnum)
---
> getfile(fnum, fname, sfname, setpm, lnum)
> 	int			fnum;
2572,2573c2898,2904
< 	fname_expand(&fname, &sfname);	/* make fname full path and set sfname */
< 	other = otherfile(fname);
---
> 	if (fnum == 0)
> 	{
> 		fname_expand(&fname, &sfname);	/* make fname full path, set sfname */
> 		other = otherfile(fname);
> 	}
> 	else
> 		other = (fnum != curbuf->b_fnum);
2588c2919
< 		curwin->w_cursor.col = 0;
---
> 		beginline(MAYBE);
2592c2923
< 	if (doecmd(fname, sfname, NULL, p_hid, lnum) == OK)
---
> 	if (doecmd(fnum, fname, sfname, NULL, p_hid, lnum) == OK)
2597d2927
< #ifdef WEBB_COMPLETE
2644,2646d2973
< #else
< 	static void
< #endif /* WEBB_COMPLETE */
2657d2983
< #ifdef WEBB_COMPLETE
2662c2988
< 		beep();
---
> 		beep_flush();
2672d2997
< #endif /* WEBB_COMPLETE */
2676d3000
< #ifdef WEBB_COMPLETE
2678,2681d3001
< #else
< 	for (i = cmdpos; i > 0 && buff[i - 1] != ' '; --i)
< 		;
< #endif /* WEBB_COMPLETE */
2693d3012
< #ifdef WEBB_COMPLETE
2695,2697d3013
< #else
< 				STRNCPY(&buff[cmdpos + difflen], &buff[cmdpos], (size_t)(cmdlen - cmdpos));
< #endif /* WEBB_COMPLETE */
2707d3022
< #ifdef WEBB_COMPLETE
2709c3024
< 		beep();
---
> 		beep_flush();
2717d3031
< #endif /* WEBB_COMPLETE */
2788d3101
< #ifdef WEBB_COMPLETE
2797,2802d3109
< #else
< 		if (ExpandWildCards(1, (char_u **)&str, &cmd_numfiles, &cmd_files, FALSE, list_notfound) == FAIL)
< 			/* error: do nothing */;
< 		else if (cmd_numfiles == 0)
< 			emsg(e_nomatch);
< #endif /* WEBB_COMPLETE */
2835d3141
< #ifdef WEBB_COMPLETE
2842d3147
< #endif /* WEBB_COMPLETE */
2844d3148
< #ifdef WEBB_COMPLETE
2846,2847c3150
< 					beep();
< #endif /* WEBB_COMPLETE */
---
> 					beep_flush();
2900d3202
< #ifdef WEBB_COMPLETE
2902,2904d3203
< #else
< 	if (!multmatch || mode == -1 || mode == 4)
< #endif /* WEBB_COMPLETE */
2915d3213
< #ifdef WEBB_COMPLETE
2919,2924d3216
< #else
< 	static void
< showmatches(file, len)
< 	char_u *file;
< 	int	len;
< #endif /* WEBB_COMPLETE */
2934d3225
< #ifdef WEBB_COMPLETE
2938c3229
< 		beep();
---
> 		beep_flush();
2955,2959d3245
< #else
< 	file_str = addstar(file, len);		/* add star to file name */
< 	if (file_str == NULL)
< 		return;
< #endif /* WEBB_COMPLETE */
2962a3249,3251
> 	cmdline_row = msg_row;
> 	msg_didany = FALSE;					/* lines_left will be set */
> 	msg_start();						/* prepare for paging */
2965d3253
< #ifdef WEBB_COMPLETE
2971,2974d3258
< #else
< 	if (ExpandWildCards(1, &file_str, &num_files, &files_found, FALSE, FALSE) == FAIL)
< 		return;
< #endif /* WEBB_COMPLETE */
3002d3285
< #ifdef WEBB_COMPLETE
3007,3009d3289
< #else
< 			j = isdir(files_found[k]);	/* highlight directories */
< #endif /* WEBB_COMPLETE */
3020a3301,3305
> 		if (got_int)
> 		{
> 			got_int = FALSE;
> 			break;
> 		}
3030d3314
< #ifdef WEBB_COMPLETE
3034d3317
< #endif /* WEBB_COMPLETE */
3040c3323
< 	static char_u *
---
> 	char_u *
3046d3328
< #ifdef WEBB_COMPLETE
3111,3136d3392
< #else /* WEBB_COMPLETE */
< #ifdef MSDOS
< 	int		i;
< #endif
< 
< 	retval = alloc(len + 4);
< 	if (retval != NULL)
< 	{
< 		STRNCPY(retval, fname, (size_t)len);
< #ifdef MSDOS
< 	/*
< 	 * if there is no dot in the file name, add "*.*" instead of "*".
< 	 */
< 		for (i = len - 1; i >= 0; --i)
< 			if (strchr(".\\/:", retval[i]))
< 				break;
< 		if (i < 0 || retval[i] != '.')
< 		{
< 			retval[len++] = '*';
< 			retval[len++] = '.';
< 		}
< #endif
< 		retval[len] = '*';
< 		retval[len + 1] = 0;
< 	}
< #endif /* WEBB_COMPLETE */
3160a3417
> 	sourcing_name = fname;
3187c3444
< 		docmdline(IObuff);
---
> 		docmdline(IObuff, TRUE, TRUE);
3193a3451
> 	sourcing_name = NULL;
3198c3456,3459
<  * get single EX address
---
>  * get a single EX address
>  * 
>  * Set ptr to the next character after the part that was interpreted.
>  * Set ptr to NULL when an error is encountered.
3214c3475
< 	skipspace(&cmd);
---
> 	skipwhite(&cmd);
3231c3492,3493
< 						if (*++cmd == NUL || (fp = getmark(*cmd++, FALSE)) == NULL)
---
> 						if (*++cmd == NUL ||
> 									(fp = getmark(*cmd++, FALSE)) == NULL)
3233a3496
> 							cmd = NULL;
3244a3508,3510
> 							++curwin->w_cursor.lnum;
> 						searchcmdlen = 0;
> 						if (!dosearch(c, cmd, FALSE, (long)1, FALSE, TRUE))
3246,3249c3512,3514
< 						 	if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)	/* :/pat on last line */
< 								curwin->w_cursor.lnum = 1;
< 							else
< 								++curwin->w_cursor.lnum;
---
> 							cmd = NULL;
> 							curwin->w_cursor = pos;
> 							goto error;
3251,3253c3516
< 						searchcmdlen = 0;
< 						if (dosearch(c, cmd, FALSE, (long)1, FALSE, TRUE))
< 							lnum = curwin->w_cursor.lnum;
---
> 						lnum = curwin->w_cursor.lnum;
3255,3256c3518,3546
< 				
< 						cmd += searchcmdlen;	/* adjust command string pointer */
---
> 											/* adjust command string pointer */
> 						cmd += searchcmdlen;
> 						break;
> 
> 			case '\\':				/* "\?", "\/" or "\&", repeat search */
> 						++cmd;
> 						if (*cmd == '&')
> 							i = 1;
> 						else if (*cmd == '?' || *cmd == '/')
> 							i = 0;
> 						else
> 						{
> 							emsg(e_backslash);
> 							cmd = NULL;
> 							goto error;
> 						}
> 						pos = curwin->w_cursor;
> 						if (*cmd != '?')
> 							++pos.lnum;
> 						pos.col = -1;
> 						if (searchit(&pos, *cmd == '?' ? BACKWARD : FORWARD,
> 										(char_u *)"", 1L, FALSE, TRUE, i) == OK)
> 							lnum = pos.lnum;
> 						else
> 						{
> 							cmd = NULL;
> 							goto error;
> 						}
> 						++cmd;
3260c3550
< 						if (isdigit(*cmd))				/* absolute line number */
---
> 						if (isdigit(*cmd))		/* absolute line number */
3264c3554
< 		while (*cmd == '-' || *cmd == '+')
---
> 		for (;;)
3265a3556,3559
> 			skipwhite(&cmd);
> 			if (*cmd != '-' && *cmd != '+' && !isdigit(*cmd))
> 				break;
> 
3267,3269c3561,3566
< 				lnum = cursor_lnum;
< 			i = *cmd++;
< 			if (!isdigit(*cmd))	/* '+' is '+1', but '+0' is not '+1' */
---
> 				lnum = cursor_lnum;		/* "+1" is same as ".+1" */
> 			if (isdigit(*cmd))
> 				i = '+';				/* "number" is same as "+number" */
> 			else
> 				i = *cmd++;
> 			if (!isdigit(*cmd))			/* '+' is '+1', but '+0' is not '+1' */
3278d3574
< 
3288d3583
< #ifdef WEBB_COMPLETE
3374,3376c3669,3674
< 
< 	--cmd;
< 	do
---
> 	/* 
> 	 * Backslashed delimiters after / or ? will be skipped, and commands will
> 	 * not be expanded between /'s and ?'s or after "'". -- webb
> 	 */
> 	while (*cmd != NUL && (isspace(*cmd) || isdigit(*cmd) ||
> 										STRCHR(".$%'/?-+,;", *cmd) != NULL))
3378,3380c3676
< 		++cmd;							/* skip ',' or ';' */
< 		skipspace(&cmd);
< 		do
---
> 		if (*cmd == '\'')
3382,3386c3678,3685
< 			switch (*cmd)
< 			{
< 				case '.': 						/* '.' - Cursor position */
< 				case '$': 						/* '$' - last line */
< 				case '%': 						/* '%' - all lines */
---
> 			if (*++cmd == NUL)
> 				expand_context = EXPAND_NOTHING;
> 		}
> 		else if (*cmd == '/' || *cmd == '?')
> 		{
> 			delim = *cmd++;
> 			while (*cmd != NUL && *cmd != delim)
> 				if (*cmd++ == '\\' && *cmd != NUL)
3388,3417c3687,3692
< 					break;
< 
< 				case '\'': 						/* ''' - mark */
< 					if (*++cmd != NUL)
< 						++cmd;
< 					break;
< 
< 				case '/':
< 				case '?':						/* '/' or '?' - search */
< 					delim = *cmd++;
< 					while (*cmd != NUL && *cmd != delim)
< 						cmd++;
< 					if (*cmd == delim)
< 						cmd++;
< 					break;
< 
< 				default:
< 					while (isdigit((char)*cmd))
< 						++cmd;
< 					break;
< 			}
< 			
< 			while (*cmd == '-' || *cmd == '+')
< 			{
< 				cmd++;
< 				while (isdigit(*cmd))
< 					cmd++;
< 			}
< 		} while (*cmd == '/' || *cmd == '?');
< 	} while (*cmd == ',' || *cmd == ';');
---
> 			if (*cmd == NUL)
> 				expand_context = EXPAND_NOTHING;
> 		}
> 		if (*cmd != NUL)
> 			++cmd;
> 	}
3423c3698
< 	skipspace(&cmd);
---
> 	skipwhite(&cmd);
3497c3772
< 	skipspace(&arg);
---
> 	skipwhite(&arg);
3505c3780
< 			skipspace(&arg);
---
> 			skipwhite(&arg);
3528c3803
< 		skipspace(&arg);
---
> 		skipwhite(&arg);
3580a3856,3859
> 		case CMD_args:			/* args now takes arguments like :next */
> 		case CMD_edit:
> 		case CMD_ex:
> 		case CMD_cfile:
3583d3861
< 		case CMD_args:			/* args now takes arguments like :next */
3588,3589d3865
< 		case CMD_edit:
< 		case CMD_ex:
3630a3907,3912
> 		case CMD_autocmd:
> 			while (*arg && (!iswhite(*arg) || arg[-1] == '\\'))
> 				arg++;
> 			if (*arg)
> 				return arg;
> 			break;
3633a3916
> 		case CMD_stag:
3686a3970,3971
> 	if (expand_context == EXPAND_OLD_SETTING)
> 		return ExpandOldSetting(num_file, file);
3688c3973
< 	reg_ic = FALSE;
---
> 	reg_ic = p_ic;
3700,3701c3985,3986
< 		if (count == 0
< 		  || (*file = (char_u **) alloc((int)(count * sizeof(char_u *)))) == NULL)
---
> 		if (count == 0 || (*file = (char_u **)
> 							alloc((int)(count * sizeof(char_u *)))) == NULL)
3723c4008,4132
< #endif /* WEBB_COMPLETE */
---
> 
> #ifdef VIMINFO
> static char_u **viminfo_history[2] = {NULL, NULL};
> static int		viminfo_hisidx[2] = {0, 0};
> static int		viminfo_hislen = 0;
> static int		viminfo_add_at_front = FALSE;
> 
> 	void
> prepare_viminfo_history(len)
> 	int len;
> {
> 	int i;
> 	int num;
> 	int	type;
> 
> 	init_history();
> 	viminfo_add_at_front = (len != 0);
> 	if (len > hislen)
> 		len = hislen;
> 
> 	for (type = 0; type <= 1; ++type)
> 	{
> 		/* If there are more spaces available than we request, then fill them up */
> 		for (i = 0, num = 0; i < hislen; i++)
> 			if (history[type][i] == NULL)
> 				num++;
> 		if (num > len)
> 			len = num;
> 		viminfo_hisidx[type] = 0;
> 		viminfo_history[type] = (char_u **)lalloc(len * sizeof(char_u *), FALSE);
> 	}
> 	viminfo_hislen = len;
> 	if (viminfo_history[0] == NULL || viminfo_history[1] == NULL)
> 		viminfo_hislen = 0;
> }
> 
> 	int
> read_viminfo_history(line, lnum, fp, force)
> 	char_u	*line;
> 	linenr_t *lnum;
> 	FILE	*fp;
> 	int		force;
> {
> 	int		type;
> 
> 	type = (line[0] == ':' ? 0 : 1);
> 	if (viminfo_hisidx[type] != viminfo_hislen)
> 	{
> 		viminfo_readstring(line);
> 		if (!is_in_history(type, line + 1, viminfo_add_at_front))
> 			viminfo_history[type][viminfo_hisidx[type]++] = strsave(line + 1);
> 	}
> 	return vim_fgets(line, LSIZE, fp, lnum);
> }
> 
> 	void
> finish_viminfo_history()
> {
> 	int idx;
> 	int i;
> 	int	type;
> 
> 	for (type = 0; type <= 1; ++type)
> 	{
> 		if (history[type] == NULL)
> 			return;
> 		idx = hisidx[type] + viminfo_hisidx[type];
> 		if (idx >= hislen)
> 			idx -= hislen;
> 		if (viminfo_add_at_front)
> 			hisidx[type] = idx;
> 		else
> 		{
> 			if (hisidx[type] == -1)
> 				hisidx[type] = hislen - 1;
> 			do
> 			{
> 				if (history[type][idx] != NULL)
> 					break;
> 				if (++idx == hislen)
> 					idx = 0;
> 			} while (idx != hisidx[type]);
> 			if (idx != hisidx[type] && --idx < 0)
> 				idx = hislen - 1;
> 		}
> 		for (i = 0; i < viminfo_hisidx[type]; i++)
> 		{
> 			history[type][idx] = viminfo_history[type][i];
> 			if (--idx < 0)
> 				idx = hislen - 1;
> 		}
> 		free(viminfo_history[type]);
> 		viminfo_history[type] = NULL;
> 	}
> }
> 
> 	void
> write_viminfo_history(fp)
> 	FILE	*fp;
> {
> 	int		i;
> 	int		type;
> 
> 	init_history();
> 	if (hislen == 0)
> 		return;
> 	for (type = 0; type <= 1; ++type)
> 	{
> 		fprintf(fp, "\n# %s History (newest to oldest):\n",
> 							type == 0 ? "Command Line" : "Search string");
> 		i = hisidx[type];
> 		if (i >= 0)
> 			do
> 			{
> 				if (history[type][i] != NULL)
> 				{
> 					putc(type == 0 ? ':' : '?', fp);
> 					viminfo_writestring(fp, history[type][i]);
> 				}
> 				if (--i < 0)
> 					i = hislen - 1;
> 			} while (i != hisidx[type]);
> 	}
> }
> #endif /* VIMINFO */
Index: ./src/cmdtab.tab
diff -r ../vim3.0/src/cmdtab.tab ./src/cmdtab.tab
1c1
< /* vi:ts=4
---
> /* vi:ts=4:sw=4
31a32
> #define EDITCMD	0x8000			/* has "+command" argument */
54,55c55,57
< 	{(char_u *)"args",			RANGE+NOTADR+BANG+NAMEDFS},
< 	{(char_u *)"argument",		BANG+RANGE+NOTADR+COUNT+EXTRA},
---
> 	{(char_u *)"args",			RANGE+NOTADR+BANG+NAMEDFS+EDITCMD+TRLBAR},
> 	{(char_u *)"argument",		BANG+RANGE+NOTADR+COUNT+EXTRA+EDITCMD+TRLBAR},
> 	{(char_u *)"autocmd",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
69c71
< 	{(char_u *)"cc",			TRLBAR+WORD1+BANG},
---
> 	{(char_u *)"cc",			RANGE+NOTADR+COUNT+TRLBAR+WORD1+BANG},
72c74
< 	{(char_u *)"cf",			TRLBAR+FILE1+BANG},
---
> 	{(char_u *)"cfile",			TRLBAR+FILE1+BANG},
74c76,77
< 	{(char_u *)"cl",			TRLBAR},
---
> 	{(char_u *)"checkpath",		TRLBAR},
> 	{(char_u *)"clist",			TRLBAR+BANG},
77c80
< 	{(char_u *)"cn",			TRLBAR+WORD1+BANG},
---
> 	{(char_u *)"cnext",			RANGE+NOTADR+COUNT+TRLBAR+WORD1+BANG},
81,82c84,85
< 	{(char_u *)"cp",			TRLBAR+WORD1+BANG},
< 	{(char_u *)"cq",			TRLBAR+BANG},
---
> 	{(char_u *)"cprevious",		RANGE+NOTADR+COUNT+TRLBAR+WORD1+BANG},
> 	{(char_u *)"cquit",			TRLBAR+BANG},
88,89c91,97
< 	{(char_u *)"edit",			BANG+FILE1},
< 	{(char_u *)"ex",			BANG+FILE1},
---
> 	{(char_u *)"djump",			BANG+RANGE+DFLALL+EXTRA+TRLBAR},
> 	{(char_u *)"dlist",			BANG+RANGE+DFLALL+EXTRA+TRLBAR},
> 	{(char_u *)"doautocmd",		NAMEDF+TRLBAR},
> 	{(char_u *)"dsearch",		BANG+RANGE+DFLALL+EXTRA+TRLBAR},
> 	{(char_u *)"dsplit",		BANG+RANGE+DFLALL+EXTRA+TRLBAR},
> 	{(char_u *)"edit",			BANG+FILE1+EDITCMD+TRLBAR},
> 	{(char_u *)"ex",			BANG+FILE1+EDITCMD+TRLBAR},
96a105,106
> 	{(char_u *)"ijump",			BANG+RANGE+DFLALL+EXTRA+TRLBAR},
> 	{(char_u *)"ilist",			BANG+RANGE+DFLALL+EXTRA+TRLBAR},
99a110,111
> 	{(char_u *)"isearch",		BANG+RANGE+DFLALL+EXTRA+TRLBAR},
> 	{(char_u *)"isplit",		BANG+RANGE+DFLALL+EXTRA+TRLBAR},
106c118
< 	{(char_u *)"last",			EXTRA+BANG},
---
> 	{(char_u *)"last",			EXTRA+BANG+EDITCMD+TRLBAR},
107a120
> 	{(char_u *)"ls",			TRLBAR},
115c128
< 	{(char_u *)"mfstat",		TRLBAR},				/* for debugging */
---
> 	{(char_u *)"mfstat",		TRLBAR},					/* for debugging */
117,118c130,131
< 	{(char_u *)"next",			RANGE+NOTADR+BANG+NAMEDFS},
< 	{(char_u *)"new",			BANG+FILE1+RANGE+NOTADR},
---
> 	{(char_u *)"next",			RANGE+NOTADR+BANG+NAMEDFS+EDITCMD+TRLBAR},
> 	{(char_u *)"new",			BANG+FILE1+RANGE+NOTADR+EDITCMD+TRLBAR},
123c136,137
< 	{(char_u *)"Next",			EXTRA+RANGE+NOTADR+COUNT+BANG},
---
> 	{(char_u *)"Next",			EXTRA+RANGE+NOTADR+COUNT+BANG+EDITCMD+TRLBAR},
> 	{(char_u *)"open",			TRLBAR},					/* not supported */
129c143
< 	{(char_u *)"previous",		EXTRA+RANGE+NOTADR+COUNT+BANG},
---
> 	{(char_u *)"previous",		EXTRA+RANGE+NOTADR+COUNT+BANG+EDITCMD+TRLBAR},
133,135c147,149
< 	{(char_u *)"read",			RANGE+NAMEDF+TRLBAR+ZEROR},
< 	{(char_u *)"rewind",		EXTRA+BANG},
< 	{(char_u *)"recover",		FILE1+TRLBAR},				/* not supported */
---
> 	{(char_u *)"read",			BANG+RANGE+NAMEDF+TRLBAR+ZEROR},
> 	{(char_u *)"rewind",		EXTRA+BANG+EDITCMD+TRLBAR},
> 	{(char_u *)"recover",		BANG+FILE1+TRLBAR},
138a153,154
> 	{(char_u *)"retab",			TRLBAR+RANGE+DFLALL+BANG+WORD1},
> 	{(char_u *)"rviminfo",		BANG+FILE1+TRLBAR},			/* only when VIMINFO defined */
140c156
< 	{(char_u *)"sargument",		BANG+RANGE+NOTADR+COUNT+EXTRA},
---
> 	{(char_u *)"sargument",		BANG+RANGE+NOTADR+COUNT+EXTRA+EDITCMD+TRLBAR},
152d167
< 	{(char_u *)"setkeymap",		NAMEDF+TRLBAR},
156,161c171,176
< 	{(char_u *)"split",			BANG+FILE1+RANGE+NOTADR},
< 	{(char_u *)"snext",			RANGE+NOTADR+BANG+NAMEDFS},
< 	{(char_u *)"sNext",			EXTRA+RANGE+NOTADR+COUNT+BANG},
< 	{(char_u *)"sprevious",		EXTRA+RANGE+NOTADR+COUNT+BANG},
< 	{(char_u *)"srewind",		EXTRA+BANG},
< 	{(char_u *)"slast",			EXTRA+BANG},
---
> 	{(char_u *)"split",			BANG+FILE1+RANGE+NOTADR+EDITCMD+TRLBAR},
> 	{(char_u *)"snext",			RANGE+NOTADR+BANG+NAMEDFS+EDITCMD+TRLBAR},
> 	{(char_u *)"sNext",			EXTRA+RANGE+NOTADR+COUNT+BANG+EDITCMD+TRLBAR},
> 	{(char_u *)"sprevious",		EXTRA+RANGE+NOTADR+COUNT+BANG+EDITCMD+TRLBAR},
> 	{(char_u *)"srewind",		EXTRA+BANG+EDITCMD+TRLBAR},
> 	{(char_u *)"slast",			EXTRA+BANG+EDITCMD+TRLBAR},
162a178
> 	{(char_u *)"stag",			RANGE+NOTADR+BANG+WORD1+TRLBAR+ZEROR},
166c182
< 	{(char_u *)"tag",			RANGE+NOTADR+COUNT+BANG+WORD1+TRLBAR+ZEROR},
---
> 	{(char_u *)"tag",			RANGE+NOTADR+BANG+WORD1+TRLBAR+ZEROR},
174c190
< 	{(char_u *)"visual",		RANGE+BANG+FILE1},
---
> 	{(char_u *)"visual",		RANGE+BANG+FILE1+EDITCMD+TRLBAR},
182a199
> 	{(char_u *)"wviminfo",		BANG+FILE1+TRLBAR},			/* only when VIMINFO defined */
Index: ./src/csearch.c
diff -r ../vim3.0/src/csearch.c ./src/csearch.c
21a22,25
> #ifdef VIMINFO
> 	static char_u   *old_sub = NULL;
> #endif /* VIMINFO */
> 
57a62
> #ifndef VIMINFO
58a64
> #endif
71c77
< 								   /* new pattern and substitution */
---
> 							/* new pattern and substitution */
74c80,81
< 		if (isalpha(*cmd))			/* don't accept alpha for separator */
---
> 							/* don't accept alphanumeric for separator */
> 		if (isalpha(*cmd) || isdigit(*cmd))
76c83
< 			emsg(e_invarg);
---
> 			emsg("Regular expressions can't be delimited by letters or digits");
81,82c88,89
< 		 *	"\/sub/" and "\?sub?" use last used search pattern (almost like //sub/r).
< 		 *  "\&sub&" use last substitute pattern (like //sub/).
---
> 		 *	"\/sub/" and "\?sub?" use last used search pattern (almost like
> 		 *	//sub/r).  "\&sub&" use last substitute pattern (like //sub/).
169c176
< 	skipspace(&cmd);
---
> 	skipwhite(&cmd);
185c192
< 	skipspace(&cmd);
---
> 	skipwhite(&cmd);
226c233,235
< 			regexec(prog, old_line, TRUE);  /* match again on this line to update the pointers. TODO: remove extra regexec() */
---
> 			regexec(prog, old_line, TRUE);  /* match again on this line to
> 											 * update the pointers. TODO:
> 											 * remove extra regexec() */
256c265
< 				while (do_ask)		/* loop until 'y', 'n' or 'q' typed */
---
> 				while (do_ask)		/* loop until 'y', 'n', 'q', CTRL-E or CTRL-Y typed */
260a270,273
> 					search_match_len = prog->endp[0] - prog->startp[0];
> 									/* invert the matched string
> 									 * remove the inversion afterwards */
> 					highlight_match = TRUE;
261a275,276
> 					highlight_match = FALSE;
> 					redraw_later(NOT_VALID);
265c280
< 					smsg((char_u *)"replace by %s (y/n/q)?", sub);
---
> 					smsg((char_u *)"replace by %s (y/n/a/q/^E/^Y)?", sub);
267d281
< 					setcursor();
269c283,292
< 					if ((i = vgetc()) == 'q' || i == ESC || i == Ctrl('C'))
---
> 					
> 					temp = State;
> 					State = NOMAPPING;	/* don't map this key */
> 					i = vgetc();
> 					State = temp;
> 						/* clear the question */
> 					msg_didout = FALSE;			/* don't scroll up */
> 					msg_col = 0;
> 					gotocmdline(TRUE);
> 					if (i == 'q' || i == ESC || i == Ctrl('C'))
277a301,309
> 					else if (i == 'a')
> 					{
> 						do_ask = FALSE;
> 						break;
> 					}
> 					else if (i == Ctrl('E'))
> 						scrollup_clamp();
> 					else if (i == Ctrl('Y'))
> 						scrolldown_clamp();
283c315
< 				sublen = regsub(prog, sub, old_line, 0, (int)p_magic);
---
> 				sublen = regsub(prog, sub, old_line, FALSE, (int)p_magic);
287,288c319,320
< 					 * Get some space for a temporary buffer to do the substitution
< 					 * into.
---
> 					 * Get some space for a temporary buffer to do the
> 					 * substitution into.
290c322,323
< 					if ((new_start = alloc((unsigned)(STRLEN(old_line) + sublen + 5))) == NULL)
---
> 					if ((new_start = alloc_check((unsigned)(STRLEN(old_line) +
> 												sublen + 5))) == NULL)
299c332,333
< 					if ((p1 = alloc((unsigned)(STRLEN(new_start) + STRLEN(old_copy) + sublen + 1))) == NULL)
---
> 					if ((p1 = alloc_check((unsigned)(STRLEN(new_start) +
> 									STRLEN(old_copy) + sublen + 1))) == NULL)
314c348
< 				regsub(prog, sub, new_end, 1, (int)p_magic);
---
> 				regsub(prog, sub, new_end, TRUE, (int)p_magic);
329c363
< 						if (u_inssub(lnum))				/* prepare for undo */
---
> 						if (u_inssub(lnum) == OK)		/* prepare for undo */
368c402
< 						if (u_savesub(lnum))
---
> 						if (u_savesub(lnum) == OK)
492a527,531
> 	else if (*cmd == NUL)
> 	{
> 		EMSG("Regular expression missing from global");
> 		return;
> 	}
511d549
< 	MSG("");
540,543d577
< 		dont_sleep = 1;			/* don't sleep in emsg() */
< 		no_wait_return = 1;		/* dont wait for return until finished */
< 		need_wait_return = FALSE;
< 		RedrawingDisabled = TRUE;
545d578
< 		did_msg = FALSE;
548,557d580
< 			/*
< 			 * If there was a message from the previous command, scroll
< 			 * the lines up for the next, otherwise it will be overwritten.
< 			 * did_msg is set by msg_start().
< 			 */
< 			if (did_msg)
< 			{
< 				cmdline_row = msg_row;
< 				did_msg = FALSE;
< 			}
561c584
< 				docmdline((char_u *)"p");
---
> 				docmdline((char_u *)"p", FALSE, TRUE);
563c586
< 				docmdline(cmd);
---
> 				docmdline(cmd, FALSE, TRUE);
567d589
< 		RedrawingDisabled = FALSE;
569,572d590
< 		dont_sleep = 0;
< 		no_wait_return = 0;
< 		if (need_wait_return)                /* wait for return now */
< 			wait_return(FALSE);
574,575c592,593
< 		screenclear();
< 		updateScreen(CURSUPD);
---
> 		must_redraw = CLEAR;
> 		cursupdate();
581a600,629
> 
> #ifdef VIMINFO
> 	int
> read_viminfo_sub_string(line, lnum, fp, force)
> 	char_u	*line;
> 	linenr_t *lnum;
> 	FILE	*fp;
> 	int		force;
> {
> 	if (old_sub != NULL && force)
> 		free(old_sub);
> 	if (force || old_sub == NULL)
> 	{
> 		viminfo_readstring(line);
> 		old_sub = strsave(line + 1);
> 	}
> 	return vim_fgets(line, LSIZE, fp, lnum);
> }
> 
> 	void
> write_viminfo_sub_string(fp)
> 	FILE	*fp;
> {
> 	if (old_sub != NULL)
> 	{
> 		fprintf(fp, "\n# Last Substitute String:\n$");
> 		viminfo_writestring(fp, old_sub);
> 	}
> }
> #endif /* VIMINFO */
Index: ./src/digraph.c
diff -r ../vim3.0/src/digraph.c ./src/digraph.c
21,22c21,22
< char_u	(*digraphnew)[3];			/* pointer to added digraphs */
< int		digraphcount = 0;			/* number of added digraphs */
---
> static char_u	(*digraphnew)[3];			/* pointer to added digraphs */
> static int		digraphcount = 0;			/* number of added digraphs */
228a229,230
> 	if (char1 >= 0x100 || char2 >= 0x100)
> 		return char2;
272c274
< 		skipspace(&str);
---
> 		skipwhite(&str);
280c282
< 		skipspace(&str);
---
> 		skipwhite(&str);
301c303,304
< 			memmove((char *)newtab, (char *)digraphnew, (size_t)(digraphcount * 3));
---
> 			memmove((char *)newtab, (char *)digraphnew,
> 										(size_t)(digraphcount * 3));
317,318d319
< 	printdigraph(NULL);
< 	msg_start();
319a321
> 	printdigraph(NULL);
331,332c333
< 	msg_outchar('\n');
< 	wait_return(TRUE);		/* clear screen, because some digraphs may be wrong,
---
> 	must_redraw = CLEAR;	/* clear screen, because some digraphs may be wrong,
Index: ./src/edit.c
diff -r ../vim3.0/src/edit.c ./src/edit.c
19c19,46
< extern char_u *get_inserted();
---
> #define CTRL_X_WANT_IDENT		0x100
> 
> #define CTRL_X_NOT_DEFINED_YET	(1)
> #define CTRL_X_SCROLL			(2)
> #define CTRL_X_WHOLE_LINE		(3)
> #define CTRL_X_FILES			(4)
> #define CTRL_X_TAGS				(5 + CTRL_X_WANT_IDENT)
> #define CTRL_X_PATH_PATTERNS	(6 + CTRL_X_WANT_IDENT)
> #define CTRL_X_PATH_DEFINES		(7 + CTRL_X_WANT_IDENT)
> #define CTRL_X_FINISHED			(8)
> 
> struct Completion
> {
> 	char_u *str;
> 	struct Completion *next;
> 	struct Completion *prev;
> };
> 
> struct Completion *first_match = NULL;
> struct Completion *curr_match = NULL;
> 
> static int add_new_completion __ARGS((char_u *str, int len, int dir));
> static void make_cyclic __ARGS((void));
> static void complete_dictionaries __ARGS((char_u *, int));
> static void free_completions __ARGS((void));
> static int count_completions __ARGS((void));
> 
> static void insert_special __ARGS((int));
23a51
> static char_u *get_id_option __ARGS((void));
25,28d52
< int arrow_used;				/* Normally FALSE, set to TRUE after hitting
< 							 * cursor key in insert mode. Used by vgetorpeek()
< 							 * to decide when to call u_sync() */
< int restart_edit = 0;		/* call edit when next command finished */
34a59,61
> static int		ctrl_x_mode = 0;	/* Which Ctrl-X mode are we in? */
> static char_u	*original_text = NULL;
> 							/* Original text typed before completion */
36c63,66
< 	void
---
> /*
>  * edit() returns TRUE if it returns because of a CTRL-O command
>  */
> 	int
43,45d72
< 	char_u		*saved_line = NULL;		/* saved line for replace mode */
< 	linenr_t	 saved_lnum = 0;		/* lnum of saved line */
< 	int			 saved_char = NUL;		/* char replaced by NL */
46a74,75
> 	int			 vcol;
> 	int			 last_vcol;
49d77
< 	int			 nextc = 0;
50a79
> 	int			 revins;					/* reverse insert mode */
54,61c83,91
< #ifdef WEBB_KEYWORD_COMPL
< 	FPOS		 complete_pos;
< 	FPOS		 first_match;
< 	char_u		 *complete_pat = NULL;
< 	char_u		 *completion_str = NULL;
< 	char_u		 *last_completion_str = NULL;
< 	char_u		 *tmp_ptr;
< 	int			 previous_c = 0;
---
> 	FPOS		 first_match_pos;
> 	FPOS		 last_match_pos;
> 	FPOS		*complete_pos = NULL;
> 	char_u		*complete_pat = NULL;
> 	char_u		*tmp_ptr;
> 	char_u		*m = NULL;					/* Message about completion */
> 	char_u		*quick_m = NULL;			/* Message without sleep */
> 	char_u		*idp;
> 	int			 started_completion = FALSE;
64,68c94,98
< 	int			 complete_any_word = 0;		/* true -> ^N/^P hit with no prefix
< 											 * init for gcc */
< 	int			 done;
< 	int			 found_error = FALSE;
< 	char_u		 backup_char = 0;			/* init for gcc */
---
> 	int			 done_dir = 0;				/* Found all matches in this direction */
> 	int			 i;
> 	int			 num_matches;
> 	char_u		**matches;
> 	regexp		*prog;
71c101,102
< #endif /* WEBB_KEYWORD_COMPL */
---
> 
> 	revins = (State == INSERT && p_ri);	/* there is no reverse replace mode */
73c104,108
< 	if (restart_edit)
---
> 	/*
> 	 * When CTRL-O . is used to repeat an insert, we get here with
> 	 * restart_edit TRUE, but something in the stuff buffer
> 	 */
> 	if (restart_edit && stuff_empty())
80a116
> 		 * Also do this if curswant is set to the end of the line.
82c118,119
< 		if (o_eol && curwin->w_cursor.lnum == o_lnum &&
---
> 		if (((o_eol && curwin->w_cursor.lnum == o_lnum) ||
> 									(curwin->w_curswant == MAXCOL)) &&
101d137
< 
118,121c154,159
< #ifdef WEBB_KEYWORD_COMPL
< 		previous_c = c;
< #endif /* WEBB_KEYWORD_COMPL */
< 		if (nextc)			/* character remaining from CTRL-V */
---
> 
> 		c = vgetc();
> 		if (c == Ctrl('C'))
> 			got_int = FALSE;
> 
> 		if (ctrl_x_mode == CTRL_X_NOT_DEFINED_YET)
123,124c161,195
< 			c = nextc;
< 			nextc = 0;
---
> 			/* We have just entered ctrl-x mode and aren't quite sure which
> 			 * ctrl-x mode it will be yet.  Now we decide -- webb
> 			 */
> 			switch (c)
> 			{
> 				case Ctrl('E'):
> 				case Ctrl('Y'):
> 					ctrl_x_mode = CTRL_X_SCROLL;
> 					edit_submode = (char_u *)"Scroll (^E/^Y)";
> 					break;
> 				case Ctrl('L'):
> 					ctrl_x_mode = CTRL_X_WHOLE_LINE;
> 					edit_submode = (char_u *)"Whole line completion (^L/^N/^P)";
> 					break;
> 				case Ctrl('F'):
> 					ctrl_x_mode = CTRL_X_FILES;
> 					edit_submode = (char_u *)"File name completion (^F/^N/^P)";
> 					break;
> 				case Ctrl(']'):
> 					ctrl_x_mode = CTRL_X_TAGS;
> 					edit_submode = (char_u *)"Tag completion (^]/^N/^P)";
> 					break;
> 				case Ctrl('G'):
> 					ctrl_x_mode = CTRL_X_PATH_PATTERNS;
> 					edit_submode = (char_u *)"Path pattern completion (^G/^N/^P)";
> 					break;
> 				case Ctrl('D'):
> 					ctrl_x_mode = CTRL_X_PATH_DEFINES;
> 					edit_submode = (char_u *)"Definition completion (^D/^N/^P)";
> 					break;
> 				default:
> 					ctrl_x_mode = 0;
> 					break;
> 			}
> 			showmode();
126c197
< 		else
---
> 		else if (ctrl_x_mode)
128,130c199,208
< 			c = vgetc();
< 			if (c == Ctrl('C'))
< 				got_int = FALSE;
---
> 			/* We we're already in ctrl-x mode, do we stay in it? */
> 			if (!is_ctrl_x_key(c))
> 			{
> 				if (ctrl_x_mode == CTRL_X_SCROLL)
> 					ctrl_x_mode = 0;
> 				else
> 					ctrl_x_mode = CTRL_X_FINISHED;
> 				edit_submode = NULL;
> 			}
> 			showmode();
132,133c210
< #ifdef WEBB_KEYWORD_COMPL
< 		if (previous_c == Ctrl('N') || previous_c == Ctrl('P'))
---
> 		if (started_completion || ctrl_x_mode == CTRL_X_FINISHED)
140c217,218
< 			if (c != Ctrl('N') && c != Ctrl('P'))
---
> 			if ((ctrl_x_mode == 0 && c != Ctrl('N') && c != Ctrl('P')) ||
> 												ctrl_x_mode == CTRL_X_FINISHED)
143,144c221,223
< 				 * ^P. Free up memory that was used, and make sure we can redo
< 				 * the insert.
---
> 				 * ^P or other completion characters in CTRL-X mode. Free up
> 				 * memory that was used, and make sure we can redo the insert
> 				 * -- webb.
146,147c225,254
< 				if (completion_str != NULL)
< 					AppendToRedobuff(completion_str);
---
> 				if (curr_match != NULL)
> 				{
> 					/*
> 					 * If any of the original typed text has been changed,
> 					 * eg when ignorecase is set, we must add back-spaces to
> 					 * the redo buffer.  We add as few as necessary to delete
> 					 * just the part of the original text that has changed
> 					 * -- webb
> 					 */
> 					ptr = curr_match->str;
> 					tmp_ptr = original_text;
> 					while (*tmp_ptr && *tmp_ptr == *ptr)
> 					{
> 						++tmp_ptr;
> 						++ptr;
> 					}
> 					temp = 0;
> 					while (tmp_ptr[temp])
> 						tmp_ptr[temp++] = BS;
> 					if (*tmp_ptr)
> 						AppendToRedobuff(tmp_ptr);
> 					if (*ptr)
> 						AppendToRedobuff(ptr);
> 				}
> 				/* Break line if it's too long */
> 				lnum = curwin->w_cursor.lnum;
> 				insertchar(NUL, FALSE);
> 				if (lnum != curwin->w_cursor.lnum)
> 					updateScreen(CURSUPD);
> 
149,151c256,265
< 				free(completion_str);
< 				free(last_completion_str);
< 				complete_pat = completion_str = last_completion_str = NULL;
---
> 				free(original_text);
> 				complete_pat = NULL;
> 				free_completions();
> 				started_completion = FALSE;
> 				ctrl_x_mode = 0;
> 				if (edit_submode != NULL)
> 				{
> 					edit_submode = NULL;
> 					showmode();
> 				}
154d267
< #endif /* WEBB_KEYWORD_COMPL */
158,172d270
< /*
<  * In replace mode a backspace puts the original text back.
<  * We save the current line to be able to do that.
<  * If characters are appended to the line, they will be deleted.
<  * If we start a new line (with CR) the saved line will be empty, thus
<  * the characters will be deleted.
<  * If we backspace over the new line, that line will be saved.
<  */
< 		if (State == REPLACE && saved_lnum != curwin->w_cursor.lnum)
< 		{
< 			free(saved_line);
< 			saved_line = strsave(ml_get(curwin->w_cursor.lnum));
< 			saved_lnum = curwin->w_cursor.lnum;
< 		}
< 
180c278
< 			screen_outchar('^', curwin->w_row, curwin->w_col);
---
> 			screen_outchar('^', curwin->w_winpos + curwin->w_row, curwin->w_col);
185,187c283,284
< 			c = get_literal(&nextc);
< 
< 			insertchar(c);
---
> 			c = get_literal();
> 			insert_special(c);
191a289,303
> 			  case K_INS:			/* toggle insert/replace mode */
> 			    if (State == REPLACE)
> 					State = INSERT;
> 				else
> 					State = REPLACE;
> 				AppendCharToRedobuff(K_INS);
> 				showmode();
> 				break;
> 
> 			  case Ctrl('X'):		/* Enter ctrl-x mode */
> 				/* We're not sure which ctrl-x mode it will be yet */
> 				ctrl_x_mode = CTRL_X_NOT_DEFINED_YET;
> 				MSG("^X mode (^E/^Y/^L/^]/^F/^G/^D)");
> 				break;
> 
193c305
< 			    if (echeck_abbr(Ctrl('O') + 0x100))
---
> 			    if (echeck_abbr(Ctrl('O') + 0x200))
205c317
< 			    if (echeck_abbr(ESC + 0x100))
---
> 			    if (echeck_abbr(ESC + 0x200))
210a323
> 				temp = curwin->w_cursor.col;
222c335,336
< 				if (!restart_edit)
---
> 				/* When an autoindent was removed, curswant stays after the indent */
> 				if (!restart_edit && temp == curwin->w_cursor.col)
228,235c342,345
< 				if (curwin->w_cursor.col != 0 && (!restart_edit || gchar_cursor() == NUL) && !p_ri)
< 					dec_cursor();
< 				if (extraspace)			/* did reverse replace in column 0 */
< 				{
< 					(void)delchar(FALSE);
< 					updateline();
< 					extraspace = FALSE;
< 				}
---
> 				if (curwin->w_cursor.col != 0 && (!restart_edit || gchar_cursor() == NUL) && !revins)
> 					--curwin->w_cursor.col;
> 				if (State == REPLACE)
> 					replace_flush();	/* free replace stack */
242d351
< 				free(saved_line);
244c353
< 				return;
---
> 				return (c == Ctrl('O'));
262c371
< 					beep();
---
> 					beep_flush();
266a376
> 				revins = (State == INSERT && p_ri);
273,274c383,384
< 				 * This isn't completely compatible with
< 				 * vi, but the difference isn't very noticeable and now you can
---
> 				 * This isn't completely compatible with vi, but the
> 				 * difference isn't very noticeable and now you can
278d387
< 			  case Ctrl('T'):		/* make indent one shiftwidth greater */
279a389,392
> 				if (ctrl_x_mode == CTRL_X_PATH_DEFINES)
> 					goto docomplete;
> 				/* FALLTHROUGH */
> 			  case Ctrl('T'):		/* make indent one shiftwidth greater */
299a413
> 					vcol = curwin->w_virtcol;
301a416,417
> 					if (temp < 0)		/* Cursor in indented part */
> 						vcol = get_indent() - vcol;
306c422,452
< 					temp += curwin->w_cursor.col;
---
> 					if (temp < 0)		/* Cursor in indented part */
> 					{
> 						temp = get_indent() - vcol;
> 						curwin->w_virtcol = (temp < 0) ? 0 : temp;
> 						vcol = last_vcol = 0;
> 						temp = -1;
> 						ptr = ml_get(curwin->w_cursor.lnum);
> 						while (vcol <= curwin->w_virtcol)
> 						{
> 							last_vcol = vcol;
> 							vcol += chartabsize(ptr[++temp], vcol);
> 						}
> 						vcol = last_vcol;
> 						if (vcol != curwin->w_virtcol)
> 						{
> 							curwin->w_cursor.col = temp;
> 							i = curwin->w_virtcol - vcol;
> 							ptr = alloc(i + 1);
> 							if (ptr != NULL)
> 							{
> 								temp += i;
> 								ptr[i] = NUL;
> 								while (--i >= 0)
> 									ptr[i] = ' ';
> 								insstr(ptr);
> 								free(ptr);
> 							}
> 						}
> 					}
> 					else
> 						temp += curwin->w_cursor.col;
317d462
< 			  case BS:
318a464,485
> 			  case K_DEL:
> 				stop_arrow();
> 			  	if (gchar_cursor() == NUL)		/* delete newline */
> 				{
> 					temp = curwin->w_cursor.col;
> 					if (!p_bs ||				/* only if 'bs' set */
> 						u_save((linenr_t)(curwin->w_cursor.lnum - 1),
> 							(linenr_t)(curwin->w_cursor.lnum + 2)) == FAIL ||
> 								dojoin(FALSE, TRUE) == FAIL)
> 						beep_flush();
> 					else
> 						curwin->w_cursor.col = temp;
> 				}
> 				else if (delchar(FALSE) == FAIL)/* delete char under cursor */
> 					beep_flush();
> 				did_ai = FALSE;
> 				did_si = FALSE;
> 				can_si = FALSE;
> 				AppendCharToRedobuff(c);
> 				goto redraw;
> 
> 			  case BS:
326,327c493,495
< 				if (bufempty() || (!p_ri &&
< 						((curwin->w_cursor.lnum == 1 && curwin->w_cursor.col <= 0) ||
---
> 				if (bufempty() || (!revins &&
> 						((curwin->w_cursor.lnum == 1 &&
> 									curwin->w_cursor.col <= 0) ||
333c501
< 					beep();
---
> 					beep_flush();
338c506
< 				if (p_ri)
---
> 				if (revins)			/* put cursor after last inserted char */
343c511
< 					if (curwin->w_cursor.lnum == Insstart.lnum || p_ri)
---
> 					if (curwin->w_cursor.lnum == Insstart.lnum || revins)
345c513,514
< 						if (!u_save((linenr_t)(curwin->w_cursor.lnum - 2), (linenr_t)(curwin->w_cursor.lnum + 1)))
---
> 						if (u_save((linenr_t)(curwin->w_cursor.lnum - 2),
> 								(linenr_t)(curwin->w_cursor.lnum + 1)) == FAIL)
349,353d517
< 						/* this is in xvim, why?
< 						if (curbuf->b_p_ai)
< 							for (ptr = ml_get(Insstart.lnum);
< 											iswhite(*ptr++); Insstart.col++)
< 								; */
354a519,526
> 					/*
> 					 * In replace mode:
> 					 * cc < 0: NL was inserted, delete it
> 					 * cc >= 0: NL was replaced, put original characters back
> 					 */
> 					cc = -1;
> 					if (State == REPLACE)
> 						cc = replace_pop();
364c536,543
< 						if (saved_char)				/* restore what NL replaced */
---
> 						/*
> 						 * in REPLACE mode we have to put back the text that
> 						 * was replace by the NL. On the replace stack is
> 						 * first a NUL-terminated sequence of characters that
> 						 * were deleted and then the character that NL
> 						 * replaced.
> 						 */
> 						if (State == REPLACE)
366,370c545,564
< 							State = NORMAL;			/* no replace for this char */
< 							inschar(saved_char);	/* but no showmatch */
< 							State = REPLACE;
< 							saved_char = NUL;
< 							if (!p_ri)
---
> 							/*
> 							 * Do the next inschar() in NORMAL state, to
> 							 * prevent inschar() from replacing characters and
> 							 * avoiding showmatch().
> 							 */
> 							State = NORMAL;
> 							/*
> 							 * restore blanks deleted after cursor
> 							 */
> 							for (i = 0; cc > 0; ++i)
> 							{
> 								temp = curwin->w_cursor.col;
> 								inschar(cc);
> 								curwin->w_cursor.col = temp;
> 								cc = replace_pop();
> 							}
> 							cc = replace_pop();
> 							if (cc > 0)
> 							{
> 								inschar(cc);
371a566,567
> 							}
> 							State = REPLACE;
373,374d568
< 						else if (p_ri)				/* in reverse mode */
< 							saved_lnum = 0;			/* save this line again */
382c576
< 					if (p_ri && State != REPLACE)
---
> 					if (revins)			/* put cursor on last inserted char */
385c579
< 					if (mode == 3 && !p_ri && curbuf->b_p_ai)	/* keep indent */
---
> 					if (mode == 3 && !revins && curbuf->b_p_ai)	/* keep indent */
394c588,589
< 					/* delete upto starting point, start of line or previous word */
---
> 					/* delete upto starting point, start of line or previous
> 					 * word */
397c592
< 						if (!p_ri)
---
> 						if (!revins)	/* put cursor on char to be deleted */
409c604
< 							if (!p_ri)
---
> 							if (!revins)
417,435c612,621
< 							if (saved_line)
< 							{
< 								if (extraspace)
< 								{
< 									if ((int)STRLEN(ml_get(curwin->w_cursor.lnum)) - 1 > (int)STRLEN(saved_line))
< 										(void)delchar(FALSE);
< 									else
< 									{
< 										dec_cursor();
< 										(void)delchar(FALSE);
< 										extraspace = FALSE;
< 										pchar_cursor(*saved_line);
< 									}
< 								}
< 								else if (curwin->w_cursor.col < STRLEN(saved_line))
< 									pchar_cursor(saved_line[curwin->w_cursor.col]);
< 								else if (!p_ri)
< 									(void)delchar(FALSE);
< 							}
---
> 							/*
> 							 * cc < 0: replace stack empty, just move cursor
> 							 * cc == 0: character was inserted, delete it
> 							 * cc > 0: character was replace, put original back
> 							 */
> 							cc = replace_pop();
> 							if (cc > 0)
> 								pchar_cursor(cc);
> 							else if (cc == 0)
> 								(void)delchar(FALSE);
440c626
< 							if (p_ri && gchar_cursor() == NUL)
---
> 							if (revins && gchar_cursor() == NUL)
445,447c631
< 						if (p_ri && State == REPLACE && inc_cursor())
< 							break;
< 					} while (p_ri || (curwin->w_cursor.col > mincol && (curwin->w_cursor.lnum != Insstart.lnum ||
---
> 					} while (revins || (curwin->w_cursor.col > mincol && (curwin->w_cursor.lnum != Insstart.lnum ||
449,450d632
< 					if (extraspace)
< 						dec_cursor();
479a662,668
> #if defined(UNIX) || defined(MSDOS)	/* only for xterm and msdos at the moment */
> 			  case K_MOUSE:
> 				if (jumpto(mouse_row, mouse_col) == OK)
> 					start_arrow();
> 				break;
> #endif
> 
482d670
< 				{
484,486c672,675
< 				}
< 					/* if 'whichwrap' set for cursor in insert mode may go
< 					 * to previous line */
---
> 				/*
> 				 * if 'whichwrap' set for cursor in insert mode may go to
> 				 * previous line
> 				 */
492c681
< 					curwin->w_curswant = MAXCOL;	/* so we stay at the end */
---
> 					curwin->w_set_curswant = TRUE;	/* so we stay at the end */
495c684,689
< 					beep();
---
> 					beep_flush();
> 				break;
> 
> 			  case K_HOME:
> 			  	curwin->w_cursor.col = 0;
> 				start_arrow();
497a692,696
> 			  case K_END:
> 				coladvance(MAXCOL);
> 				start_arrow();
> 				break;
> 
505c704
< 					beep();
---
> 					beep_flush();
525c724
< 					beep();
---
> 					beep_flush();
535c734
< 					beep();
---
> 					beep_flush();
542c741
< 					beep();
---
> 					beep_flush();
545a745
> 			  case K_PAGEUP:
549c749
< 					beep();
---
> 					beep_flush();
556c756
< 					beep();
---
> 					beep_flush();
559a760
> 			  case K_PAGEDOWN:
563c764
< 					beep();
---
> 					beep_flush();
567c768
< 			    if (echeck_abbr(TAB + 0x100))
---
> 			    if (echeck_abbr(TAB + 0x200))
569c770
< 			  	if ((!curbuf->b_p_et && !(p_sta && inindent())) || (p_ri && State == REPLACE))
---
> 			  	if (!curbuf->b_p_et && !(p_sta && inindent()))
574c775
< 				if (!curbuf->b_p_et)				/* insert smart tab */
---
> 				if (!curbuf->b_p_et)
582c783
< 				if (p_sta && inindent())
---
> 				if (p_sta && inindent())		/* insert smart tab */
584c785
< 				else
---
> 				else							/* insert normal tab */
586,587c787,793
< 				temp -= curwin->w_cursor.col % temp;
< 				inschar(' ');			/* delete one char in replace mode */
---
> 				temp -= curwin->w_virtcol % temp;
> 				/*
> 				 * insert the first space with inschar(); it will delete one
> 				 * char in replace mode. Insert the rest with insstr(); it
> 				 * will not delete any chars
> 				 */
> 				inschar(' ');
589c795,799
< 					insstr((char_u *)" ");		/* insstr does not delete chars */
---
> 				{
> 					insstr((char_u *)" ");
> 					if (State == REPLACE)		/* no char replaced */
> 						replace_push(0);
> 				}
594c804
< 			    if (echeck_abbr(c + 0x100))
---
> 			    if (echeck_abbr(c + 0x200))
598,609c808
< 				{
< 					saved_char = gchar_cursor();
< 					(void)delchar(FALSE);
< 				}
< 				/*
< 				 * When 'autoindent' set delete white space after the cursor.
< 				 * Vi does this, although it probably does it implicitly due
< 				 * to the way it does auto-indent -- webb.
< 				 */
< 				if (curbuf->b_p_ai || curbuf->b_p_si)
< 					while ((c = gchar_cursor()) == ' ' || c == TAB)
< 						(void)delchar(FALSE);
---
> 					replace_push(NUL);
612c811,815
< 				if (!Opencmd(FORWARD, TRUE, State == INSERT))
---
> 				if (curbuf->b_p_fo != NULL && STRCHR(curbuf->b_p_fo, FO_RET_COMS) != NULL)
> 					fo_do_comments = TRUE;
> 				i = Opencmd(FORWARD, TRUE);
> 				fo_do_comments = FALSE;
> 				if (!i)
614,615c817
< 				if (p_ri)
< 				{
---
> 				if (revins)
617,619d818
< 					if (State == REPLACE && curwin->w_cursor.col > 0)
< 						dec_cursor();
< 				}
625c824,825
< 				screen_outchar('?', curwin->w_row, curwin->w_col);
---
> 				screen_outchar('?', curwin->w_winpos + curwin->w_row,
> 															curwin->w_col);
633c833,834
< 						screen_outchar(c, curwin->w_row, curwin->w_col);
---
> 						screen_outchar(c, curwin->w_winpos + curwin->w_row,
> 																curwin->w_col);
648c849,868
< #ifdef WEBB_KEYWORD_COMPL
---
> 			  case Ctrl('G'):			/* Complete patterns along path */
> 				if (ctrl_x_mode != CTRL_X_PATH_PATTERNS)
> 					goto normalchar;
> 				goto docomplete;
> 
> 			  case Ctrl(']'):			/* Tag name completion after ^X */
> 				if (ctrl_x_mode != CTRL_X_TAGS)
> 					goto normalchar;
> 				goto docomplete;
> 
> 			  case Ctrl('F'):			/* File name completion after ^X */
> 				if (ctrl_x_mode != CTRL_X_FILES)
> 					goto normalchar;
> 				goto docomplete;
> 
> 			  case Ctrl('L'):			/* Whole line completion after ^X */
> 				if (ctrl_x_mode != CTRL_X_WHOLE_LINE)
> 					goto normalchar;
> 				/* FALLTHROUGH */
> 
651c871,872
< 				if (c == Ctrl('P'))
---
> docomplete:
> 				if (c == Ctrl('P') || c == Ctrl('L'))
655c876,877
< 				if (previous_c != Ctrl('N') && previous_c != Ctrl('P'))
---
> 				quick_m = m = NULL;			/* No message by default */
> 				if (!started_completion)
658,660c880,892
< 					complete_pos = curwin->w_cursor;
< 					ptr = ml_get(complete_pos.lnum);
< 					complete_col = complete_pos.col;
---
> 					if (ctrl_x_mode == 0)
> 					{
> 						edit_submode = (char_u *)"Keyword completion (^P/^N)";
> 						showmode();
> 					}
> 					did_ai = FALSE;
> 					did_si = FALSE;
> 					can_si = FALSE;
> 					stop_arrow();
> 					done_dir = 0;
> 					first_match_pos = curwin->w_cursor;
> 					ptr = tmp_ptr = ml_get(first_match_pos.lnum);
> 					complete_col = first_match_pos.col;
662c894,896
< 					if (temp < 0 || !isidchar(ptr[temp]))
---
> 
> 					/* Work out completion pattern and original text -- webb */
> 					if (ctrl_x_mode == 0 || (ctrl_x_mode & CTRL_X_WANT_IDENT))
664,665c898,936
< 						complete_pat = strsave((char_u *)"\\<[a-zA-Z_]");
< 						complete_any_word = TRUE;
---
> 						if (temp < 0 || !isidchar(ptr[temp]))
> 						{
> 							/* Match any identifier of at least two chars */
> 							idp = get_id_option();	/* get value of 'id' */
> 							sprintf((char *)IObuff,
> 									(char_u *)"\\<[a-zA-Z%s][a-zA-Z0-9%s]",
> 											idp, idp);
> 							complete_pat = strsave(IObuff);
> 							if (complete_pat == NULL)
> 								break;
> 							tmp_ptr += complete_col;
> 							temp = 0;
> 						}
> 						else
> 						{
> 							while (temp >= 0 && isidchar(ptr[temp]))
> 								temp--;
> 							tmp_ptr += ++temp;
> 							if ((temp = complete_col - temp) == 1)
> 							{
> 								/* Only match identifiers with at least two
> 								 * chars -- webb
> 								 */
> 								idp = get_id_option();	/* get value of 'id' */
> 								sprintf((char *)IObuff,
> 										"\\<%c[a-zA-Z0-9%s]", *tmp_ptr, idp);
> 								complete_pat = strsave(IObuff);
> 								if (complete_pat == NULL)
> 									break;
> 							}
> 							else
> 							{
> 								complete_pat = alloc(temp + 3);
> 								if (complete_pat == NULL)
> 									break;
> 								sprintf((char *)complete_pat, "\\<%.*s", temp,
> 																	tmp_ptr);
> 							}
> 						}
667c938
< 					else
---
> 					else if (ctrl_x_mode == CTRL_X_WHOLE_LINE)
669,676c940,947
< 						while (temp >= 0 && isidchar(ptr[temp]))
< 							temp--;
< 						temp++;
< 						complete_pat = alloc(curwin->w_cursor.col - temp + 3);
< 						if (complete_pat != NULL)
< 							sprintf((char *)complete_pat, "\\<%.*s",
< 								(int)(curwin->w_cursor.col - temp), ptr + temp);
< 						complete_any_word = FALSE;
---
> 						tmp_ptr = ptr;
> 						skipwhite(&tmp_ptr);
> 						temp = complete_col - (tmp_ptr - ptr);
> 						complete_pat = alloc(temp + 1);
> 						if (complete_pat == NULL)
> 							break;
> 						STRNCPY(complete_pat, tmp_ptr, temp);
> 						complete_pat[temp] = NUL;
678,683c949
< 					last_completion_str = strsave((char_u *)" ");
< 				}
< 				else
< 				{
< 					/* This is not the first ^N or ^P we have hit in a row */
< 					while (curwin->w_cursor.col != complete_col)
---
> 					else if (ctrl_x_mode == CTRL_X_FILES)
685,686c951,957
< 						curwin->w_cursor.col--;
< 						delchar(FALSE);
---
> 						while (temp >= 0 && isfilechar(ptr[temp]))
> 							temp--;
> 						tmp_ptr += ++temp;
> 						temp = complete_col - temp;
> 						complete_pat = addstar(tmp_ptr, temp);
> 						if (complete_pat == NULL)
> 							break;
688c959,960
< 					if (completion_str != NULL)
---
> 					original_text = alloc(temp + 1);
> 					if (original_text == NULL)
690,691c962,964
< 						free(last_completion_str);
< 						last_completion_str = strsave(completion_str);
---
> 						free(complete_pat);
> 						complete_pat = NULL;
> 						break;
693,711c966,971
< 				}
< 				if (complete_pat == NULL || last_completion_str == NULL)
< 				{
< 					found_error = TRUE;
< 					break;
< 				}
< 				if (!complete_any_word)
< 				{
< 					ptr = ml_get(curwin->w_cursor.lnum);
< 					backup_char = ptr[complete_col - 1];
< 					ptr[complete_col - 1] = ' ';
< 				}
< 				done = FALSE;
< 				found_error = FALSE;
< 				first_match.lnum = 0;
< 				keep_old_search_pattern = TRUE;
< 				while (!done)
< 				{
< 					if (complete_direction == BACKWARD)
---
> 					STRNCPY(original_text, tmp_ptr, temp);
> 					original_text[temp] = NUL;
> 
> 					/* Get list of all completions now, if appropriate */
> 					if (ctrl_x_mode == CTRL_X_PATH_PATTERNS ||
> 						ctrl_x_mode == CTRL_X_PATH_DEFINES)
713,716c973,991
< 						ptr = ml_get(complete_pos.lnum);
< 						while (isidchar(ptr[complete_pos.col]))
< 							complete_pos.col--;
< 						complete_pos.col++;
---
> 						started_completion = TRUE;
> 						find_pattern_in_path(complete_pat,
> 								STRLEN(complete_pat), FALSE,
> 							(ctrl_x_mode == CTRL_X_PATH_DEFINES) ? FIND_DEFINE
> 							: FIND_ANY, 1, ACTION_EXPAND,
> 							(linenr_t)1, (linenr_t)MAXLNUM);
> 							/* eat the ESC to avoid leaving insert mode */
> 						if (got_int)
> 						{
> 							(void)vgetc();
> 							got_int = FALSE;
> 						}
> 						make_cyclic();
> 						if (first_match && first_match->next != first_match)
> 						{
> 							sprintf((char *)IObuff, "There are %d matches",
> 								count_completions());
> 							m = IObuff;
> 						}
718,719c993
< 					if (!searchit(&complete_pos, complete_direction,
< 						complete_pat, 1L, TRUE, TRUE))
---
> 					else if (ctrl_x_mode == CTRL_X_TAGS)
721,722c995,1022
< 						found_error = TRUE;
< 						break;
---
> 						started_completion = TRUE;
> 						reg_ic = p_ic;
> 						prog = regcomp(complete_pat);
> 						if (prog != NULL &&
> 							ExpandTags(prog, &num_matches, &matches) == OK &&
> 							num_matches > 0)
> 						{
> 							for (i = 0; i < num_matches; i++)
> 								if (add_new_completion(matches[i],
> 								  STRLEN(matches[i]), FORWARD) == RET_ERROR)
> 									break;
> 							free(matches);
> 							make_cyclic();
> 							free(prog);
> 							if (first_match && first_match->next != first_match)
> 							{
> 								sprintf((char *)IObuff,
> 									"There are %d matching tags",
> 									count_completions());
> 								m = IObuff;
> 							}
> 						}
> 						else
> 						{
> 							free(prog);
> 							free(complete_pat);
> 							complete_pat = NULL;
> 						}
724,734c1024
< 					if (complete_any_word)
< 						ptr = ml_get_pos(&complete_pos);
< 					else
< 						ptr = ml_get_pos(&complete_pos) + 1;
< 					tmp_ptr = ptr;
< 					temp = 1;
< 					while (*tmp_ptr != NUL && isidchar(*tmp_ptr++))
< 						temp++;
< 					free (completion_str);
< 					tmp_ptr = completion_str = alloc(temp);
< 					if (completion_str == NULL)
---
> 					else if (ctrl_x_mode == CTRL_X_FILES)
736,737c1026,1050
< 						found_error = TRUE;
< 						break;
---
> 						started_completion = TRUE;
> 						expand_interactively = TRUE;
> 						if (ExpandWildCards(1, &complete_pat, &num_matches,
> 							&matches, FALSE, FALSE) == OK)
> 						{
> 							for (i = 0; i < num_matches; i++)
> 								if (add_new_completion(matches[i],
> 								  STRLEN(matches[i]), FORWARD) == RET_ERROR)
> 									break;
> 							free(matches);
> 							make_cyclic();
> 							if (first_match && first_match->next != first_match)
> 							{
> 								sprintf((char *)IObuff,
> 									"There are %d matching file names",
> 									count_completions());
> 								m = IObuff;
> 							}
> 						}
> 						else
> 						{
> 							free(complete_pat);
> 							complete_pat = NULL;
> 						}
> 						expand_interactively = FALSE;
739,745c1052,1068
< 					while (*ptr != NUL && isidchar(*ptr))
< 						*(tmp_ptr++) = *(ptr++);
< 					*tmp_ptr = NUL;
< 					if (completion_str[0] != NUL &&
< 							STRCMP(completion_str, last_completion_str) != 0)
< 						done = TRUE;
< 					else if (first_match.lnum == 0)
---
> 					complete_col = tmp_ptr - ptr;
> 					first_match_pos.col -= temp;
> 
> 					/* So that ^N can match word immediately after cursor */
> 					if (ctrl_x_mode == 0)
> 						dec(&first_match_pos);
> 
> 					last_match_pos = first_match_pos;
> 				}
> 				/*
> 				 * In insert mode: Delete the typed part.
> 				 * In replace mode: Put the old characters back, if any.
> 				 */
> 				while (curwin->w_cursor.col > complete_col)
> 				{
> 					curwin->w_cursor.col--;
> 					if (State == REPLACE)
747,748c1070,1071
< 						first_match.lnum = complete_pos.lnum;
< 						first_match.col = complete_pos.col;
---
> 						if ((cc = replace_pop()) > 0)
> 							pchar(curwin->w_cursor, cc);
750,751c1073,1091
< 					else if (complete_pos.lnum == first_match.lnum
< 						 && complete_pos.col == first_match.col)
---
> 					else
> 						delchar(FALSE);
> 				}
> 				complete_pos = NULL;
> 				if (started_completion && curr_match == NULL &&
> 										(p_ws || done_dir == BOTH_DIRECTIONS))
> 					quick_m = e_patnotf;
> 				else if (curr_match != NULL && complete_direction == FORWARD &&
> 											curr_match->next != NULL)
> 					curr_match = curr_match->next;
> 				else if (curr_match != NULL && complete_direction == BACKWARD &&
> 											curr_match->prev != NULL)
> 					curr_match = curr_match->prev;
> 				else
> 				{
> 					complete_pos = (complete_direction == FORWARD) ?
> 										&last_match_pos : &first_match_pos;
> 					keep_old_search_pattern = TRUE;
> 					for (;;)
753,754c1093,1129
< 						if (completion_str[0] == NUL)
< 							EMSG("Exact match only");
---
> 						if (ctrl_x_mode == CTRL_X_WHOLE_LINE)
> 							temp = search_for_exact_line(complete_pos,
> 										complete_direction, complete_pat);
> 						else
> 							temp = searchit(complete_pos, complete_direction,
> 										complete_pat, 1L, FALSE, TRUE, 2);
> 						if (temp == FAIL)
> 						{
> 							if (!p_ws && done_dir != -complete_direction)
> 							{
> 								/*
> 								 * With nowrapscan, we haven't finished
> 								 * looking in the other direction yet -- webb
> 								 */
> 								temp = OK;
> 								done_dir = complete_direction;
> 							}
> 							else if (!p_ws)
> 								done_dir = BOTH_DIRECTIONS;
> 							break;
> 						}
> 						if (!started_completion)
> 						{
> 							started_completion = TRUE;
> 							first_match_pos = *complete_pos;
> 							last_match_pos = *complete_pos;
> 						}
> 						else if (first_match_pos.lnum == last_match_pos.lnum &&
> 						  first_match_pos.col == last_match_pos.col)
> 						{
> 							/* We have found all the matches in this file */
> 							temp = FAIL;
> 							break;
> 						}
> 						ptr = ml_get_pos(complete_pos);
> 						if (ctrl_x_mode == CTRL_X_WHOLE_LINE)
> 							temp = STRLEN(ptr);
756,757c1131,1142
< 							EMSG("No other matches");
< 						done = TRUE;
---
> 						{
> 							tmp_ptr = ptr;
> 							temp = 0;
> 							while (*tmp_ptr != NUL && isidchar(*tmp_ptr++))
> 								temp++;
> 						}
> 						if (add_completion_and_infercase(ptr, temp,
> 								complete_direction) != FAIL)
> 						{
> 							temp = OK;
> 							break;
> 						}
758a1144,1150
> 					keep_old_search_pattern = FALSE;
> 				}
> 				i = -1;
> 				if (complete_pos != NULL && temp == FAIL && ctrl_x_mode == 0)
> 				{
> 					i = count_completions();	/* Num matches in this file */
> 					complete_dictionaries(complete_pat, complete_direction);
760,762c1152
< 				if (!found_error)
< 					insstr(completion_str);
< 				if (!complete_any_word)
---
> 				if (complete_pos != NULL && temp == FAIL)
764,765c1154,1179
< 					ptr = ml_get(curwin->w_cursor.lnum);
< 					ptr[complete_col - 1] = backup_char;
---
> 					int tot;
> 
> 					tot = count_completions();	/* Total num matches */
> 					if (curr_match != NULL)
> 					{
> 						make_cyclic();
> 						if (complete_direction == FORWARD)
> 							curr_match = curr_match->next;
> 						else
> 							curr_match = curr_match->prev;
> 					}
> 					if ((i < 0 && tot > 1) || (tot == i && i > 1))
> 					{
> 						sprintf((char *)IObuff,
> 							"All %d matches have now been found", tot);
> 						m = IObuff;
> 					}
> 					else if (i >= 0 && tot > i)
> 					{
> 						sprintf((char *)IObuff,
> 							"%d matches in file, %d matches in dictionary",
> 							i, tot - i);
> 						m = IObuff;
> 					}
> 					else if (tot == 0)
> 						quick_m = e_patnotf;
767c1181,1196
< 				keep_old_search_pattern = FALSE;
---
> 
> 				/* Why do we still exit insert mode after ^C? -- webb */
> 				got_int = FALSE;
> 
> 				/*
> 				 * Use inschar() to insert the text, it is a bit slower than
> 				 * insstr(), but it takes care of replace mode.
> 				 */
> 				if (curr_match != NULL)
> 					ptr = curr_match->str;
> 				else
> 					ptr = original_text;
> 				if (ptr != NULL)
> 					while (*ptr)
> 						inschar(*ptr++);
> 				started_completion = TRUE;
768a1198,1209
> 				(void)set_highlight('r');
> 				msg_highlight = TRUE;
> 				if (m != NULL)
> 				{
> 					msg(m);
> 					sleep(1);
> 				}
> 				else if (quick_m != NULL)
> 					msg(quick_m);
> 				else if (first_match != NULL &&
> 											first_match->next == first_match)
> 					MSG("This is the only match");
770d1210
< #endif /* WEBB_KEYWORD_COMPL */
772a1213,1218
> 				if (ctrl_x_mode == CTRL_X_SCROLL)
> 				{
> 					scrolldown_clamp();
> 					updateScreen(VALID);
> 					break;
> 				}
776a1223,1228
> 				if (ctrl_x_mode == CTRL_X_SCROLL)
> 				{
> 					scrollup_clamp();
> 					updateScreen(VALID);
> 					break;
> 				}
781c1233
< 					beep();
---
> 					beep_flush();
795c1247
< 					beep();
---
> 					beep_flush();
805c1257,1258
< 				if (curwin->w_cursor.col > 0 && ((can_si && c == '}') || (did_si && c == '{')))
---
> 				if ((curwin->w_cursor.col > 0 && did_si && c == '{') ||
> 													(can_si && c == '}'))
808d1260
< 					int		i;
810,811c1262,1265
< 						/* for '}' set indent equal to matching '{' */
< 					if (c == '}' && (pos = showmatch('{')) != NULL)
---
> 						/* for '}' set indent equal to indent of line
> 						 * containing matching '{'
> 						 */
> 					if (c == '}' && (pos = findmatch('{')) != NULL)
814c1268,1286
< 						curwin->w_cursor = *pos;
---
> 						/*
> 						 * If the matching '{' has a ')' immediately before it
> 						 * (ignoring white-space), then line up with the
> 						 * matching '(' if there is one.  This handles the case
> 						 * where an "if (..\n..) {" statement continues over
> 						 * multiple lines -- webb
> 						 */
> 						ptr = ml_get(pos->lnum);
> 						i = (pos->col == 0) ? pos->col : (pos->col - 1);
> 						while (i > 0 && iswhite(ptr[i]))
> 						{
> 							if (ptr[i] == ')')
> 								break;
> 							i--;
> 						}
> 						curwin->w_cursor.lnum = pos->lnum;
> 						curwin->w_cursor.col = i;
> 						if (ptr[i] == ')' && (pos = findmatch('(')) != NULL)
> 							curwin->w_cursor = *pos;
819,820c1291,1292
< 					else
< 						shift_line(TRUE, TRUE, 1);
---
> 					else if (curwin->w_cursor.col > 0)
> 						shift_line(TRUE, FALSE, 1);
831c1303
< 					insertchar(c);
---
> 					insert_special(c);
832a1305,1581
> 		}	/* end of switch (c) */
> 	}
> }
> 
> /*
>  * Is the character 'c' a valid key to keep us in the current ctrl-x mode?
>  * -- webb
>  */
> 	int
> is_ctrl_x_key(c)
> 	int		c;
> {
> 	switch (ctrl_x_mode)
> 	{
> 		case 0:				/* Not in any ctrl-x mode */
> 			break;
> 		case CTRL_X_NOT_DEFINED_YET:
> 			if (c == Ctrl('X') || c == Ctrl('Y') || c == Ctrl('E') ||
> 					c == Ctrl('L') || c == Ctrl('F') || c == Ctrl(']') ||
> 					c == Ctrl('G') || c == Ctrl('D') || c == Ctrl('P') ||
> 					c == Ctrl('N'))
> 				return TRUE;
> 			break;
> 		case CTRL_X_SCROLL:
> 			if (c == Ctrl('Y') || c == Ctrl('E'))
> 				return TRUE;
> 			break;
> 		case CTRL_X_WHOLE_LINE:
> 			if (c == Ctrl('L') || c == Ctrl('P') || c == Ctrl('N'))
> 				return TRUE;
> 			break;
> 		case CTRL_X_FILES:
> 			if (c == Ctrl('F') || c == Ctrl('P') || c == Ctrl('N'))
> 				return TRUE;
> 			break;
> 		case CTRL_X_TAGS:
> 			if (c == Ctrl(']') || c == Ctrl('P') || c == Ctrl('N'))
> 				return TRUE;
> 			break;
> 		case CTRL_X_PATH_PATTERNS:
> 			if (c == Ctrl('G') || c == Ctrl('P') || c == Ctrl('N'))
> 				return TRUE;
> 			break;
> 		case CTRL_X_PATH_DEFINES:
> 			if (c == Ctrl('D') || c == Ctrl('P') || c == Ctrl('N'))
> 				return TRUE;
> 			break;
> 		default:
> 			emsg(e_internal);
> 			break;
> 	}
> 	return FALSE;
> }
> 
> /*
>  * This is like add_new_completion(), but if ic and inf are set, then the
>  * case of the originally typed text is used, and the case of the completed
>  * text is infered, ie this tries to work out what case you probably wanted
>  * the rest of the word to be in -- webb
>  */
> 	int
> add_completion_and_infercase(str, len, dir)
> 	char_u	*str;
> 	int		len;
> 	int		dir;
> {
> 	int has_lower = FALSE;
> 	int was_letter = FALSE;
> 	int orig_len;
> 	int idx;
> 
> 	if (p_ic && p_inf && len < IOSIZE)
> 	{
> 		/* Infer case of completed part -- webb */
> 		orig_len = STRLEN(original_text);
> 
> 		/* Use IObuff, str would change text in buffer! */
> 		STRNCPY(IObuff, str, len);
> 		IObuff[len] = NUL;
> 
> 		/* Rule 1: Were any chars converted to lower? */
> 		for (idx = 0; idx < orig_len; ++idx)
> 		{
> 			if (islower(original_text[idx]))
> 			{
> 				has_lower = TRUE;
> 				if (isupper(IObuff[idx]))
> 				{
> 					/* Rule 1 is satisfied */
> 					for (idx = orig_len; idx < len; ++idx)
> 						IObuff[idx] = TO_LOWER(IObuff[idx]);
> 					break;
> 				}
> 			}
> 		}
> 
> 		/*
> 		 * Rule 2: No lower case, 2nd consecutive letter converted to
> 		 * upper case.
> 		 */
> 		if (!has_lower)
> 		{
> 			for (idx = 0; idx < orig_len; ++idx)
> 			{
> 				if (was_letter && isupper(original_text[idx]) &&
> 					islower(IObuff[idx]))
> 				{
> 					/* Rule 2 is satisfied */
> 					for (idx = orig_len; idx < len; ++idx)
> 						IObuff[idx] = TO_UPPER(IObuff[idx]);
> 					break;
> 				}
> 				was_letter = isalpha(original_text[idx]);
> 			}
> 		}
> 
> 		/* Copy the original case of the part we typed */
> 		STRNCPY(IObuff, original_text, orig_len);
> 
> 		return add_new_completion(IObuff, len, dir);
> 	}
> 	return add_new_completion(str, len, dir);
> }
> 
> /*
>  * If the given string is already in the list of completions, then return
>  * FAIL, otherwise add it to the list and return OK.  If there is an error,
>  * maybe because alloc returns NULL, then RET_ERROR is returned -- webb.
>  */
> 	static int
> add_new_completion(str, len, dir)
> 	char_u	*str;
> 	int		len;
> 	int		dir;
> {
> 	struct Completion *match;
> 	char_u *new_str;
> 
> 	breakcheck();
> 	if (got_int)
> 		return RET_ERROR;
> 	if (first_match == NULL)
> 	{
> 		if ((new_str = alloc(len + 1)) == NULL)
> 			return RET_ERROR;
> 		first_match = curr_match =
> 			(struct Completion *)alloc(sizeof(struct Completion));
> 		if (first_match == NULL)
> 		{
> 			free(new_str);
> 			return RET_ERROR;
> 		}
> 		curr_match->next = curr_match->prev = NULL;
> 	}
> 	else
> 	{
> 		match = first_match;
> 		do
> 		{
> 			if (STRNCMP(match->str, str, len) == 0 && match->str[len] == NUL)
> 				return FAIL;
> 			match = match->next;
> 		} while (match != NULL && match != first_match);
> 		if ((new_str = alloc(len + 1)) == NULL)
> 			return RET_ERROR;
> 		match = (struct Completion *)alloc(sizeof(struct Completion));
> 		if (match == NULL)
> 		{
> 			free(new_str);
> 			return RET_ERROR;
> 		}
> 		if (dir == FORWARD)
> 		{
> 			match->next = NULL;
> 			match->prev = curr_match;
> 			curr_match->next = match;
> 			curr_match = match;
> 		}
> 		else	/* BACKWARD */
> 		{
> 			match->prev = NULL;
> 			match->next = curr_match;
> 			curr_match->prev = match;
> 			first_match = curr_match = match;
> 		}
> 	}
> 	STRNCPY(new_str, str, len);
> 	new_str[len] = NUL;
> 	curr_match->str = new_str;
> 	return OK;
> }
> 
> /*
>  * Make the completion list cyclic.  We assume that curr_match is either at
>  * the start or the end of the list.
>  */
> 	static void
> make_cyclic()
> {
> 	if (curr_match != NULL)
> 	{
> 		if (curr_match != first_match)		/* must be last match */
> 		{
> 			curr_match->next = first_match;
> 			first_match->prev = curr_match;
> 		}
> 		else
> 		{
> 			while (curr_match->next != NULL)
> 				curr_match = curr_match->next;
> 			curr_match->next = first_match;
> 			first_match->prev = curr_match;
> 			curr_match = first_match;
> 		}
> 	}
> }
> 
> /*
>  * Add any identifiers that match the given pattern to the list of
>  * completions.
>  */
> 	static void
> complete_dictionaries(pat, dir)
> 	char_u	*pat;
> 	int		dir;
> {
> 	struct Completion *save_curr_match = curr_match;
> 	char_u	*dict = p_dict;
> 	char_u	*ptr;
> 	char_u	save_char;
> 	char_u	buf[LSIZE];
> 	int		at_start;
> 	FILE	*fp;
> 	struct regexp *prog = NULL;
> 
> 	if (curr_match != NULL)
> 	{
> 		while (curr_match->next != NULL)
> 			curr_match = curr_match->next;
> 	}
> 	if (dict != NULL)
> 	{
> 		skipwhite(&dict);
> 		if (*dict != NUL)
> 		{
> 			(void)set_highlight('r');
> 			msg_highlight = TRUE;
> 			MSG("Please wait, searching dictionaries");
> 			prog = regcomp(pat);
> 		}
> 		while (*dict != NUL && prog != NULL && !got_int)
> 		{
> 			ptr = dict;
> 			skiptowhite(&ptr);
> 			save_char = *ptr;
> 			*ptr = NUL;
> 			fp = fopen((char *)dict, "r");
> 			*ptr = save_char;
> 			dict = ptr;
> 			if (fp != NULL)
> 			{
> 				while (!got_int && vim_fgets(buf, LSIZE, fp, NULL) != VIM_EOF)
> 				{
> 					ptr = buf;
> 					at_start = TRUE;
> 					while (regexec(prog, ptr, at_start))
> 					{
> 						at_start = FALSE;
> 						ptr = prog->startp[0];
> 						while (isidchar(*ptr))
> 							++ptr;
> 						if (add_completion_and_infercase(prog->startp[0],
> 								ptr - prog->startp[0], FORWARD) == RET_ERROR)
> 							break;
> 					}
> 				}
> 				fclose(fp);
833a1583,1585
> 			skipwhite(&dict);
> 		}
> 		free(prog);
834a1587,1630
> 	if (save_curr_match != NULL)
> 		curr_match = save_curr_match;
> 	else if (dir == BACKWARD)
> 		curr_match = first_match;
> }
> 
> /*
>  * Free the list of completions
>  */
> 	static void
> free_completions()
> {
> 	struct Completion *match;
> 
> 	if (first_match == NULL)
> 		return;
> 	curr_match = first_match;
> 	do
> 	{
> 		match = curr_match;
> 		curr_match = curr_match->next;
> 		free(match);
> 	} while (curr_match != NULL && curr_match != first_match);
> 	first_match = curr_match = NULL;
> }
> 
> /*
>  * Return the number of items in the Completion list
>  */
> 	static int
> count_completions()
> {
> 	struct Completion *match;
> 	int num = 0;
> 
> 	if (first_match == NULL)
> 		return 0;
> 	match = first_match;
> 	do
> 	{
> 		num++;
> 		match = match->next;
> 	} while (match != NULL && match != first_match);
> 	return num;
840c1636
<  * If one or two digits are entered, *nextc is set to the next character.
---
>  * If one or two digits are entered, the next character is given to vungetc().
843,844c1639
< get_literal(nextc)
< 	int *nextc;
---
> get_literal()
855,856d1649
< 	{
< 		*nextc = NUL;
858d1650
< 	}
863c1655
< 		if (!isdigit(nc))
---
> 		if (nc >= 0x100 || !isdigit(nc))
870,872c1662,1663
< 		cc = nc;
< 		nc = 0;
< 		if (cc == K_ZERO)	/* NUL is stored as NL */
---
> 		if (nc == K_ZERO)	/* NUL is stored as NL */
> 		{
873a1665,1671
> 			nc = 0;
> 		}
> 		else
> 		{
> 			cc = nc;
> 			nc = 0;
> 		}
879c1677,1678
< 	*nextc = nc;
---
> 	if (nc)
> 		vungetc(nc);
884a1684,1701
>  * Insert character, taking care of special codes above 0x100
>  */
> 	static void
> insert_special(c)
> 	int		c;
> {
> 	/*
> 	 * Special function key, translate into two chars: K_SPECIAL KS_...
> 	 */
> 	if (c >= 0x100)
> 	{
> 		insertchar(K_SPECIAL, FALSE);
> 		c = K_SECOND(c);
> 	}
> 	insertchar(c, FALSE);
> }
> 
> /*
895c1712
< insertchar(c)
---
> insertchar(c, force_formatting)
896a1714
> 	int			force_formatting;		/* format line regardless of p_fo */
899a1718,1719
> 	int		leader_len;
> 	int		save;
907c1727
< 	 *	if invalid value, us 0.
---
> 	 *	if invalid value, use 0.
921c1741,1742
< 	if (c == NUL || !(isspace(c) || (State == REPLACE && *ml_get_cursor() != NUL)))
---
> 	if (force_formatting ||
> 				!(isspace(c) || (State == REPLACE && *ml_get_cursor() != NUL)))
927c1748,1749
< 			int		foundcol;		/* column for start of word */
---
> 			int		foundcol;		/* column for start of spaces */
> 			int		end_foundcol = 0;/* column for start of word */
928a1751,1763
> 			if (!force_formatting && curbuf->b_p_fo != NULL &&
> 								STRCHR(curbuf->b_p_fo, FO_WRAP_COMS) != NULL)
> 				fo_do_comments = TRUE;
> 
> 			/* Don't break until after the comment leader */
> 			leader_len = get_leader_len(ml_get(curwin->w_cursor.lnum));
> 			if (!force_formatting && leader_len == 0 &&
> 								curbuf->b_p_fo != NULL &&
> 								STRCHR(curbuf->b_p_fo, FO_WRAP) == NULL)
> 			{
> 				textwidth = 0;
> 				break;
> 			}
939a1775,1776
> 						/* remember position of blank just before text */
> 					end_foundcol = curwin->w_cursor.col;
943a1781,1783
> 					/* Don't break until after the comment leader */
> 					if (curwin->w_cursor.col < leader_len)
> 						break;
956,959c1796,1807
< 			curwin->w_cursor.col = foundcol;		/* put cursor after pos. to break line */
< 			startcol -= foundcol;
< 			Opencmd(FORWARD, FALSE, FALSE);
< 			while (isspace(gchar_cursor()) && startcol)		/* delete blanks */
---
> 			/*
> 			 * offset between cursor position and line break is used by
> 			 * replace stack functions
> 			 */
> 			replace_offset = startcol - end_foundcol - 1;
> 
> 			/*
> 			 * adjust startcol for spaces that will be deleted and
> 			 * characters that will remain on top line
> 			 */
> 			curwin->w_cursor.col = foundcol;
> 			while (isspace(gchar_cursor()))
961,962c1809,1810
< 				(void)delchar(FALSE);
< 				--startcol;				/* adjust cursor pos. */
---
> 				++curwin->w_cursor.col;
> 				--startcol;
963a1812,1824
> 			startcol -= foundcol;
> 			if (startcol < 0)
> 				startcol = 0;
> 
> 				/* put cursor after pos. to break line */
> 			curwin->w_cursor.col = foundcol;
> 
> 				/* switch 'ai' on to make spaces to be deleted */
> 			save = curbuf->b_p_ai;
> 			curbuf->b_p_ai = TRUE;
> 			Opencmd(FORWARD, FALSE);
> 			curbuf->b_p_ai = save;
> 			replace_offset = 0;
969a1831
> 		fo_do_comments = FALSE;
980a1843,1844
> 	if (c == NUL)			/* only formatting was wanted */
> 		return;
1047c1911
< 		u_save_cursor();			/* errors are ignored! */
---
> 		(void)u_save_cursor();				/* errors are ignored! */
1071,1072c1935,1936
< 	 * If we just did an auto-indent, truncate the line, and put
< 	 * the cursor back.
---
> 	 * If we just did an auto-indent, remove the white space from the end of
> 	 * the line, and put the cursor back.
1076,1077c1940,1945
< 		ml_replace(curwin->w_cursor.lnum, (char_u *)"", TRUE);
< 		curwin->w_cursor.col = 0;
---
> 		if (gchar_cursor() == NUL && curwin->w_cursor.col > 0)
> 			--curwin->w_cursor.col;
> 		while (iswhite(gchar_cursor()))
> 			delchar(TRUE);
> 		if (gchar_cursor() != NUL)
> 			++curwin->w_cursor.col;		/* put cursor back on the NUL */
1086a1955,1975
>  * Set the last inserted text to a single character.
>  * Used for the replace command.
>  */
> 	void
> set_last_insert(c)
> 	int		c;
> {
> 	free(last_insert);
> 	last_insert = alloc(4);
> 	if (last_insert != NULL)
> 	{
> 		last_insert[0] = Ctrl('V');
> 		last_insert[1] = c;
> 		last_insert[2] = ESC;
> 		last_insert[3] = NUL;
> 			/* Use the CTRL-V only when not entering a digit */
> 		last_insert_skip = isdigit(c) ? 1 : 0;
> 	}
> }
> 
> /*
1088a1978,1979
>  * if flag == MAYBE then move to first non-white if startofline is set,
>  *		otherwise don't move at all.
1094,1095c1985,1987
< 	curwin->w_cursor.col = 0;
< 	if (flag)
---
> 	if (flag == MAYBE && !p_sol)
> 		coladvance(curwin->w_curswant);
> 	else
1097c1989,1992
< 		register char_u *ptr;
---
> 		curwin->w_cursor.col = 0;
> 		if (flag)
> 		{
> 			register char_u *ptr;
1099,1100c1994,1997
< 		for (ptr = ml_get(curwin->w_cursor.lnum); iswhite(*ptr); ++ptr)
< 			++curwin->w_cursor.col;
---
> 			for (ptr = ml_get(curwin->w_cursor.lnum); iswhite(*ptr); ++ptr)
> 				++curwin->w_cursor.col;
> 		}
> 		curwin->w_set_curswant = TRUE;
1102d1998
< 	curwin->w_set_curswant = TRUE;
1145a2042,2044
> 	/* try to advance to the column we want to be at */
> 	coladvance(curwin->w_curswant);
> 
1149,1150d2047
< 	/* try to advance to the column we want to be at */
< 	coladvance(curwin->w_curswant);
1163a2061,2063
> 	/* try to advance to the column we want to be at */
> 	coladvance(curwin->w_curswant);
> 
1167,1168d2066
< 	/* try to advance to the column we want to be at */
< 	coladvance(curwin->w_curswant);
1191c2089
< 			beep();
---
> 			beep_flush();
1237c2135
< 	beginline(TRUE);
---
> 	beginline(MAYBE);
1254c2152
< 		return;
---
> 		ptr = (char_u *)"";
1255a2154,2156
> 	else	/* skip the command */
> 		ptr = last_insert + last_insert_skip;
> 
1258c2159
< 	if (no_esc && (esc_ptr = (char_u *)STRRCHR(last_insert, 27)) != NULL)
---
> 	if (no_esc && (esc_ptr = (char_u *)STRRCHR(ptr, 27)) != NULL)
1261,1263d2161
< 			/* skip the command */
< 	ptr = last_insert + last_insert_skip;
< 
1294a2193,2288
> }
> 
> /*
>  * replace-stack functions
>  *
>  * When replacing characters the replaced character is remembered
>  * for each new character. This is used to re-insert the old text
>  * when backspacing.
>  *
>  * replace_offset is normally 0, in which case replace_push will add a new
>  * character at the end of the stack. If replace_offset is not 0, that many
>  * characters will be left on the stack above the newly inserted character.
>  */
> 
> char_u	*replace_stack = NULL;
> long	replace_stack_nr = 0;		/* next entry in replace stack */
> long	replace_stack_len = 0;		/* max. number of entries */
> 
> 	void
> replace_push(c)
> 	int		c;		/* character that is replaced (NUL is none) */
> {
> 	char_u	*p;
> 
> 	if (replace_stack_nr < replace_offset)		/* nothing to do */
> 		return;
> 	if (replace_stack_len <= replace_stack_nr)
> 	{
> 		replace_stack_len += 50;
> 		p = lalloc(sizeof(char_u) * replace_stack_len, TRUE);
> 		if (p == NULL)		/* out of memory */
> 		{
> 			replace_stack_len -= 50;
> 			return;
> 		}
> 		if (replace_stack != NULL)
> 		{
> 			memmove(p, replace_stack, replace_stack_nr * sizeof(char_u));
> 			free(replace_stack);
> 		}
> 		replace_stack = p;
> 	}
> 	p = replace_stack + replace_stack_nr - replace_offset;
> 	if (replace_offset)
> 		memmove(p + 1, p, replace_offset * sizeof(char_u));
> 	*p = c;
> 	++replace_stack_nr;
> }
> 
> /*
>  * pop one item from the replace stack
>  * return -1 if stack empty
>  * return 0 if no character was replaced
>  * return replaced character otherwise
>  */
> 	int
> replace_pop()
> {
> 	if (replace_stack_nr == 0)
> 		return -1;
> 	return (int)replace_stack[--replace_stack_nr];
> }
> 
> /*
>  * make the replace stack empty
>  * (called when exiting replace mode)
>  */
> 	void
> replace_flush()
> {
> 	free(replace_stack);
> 	replace_stack = NULL;
> 	replace_stack_len = 0;
> 	replace_stack_nr = 0;
> }
> 
> 	static char_u *
> get_id_option()
> {
> 	char_u	*idp;
> 
> 	if (curbuf->b_p_id != NULL)
> 	{
> 		/* move '-' to the end of 'id' to avoid
> 		 * problems with the search pattern */
> 		idp = STRCHR(curbuf->b_p_id, '-');
> 		if (idp != NULL)
> 		{
> 			STRCPY(idp, idp + 1);
> 			STRCAT(idp, "-");
> 		}
> 		idp = curbuf->b_p_id;
> 	}
> 	else
> 		idp = "_";
> 	return idp;
Index: ./src/fileio.c
diff -r ../vim3.0/src/fileio.c ./src/fileio.c
35a36,38
> #ifdef VIMINFO
> static void check_marks_read __ARGS((void));
> #endif
50c53,55
< 	 * don't use msg(), because it sometimes outputs a newline
---
> 	 * For the first message may have to start a new line.
> 	 * For further ones overwrite the previous one, reset msg_scroll before
> 	 * calling filemess().
54c59
< 	msg_ceol();
---
> 	msg_clr_eos();
109a115
> 	int					msg_save;
184,191d189
< #ifdef MSDOS
< 	/*
< 	 * The screen may be messed up by the "insert disk
< 	 * in drive b: and hit return" message
< 	 */
< 		screenclear();
< #endif
< 
203a202
> 				{
204a204,205
> 					return OK;		/* a new file is not an error */
> 				}
221a223,224
> 	msg_save = msg_scroll;
> 	msg_scroll = FALSE;							/* overwrite the file message */
254c257
< 				emsg(e_outofmem);
---
> 				do_outofmem_msg();
341c344
< 	if (error && nlines == 0)		/* not an error, max. number of lines reached */
---
> 	if (error && nlines == 0)	/* not an error, max. number of lines reached */
349c352,353
< 		&& !(!curbuf->b_p_bin && *line_start == Ctrl('Z') && ptr == line_start + 1)
---
> 		&& !(!curbuf->b_p_bin && *line_start == Ctrl('Z') &&
> 											ptr == line_start + 1)
361c365,366
< 		if (ml_append(lnum, line_start, (colnr_t)(ptr - line_start + 1), newfile) == FAIL)
---
> 		if (ml_append(lnum, line_start,
> 						(colnr_t)(ptr - line_start + 1), newfile) == FAIL)
369c374
< 	close(fd);
---
> 	close(fd);						/* errors are ignored */
374a380
> 		msg_scroll = msg_save;
376a383,385
> #ifdef VIMINFO
> 		check_marks_read();
> #endif /* VIMINFO */
380,384c389,391
< #ifdef MSDOS					/* the screen may be messed up by the "insert disk
< 									in drive b: and hit return" message */
< 	screenclear();
< #endif
< 
---
> 		/* need to delete the last line, which comes from the empty buffer */
> 	if (newfile && !(curbuf->b_ml.ml_flags & ML_EMPTY))
> 		ml_delete(curbuf->b_ml.ml_line_count, FALSE);
385a393,394
> 	if (filesize == 0)
> 		linecnt = 0;
391a401,404
> 		msg_scroll = msg_save;
> #ifdef VIMINFO
> 		check_marks_read();
> #endif /* VIMINFO */
400,401c413,414
< 			curbuf->b_p_ro ? "[readonly] " : "",
< 			incomplete ? "[Incomplete last line] " : "",
---
> 			curbuf->b_p_ro ? (p_shm ? "[RO] " : "[readonly] ") : "",
> 			incomplete ? (p_shm ? "[last]" : "[Incomplete last line] ") : "",
411c424,425
< 	msg(IObuff);
---
> 	msg_trunc(IObuff);
> 	msg_scroll = msg_save;
428a443,445
> #ifdef VIMINFO
> 	check_marks_read();
> #endif /* VIMINFO */
431a449,460
> #ifdef VIMINFO
> 	static void
> check_marks_read()
> {
> 	if (!curbuf->b_marks_read && p_viminfo)
> 	{
> 		read_viminfo(NULL, FALSE, TRUE, FALSE);
> 		curbuf->b_marks_read = TRUE;
> 	}
> }
> #endif /* VIMINFO */
> 
466a496
> 	char_u				*backup_ext;
470a501
> 	int					msg_save;
503a535,540
> 		/* make sure we have a valid backup extension to use */
> 	if (p_bex == NULL || *p_bex == NUL)
> 		backup_ext = (char_u *)".bak";
> 	else
> 		backup_ext = p_bex;
> 
519a557,558
> 	msg_save = msg_scroll;
> 	msg_scroll = FALSE;				/* overwrite the file message */
522c561,563
< 	if (buffer == NULL)				/* can't allocate big buffer, use small one */
---
> 	if (buffer == NULL)				/* can't allocate big buffer, use small
> 									 * one (to be able to write when out of
> 									 * memory) */
559,560c600,601
< 	if (!append && perm >= 0 && (p_wb || p_bk || (p_pm != NULL && *p_pm != NUL)) &&
< 					(fd = open((char *)fname, O_RDONLY)) >= 0)
---
> 	if (!append && perm >= 0 && (p_wb || p_bk || (p_pm != NULL &&
> 				*p_pm != NUL)) && (fd = open((char *)fname, O_RDONLY)) >= 0)
581c622
< 			if ((backup = modname(fname, ".bak")) == NULL)
---
> 			if ((backup = modname(fname, backup_ext)) == NULL)
615c656
< 			if ((backup = buf_modname(buf, copybuf, (char_u *)".bak")) == NULL)
---
> 			if ((backup = buf_modname(buf, copybuf, backup_ext)) == NULL)
646c687
< 				goto writeerr;
---
> 				break;
649,650c690,691
< writeerr:
< 		close(bfd);
---
> 		if (close(bfd) < 0 && errmsg == NULL)
> 			errmsg = (char_u *)"Close error for backup file (use ! to override)";
654c695
< 		close(fd);
---
> 		close(fd);				/* ignore errors for closing read file */
690c731,732
< 	if (!append && perm >= 0 && (p_wb || p_bk || (p_pm != NULL && *p_pm != NUL)))
---
> 	if (!append && perm >= 0 && (p_wb || p_bk ||
> 										(p_pm != NULL && *p_pm != NUL)))
695c737
< 		backup = buf_modname(buf, fname, (char_u *)".bak");
---
> 		backup = buf_modname(buf, fname, backup_ext);
704,706c746,749
< 			 * Delete any existing backup and move the current version to the backup.
< 			 * For safety, we don't remove the backup until the write has finished
< 			 * successfully. And if the 'backup' option is set, leave it around.
---
> 			 * Delete any existing backup and move the current version to the
> 			 * backup.  For safety, we don't remove the backup until the write
> 			 * has finished successfully. And if the 'backup' option is set,
> 			 * leave it around.
728,729c771
< 			len = rename((char *)fname, (char *)backup);
< 			if (len != 0)
---
> 			if (rename((char *)fname, (char *)backup) != 0)
753c795,796
< 	if (reset_changed && !newfile && !otherfile(ffname) && !(exiting && backup != NULL))
---
> 	if (reset_changed && !newfile && !otherfile(ffname) &&
> 											!(exiting && backup != NULL))
805,807c848,853
< 			if (stat((char *)fname, &st) < 0)	/* file does not exist */
< 				rename((char *)backup, (char *)fname);	/* put the copy in its place */
< 			if (stat((char *)fname, &st) >= 0)	/* original file does exist */
---
> 			 							/* file does not exist */
> 			if (stat((char *)fname, &st) < 0)
> 										/* put the copy in its place */
> 				rename((char *)backup, (char *)fname);
> 										/* original file does exist */
> 			if (stat((char *)fname, &st) >= 0)
810c856,857
<  			rename((char *)backup, (char *)fname);	/* try to put the original file back */
---
> 										/* try to put the original file back */
>  			rename((char *)backup, (char *)fname);
821a869,870
> 	if (buf->b_ml.ml_flags & ML_EMPTY)
> 		start = end + 1;
902,903c951,964
< 		goto fail;
< 	}
---
> 		/*
> 		 * If we have a backup file, try to put it in place of the new file,
> 		 * because it is probably corrupt. This avoids loosing the original
> 		 * file when trying to make a backup when writing the file a second
> 		 * time.
> 		 * For unix this means copying the backup over the new file.
> 		 * For others this means renaming the backup file.
> 		 * If this is OK, don't give the extra warning message.
> 		 */
> 		if (backup != NULL)
> 		{
> #ifdef UNIX
> 			char_u		copybuf[BUFSIZE + 1];
> 			int			bfd, buflen;
905,908c966,983
< #ifdef MSDOS		/* the screen may be messed up by the "insert disk
< 							in drive b: and hit return" message */
< 	if (!exiting)
< 		screenclear();
---
> 			if ((bfd = open((char *)backup, O_RDONLY)) >= 0)
> 			{
> 				if ((fd = open((char *)fname,
> 								O_WRONLY | O_CREAT | O_TRUNC, 0666)) >= 0)
> 				{
> 					/* copy the file. */
> 					while ((buflen = read(bfd, (char *)copybuf, BUFSIZE)) > 0)
> 						if (write_buf(fd, copybuf, buflen) == FAIL)
> 							break;
> 					if (close(fd) >= 0 && buflen == 0)	/* success */
> 						end = 1;
> 				}
> 				close(bfd);		/* ignore errors for closing read file */
> 			}
> #else
> 			remove((char *)fname);			/* throw away the new file */
> 			if (rename((char *)backup, (char *)fname) == 0)
> 				end = 1;
909a985,987
> 		}
> 		goto fail;
> 	}
927c1005
< 	msg(IObuff);
---
> 	msg_trunc(IObuff);
976c1054
< 		    int fd;
---
> 		    int empty_fd;
978c1056
< 			if (org == NULL || (fd = open(org, O_CREAT, 0666)) < 0)
---
> 			if (org == NULL || (empty_fd = open(org, O_CREAT, 0666)) < 0)
981c1059
< 			  close(fd);
---
> 			  close(empty_fd);
1000,1003d1077
< #ifdef MSDOS				/* the screen may be messed up by the "insert disk
< 								in drive b: and hit return" message */
< 	screenclear();
< #endif
1007c1081,1082
< 	free(buffer);
---
> 	if (buffer != smallbuf)
> 		free(buffer);
1012a1088,1092
> 		if (end == 0)
> 		{
> 			msg_outstr("\nWARNING: Original file may be lost or damaged\n");
> 			msg_outstr("don't quit the editor until the file is sucessfully written!");
> 		}
1013a1094
> 	msg_scroll = msg_save;
1056a1138
> 	sourcing_name = (char_u *)"modelines";
1062a1145
> 	sourcing_name = NULL;
1081c1164,1166
< 		if (isspace(prev) && (STRNCMP(s, "vi:", (size_t)3) == 0 || STRNCMP(s, "ex:", (size_t)3) == 0 || STRNCMP(s, "vim:", (size_t)4) == 0))
---
> 		if (isspace(prev) && (STRNCMP(s, "vi:", (size_t)3) == 0 ||
> 					STRNCMP(s, "ex:", (size_t)3) == 0 ||
> 					STRNCMP(s, "vim:", (size_t)4) == 0))
1139,1143c1224,1227
< 	char_u			*retval;
< 	register char_u   *s;
< 	register char_u   *ptr;
< 	register int	fnamelen, extlen;
< 	char_u			currentdir[512];
---
> 	char_u				*retval;
> 	register char_u 	*s;
> 	register char_u		*ptr;
> 	register int		fnamelen, extlen;
1153c1237,1238
< 		if (vim_dirname(currentdir, 510) == FAIL || (fnamelen = STRLEN(currentdir)) == 0)
---
> 		retval = alloc((unsigned)(MAXPATHL + extlen + 3));
> 		if (retval == NULL)
1155c1240,1243
< 		if (!ispathsep(currentdir[fnamelen - 1]))
---
> 		if (vim_dirname(retval, MAXPATHL) == FAIL ||
> 									(fnamelen = STRLEN(retval)) == 0)
> 			return NULL;
> 		if (!ispathsep(retval[fnamelen - 1]))
1157,1158c1245,1246
< 			currentdir[fnamelen++] = PATHSEP;
< 			currentdir[fnamelen] = NUL;
---
> 			retval[fnamelen++] = PATHSEP;
> 			retval[fnamelen] = NUL;
1161a1250
> 	{
1163,1164c1252,1264
< 	retval = alloc((unsigned) (fnamelen + extlen + 1));
< 	if (retval != NULL)
---
> 		retval = alloc((unsigned)(fnamelen + extlen + 1));
> 		if (retval == NULL)
> 			return NULL;
> 		STRCPY(retval, fname);
> 	}
> 
> 	/*
> 	 * search backwards until we hit a '/', '\' or ':' replacing all '.'
> 	 * by '_' for MSDOS or when dotfname option reset.
> 	 * Then truncate what is after the '/', '\' or ':' to 8 characters for
> 	 * MSDOS and 26 characters for AMIGA and UNIX.
> 	 */
> 	for (ptr = retval + fnamelen; ptr >= retval; ptr--)
1166,1177d1265
< 		if (fname == NULL || *fname == NUL)
< 			STRCPY(retval, currentdir);
< 		else
< 			STRCPY(retval, fname);
< 		/*
< 		 * search backwards until we hit a '/', '\' or ':' replacing all '.' by '_'
< 		 * for MSDOS or when dotfname option reset.
< 		 * Then truncate what is after the '/', '\' or ':' to 8 characters for MSDOS
< 		 * and 26 characters for AMIGA and UNIX.
< 		 */
< 		for (ptr = retval + fnamelen; ptr >= retval; ptr--)
< 		{
1179c1267
< 			if (buf->b_p_sn || buf->b_shortname)
---
> 		if (buf->b_p_sn || buf->b_shortname)
1181,1186c1269,1274
< 				if (*ptr == '.')	/* replace '.' by '_' */
< 					*ptr = '_';
< 			if (ispathsep(*ptr))
< 				break;
< 		}
< 		ptr++;
---
> 			if (*ptr == '.')	/* replace '.' by '_' */
> 				*ptr = '_';
> 		if (ispathsep(*ptr))
> 			break;
> 	}
> 	ptr++;
1188,1190c1276,1278
< 		/* the filename has at most BASENAMELEN characters. */
< 		if (STRLEN(ptr) > (unsigned)BASENAMELEN)
< 			ptr[BASENAMELEN] = '\0';
---
> 	/* the filename has at most BASENAMELEN characters. */
> 	if (STRLEN(ptr) > (unsigned)BASENAMELEN)
> 		ptr[BASENAMELEN] = '\0';
1192,1193c1280,1281
< 		if ((buf->b_p_sn || buf->b_shortname) && STRLEN(ptr) > (unsigned)8)
< 			ptr[8] = '\0';
---
> 	if ((buf->b_p_sn || buf->b_shortname) && STRLEN(ptr) > (unsigned)8)
> 		ptr[8] = '\0';
1195c1283
< 		s = ptr + STRLEN(ptr);
---
> 	s = ptr + STRLEN(ptr);
1197,1201c1285,1289
< 		/*
< 		 * Append the extention.
< 		 * ext must start with '.' and cannot exceed 3 more characters.
< 		 */
< 		STRCPY(s, ext);
---
> 	/*
> 	 * Append the extention.
> 	 * ext must start with '.' and cannot exceed 3 more characters.
> 	 */
> 	STRCPY(s, ext);
1203,1204c1291,1292
< 		if (fname == NULL || *fname == NUL)		/* can't have just the extension */
< 			*s = '_';
---
> 	if (fname == NULL || *fname == NUL)		/* can't have just the ext */
> 		*s = '_';
1206c1294,1298
< 		if (fname != NULL && STRCMP(fname, retval) == 0)
---
> 	if (fname != NULL && STRCMP(fname, retval) == 0)
> 	{
> 		/* after modification still the same name? */
> 		/* we search for a character that can be replaced by '_' */
> 		while (--s >= ptr)
1208,1218c1300
< 			/* after modification still the same name? */
< 			/* we search for a character that can be replaced by '_' */
< 			while (--s >= ptr)
< 			{
< 				if (*s != '_')
< 				{
< 					*s = '_';
< 					break;
< 				}
< 			}
< 			if (s < ptr)
---
> 			if (*s != '_')
1220,1221c1302,1303
< 				/* fname was "________.<ext>" how tricky! */
< 				*ptr = 'v';
---
> 				*s = '_';
> 				break;
1223a1306,1310
> 		if (s < ptr)
> 		{
> 			/* fname was "________.<ext>" how tricky! */
> 			*ptr = 'v';
> 		}
1228d1314
< #ifdef WEBB_COMPLETE
1239,1242c1325,1328
< 	char_u *buf;
< 	int size;
< 	FILE *fp;
< 	int *lnum;
---
> 	char_u		*buf;
> 	int			size;
> 	FILE		*fp;
> 	linenr_t	*lnum;
1258c1344,1400
< 		return FALSE;
---
> 		return !VIM_EOF;
> 	}
> 	if (lnum != NULL)
> 		++*lnum;
> 	return (eof == NULL) ? VIM_EOF : !VIM_EOF;
> }
> 
> /*
>  * rename() only works if both files are on the same file system, this
>  * function will (attempts to?) copy the file across if rename fails -- webb
>  */
> 	int
> vim_rename(from, to)
> 	char_u *from;
> 	char_u *to;
> {
> 	int		fd_in;
> 	int		fd_out;
> 	int		n;
> 	char 	*errmsg = NULL;
> 
> /*
>  * first try a normal rename
>  */
> 	if (rename((char *)from, (char *)to) == 0)
> 		return 0;
> /*
>  * if this fails, try copying the file
>  */
> 	fd_in = open((char *)from, O_RDONLY);
> 	if (fd_in == -1)
> 		return -1;
> 	fd_out = creat((char *)to, 0666);
> 	if (fd_out == -1)
> 	{
> 		close(fd_in);
> 		return -1;
> 	}
> 	while ((n = read(fd_in, IObuff, IOSIZE)) > 0)
> 		if (write(fd_out, IObuff, n) != n)
> 		{
> 			errmsg = "writing to";
> 			break;
> 		}
> 	close(fd_in);
> 	if (close(fd_out) < 0)
> 		errmsg = "closing";
> 	if (n < 0)
> 	{
> 		errmsg = "reading";
> 		to = from;
> 	}
> 	if (errmsg != NULL)
> 	{
> 		sprintf((char *)IObuff, "Error %s '%s'", errmsg, to);
> 		emsg(IObuff);
> 		return -1;
1260,1261c1402,1403
< 	++*lnum;
< 	return (eof == NULL);
---
> 	unlink((char *)from);
> 	return 0;
1263d1404
< #endif /* WEBB_COMPLETE */
Index: ./src/getchar.c
diff -r ../vim3.0/src/getchar.c ./src/getchar.c
46a47
> static struct buffheader old_redobuff = {{NULL, {NUL}}, NULL, 0, 0};
81,100c82,91
<  * the noremaplist. 
<  */
< #define MAXMAPLEN 50				/* maximum length of key sequence to be mapped */
< 									/* must be able to hold an Amiga resize report */
< static char_u	*typestr = NULL;	/* NUL-terminated buffer for typeahead characters */
< static char_u	typebuf[MAXMAPLEN + 3]; /* initial typestr */
< 
< static int		typemaplen = 0;		/* number of mapped characters in typestr */
< static int		no_abbr_cnt = 0;	/* number of chars without abbrev. in typestr */
< 
< /* 
<  * parts int typestr that should not be mapped are remembered with a list
<  * of noremap structs. Noremaplist is the first.
<  */
< struct noremap
< {
< 	int				nr_off;			/* offset to not remappable chars */
< 	int				nr_len;			/* number of not remappable chars */
< 	struct noremap	*nr_next;		/* next entry in the list */
< };
---
>  * noremapstr, which is the same length as typestr and contains TRUE for the
>  * characters that are not to be remapped. 
>  * (typestr has been put in globals.h, because check_termcode() needs it).
>  */
> #define MAXMAPLEN 50		/* maximum length of key sequence to be mapped */
> 							/* must be able to hold an Amiga resize report */
> static char_u	*noremapstr = NULL;
> 							/* NUL-terminated buffer for typeahead characters */
> static char_u	typebuf[MAXMAPLEN + 3];			/* initial typestr */
> static char_u	noremapbuf[MAXMAPLEN + 3];		/* initial noremapstr */
102c93,94
< static struct noremap noremaplist = {0, 0, NULL};
---
> static int		typemaplen = 0;		/* nr of mapped characters in typestr */
> static int		no_abbr_cnt = 0;	/* nr of chars without abbrev. in typestr */
111c103,104
< static int		read_redo __ARGS((int));
---
> static int		read_redo __ARGS((int, int));
> static void		copy_redo __ARGS((int));
142,144c135,139
< 		long_u			count = 0;
< 		char_u			*p = NULL;
< 		struct bufblock	*bp;
---
> 	long_u			count = 0;
> 	char_u			*p = NULL;
> 	char_u			*p2;
> 	char_u			*str;
> 	struct bufblock	*bp;
147,148c142,143
< 		for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
< 				count += STRLEN(bp->b_str);
---
> 	for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
> 		count += STRLEN(bp->b_str);
150,156c145,153
< 		if ((count || dozero) && (p = lalloc(count + 1, TRUE)) != NULL)
< 		{
< 				*p = NUL;
< 				for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
< 						strcat((char *)p, (char *)bp->b_str);
< 		}
< 		return (p);
---
> 	if ((count || dozero) && (p = lalloc(count + 1, TRUE)) != NULL)
> 	{
> 		p2 = p;
> 		for (bp = buffer->bh_first.b_next; bp != NULL; bp = bp->b_next)
> 			for (str = bp->b_str; *str; )
> 				*p2++ = *str++;
> 		*p2 = NUL;
> 	}
> 	return (p);
251c248
< 		char_u	temp[2];
---
> 	char_u	temp[3];
252a250,260
> 	/*
> 	 * translate special key code into two byte sequence
> 	 */
> 	if (c >= 0x100)
> 	{
> 		temp[0] = K_SPECIAL;
> 		temp[1] = K_SECOND(c);
> 		temp[2] = NUL;
> 	}
> 	else
> 	{
255c263,264
< 		add_buff(buf, temp);
---
> 	}
> 	add_buff(buf, temp);
319,320d327
< 	struct noremap *p;
< 
338a346
> 	{
339a348,349
> 		memmove(noremapstr, noremapstr + typemaplen, STRLEN(typestr));
> 	}
342,349d351
< 	noremaplist.nr_len = 0;
< 	noremaplist.nr_off = 0;
< 	while (noremaplist.nr_next)
< 	{
< 		p = noremaplist.nr_next->nr_next;
< 		free(noremaplist.nr_next);
< 		noremaplist.nr_next = p;
< 	}
351a354,357
> /*
>  * The previous contents of the redo buffer is kept in old_redobuffer.
>  * This is used for the CTRL-O <.> command in insert mode.
>  */
356c362,366
< 		free_buff(&redobuff);
---
> 	{
> 		free_buff(&old_redobuff);
> 		old_redobuff = redobuff;
> 		redobuff.bh_first.b_next = NULL;
> 	}
407a418
>  * if old is TRUE, use old_redobuff instead of redobuff
410c421
< read_redo(init)
---
> read_redo(init, old)
411a423
> 	int			old;
419c431,435
< 		if ((bp = redobuff.bh_first.b_next) == NULL)
---
> 		if (old)
> 			bp = old_redobuff.bh_first.b_next;
> 		else
> 			bp = redobuff.bh_first.b_next;
> 		if (bp == NULL)
436a453
>  * if old is TRUE, use old_redobuff instead of redobuff
438,439c455,457
< 	void
< copy_redo()
---
> 	static void
> copy_redo(old)
> 	int		old;
443c461
< 	while ((c = read_redo(FALSE)) != NUL)
---
> 	while ((c = read_redo(FALSE, old)) != NUL)
447,448d464
< extern int redo_Visual_busy;		/* this is in normal.c */
< 
451a468,471
>  * If 'old' is TRUE, the last but one command is repeated
>  * instead of the last command (inserting text). This is used for
>  * CTRL-O <.> in insert mode
>  *
455,456c475,477
< start_redo(count)
< 	long count;
---
> start_redo(count, old)
> 	long	count;
> 	int		old;
460c481
< 	if (read_redo(TRUE) == FAIL)	/* init the pointers; return if nothing to redo */
---
> 	if (read_redo(TRUE, old) == FAIL)	/* init the pointers; return if nothing to redo */
463c484
< 	c = read_redo(FALSE);
---
> 	c = read_redo(FALSE, old);
469c490
< 		c = read_redo(FALSE);
---
> 		c = read_redo(FALSE, old);
475c496
< 		c = read_redo(FALSE);
---
> 		c = read_redo(FALSE, old);
482c503
< 		c = read_redo(FALSE);
---
> 		c = read_redo(FALSE, old);
489c510
< 			c = read_redo(FALSE);
---
> 			c = read_redo(FALSE, old);
495c516
< 	copy_redo();
---
> 	copy_redo(old);
509c530
< 	if (read_redo(TRUE) == FAIL)
---
> 	if (read_redo(TRUE, FALSE) == FAIL)
514c535
< 	while ((c = read_redo(FALSE)) != NUL)
---
> 	while ((c = read_redo(FALSE, FALSE)) != NUL)
526c547
< 	copy_redo();
---
> 	copy_redo(FALSE);
554a576
> 		noremapstr = noremapbuf;
559c581,590
<  * insert a string in front of the typeahead buffer (for '@' command and vgetorpeek)
---
>  * insert a string in position 'offset' in the typeahead buffer (for '@'
>  * command, vgetorpeek() and check_termcode())
>  *
>  * If noremap is 0, new string can be mapped again.
>  * If noremap is -1, new string cannot be mapped again.
>  * If noremap is >0, that many characters of the new string cannot be mapped.
>  *
>  * If nottyped is TRUE, the string does not return KeyTyped (don't use when
>  * offset is non-zero!).
>  *
563c594
< ins_typestr(str, noremap)
---
> ins_typestr(str, noremap, offset, nottyped)
565a597,598
> 	int		offset;
> 	int		nottyped;
567c600
< 	register char_u	*s;
---
> 	register char_u	*s1, *s2;
569a603,604
> 	register int	oldlen;
> 	register int	i;
577c612,613
< 	newlen = STRLEN(typestr) + addlen + MAXMAPLEN + 3;
---
> 	oldlen = STRLEN(typestr);
> 	newlen = oldlen + addlen + MAXMAPLEN + 3;
584,585c620,626
< 	s = alloc(newlen);
< 	if (s == NULL)				/* out of memory */
---
> 	s1 = alloc(newlen);
> 	if (s1 == NULL)				/* out of memory */
> 		return FAIL;
> 	s2 = alloc(newlen);
> 	if (s2 == NULL)				/* out of memory */
> 	{
> 		free(s1);
586a628
> 	}
588,589c630,632
< 	STRCPY(s, str);
< 	STRCAT(s, typestr);
---
> 	STRNCPY(s1, typestr, offset);
> 	STRCPY(s1 + offset, str);
> 	STRCPY(s1 + offset + addlen, typestr + offset);
592,596c635,648
< 	typestr = s;
< 	typemaplen += addlen;		/* the inserted string is not typed */
< 	if (no_abbr_cnt)			/* and not used for abbreviations */
< 		no_abbr_cnt += addlen;
< 	if (noremap)
---
> 	typestr = s1;
> 
> 	/*
> 	 * Adjust the noremapstr:
> 	 * If noremap  < 0: all the new characters are flagged not remappable
> 	 * If noremap == 0: all the new characters are flagged mappable
> 	 * If noremap  > 0: 'noremap' characters are flagged not remappable, the
> 	 *					rest mappable
> 	 */
> 	memmove(s2, noremapstr, offset);
> 	memmove(s2 + addlen + offset, noremapstr + offset, oldlen - offset);
> 	if (noremap < 0)		/* length not specified */
> 		noremap = addlen;
> 	for (i = 0; i < addlen; ++i)
598,600c650
< 		if (noremaplist.nr_off == 0)
< 			noremaplist.nr_len += addlen;
< 		else
---
> 		if (noremap)
602,613c652,653
< 			struct noremap *p;
< 
< 			p = (struct noremap *)alloc((int)sizeof(struct noremap));
< 			if (p != NULL)
< 			{
< 				p->nr_next = noremaplist.nr_next;
< 				p->nr_off = noremaplist.nr_off;
< 				p->nr_len = noremaplist.nr_len;
< 				noremaplist.nr_next = p;
< 				noremaplist.nr_len = addlen;
< 				noremaplist.nr_off = 0;
< 			}
---
> 			--noremap;
> 			s2[i + offset] = TRUE;			/* not mappable character */
614a655,656
> 		else
> 			s2[i + offset] = FALSE;			/* mappable character */
616,617c658,667
< 	else if (noremaplist.nr_len)
< 		noremaplist.nr_off += addlen;
---
> 	if (noremapstr != noremapbuf)
> 		free(noremapstr);
> 	noremapstr = s2;
> 
> 					/* this is only correct for offset == 0! */
> 	if (nottyped)						/* the inserted string is not typed */
> 		typemaplen += addlen;
> 	if (no_abbr_cnt && offset == NULL)	/* and not used for abbreviations */
> 		no_abbr_cnt += addlen;
> 
622c672
<  * remove "len" characters from the front of typestr
---
>  * remove "len" characters from typestr[offset]
625c675
< del_typestr(len)
---
> del_typestr(len, offset)
626a677
> 	int	offset;
628,630d678
< 	struct noremap *p;
< 
< 	STRCPY(typestr, typestr + len);
632,635c680,683
< 	if ((typemaplen -= len) < 0)		/* adjust typemaplen */
< 		typemaplen = 0;
< 	if ((no_abbr_cnt -= len) < 0)		/* adjust no_abbr_cnt */
< 		no_abbr_cnt = 0;
---
> 	STRCPY(typestr + offset, typestr + offset + len);
> 										/* adjust noremapstr */
> 	memmove(noremapstr + offset, noremapstr + offset + len,
> 												STRLEN(typestr + offset));
637c685
< 	while (len)							/* adjust noremaplist */
---
> 	if (typemaplen > offset)			/* adjust typemaplen */
639,661c687,697
< 		if (noremaplist.nr_off >= len)
< 		{
< 			noremaplist.nr_off -= len;
< 			break;
< 		}
< 		len -= noremaplist.nr_off;
< 		noremaplist.nr_off = 0;
< 		if (noremaplist.nr_len > len)
< 		{
< 			noremaplist.nr_len -= len;
< 			break;
< 		}
< 		len -= noremaplist.nr_len;
< 		p = noremaplist.nr_next;
< 		if (p == NULL)
< 		{
< 			noremaplist.nr_len = 0;
< 			break;
< 		}
< 		noremaplist.nr_next = p->nr_next;
< 		noremaplist.nr_len = p->nr_len;
< 		noremaplist.nr_off = p->nr_off;
< 		free(p);
---
> 		if (typemaplen < offset + len)
> 			typemaplen = offset;
> 		else
> 			typemaplen -= len;
> 	}
> 	if (no_abbr_cnt > offset)			/* adjust no_abbr_cnt */
> 	{
> 		if (no_abbr_cnt < offset + len)
> 			no_abbr_cnt = offset;
> 		else
> 			no_abbr_cnt -= len;
665,666d700
< extern int arrow_used;			/* this is in edit.c */
< 
753c787
< 		ml_sync_all(c == 0);
---
> 		ml_sync_all(c == 0, TRUE);
760,768c794,795
< /*
<  * get a character: 1. from the stuffbuffer
<  *					2. from the typeahead buffer
<  *					3. from the user
<  *
<  * KeyTyped is set to TRUE in the case the user typed the key.
<  * vgetc() (advance is TRUE): really get the character.
<  * vpeekc() (advance is FALSE): just look whether there is a character available.
<  */
---
> static int old_char = -1;		/* ungotten character */
> 
772c799,825
< 	return (vgetorpeek(TRUE));
---
> 	int		c;
> 	int		save_State;
> 
> 	c = vgetorpeek(TRUE);
> /*
>  * get extra byte for special keys
>  */
> 	if (c == K_SPECIAL)
> 	{
> 		save_State = State;
> 		State = NOMAPPING;
> 		c = vgetorpeek(TRUE);		/* no mapping for second char */
> 		State = save_State;
> 		if (c == KS_SPECIAL)
> 			c = K_SPECIAL;
> 		else
> 			c += KS_OFF;
> 	}
> #ifdef MSDOS
> /*
>  * If K_NUL was typed, it is replaced by K_NUL, 3 in GetChars().
>  * Delete the 3 here.
>  */
> 	else if (c == K_NUL && vpeekc() == 3)
> 		(void)vgetorpeek(TRUE);
> #endif
> 	return c;
780a834,869
> /*
>  * Call vpeekc() without causing anything to be mapped.
>  * Return TRUE if a character is available, FALSE otherwise.
>  */
> 	int
> char_avail()
> {
> 	int		save_State;
> 	int		retval;
> 
> 	save_State = State;
> 	State = NOMAPPING;
> 	retval = vpeekc();
> 	State = save_State;
> 	return (retval != NUL);
> }
> 
> 	void
> vungetc(c)		/* unget one character (can only be done once!) */
> 	int		c;
> {
> 	old_char = c;
> }
> 
> /*
>  * get a character: 1. from a previously ungotten character
>  *					2. from the stuffbuffer
>  *					3. from the typeahead buffer
>  *					4. from the user
>  *
>  * KeyTyped is set to TRUE in the case the user typed the key.
>  * advance is TRUE (vgetc()): really get the character.
>  * advance is FALSE (vpeekc()): just look whether there is a character
>  * available.
>  */
> 
796a886,896
> /*
>  * get a character: 1. from a previously ungotten character
>  */
> 	if (old_char >= 0)
> 	{
> 		c = old_char;
> 		if (advance)
> 			old_char = -1;
> 		return c;
> 	}
> 
799c899
< 	if (typemaplen == 0)
---
> 	if (advance && typemaplen == 0)
802a903,905
> /*
>  * get a character: 2. from the stuffbuffer
>  */
846c949,952
< 					 * - waiting for "hit return to continue" and CR or SPACE typed
---
> 					 * - waiting for "hit return to continue" and CR or SPACE
> 					 *   typed
> 					 * - waiting for a char with --more--
> 					 * - in Ctrl-X mode, and we get a valid char for that mode
849,850c955,956
< 					if (!timedout && (typemaplen == 0 || (p_remap &&
< 							(noremaplist.nr_len == 0 || noremaplist.nr_off != 0)))
---
> 					if (!timedout && (typemaplen == 0 ||
> 								(p_remap && *noremapstr == FALSE))
852c958,961
< 							&& !(State == HITRETURN && (typestr[0] == CR || typestr[0] == ' ')))
---
> 							&& !(State == HITRETURN && (typestr[0] == CR
> 								|| typestr[0] == ' '))
> 							&& State != ASKMORE
> 							&& !is_ctrl_x_key(typestr[0]))
858,859c967,975
< 							n = mp->m_keylen;
< 							if (noremaplist.nr_off != 0 && n > noremaplist.nr_off)
---
> 								/* if one of the typed keys cannot be
> 								 * remapped, skip it */
> 							n = mp->m_keylen - 1;
> 							if (n >= len)
> 								n = len - 1;
> 							for ( ; n >= 0; --n)
> 								if (noremapstr[n] == TRUE)
> 									break;
> 							if (n >= 0)
860a977
> 							n = mp->m_keylen;
875,879c992,993
< 						if (State != NOMAPPING &&
< 								/* typemaplen == 0 && */ /* allow mapped keys anyway */
< 								(typestr[0] != ESC || p_ek || !(State & INSERT)) &&
< 								!timedout)
< 							n = check_termcode(typestr);
---
> 						if (State != NOMAPPING && !timedout)
> 							n = check_termcode();
891c1005
< 									STRCPY(typestr, s + 1);
---
> 									del_typestr(s + 1 - typestr, 0);
900a1015,1017
> /*
>  * get a character: 3. from the typeahead buffer
>  */
907c1024,1025
< 									if (advance)	/* write char to script file(s) */
---
> 										/* write char to script file(s) */
> 									if (advance)
910,911c1028,1029
< 								if (advance)		/* remove chars from typestr */
< 									del_typestr(1);
---
> 								if (advance)	/* remove chars from typestr */
> 									del_typestr(1, 0);
926c1044
< 						del_typestr(n);	/* remove the mapped keys */
---
> 						del_typestr(n, 0);	/* remove the mapped keys */
944c1062,1071
< 						if (ins_typestr(mp->m_str, mp->m_noremap) == FAIL)
---
> 						/*
> 						 * Insert the 'to' part in the typestr.
> 						 * If 'from' field is the same as the start of the
> 						 * 'to' field, don't remap this part.
> 						 * If m_noremap is set, don't remap the whole 'to'
> 						 * part.
> 						 */
> 						if (ins_typestr(mp->m_str, mp->m_noremap ? -1 :
> 								STRNCMP(mp->m_str, mp->m_keys, n) ? 0 : n,
> 															0, TRUE) == FAIL)
973,976c1100,1117
< 								if (curwin->w_p_nu)
< 									curwin->w_col = 8;
< 								else
< 									curwin->w_col = 0;
---
> 								/*
> 								 * We are expecting to truncate the trailing
> 								 * white-space, so find the last non-white
> 								 * character -- webb
> 								 */
> 								int		col, vcol;
> 								char_u	*ptr;
> 
> 								col = vcol = curwin->w_col = 0;
> 								ptr = ml_get(curwin->w_cursor.lnum);
> 								while (col < curwin->w_cursor.col)
> 								{
> 									if (!iswhite(ptr[col]))
> 										curwin->w_col = vcol;
> 									vcol += chartabsize(ptr[col++], vcol);
> 								}
>   								if (curwin->w_p_nu)
> 									curwin->w_col += 8;
996a1138,1140
> /*
>  * get a character: 4. from the user
>  */
1007a1152,1156
> 				else
> 				{			/* allow mapping for just typed characters */
> 					while (typestr[len] != NUL)
> 						noremapstr[len++] = FALSE;
> 				}
1076a1226,1228
> 	char_u				*keys_buf = NULL;
> 	char_u				*arg_buf = NULL;
> 	int					retval = 0;
1096c1248
< 	skipspace(&p);
---
> 	skipwhite(&p);
1103c1255,1284
< 		return 1;
---
> 	{
> 		retval = 1;
> 		goto theend;
> 	}
> 
> 	/*
> 	 * If mapping has been given as ^V<C_UP> say, then replace the term codes
> 	 * with the appropriate two bytes.
> 	 * The length may be doubled, we need to allocate some memory.
> 	 */
> 	if (haskey)
> 	{
> 		keys_buf = alloc(STRLEN(keys) * 2 + 1);
> 		if (keys_buf != NULL)
> 		{
> 			STRCPY(keys_buf, keys);
> 			keys = keys_buf;
> 			replace_termcodes(keys);
> 		}
> 	}
> 	if (hasarg)
> 	{
> 		arg_buf = alloc(STRLEN(arg) * 2 + 1);
> 		if (arg_buf != NULL)
> 		{
> 			STRCPY(arg_buf, arg);
> 			arg = arg_buf;
> 			replace_termcodes(arg);
> 		}
> 	}
1108,1109c1289
< 	while (*p)
< 	{
---
> 	for (p = arg; *p; ++p)
1112,1113d1291
< 		++p;
< 	}
1120c1298
< 		if (*keys == '#' && isdigit(*(keys + 1)))	/* function key */
---
> 		if (keys[0] == '#' && isdigit(keys[1]))		/* function key */
1122,1123c1300,1302
< 			if (*++keys == '0')
< 				*keys = K_F10;
---
> 			keys[0] = K_SPECIAL;
> 			if (keys[1] == '0')
> 				keys[1] = KS_F10;
1125c1304
< 				*keys += K_F1 - '1';
---
> 				keys[1] = keys[1] - '1' + KS_F1;
1129c1308,1311
< 			return 1;
---
> 		{
> 			retval = 1;
> 			goto theend;
> 		}
1138c1320,1323
< 				return 1;
---
> 				{
> 					retval = 1;
> 					goto theend;
> 				}
1141c1326,1329
< 					return 1;
---
> 				{
> 					retval = 1;
> 					goto theend;
> 				}
1205c1393,1394
< 						return 3;
---
> 						retval = 3;
> 						goto theend;
1214c1403,1406
< 								return 4;			/* no mem */
---
> 							{
> 								retval = 4;			/* no mem */
> 								goto theend;
> 							}
1237,1240c1429,1431
< 		if (did_it)
< 			return 0;						/* removed OK */
< 		else
< 			return 2;						/* no match */
---
> 		if (!did_it)
> 			retval = 2;						/* no match */
> 		goto theend;
1245,1251c1436,1443
< 		if (did_it)
< 			msg_end();
< 		else if (abbrev)
< 			MSG("No abbreviation found");
< 		else
< 			MSG("No mapping found");
< 		return 0;							/* listing finished */
---
> 		if (!did_it)
> 		{
> 			if (abbrev)
> 				MSG("No abbreviation found");
> 			else
> 				MSG("No mapping found");
> 		}
> 		goto theend;						/* listing finished */
1255c1447
< 		return 0;
---
> 		goto theend;
1262c1454,1457
< 		return 4;			/* no mem */
---
> 	{
> 		retval = 4;			/* no mem */
> 		goto theend;
> 	}
1270c1465,1466
< 		return 4;		/* no mem */
---
> 		retval = 4;		/* no mem */
> 		goto theend;
1280c1476,1479
< 	return 0;				/* added OK */
---
> theend:
> 	free(keys_buf);
> 	free(arg_buf);
> 	return retval;
1289c1488,1489
< 	msg_pos(-1, 0);						/* always start in column 0 */
---
> 	if (msg_didout)
> 		msg_outchar('\n');
1296c1496
< 	len = msg_outtrans(mp->m_keys, -1);	/* get length of what we have written */
---
> 	len = msg_outtrans_meta(mp->m_keys, TRUE);	/* get length of what we write */
1306,1307c1506,1509
< 	msg_outtrans(mp->m_str, -1);
< 	msg_outchar('\n');
---
> 	/* Use FALSE below if we only want things like <C_UP> to show up as such on
> 	 * the rhs, and not M-x etc, TRUE gets both -- webb
> 	 */
> 	msg_outtrans_meta(mp->m_str, TRUE);
1318c1520,1521
<  * characters or all non-id characters. This allows for abbr. "#i" to "#include".
---
>  * characters or all non-id characters. This allows for abbr. "#i" to
>  * "#include".
1362c1565
< 		if (mp)								/* found a match */
---
> 		if (mp)
1363a1567,1575
> 			/*
> 			 * Found a match:
> 			 * Insert the rest of the abbreviation in typestr.
> 			 * This goes from end to start.
> 			 *
> 			 * Characters 0x000 - 0x100: normal chars, may need CTRL-V.
> 			 * Characters 0x100 - 0x200: key codes, need K_SPECIAL.
> 			 * Characters   above 0x200: don't use CTRL-V
> 			 */
1365,1366c1577,1586
< 			if (c < 0x100 && (c < ' ' || c > '~'))
< 				tb[j++] = Ctrl('V');		/* special char needs CTRL-V */
---
> 			if (c < 0x100)
> 			{
> 				if (c < ' ' || c > '~')
> 					tb[j++] = Ctrl('V');	/* special char needs CTRL-V */
> 			}
> 			else if (c < 0x200)				/* special key code, split up */
> 			{
> 				tb[j++] = K_SPECIAL;
> 				c = K_SECOND(c);
> 			}
1369,1371c1589,1594
< 			(void)ins_typestr(tb, TRUE);					/* insert the last typed char */
< 			(void)ins_typestr(mp->m_str, mp->m_noremap);	/* insert the to string */
< 			no_abbr_cnt += STRLEN(mp->m_str) + j;	/* no abbrev. for these chars */
---
> 												/* insert the last typed char */
> 			(void)ins_typestr(tb, TRUE, 0, TRUE);
> 												/* insert the to string */
> 			(void)ins_typestr(mp->m_str, mp->m_noremap, 0, TRUE);
> 												/* no abbrev. for these chars */
> 			no_abbr_cnt += STRLEN(mp->m_str) + j;
1373c1596,1597
< 				(void)ins_typestr((char_u *)"\b", TRUE);	/* delete the from string */
---
> 												/* delete the from string */
> 				(void)ins_typestr((char_u *)"\b", TRUE, 0, TRUE);
1452a1677,1678
> 	int		c;
> 
1454a1681,1700
> 		c = *str;
> 		/*
> 		 * Special key codes have to be translated to be able to make sense
> 		 * when they are read back.
> 		 */
> 		if (c == K_SPECIAL)
> 		{
> 			c = *++str;
> 			if (!set && c >= KS_UARROW && c <= KS_MAXKEY)
> 			{
> 					/* sorry, no check for write error on this one */
> 				fprintf(fd, "<%s>", (char *)get_key_names()[c - KS_UARROW]);
> 				continue;
> 			}
> 			else if (c == KS_SPECIAL)
> 				c = K_SPECIAL;
> 			else if (c == KS_ZERO)
> 				c = NUL;
> 			/* else: illegal key code !? */
> 		}
1461c1707
< 		if (*str < ' ' || *str > '~' || (*str == ' ' && !set))
---
> 		if (c < ' ' || c > '~' || (c == ' ' && !set))
1466c1712
< 		else if ((set && *str == ' ') || *str == '|')
---
> 		else if ((set && c == ' ') || c == '|')
1471c1717
< 		if (putc(*str, fd) < 0)
---
> 		if (putc(c, fd) < 0)
Index: ./src/globals.h
diff -r ../vim3.0/src/globals.h ./src/globals.h
45d44
< #ifdef WEBB_COMPLETE
52d50
< #endif /* WEBB_COMPLETE */
61a60,67
> EXTERN int		need_sleep INIT(= FALSE);	/* call sleep() before redraw */
> EXTERN int		need_fileinfo INIT(= FALSE);/* do fileinfo() after redraw */
> EXTERN int		msg_scroll INIT(= FALSE);	/* msg_start() will scroll */
> EXTERN int		msg_didout INIT(= FALSE);	/* msg_outstr() was used in line */
> EXTERN int		msg_didany INIT(= FALSE);	/* msg_outstr() was used at all */
> EXTERN int		emsg_off INIT(= FALSE);		/* don't display errors for now */
> EXTERN char_u	*sourcing_name INIT( = NULL);/* name of error message source */
> 
65a72,80
> EXTERN int		highlight_match INIT(= FALSE);	/* show search match pos */
> EXTERN int		search_match_len;			/* length of matched string */
> 
> /*
>  * Mouse coordinates, set by check_termcode()
>  */
> EXTERN int		mouse_code;
> EXTERN int		mouse_row;
> EXTERN int		mouse_col;
89a105
> EXTERN int		arg_had_last INIT(= FALSE);	/* accessed last file in arglist */
101a118,119
> EXTERN int		not_full_screen INIT(= FALSE);
> 								/* set to TRUE when not doing full-screen */
108,111c126,135
< EXTERN FPOS 	VIsual; 		/* start position of Visual
< 								 * (VIsual.lnum == 0 when not active) */
< EXTERN int		Visual_block INIT(= FALSE);
< 								/* Visual is blockwise */
---
> EXTERN FPOS 	VIsual; 		/* start position of Visual (if VIsual.lnum ==
> 								 * 0, visual is not active) */
> 
> EXTERN int		Visual_mode INIT(= 'v');
> 								/* type of Visual mode */
> EXTERN int		block_mode INIT(= FALSE);
> 								/* current operator in Visual block mode */
> EXTERN int redo_Visual_busy INIT(= FALSE);
> 								/* TRUE when redo-ing a visual */
> 
138,143d161
< /*
<  * This flag is set after doing a reverse replace in column 0.
<  * An extra space has been inserted in column 0.
<  */
< EXTERN int				extraspace INIT(= FALSE);
< 
147c165,174
< EXTERN int		Recording INIT(= FALSE);/* TRUE when recording into a register */
---
> EXTERN int		restart_edit INIT(= 0);	/* call edit when next command finished
> 										 */
> EXTERN int		arrow_used;				/* Normally FALSE, set to TRUE after
> 										 * hitting cursor key in insert mode.
> 										 * Used by vgetorpeek() to decide when
> 										 * to call u_sync() */
> EXTERN char_u	*edit_submode INIT(= NULL);		/* Name of edit submode */
> 
> EXTERN int		Recording INIT(= FALSE);/* TRUE when recording into a register
> 										 */
151a179,181
> EXTERN int		fo_do_comments INIT(= FALSE);
> 										/* TRUE when comments are to be
> 										 * formatted */
155c185,187
< EXTERN char_u	*NameBuff;				/* file names are expanded in this buffer */
---
> EXTERN char_u	*NameBuff;				/* file names are expanded in this
> 										 * buffer */
> EXTERN char_u	msg_buf[MSG_BUF_LEN];	/* small buffer for messages */
162a195
> EXTERN char_u	*typestr INIT(= NULL);		/* buffer for typed characters */
180c213,217
< EXTERN int		did_outofmem_msg INIT(= FALSE);	/* set after out of memory msg */
---
> EXTERN int		did_outofmem_msg INIT(= FALSE);
> 											/* set after out of memory msg */
> EXTERN int		did_swapwrite_msg INIT(= FALSE);
> 											/* set after swap write error msg */
> EXTERN int		undo_off INIT(= FALSE);		/* undo switched off for now */
184d220
< EXTERN int		did_msg;					/* set in msg_start, used for :global */
186a223
> EXTERN int		dont_wait_return INIT(= 0);	/* no need to wait for return */
191a229,232
> EXTERN int		need_autocmd INIT(= FALSE);	/* Need to apply autocmd's? */
> EXTERN int		replace_offset INIT(= 0);	/* offset for replace_push() */
> EXTERN int		second_indent INIT(= -1);   /* Indent of 2nd line for Q */
> EXTERN char_u	*second_leader INIT(= NULL); /* Comment leader from 2nd line */
208a250
> EXTERN char_u e_bot_search[] INIT(="search hit BOTTOM without match");
221a264
> EXTERN char_u e_nobang[] 	INIT(="No ! allowed");
227c270
< EXTERN char_u e_nopresub[]	INIT(="No previous substitute");
---
> EXTERN char_u e_nopresub[]	INIT(="No previous substitute regular expression");
229c272
< EXTERN char_u e_noprevre[]	INIT(="No previous regexp");
---
> EXTERN char_u e_noprevre[]	INIT(="No previous regular expression");
243c286
< EXTERN char_u e_quickfix[]	INIT(="No errorfile; use :cf");
---
> EXTERN char_u e_quickfix[]	INIT(="Errorfile not found");
254a298
> EXTERN char_u e_top_search[] INIT(="search hit TOP without match");
259a304
> 
Index: ./src/help.c
diff -r ../vim3.0/src/help.c ./src/help.c
71,75c71,72
< 		if (c == ' ' ||
< #ifdef MSDOS
< 				(c == K_NUL && vpeekc() == 'Q') ||	/* page down */
< #endif
< 				c == Ctrl('F'))						/* one screen forwards */
---
> 											/* one screen forwards */
> 		if (c == ' ' || c == K_PAGEDOWN || c == Ctrl('F'))
82,86c79,80
< 		else if (c == 'b' ||
< #ifdef MSDOS
< 				(c == K_NUL && vpeekc() == 'I') ||	/* page up */
< #endif
< 				c == Ctrl('B'))					/* go one screen backwards */
---
> 											/* go one screen backwards */
> 		else if (c == 'b' || c == K_PAGEUP || c == Ctrl('B'))
91c85
< 		else if (isalpha(c))				/* go to specified screen */
---
> 		else if (c < 0x100 && isalpha(c))	/* go to specified screen */
97,100d90
< #ifdef MSDOS
< 		if (c == K_NUL)
< 			c = vgetc();
< #endif
Index: ./src/keymap.h
diff -r ../vim3.0/src/keymap.h ./src/keymap.h
8a9,10
> #define K_CCIRCM		0x1e	/* control circumflex */
> 
10c12
<  * Keycode definitions for special keys
---
>  * Keycode definitions for special keys.
12,13c14
<  * On systems that have any of these keys, the routine 'inchar' in the
<  * machine-dependent code should return one of the codes here.
---
>  * Any special key code sequences are replaced by these codes.
15a17,18
> #define KS_OFF			(0x100)
> 
17,19c20,21
<  * On MSDOS we use other codes, because the codes 0x80 - 0xb0 are used
<  * for special characters. If this is changed also change the numbers in
<  * term.h and main.c.
---
>  * For MSDOS some keys produce codes larger than 0xff. They are split into two
>  * chars, the first one is K_NUL (same value used in term.h).
21,25c23
< #ifdef MSDOS
< # define K_OFF 0x30
< #else
< # define K_OFF 0x00
< #endif
---
> #define K_NUL			(0xce)		/* for MSDOS: special key follows */
27c25,42
< #define K_CCIRCM		0x1e	/* control circumflex */
---
> #define K_SPECIAL		(0x80)
> 
> /*
>  * NULs cannot be in the input string, therefore it is replaced by
>  *		K_SPECIAL	KS_ZERO
>  */
> #define KS_ZERO			254
> 
> /*
>  * K_SPECIAL cannot be in the input string, therefore it is replaced by
>  *		K_SPECIAL	KS_SPECIAL
>  */
> #define KS_SPECIAL		255
> 
> /*
>  * get second byte when translating special key code into two bytes
>  */
> #define K_SECOND(c)		((c) == K_SPECIAL ? KS_SPECIAL : (c) - KS_OFF)
30c45
<  * careful: the next entries must be in the same order as the termcap strings
---
>  * careful: The next entries must be in the same order as the termcap strings
31a47,49
>  * KS_UARROW must be the first and KS_MAXKEY must be the last.
>  * When adding new ones, do this at the end, so that the entry numbers don't
>  * change (otherwise script files using them not work anymore).
33,65c51,128
< #define K_UARROW		(K_OFF + 0x80)
< #define K_DARROW		(K_OFF + 0x81)
< #define K_LARROW		(K_OFF + 0x82)
< #define K_RARROW		(K_OFF + 0x83)
< #define K_SUARROW		(K_OFF + 0x84)
< #define K_SDARROW		(K_OFF + 0x85)
< #define K_SLARROW		(K_OFF + 0x86)
< #define K_SRARROW		(K_OFF + 0x87)
< 
< #define K_F1			(K_OFF + 0x88)	/* function keys */
< #define K_F2			(K_OFF + 0x89)
< #define K_F3			(K_OFF + 0x8a)
< #define K_F4			(K_OFF + 0x8b)
< #define K_F5			(K_OFF + 0x8c)
< #define K_F6			(K_OFF + 0x8d)
< #define K_F7			(K_OFF + 0x8e)
< #define K_F8			(K_OFF + 0x8f)
< #define K_F9			(K_OFF + 0x90)
< #define K_F10			(K_OFF + 0x91)
< 
< #define K_SF1			(K_OFF + 0x92)	/* shifted function keys */
< #define K_SF2			(K_OFF + 0x93)
< #define K_SF3			(K_OFF + 0x94)
< #define K_SF4			(K_OFF + 0x95)
< #define K_SF5			(K_OFF + 0x96)
< #define K_SF6			(K_OFF + 0x97)
< #define K_SF7			(K_OFF + 0x98)
< #define K_SF8			(K_OFF + 0x99)
< #define K_SF9			(K_OFF + 0x9a)
< #define K_SF10			(K_OFF + 0x9b)
< 
< #define K_HELP			(K_OFF + 0x9c)
< #define K_UNDO			(K_OFF + 0x9d)
---
> enum SpecialKeys
> {
> 	KS_NAME = 0,		/* name of this terminal entry */
> 
> 	KS_UARROW,
> 	KS_DARROW,
> 	KS_LARROW,
> 	KS_RARROW,
> 	KS_SUARROW,
> 	KS_SDARROW,
> 	KS_SLARROW,
> 	KS_SRARROW,
> 	
> 	KS_F1,				/* function keys */
> 	KS_F2,
> 	KS_F3,
> 	KS_F4,
> 	KS_F5,
> 	KS_F6,
> 	KS_F7,
> 	KS_F8,
> 	KS_F9,
> 	KS_F10,
> 	
> 	KS_SF1,				/* shifted function keys */
> 	KS_SF2,
> 	KS_SF3,
> 	KS_SF4,
> 	KS_SF5,
> 	KS_SF6,
> 	KS_SF7,
> 	KS_SF8,
> 	KS_SF9,
> 	KS_SF10,
> 	
> 	KS_HELP,
> 	KS_UNDO,
> 	
> 	KS_INS,
> 	KS_DEL,
> 	KS_HOME,
> 	KS_END,
> 	KS_PAGEUP,
> 	KS_PAGEDOWN,
> 	
> 	KS_MOUSE,
> 	
> 	KS_MAXKEY = KS_MOUSE,
> 	
> 	KS_EL,		/* clear to end of line */
> 	KS_IL,		/* add new blank line */
> 	KS_CIL,		/* add number of blank lines */
> 	KS_DL,		/* delete line */
> 	KS_CDL,		/* delete number of lines */
> 	KS_CS,		/* scroll region */
> 	KS_ED,		/* clear screen */
> 	KS_CI,		/* cursor invisible */
> 	KS_CV,		/* cursor visible */
> 	KS_CVV,		/* cursor very visible */
> 	KS_TP,		/* normal mode */
> 	KS_TI,		/* reverse mode */
> 	KS_TB,		/* bold mode */
> 	KS_SE,		/* normal mode */
> 	KS_SO,		/* standout mode */
> 	KS_UE,		/* exit underscore mode */
> 	KS_US,		/* underscore mode */
> 	KS_MS,		/* save to move cursor in reverse mode */
> 	KS_CM,		/* cursor motion */
> 	KS_SR,		/* scroll reverse (backward) */
> 	KS_CRI,		/* cursor number of chars right */
> 	KS_VB,		/* visual bell */
> 	KS_KS,		/* put terminal in "keypad transmit" mode */
> 	KS_KE,		/* out of "keypad transmit" mode */
> 	KS_TS,		/* put terminal in termcap mode */
> 	KS_TE,		/* out of termcap mode */
> 	
> 	KS_CSC		/* out of termcap mode */
> };
68,69c131
<  * NULs cannot be in the input string, therefore CTRL-@ is replaced by K_ZERO.
<  * K_NUL is used for MSDOS extended keys (same value used in term.h).
---
>  * the two byte codes are replaced with the following int when using vgetc()
71,72c133,178
< #define K_NUL			(K_OFF + 0x9e)	/* for MSDOS: special key follows */
< #define K_ZERO			(K_OFF + 0x9f)	/* replaces ^@ */
---
> #define K_ZERO			(KS_OFF + KS_ZERO)
> 
> #define K_UARROW		(KS_OFF + KS_UARROW)
> #define K_DARROW		(KS_OFF + KS_DARROW)
> #define K_LARROW		(KS_OFF + KS_LARROW)
> #define K_RARROW		(KS_OFF + KS_RARROW)
> #define K_SUARROW		(KS_OFF + KS_SUARROW)
> #define K_SDARROW		(KS_OFF + KS_SDARROW)
> #define K_SLARROW		(KS_OFF + KS_SLARROW)
> #define K_SRARROW		(KS_OFF + KS_SRARROW)
> 
> #define K_F1			(KS_OFF + KS_F1)	/* function keys */
> #define K_F2			(KS_OFF + KS_F2)
> #define K_F3			(KS_OFF + KS_F3)
> #define K_F4			(KS_OFF + KS_F4)
> #define K_F5			(KS_OFF + KS_F5)
> #define K_F6			(KS_OFF + KS_F6)
> #define K_F7			(KS_OFF + KS_F7)
> #define K_F8			(KS_OFF + KS_F8)
> #define K_F9			(KS_OFF + KS_F9)
> #define K_F10			(KS_OFF + KS_F10)
> 
> #define K_SF1			(KS_OFF + KS_SF1)	/* shifted function keys */
> #define K_SF2			(KS_OFF + KS_SF2)
> #define K_SF3			(KS_OFF + KS_SF3)
> #define K_SF4			(KS_OFF + KS_SF4)
> #define K_SF5			(KS_OFF + KS_SF5)
> #define K_SF6			(KS_OFF + KS_SF6)
> #define K_SF7			(KS_OFF + KS_SF7)
> #define K_SF8			(KS_OFF + KS_SF8)
> #define K_SF9			(KS_OFF + KS_SF9)
> #define K_SF10			(KS_OFF + KS_SF10)
> 
> #define K_HELP			(KS_OFF + KS_HELP)
> #define K_UNDO			(KS_OFF + KS_UNDO)
> 
> #define K_INS			(KS_OFF + KS_INS)
> #define K_DEL			(KS_OFF + KS_DEL)
> #define K_HOME			(KS_OFF + KS_HOME)
> #define K_END			(KS_OFF + KS_END)
> #define K_PAGEUP		(KS_OFF + KS_PAGEUP)
> #define K_PAGEDOWN		(KS_OFF + KS_PAGEDOWN)
> 
> #define K_MOUSE			(KS_OFF + KS_MOUSE)
> 
> #define K_MAXKEY		K_MOUSE			/* used for the last key code */
Index: ./src/linefunc.c
diff -r ../vim3.0/src/linefunc.c ./src/linefunc.c
28c28
< 	int 				index;
---
> 	int 				idx;
35c35
< 	index = -1;
---
> 	idx = -1;
39c39
< 		++index;
---
> 		++idx;
48,49c48,49
< 		++index;
< 	if (index < 0)
---
> 		++idx;
> 	if (idx < 0)
52c52
< 		curwin->w_cursor.col = index;
---
> 		curwin->w_cursor.col = idx;
Index: ./src/macros.h
diff -r ../vim3.0/src/macros.h ./src/macros.h
35c35
<  * bufempty() - return TRUE if the file buffer is empty
---
>  * bufempty() - return TRUE if the current buffer is empty
37c37
< #define bufempty() (curbuf->b_ml.ml_flags & ML_EMPTY)
---
> #define bufempty() (curbuf->b_ml.ml_line_count == 1 && *ml_get((linenr_t)1) == NUL)
Index: ./src/main.c
diff -r ../vim3.0/src/main.c ./src/main.c
47c47
< 	fprintf(stderr, "\t\t-r\t\trecovery mode\n");
---
> 	fprintf(stderr, "\t\t-r\t\trecovery mode (needs a file name)\n");
215c215,216
< 	if ((IObuff = alloc(IOSIZE)) == NULL || (NameBuff = alloc(MAXPATHL)) == NULL)
---
> 	if ((IObuff = alloc(IOSIZE)) == NULL ||
> 							(NameBuff = alloc(MAXPATHL)) == NULL)
301a303,308
> 	/*
> 	 * When listing swap file names, don't do cursor positioning et. al.
> 	 */
> 	if (recoverymode && fname == NULL)
> 		not_full_screen = TRUE;
> 
308a316,320
> 	if (!not_full_screen)
> 		msg_start();		/* in case a mapping or error message is printed */
> 	msg_scroll = TRUE;
> 	no_wait_return = TRUE;
> 
311,313d322
< 	domap(0, "\316R i", NORMAL);			/* INSERT is 'i' */
< 	domap(0, "\316S \177", NORMAL);			/* DELETE is 0x7f */
< 	domap(0, "\316G 0", NORMAL);			/* HOME is '0' */
315d323
< 	domap(0, "\316O $", NORMAL);			/* END is '$' */
317d324
< 	domap(0, "\316I \002", NORMAL);			/* PageUp is '^B' */
319d325
< 	domap(0, "\316Q \006", NORMAL);			/* PageDown is '^F' */
323,327d328
< 	domap(0, "\316R \033", INSERT);			/* INSERT is ESC */
< 			/* note: extra space needed to avoid the same memory used for this
< 			   and the one above, domap() will add a NUL to it */
< 	domap(0, "\316S  \177", INSERT+CMDLINE);	/* DELETE is 0x7f */
< 	domap(0, "\316G \017""0", INSERT);		/* HOME is '^O0' */
329d329
< 	domap(0, "\316O \017$", INSERT);		/* END is '^O$' */
331d330
< 	domap(0, "\316I \017\002", INSERT);		/* PageUp is '^O^B' */
333d331
< 	domap(0, "\316Q \017\006", INSERT);		/* PageDown is '^O^F' */
337,339d334
< 	msg_start();		/* in case a mapping is printed */
< 	no_wait_return = TRUE;
< 
344c339
< 	(void)dosource(DEFVIMRC_FILE);
---
> 	(void)dosource((char_u *)DEFVIMRC_FILE);
355,356c350,355
< 	if ((initstr = vimgetenv((char_u *)"VIMINIT")) != NULL)
< 		docmdline(initstr);
---
> 	if ((initstr = vimgetenv((char_u *)"VIMINIT")) != NULL && *initstr != NUL)
> 	{
> 		sourcing_name = (char_u *)"VIMINIT";
> 		docmdline(initstr, TRUE, TRUE);
> 		sourcing_name = NULL;
> 	}
360c359,363
< 			docmdline(initstr);
---
> 		{
> 			sourcing_name = (char_u *)"EXINIT";
> 			docmdline(initstr, TRUE, TRUE);
> 			sourcing_name = NULL;
> 		}
409a413,431
> 	/*
> 	 * Recovery mode without a file name: List swap files.
> 	 * This uses the 'dir' option, therefore it must be after the
> 	 * initializations.
> 	 */
> 	if (recoverymode && fname == NULL)
> 	{
> 		recover_list();
> 		mch_windexit(0);
> 	}
> 
> #ifdef VIMINFO
> /*
>  * Read in registers, history etc, but not marks, from the viminfo file
>  */
> 	if (p_viminfo)
> 		read_viminfo(NULL, TRUE, FALSE, FALSE);
> #endif /* VIMINFO */
> 
419,424c441
< 
< 	no_wait_return = FALSE;
< 		/* done something that is not allowed or error message */
< 	if (secure == 2 || need_wait_return)
< 		wait_return(TRUE);		/* must be called after settmode(1) */
< 	secure = 0;
---
> 	scroll_start();
437,438c454
< 	(void)setfname(fname, NULL, TRUE);
< 	maketitle();
---
> 	(void)setfname(fname, NULL, TRUE);	/* includes maketitle() */
453,457c469,476
< 	if (T_CVV != NULL && *T_CVV)
< 	{
< 		outstr(T_CVV);
< 		outstr(T_CV);
< 	}
---
> 
> 	no_wait_return = FALSE;
> 	msg_scroll = FALSE;
> 		/* done something that is not allowed or error message */
> 	if (secure == 2 || need_wait_return || msg_didany)
> 		wait_return(TRUE);				/* must be called after settmode(1) */
> 	secure = 0;
> 
459a479,480
> 	no_wait_return = TRUE;
> 
461a483
> 		msg_scroll = TRUE;				/* scroll message up */
464c486,487
< 		ml_recover();
---
> 		ml_recover();					/* recover the file */
> 		msg_scroll = FALSE;
477d499
< 	 * This is all done by putting commands in the stuff buffer.
485c507
< 		(void)doecmd(i < arg_count ? arg_files[i] : NULL,
---
> 		(void)doecmd(0, i < arg_count ? arg_files[i] : NULL,
487a510,511
> 		if (i == arg_count - 1)
> 			arg_had_last = TRUE;
499c523,527
< 		docmdline(command);
---
> 	{
> 		sourcing_name = (char_u *)"command line";
> 		docmdline(command, TRUE, TRUE);
> 		sourcing_name = NULL;
> 	}
512c540,541
< 	updateScreen(NOT_VALID);
---
> 	redraw_later(NOT_VALID);
> 	no_wait_return = FALSE;
516a546
> 
521a552,556
> 										/* if wait_return still needed ... */
> 		if (stuff_empty() && (need_wait_return ||
> 								(msg_scrolled && !dont_wait_return)))
> 			wait_return(FALSE);			/* ... call it now */
> 		dont_wait_return = FALSE;
528c563,564
< 		if (skip_redraw)				/* skip redraw (for ":" in wait_return()) */
---
> 		if (skip_redraw)				/* skip redraw (for ":" in
> 											wait_return()) */
534,535c570,577
< 			if (VIsual.lnum)
< 				updateScreen(INVERTED);	/* update inverted part */
---
> 			if (need_sleep)				/* sleep before redrawing */
> 			{
> 				sleep(1);
> 				need_sleep = FALSE;
> 			}
> 			msg_scroll = FALSE;
> 			if (VIsual.lnum != 0)
> 				update_curbuf(INVERTED);/* update inverted part */
539a582,586
> 			if (need_fileinfo)			/* used after jumping to a tag */
> 			{
> 				fileinfo(did_cd);
> 				need_fileinfo = FALSE;
> 			}
540a588
> 			msg_didany = FALSE;			/* reset lines_left in msg_start() */
556a605,609
> #ifdef VIMINFO
> 	/* Write out the registers, history, marks etc, to the viminfo file */
> 	if (p_viminfo)
> 		write_viminfo(NULL, FALSE);
> #endif /* VIMINFO */
Index: ./src/makefile.bcc
diff -r ../vim3.0/src/makefile.bcc ./src/makefile.bcc
75c75
< #  add /v to TLINK for degubbing
---
> #  add /v to TLINK for debugging
220c220
< -DPC;MSDOS;SPAWNO;DIGRAPHS;WEBB_COMPLETE;WEBB_KEYWORD_COMPL
---
> -DPC;MSDOS;SPAWNO;DIGRAPHS
243,244d242
< ### -DWEBB_COMPLETE	include Webb's code for command line completion
< ### -DWEBB_KEYWORD_COMPL include Webb's code for keyword completion
Index: ./src/makefile.dice
diff -r ../vim3.0/src/makefile.dice ./src/makefile.dice
9a10
> ### -DNOSTRTOL		strtol() function not available
20,21d20
< ### -DWEBB_COMPLETE	include Webb's code for command line completion
< ### -DWEBB_KEYWORD_COMPL include Webb's code for keyword completion
23,24c22,23
< DEFINES = -DTERMCAP -DDIGRAPHS -DSOME_BUILTIN_TCAPS \
< 		-DWEBB_COMPLETE -DWEBB_KEYWORD_COMPL
---
> ### -DVIMINFO		include reading/writing viminfo file
> DEFINES = -DTERMCAP -DDIGRAPHS -DSOME_BUILTIN_TCAPS
43a43,49
> SRC =	alloc.c amiga.c buffer.c charset.c cmdcmds.c cmdline.c \
> 	csearch.c digraph.c edit.c fileio.c getchar.c help.c \
> 	linefunc.c main.c mark.c memfile.c memline.c message.c misccmds.c \
> 	normal.c ops.c param.c quickfix.c regexp.c \
> 	regsub.c screen.c search.c \
> 	tag.c term.c undo.c window.c version.c
> 
60c66
< 	csh -c ctags *.c *.h
---
> 	csh -c ctags $(SRC) *.h
Index: ./src/makefile.dos
diff -r ../vim3.0/src/makefile.dos ./src/makefile.dos
8a9
> ### -DNOSTRTOL		strtol() function not available
23,24d23
< ### -DWEBB_COMPLETE	include Webb's code for command line completion
< ### -DWEBB_KEYWORD_COMPL include Webb's code for keyword completion
26c25,26
< DEFINES = -DDIGRAPHS -DWEBB_COMPLETE -DWEBB_KEYWORD_COMPL
---
> ### -DVIMINFO		include reading/writing viminfo file
> DEFINES = -DDIGRAPHS -DVIMINFO
38a39,45
> SRC =	alloc.c msdos.c buffer.c charset.c cmdcmds.c cmdline.c \
> 	csearch.c digraph.c edit.c fileio.c getchar.c help.c \
> 	linefunc.c main.c mark.c memfile.c memline.c message.c misccmds.c \
> 	normal.c ops.c param.c quickfix.c regexp.c \
> 	regsub.c screen.c search.c \
> 	tag.c term.c undo.c window.c version.c
> 
51c58
< 	command /c ctags *.c *.h
---
> 	command /c ctags $(SRC) $(INCL)
Index: ./src/makefile.manx
diff -r ../vim3.0/src/makefile.manx ./src/makefile.manx
12a13
> ### -DNOSTRTOL		strtol() function not available
29,30c30
< ### -DWEBB_COMPLETE	include Webb's code for command line completion
< ### -DWEBB_KEYWORD_COMPL include Webb's code for keyword completion
---
> ### -DVIMINFO		include reading/writing viminfo file
32,33c32
< DEFINES = -DDIGRAPHS -DSOME_BUILTIN_TCAPS -DVIM_ISSPACE \
< 		-DWEBB_COMPLETE -DWEBB_KEYWORD_COMPL
---
> DEFINES = -DDIGRAPHS -DSOME_BUILTIN_TCAPS -DVIM_ISSPACE
50a50,56
> SRC =	alloc.c amiga.c buffer.c charset.c cmdcmds.c cmdline.c \
> 	csearch.c digraph.c edit.c fileio.c getchar.c help.c \
> 	linefunc.c main.c mark.c memfile.c memline.c message.c misccmds.c \
> 	normal.c ops.c param.c quickfix.c regexp.c \
> 	regsub.c screen.c search.c \
> 	tag.c term.c undo.c window.c version.c
> 
78c84
< 	csh -c ctags *.c *.h
---
> 	csh -c ctags $(SRC) *.h
Index: ./src/makefile.nt
diff -r ../vim3.0/src/makefile.nt ./src/makefile.nt
9a10
> ### -DNOSTRTOL		strtol() function not available
24,25d24
< ### -DWEBB_COMPLETE	include Webb's code for command line completion
< ### -DWEBB_KEYWORD_COMPL include Webb's code for keyword completion
27c26,27
< DEFINES = -DDIGRAPHS -DWEBB_COMPLETE -DWEBB_KEYWORD_COMPL
---
> ### -DVIMINFO		include reading/writing viminfo file
> DEFINES = -DDIGRAPHS
42a43,49
> SRC =	alloc.c winnt.c buffer.c charset.c cmdcmds.c cmdline.c \
> 	csearch.c digraph.c edit.c fileio.c getchar.c help.c \
> 	linefunc.c main.c mark.c memfile.c memline.c message.c misccmds.c \
> 	normal.c ops.c param.c quickfix.c regexp.c \
> 	regsub.c screen.c search.c \
> 	tag.c term.c undo.c window.c version.c
> 
56c63
< 	command /c ctags *.c *.h
---
> 	command /c ctags $(SRC) $(INCL)
Index: ./src/makefile.sas
diff -r ../vim3.0/src/makefile.sas ./src/makefile.sas
20a21
> ### DEF=NOSTRTOL		strtol() function not available
30,31d30
< ### DEF=WEBB_COMPLETE		include Webb's code for command line completion
< ### DEF=WEBB_KEYWORD_COMPL	include Webb's code for keyword completion
33,34c32,33
< DEFINES = DEF=DIGRAPHS DEF=SOME_BUILTIN_TCAPS \
< 		DEF=WEBB_COMPLETE DEF=WEBB_KEYWORD_COMPL
---
> ### DEF=VIMINFO			include reading/writing viminfo file
> DEFINES = DEF=DIGRAPHS DEF=SOME_BUILTIN_TCAPS
61a61,67
> SRC =	alloc.c amiga.c buffer.c charset.c cmdcmds.c cmdline.c \
> 	csearch.c digraph.c edit.c fileio.c getchar.c help.c \
> 	linefunc.c main.c mark.c memfile.c memline.c message.c misccmds.c \
> 	normal.c ops.c param.c quickfix.c regexp.c \
> 	regsub.c screen.c search.c \
> 	tag.c term.c undo.c window.c version.c
> 
89c95
< 	csh -c ctags *.c *.h
---
> 	csh -c ctags $(SRC) *.h
Index: ./src/makefile.unix
diff -r ../vim3.0/src/makefile.unix ./src/makefile.unix
1c1
< #
---
> #		vim:ts=8:sw=8:
36c36
< #IRIX 4.0  SGI		cc		X11		(jw)
---
> #IRIX 4.0  SGI		cc	gcc	X11		(jw) (webb)
40a41
> #Coherent 4.2.10	cc			no X11  (fredex@fcshome.stoneham.ma.us)
127,128d127
< ### -DWEBB_COMPLETE	include Webb's code for command line completion
< ### -DWEBB_KEYWORD_COMPL include Webb's code for keyword completion
129a129
> ### -DVIMINFO		include reading/writing viminfo file
131,132c131,135
< 		-DWEBB_COMPLETE -DWEBB_KEYWORD_COMPL \
< 		-DVIM_HLP=\"$(HELPLOC)/vim.hlp\"
---
> 		-DVIMINFO -DVIM_HLP=\"$(HELPLOC)/vim.hlp\"
> 
> # Use this for cproto 3 patchlevel 6 or below (use "cproto -V" to check):
> #     (maybe the "/usr/bin/cc -E" has to be adjusted for some systems)
> # PROTO_FLAGS = -f4 -m__PARMS -d -E"/usr/bin/cc -E"
133a137,139
> # Use this for cproto 3 patchlevel 7 or above (use "cproto -V" to check):
> PROTO_FLAGS = -m -M__PARMS -d -E"/usr/bin/cc -E"
> 
138,140c144,146
< ### CC entry:      name and arguments for the compiler (also for linking)
< ### MACHINE entry: defines used for compiling (not for linking)
< ### LIBS:          defines used for linking
---
> ### CC        - name and arguments for the compiler (also for linking)
> ### MACHINE   - defines used for compiling (not for linking)
> ### LIBS      - defines used for linking
145,146c151,152
< #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11
< #CC=cc -O -I$(X11INCDIR)
---
> #MACHINE = -DBSD_UNIX -DUSE_LOCALE -Dconst= -DUSE_X11 -I$(X11INCDIR)
> #CC=cc -O
153c159
< #MACHINE = -DBSD_UNIX -DUSE_LOCALE
---
> #MACHINE = -DBSD_UNIX -DUSE_LOCALE -Dconst=
160,162c166,168
< #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11
< #CC=cc -O -L/usr/X386/lib -I/usr/X386/include
< #LIBS = -ltermlib -lX11
---
> #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11 -I/usr/X386/include
> #CC=cc -O
> #LIBS = -ltermlib -L/usr/X386/lib -lX11
165c171
< # gcc with optimizer
---
> # gcc with optimizer or debugging
167,168c173,175
< #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11
< #CC=gcc -O -Wall -traditional -Dconst= -I/usr/X386/include
---
> #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11 -I/usr/X386/include
> #CC=gcc -O -Wall -Wshadow -Wmissing-prototypes
> #CC=gcc -g -DDEBUG -Wall -Wshadow -Wmissing-prototypes
180,181c187,188
< #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11
< #CC=cc -O -I/usr/X11/include
---
> #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11 -I/usr/X11/include
> #CC=cc -O
192,194c199,201
< #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11
< #CC=gcc -O -Wall -traditional -Dconst= -L$(X11LIBDIR) -I$(X11INCDIR)
< #LIBS = -ltermlib -lX11
---
> #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11 -Dconst= -I$(X11INCDIR)
> #CC=gcc -O -Wall -Wshadow -Wmissing-prototypes -traditional
> #LIBS = -L$(X11LIBDIR) -ltermlib -lX11
198,199c205,206
< #MACHINE = -DBSD_UNIX -DUSE_LOCALE
< #CC=gcc -O -Wall -traditional -Dconst=
---
> #MACHINE = -DBSD_UNIX -DUSE_LOCALE -Dconst=
> #CC=gcc -O -Wall -Wshadow -Wmissing-prototypes -traditional
217c224
< #CC=gcc -O6 -Wall
---
> #CC=gcc -O6 -Wall -Wshadow -Wmissing-prototypes
228,229c235,236
< #MACHINE = -DBSD_UNIX -DTERMINFO -DUSE_X11
< #CC=cc -O -I$(X11INCDIR)
---
> #MACHINE = -DBSD_UNIX -DTERMINFO -DUSE_X11 -Dconst= -I$(X11INCDIR)
> #CC=cc -O
234c241
< #MACHINE = -DBSD_UNIX -DTERMINFO
---
> #MACHINE = -DBSD_UNIX -DTERMINFO -Dconst=
247,248c254,255
< #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11
< #CC=cc -O -I$(X11INCDIR)
---
> #MACHINE = -DBSD_UNIX -DUSE_LOCALE -DUSE_X11 -I$(X11INCDIR)
> #CC=cc -O
251c258
< # IRIX 4.0 (Silicon Graphics Indigo, __sgi will be defined) (TESTED)
---
> # IRIX 4.0 & 5.2 (Silicon Graphics Machines, __sgi will be defined) (TESTED)
253c260
< #MACHINE = -DBSD_UNIX -DUSE_X11                         
---
> #MACHINE = -DBSD_UNIX -DUSE_X11
256a264,270
> # IRIX 4.0 & 5.2 with gcc (Silicon Graphics Machines, __sgi will be defined)
> # (TESTED)
> #
> #MACHINE = -DBSD_UNIX -DUSE_X11
> #CC=gcc -O -Wall -Wshadow -Wmissing-prototypes
> #LIBS = -ltermlib -lX11 -lmalloc -lc_s
> 
271a286,292
> # generic SYSV_UNIX for Coherent 4.2.10
> # (TESTED on Intel 386 platform)
> #
> #MACHINE = -DSYSV_UNIX -Dvoid=int
> #CC=cc -O
> #LIBS = -lterm -lsocket
> 
288c309
< #CC=gcc -O -Wall
---
> #CC=gcc -O -Wall -Wshadow -Wmissing-prototypes
300c321
< #CC=gcc -O -Wall -traditional
---
> #CC=gcc -O -Wall -Wshadow -Wmissing-prototypes -traditional
305,307c326,328
< #MACHINE = -DSYSV_UNIX -DSOLARIS -DTERMINFO -DUSE_X11
< #CC=cc -O -Xa -v -R$(X11LIBDIR) -L$(X11LIBDIR) -I$(X11INCDIR)
< #LIBS = -ltermlib -lX11
---
> #MACHINE = -DSYSV_UNIX -DSOLARIS -DTERMINFO -DUSE_X11 -I$(X11INCDIR)
> #CC=cc -O -Xa -v -R$(X11LIBDIR)
> #LIBS = -L$(X11LIBDIR) -ltermlib -lX11
311,313c332,334
< #MACHINE = -DSYSV_UNIX -DSOLARIS -DTERMINFO -DUSE_X11
< #CC=gcc -O -R$(X11LIBDIR) -L$(X11LIBDIR) -I$(X11INCDIR)
< #LIBS = -ltermlib -lX11
---
> #MACHINE = -DSYSV_UNIX -DSOLARIS -DTERMINFO -DUSE_X11 -I$(X11INCDIR)
> #CC=gcc -O -R$(X11LIBDIR)
> #LIBS = -L$(X11LIBDIR) -ltermlib -lX11
359,360c380,381
< #MACHINE=-DSYSV_UNIX -DUSE_LOCALE -DUSE_X11
< #CC=cc -O -I$(X11INCDIR)
---
> #MACHINE=-DSYSV_UNIX -DUSE_LOCALE -DUSE_X11 -I$(X11INCDIR)
> #CC=cc -O
368a390,391
> PFLAGS = $(PROTO_FLAGS) -DPROTO $(MACHINE) $(DEFS)
> 
371,376c394,422
< OBJ =	alloc.o unix.o buffer.o charset.o cmdcmds.o cmdline.o \
< 	csearch.o digraph.o edit.o fileio.o getchar.o help.o \
< 	linefunc.o main.o mark.o memfile.o memline.o message.o misccmds.o \
< 	normal.o ops.o param.o quickfix.o regexp.o \
< 	regsub.o screen.o search.o \
< 	tag.o term.o undo.o window.o $(TERMLIB)
---
> SRC =	alloc.c buffer.c charset.c \
> 	cmdcmds.c cmdline.c csearch.c \
> 	digraph.c edit.c fileio.c getchar.c \
> 	help.c linefunc.c main.c mark.c \
> 	memfile.c memline.c message.c \
> 	misccmds.c normal.c ops.c param.c \
> 	quickfix.c regexp.c regsub.c screen.c \
> 	search.c tag.c term.c undo.c \
> 	unix.c window.c version.c
> 
> OBJ =	objects/alloc.o objects/unix.o objects/buffer.o objects/charset.o \
> 	objects/cmdcmds.o objects/cmdline.o objects/csearch.o \
> 	objects/digraph.o objects/edit.o objects/fileio.o objects/getchar.o \
> 	objects/help.o objects/linefunc.o objects/main.o objects/mark.o \
> 	objects/memfile.o objects/memline.o objects/message.o \
> 	objects/misccmds.o objects/normal.o objects/ops.o objects/param.o \
> 	objects/quickfix.o objects/regexp.o objects/regsub.o objects/screen.o \
> 	objects/search.o objects/tag.o objects/term.o objects/undo.o \
> 	objects/window.o $(TERMLIB)
> 
> PRO =	proto/alloc.pro proto/buffer.pro proto/charset.pro proto/cmdcmds.pro \
> 	proto/cmdline.pro proto/csearch.pro proto/digraph.pro proto/edit.pro \
> 	proto/fileio.pro proto/getchar.pro proto/help.pro proto/linefunc.pro \
> 	proto/main.pro proto/mark.pro proto/memfile.pro proto/memline.pro \
> 	proto/message.pro proto/misccmds.pro proto/normal.pro proto/ops.pro \
> 	proto/param.pro proto/quickfix.pro proto/regexp.pro proto/regsub.pro \
> 	proto/screen.pro proto/search.pro proto/tag.pro proto/term.pro \
> 	proto/termlib.pro proto/undo.pro proto/window.pro proto/amiga.pro \
> 	proto/unix.pro
378c424
< $(TARGET): $(OBJ) version.c
---
> $(TARGET): objects $(OBJ) version.c
380c426,427
< 	$(CC) -o $(TARGET) $(OBJ) version.o $(LIBS)
---
> 	mv version.o objects/version.o
> 	$(CC) -o $(TARGET) $(OBJ) objects/version.o $(LIBS)
382c429
< debug: $(OBJ) version.c
---
> debug: objects $(OBJ) version.c
384c431,445
< 	$(CC) -o $(TARGET) -g $(OBJ) version.o $(LIBS)
---
> 	mv version.o objects/version.o
> 	$(CC) -o $(TARGET) -g $(OBJ) objects/version.o $(LIBS)
> 
> objects:
> 	-mkdir objects
> 
> # Generate function prototypes.  This is not needed to compile vim, but if
> # you want to use it, cproto is out there on the net somewhere -- Webb
> #
> # When generating msdos.pro and amiga.pro there will be a few include
> # files that can not be found, that's OK.
> proto: $(PRO)
> 
> proto/msdos.pro: msdos.c
> 	cproto $(PFLAGS) -DMSDOS -UBSD_UNIX msdos.c > proto/msdos.pro
385a447,449
> proto/amiga.pro: amiga.c
> 	cproto $(PFLAGS) -DAMIGA -UBSD_UNIX -DBPTR=char* amiga.c > proto/amiga.pro
> 
387c451,453
< 	ctags *.c *.h
---
> 	ctags -t $(SRC) $(INCL)
> #	If we have elvis's ctags:
> #	ctags -tvs $(SRC) $(INCL)
402c468
< 	-rm -f $(OBJ) mkcmdtab.o version.o core $(TARGET) mkcmdtab cmdtab.h
---
> 	-rm -f $(OBJ) objects/mkcmdtab.o objects/vim.o objects/version.o core vim.core $(TARGET) mkcmdtab cmdtab.h
422c488
< alloc.o:	alloc.c  $(INCL)
---
> objects/alloc.o:	alloc.c  $(INCL)
423a490,493
> 	mv alloc.o objects/alloc.o
> 
> proto/alloc.pro:	alloc.c
> 	cproto $(PFLAGS) alloc.c >proto/alloc.pro
425c495
< unix.o:	unix.c  $(INCL)
---
> objects/unix.o:	unix.c  $(INCL)
426a497
> 	mv unix.o objects/unix.o
428c499,502
< buffer.o:	buffer.c  $(INCL)
---
> proto/unix.pro:		unix.c
> 	cproto $(PFLAGS) unix.c >proto/unix.pro
> 
> objects/buffer.o:	buffer.c  $(INCL)
429a504,507
> 	mv buffer.o objects/buffer.o
> 
> proto/buffer.pro:	buffer.c
> 	cproto $(PFLAGS) buffer.c >proto/buffer.pro
431c509
< charset.o:	charset.c  $(INCL)
---
> objects/charset.o:	charset.c  $(INCL)
432a511,514
> 	mv charset.o objects/charset.o
> 
> proto/charset.pro:	charset.c
> 	cproto $(PFLAGS) charset.c >proto/charset.pro
434c516
< cmdcmds.o:	cmdcmds.c  $(INCL)
---
> objects/cmdcmds.o:	cmdcmds.c  $(INCL)
435a518
> 	mv cmdcmds.o objects/cmdcmds.o
437c520,523
< cmdline.o:	cmdline.c  $(INCL) cmdtab.h ops.h
---
> proto/cmdcmds.pro:	cmdcmds.c
> 	cproto $(PFLAGS) cmdcmds.c >proto/cmdcmds.pro
> 
> objects/cmdline.o:	cmdline.c  $(INCL) cmdtab.h ops.h
438a525,528
> 	mv cmdline.o objects/cmdline.o
> 
> proto/cmdline.pro:	cmdline.c
> 	cproto $(PFLAGS) cmdline.c >proto/cmdline.pro
440c530
< csearch.o:	csearch.c  $(INCL)
---
> objects/csearch.o:	csearch.c  $(INCL)
441a532
> 	mv csearch.o objects/csearch.o
443c534,537
< digraph.o:	digraph.c  $(INCL)
---
> proto/csearch.pro:	csearch.c
> 	cproto $(PFLAGS) csearch.c >proto/csearch.pro
> 
> objects/digraph.o:	digraph.c  $(INCL)
444a539,542
> 	mv digraph.o objects/digraph.o
> 
> proto/digraph.pro:	digraph.c
> 	cproto $(PFLAGS) digraph.c >proto/digraph.pro
446c544
< edit.o:	edit.c  $(INCL) ops.h
---
> objects/edit.o:	edit.c  $(INCL) ops.h
447a546
> 	mv edit.o objects/edit.o
449c548,551
< fileio.o:	fileio.c  $(INCL)
---
> proto/edit.pro:	edit.c
> 	cproto $(PFLAGS) edit.c >proto/edit.pro
> 
> objects/fileio.o:	fileio.c  $(INCL)
450a553,556
> 	mv fileio.o objects/fileio.o
> 
> proto/fileio.pro:	fileio.c
> 	cproto $(PFLAGS) fileio.c >proto/fileio.pro
452c558
< getchar.o:	getchar.c  $(INCL)
---
> objects/getchar.o:	getchar.c  $(INCL)
453a560,563
> 	mv getchar.o objects/getchar.o
> 
> proto/getchar.pro:	getchar.c
> 	cproto $(PFLAGS) getchar.c >proto/getchar.pro
455c565
< help.o:	help.c  $(INCL)
---
> objects/help.o:	help.c  $(INCL)
456a567
> 	mv help.o objects/help.o
458c569,572
< linefunc.o:	linefunc.c  $(INCL)
---
> proto/help.pro:	help.c
> 	cproto $(PFLAGS) help.c >proto/help.pro
> 
> objects/linefunc.o:	linefunc.c  $(INCL)
459a574,577
> 	mv linefunc.o objects/linefunc.o
> 
> proto/linefunc.pro:	linefunc.c
> 	cproto $(PFLAGS) linefunc.c >proto/linefunc.pro
461c579
< main.o:	main.c  $(INCL)
---
> objects/main.o:	main.c  $(INCL)
462a581
> 	mv main.o objects/main.o
464c583,586
< mark.o:	mark.c  $(INCL)
---
> proto/main.pro:	main.c
> 	cproto $(PFLAGS) main.c >proto/main.pro
> 
> objects/mark.o:	mark.c  $(INCL)
465a588,591
> 	mv mark.o objects/mark.o
> 
> proto/mark.pro:	mark.c
> 	cproto $(PFLAGS) mark.c >proto/mark.pro
467c593
< memfile.o:	memfile.c  $(INCL)
---
> objects/memfile.o:	memfile.c  $(INCL)
468a595
> 	mv memfile.o objects/memfile.o
470c597,600
< memline.o:	memline.c  $(INCL)
---
> proto/memfile.pro:	memfile.c
> 	cproto $(PFLAGS) memfile.c >proto/memfile.pro
> 
> objects/memline.o:	memline.c  $(INCL)
471a602,605
> 	mv memline.o objects/memline.o
> 
> proto/memline.pro:	memline.c
> 	cproto $(PFLAGS) memline.c >proto/memline.pro
473c607
< message.o:	message.c  $(INCL)
---
> objects/message.o:	message.c  $(INCL)
474a609,612
> 	mv message.o objects/message.o
> 
> proto/message.pro:	message.c
> 	cproto $(PFLAGS) message.c >proto/message.pro
476c614
< misccmds.o:	misccmds.c  $(INCL)
---
> objects/misccmds.o:	misccmds.c  $(INCL)
477a616
> 	mv misccmds.o objects/misccmds.o
479c618,621
< normal.o:	normal.c  $(INCL) ops.h
---
> proto/misccmds.pro:	misccmds.c
> 	cproto $(PFLAGS) misccmds.c >proto/misccmds.pro
> 
> objects/normal.o:	normal.c  $(INCL) ops.h
480a623,626
> 	mv normal.o objects/normal.o
> 
> proto/normal.pro:	normal.c
> 	cproto $(PFLAGS) normal.c >proto/normal.pro
482c628
< ops.o:	ops.c  $(INCL) ops.h
---
> objects/ops.o:	ops.c  $(INCL) ops.h
483a630
> 	mv ops.o objects/ops.o
485c632,635
< param.o:	param.c  $(INCL)
---
> proto/ops.pro:	ops.c
> 	cproto $(PFLAGS) ops.c >proto/ops.pro
> 
> objects/param.o:	param.c  $(INCL)
486a637,640
> 	mv param.o objects/param.o
> 
> proto/param.pro:	param.c
> 	cproto $(PFLAGS) param.c >proto/param.pro
488c642
< quickfix.o:	quickfix.c  $(INCL)
---
> objects/quickfix.o:	quickfix.c  $(INCL)
489a644
> 	mv quickfix.o objects/quickfix.o
491c646,649
< regexp.o:	regexp.c  $(INCL)
---
> proto/quickfix.pro:	quickfix.c
> 	cproto $(PFLAGS) quickfix.c >proto/quickfix.pro
> 
> objects/regexp.o:	regexp.c  $(INCL)
492a651,654
> 	mv regexp.o objects/regexp.o
> 
> proto/regexp.pro:	regexp.c
> 	cproto $(PFLAGS) regexp.c >proto/regexp.pro
494c656
< regsub.o:	regsub.c  $(INCL)
---
> objects/regsub.o:	regsub.c  $(INCL)
495a658,661
> 	mv regsub.o objects/regsub.o
> 
> proto/regsub.pro:	regsub.c
> 	cproto $(PFLAGS) regsub.c >proto/regsub.pro
497c663
< screen.o:	screen.c  $(INCL)
---
> objects/screen.o:	screen.c  $(INCL)
498a665
> 	mv screen.o objects/screen.o
500c667,670
< search.o:	search.c  $(INCL) ops.h
---
> proto/screen.pro:	screen.c
> 	cproto $(PFLAGS) screen.c >proto/screen.pro
> 
> objects/search.o:	search.c  $(INCL) ops.h
501a672,675
> 	mv search.o objects/search.o
> 
> proto/search.pro:	search.c
> 	cproto $(PFLAGS) search.c >proto/search.pro
503c677
< tag.o:	tag.c  $(INCL)
---
> objects/tag.o:	tag.c  $(INCL)
504a679
> 	mv tag.o objects/tag.o
506c681,684
< term.o:	term.c  $(INCL)
---
> proto/tag.pro:	tag.c
> 	cproto $(PFLAGS) tag.c >proto/tag.pro
> 
> objects/term.o:	term.c  $(INCL)
507a686,689
> 	mv term.o objects/term.o
> 
> proto/term.pro:	term.c
> 	cproto $(PFLAGS) term.c >proto/term.pro
509c691
< undo.o:	undo.c  $(INCL)
---
> objects/undo.o:	undo.c  $(INCL)
510a693
> 	mv undo.o objects/undo.o
512c695,698
< window.o:	window.c  $(INCL)
---
> proto/undo.pro:	undo.c
> 	cproto $(PFLAGS) undo.c >proto/undo.pro
> 
> objects/window.o:	window.c  $(INCL)
513a700,703
> 	mv window.o objects/window.o
> 
> proto/window.pro:	window.c
> 	cproto $(PFLAGS) window.c >proto/window.pro
518,522c708,709
< mkcmdtab: mkcmdtab.o
< 	$(CC) -o mkcmdtab mkcmdtab.o
< 
< mkcmdtab.o: mkcmdtab.c
< 	$(CC) $(CFLAGS) mkcmdtab.c
---
> mkcmdtab: mkcmdtab.c
> 	$(CC) $(MACHINE) $(DEFS) -o mkcmdtab mkcmdtab.c
Index: ./src/mark.c
diff -r ../vim3.0/src/mark.c ./src/mark.c
33a34,35
> 	if (c >= 0x100)
> 		return FAIL;
193c195,197
< 	if (c == '\'' || c == '`')			/* previous context mark */
---
> 	if (c >= 0x100)
> 		;
> 	else if (c == '\'' || c == '`')		/* previous context mark */
278,279c282
< 	gotocmdline(TRUE, NUL);
< 	msg_outstr((char_u *)"\nmark line  file\n");
---
> 	msg_outstr((char_u *)"\nmark line  col file");
284,285c287,289
< 			sprintf((char *)IObuff, " %c %5ld\n", i + 'a',
< 												curbuf->b_namedm[i].lnum);
---
> 			sprintf((char *)IObuff, "\n %c %5ld  %3d", i + 'a',
> 												curbuf->b_namedm[i].lnum,
> 												curbuf->b_namedm[i].col);
298c302
< 			sprintf((char *)IObuff, " %c %5ld  %s\n",
---
> 			sprintf((char *)IObuff, "\n %c %5ld  %3d %s",
300a305
> 				namedfm[i].mark.col,
306d310
< 	msg_end();
318,319c322
< 	gotocmdline(TRUE, NUL);
< 	msg_outstr((char_u *)"\n jump line  file\n");
---
> 	msg_outstr((char_u *)"\n jump line  file");
328c331
< 			sprintf((char *)IObuff, "%c %2d %5ld  %s\n",
---
> 			sprintf((char *)IObuff, "\n%c %2d %5ld  %s",
338,339c341
< 		msg_outstr((char_u *)">\n");
< 	msg_end();
---
> 		msg_outstr((char_u *)"\n>");
343,344c345,346
<  * adjust marks between line1 and line2 (inclusive) to move 'inc' lines
<  * If 'inc' is MAXLNUM the mark is made invalid.
---
>  * adjust marks between line1 and line2 (inclusive) to move 'amount' lines
>  * If 'amount' is MAXLNUM the mark is made invalid.
347c349
< mark_adjust(line1, line2, inc)
---
> mark_adjust(line1, line2, amount)
350c352
< 	long		inc;
---
> 	long		amount;
363c365
< 			if (inc == MAXLNUM)
---
> 			if (amount == MAXLNUM)
366c368
< 				*lp += inc;
---
> 				*lp += amount;
373c375
< 				if (inc == MAXLNUM)
---
> 				if (amount == MAXLNUM)
376c378
< 					*lp += inc;
---
> 					*lp += amount;
385c387
< 		if (inc == MAXLNUM)
---
> 		if (amount == MAXLNUM)
388c390
< 			*lp += inc;
---
> 			*lp += amount;
395c397
< 		if (inc == MAXLNUM)
---
> 		if (amount == MAXLNUM)
398c400
< 			*lp += inc;
---
> 			*lp += amount;
400a403,418
> /* marks in the tag stack */
> 	for (i = 0; i < curwin->w_tagstacklen; i++)
> 	{
> 		if (curwin->w_tagstack[i].fmark.fnum == fnum)
> 		{
> 			lp = &(curwin->w_tagstack[i].fmark.mark.lnum);
> 			if (*lp >= line1 && *lp <= line2)
> 			{
> 				if (amount == MAXLNUM)
> 					*lp = line1;		/* don't delete it, just put at first deleted line */
> 				else
> 					*lp += amount;
> 			}
> 		}
> 	}
> 
402c420
< 	qf_mark_adjust(line1, line2, inc);
---
> 	qf_mark_adjust(line1, line2, amount);
413c431
< 					if (inc == MAXLNUM)
---
> 					if (amount == MAXLNUM)
416c434
< 						*lp += inc;
---
> 						*lp += amount;
427,428c445,451
< 				if (inc == MAXLNUM)		/* topline is deleted */
< 					win->w_topline = line1;
---
> 				if (amount == MAXLNUM)		/* topline is deleted */
> 				{
> 					if (line1 == 0)
> 						win->w_topline = 1;
> 					else
> 						win->w_topline = line1;
> 				}
430c453
< 					win->w_topline += inc;
---
> 					win->w_topline += amount;
434c457
< 				if (inc == MAXLNUM)		/* line with cursor is deleted */
---
> 				if (amount == MAXLNUM)		/* line with cursor is deleted */
440c463
< 					win->w_cursor.lnum += inc;
---
> 					win->w_cursor.lnum += amount;
Index: ./src/memfile.c
diff -r ../vim3.0/src/memfile.c ./src/memfile.c
50c50
< #if defined(SCO) || defined(_SEQUENT_) || defined(__sgi) || defined(MIPS) || defined(MIPSEB) || defined(m88k)
---
> #if defined(SCO) || defined(_SEQUENT_) || defined(__sgi) || defined(MIPS) || defined(MIPSEB) || defined(m88k) || defined(__COHERENT__)
67c67
< extern int dos2;					/* this is in amiga.c */
---
> extern int dos2;						/* this is in amiga.c */
71c71
< #  include <ios1.h>					/* for chkufb() */
---
> #  include <ios1.h>						/* for chkufb() */
75c75
< #define MEMFILE_PAGE_SIZE 4096		/* default page size */
---
> #define MEMFILE_PAGE_SIZE 4096			/* default page size */
77c77
< static long total_mem_used = 0;	/* total memory used for memfiles */
---
> static long total_mem_used = 0;			/* total memory used for memfiles */
472c472
< #if defined(MSDOS) || defined(SCO)
---
> #if defined(MSDOS) || defined(SCO) || defined(__COHERENT__)
511,512c511,513
< #if defined(UNIX) && !defined(SCO)
< # if !defined(SVR4) && (defined(MIPS) || defined(MIPSEB) || defined(m88k))         
---
> #if defined(UNIX) && !defined(SCO) && !defined(__COHERENT__)
> 	/* SGI has fsync() -- webb */
> # if !defined(SVR4) && !defined(__sgi) && (defined(MIPS) || defined(MIPSEB) || defined(m88k))
522c523
< #if defined(MSDOS) || defined(SCO)
---
> #if defined(MSDOS) || defined(SCO) || defined(__COHERENT__)
893c894,902
< 			EMSG("Write error in swap file");
---
> 			/*
> 			 * Avoid repeating the error message, this mostly happens when the
> 			 * disk is full. We give the message again only after a succesful
> 			 * write or when hitting a key. We keep on trying, in case some
> 			 * space becomes available.
> 			 */
> 			if (!did_swapwrite_msg)
> 				EMSG("Write error in swap file");
> 			did_swapwrite_msg = TRUE;
895a905
> 		did_swapwrite_msg = FALSE;
Index: ./src/memline.c
diff -r ../vim3.0/src/memline.c ./src/memline.c
172c172
< static int ml_delete_int __ARGS((BUF *, linenr_t));
---
> static int ml_delete_int __ARGS((BUF *, linenr_t, int));
193a194,195
> 	PTR_BL		*pp;
> 	DATA_BL		*dp;
233a236
> 	curbuf->b_ml.ml_flags = ML_EMPTY;
234a238,239
> 	curbuf->b_ml.ml_line_count = 1;
> 
237,242c242,245
< 				/* call wait_return if not done by emsg() */
< 		if (EMSG("Unable to open swap file, recovery impossible"))
< 		{
< 			msg_outchar('\n');
< 			wait_return(FALSE);
< 		}
---
> 		need_wait_return = TRUE;		/* call wait_return later */
> 		++no_wait_return;
> 		(void)EMSG("Unable to open swap file, recovery impossible");
> 		--no_wait_return;
269a273,275
> 		/* sync block number 0 to disk, so we can check the file name in the
> 		 * swap file in findswapname() */
> 	mf_sync(mfp, FALSE, FALSE);
280a287,292
> 	pp = (PTR_BL *)(hp->bh_data);
> 	pp->pb_count = 1;
> 	pp->pb_pointer[0].pe_bnum = 2;
> 	pp->pb_pointer[0].pe_page_count = 1;
> 	pp->pb_pointer[0].pe_old_lnum = 1;
> 	pp->pb_pointer[0].pe_line_count = 1;	/* line count after insertion */
282c294,304
< 	curbuf->b_ml.ml_flags = ML_EMPTY;
---
> 
> /*
>  * allocate first data block and create an empty line 1.
>  */
> 	if ((hp = ml_new_data(mfp, FALSE, 1)) == NULL)
> 		goto error;
> 	if (hp->bh_bnum != 2)
> 	{
> 		EMSG("didn't get block nr 2?");
> 		goto error;
> 	}
283a306,311
> 	dp = (DATA_BL *)(hp->bh_data);
> 	dp->db_index[0] = --dp->db_txt_start;		/* at end of block */
> 	dp->db_free -= 1 + INDEX_SIZE;
> 	dp->db_line_count = 1;
> 	*((char_u *)dp + dp->db_txt_start) = NUL;	/* emtpy line */
> 
299a328,401
>  * ml_setname() is called when the file name has been changed.
>  * It may rename the swap file.
>  */
> 	void
> ml_setname()
> {
> 	int			success = FALSE;
> 	MEMFILE		*mfp;
> 	char_u		*fname;
> 	int			i;
> 
> /*
>  * When 'updatecount' is 0 there is never a swap file.
>  */
> 	if (p_uc == 0)
> 		return;
> 
> /*
>  * If a file name given, 'directory' option is set and does not start with '>'
>  * try twice: First in current dir and if that fails in 'directory'.
>  */
> 	mfp = curbuf->b_ml.ml_mfp;
> 	fname = findswapname(curbuf, FALSE);		/* NULL detected below */
> 	if (fname != NULL && *p_dir != NUL && *p_dir != '>')
> 		i = 0;		/* try twice */
> 	else
> 		i = 1;		/* try once */
> 	for ( ; i < 2; ++i)
> 	{
> 		if (fname == NULL)			/* no file name found */
> 			break;
> 			/* if the file name is the same we don't have to do anything */
> 		if (fnamecmp(fname, mfp->mf_fname) == 0)
> 		{
> 			free(fname);
> 			success = TRUE;
> 			break;
> 		}
> 			/* need to close the swap file before renaming */
> 		close(mfp->mf_fd);
> 		mfp->mf_fd = -1;
> 
> 			/* try to rename the swap file */
> 		if (vim_rename(mfp->mf_fname, fname) == 0)
> 		{
> 			success = TRUE;
> 			free(mfp->mf_fname);
> 			mfp->mf_fname = fname;
> 			free(mfp->mf_xfname);
> 			if (FullName(fname, NameBuff, MAXPATHL) == FAIL)
> 				mfp->mf_xfname = NULL;
> 			else
> 				mfp->mf_xfname = strsave(NameBuff);
> 			break;
> 		}
> 			/* prepare for second try */
> 		free(fname);
> 		if (i == 0)
> 			fname = findswapname(curbuf, TRUE);
> 	}
> 	if (mfp->mf_fd == -1)
> 	{
> 		mfp->mf_fd = open(mfp->mf_fname, O_RDWR);
> 		if (mfp->mf_fd == -1)
> 		{
> 			/* what can we do???? */
> 			EMSG("Oops, lost the swap file!!!");
> 		}
> 	}
> 	if (!success)
> 		EMSG("Could not rename swap file");
> }
> 
> /*
340,341c442,444
< 					/* call wait_return if not done by emsg() */
< 			if (EMSG2("Unable to open swap file for \"%s\", recovery impossible",
---
> 			need_wait_return = TRUE;		/* call wait_return later */
> 			++no_wait_return;
> 			(void)EMSG2("Unable to open swap file for \"%s\", recovery impossible",
343,347c446,447
< 											 : buf->b_xfilename))
< 			{
< 				msg_outchar('\n');
< 				wait_return(FALSE);
< 			}
---
> 											 : buf->b_xfilename);
> 			--no_wait_return;
353c453,454
<  * close memline for buffer 'buf' and delete the swap file
---
>  * Close memline for buffer 'buf'.
>  * If 'delete' is TRUE, delete the swap file
356c457
< ml_close(buf)
---
> ml_close(buf, delete)
357a459
> 	int		delete;
361c463
< 	mf_close(buf->b_ml.ml_mfp, TRUE);			/* delete the .swp file */
---
> 	mf_close(buf->b_ml.ml_mfp, delete);			/* close the .swp file */
370a473
>  * When 'delete' is TRUE, delete the memfiles.
373c476,477
< ml_close_all()
---
> ml_close_all(delete)
> 	int		delete;
378c482
< 		ml_close(buf);
---
> 		ml_close(buf, delete);
553c657
< 		MSG("Warning: Original file may have been changed");
---
> 		EMSG("Warning: Original file may have been changed");
554a659
> 	flushbuf();
741a847,852
> 	/*
> 	 * The dummy line from the empty buffer will now be after the last line in
> 	 * the buffer. Delete it.
> 	 */
> 	ml_delete(curbuf->b_ml.ml_line_count, FALSE);
> 
748c859,865
< 		MSG("Recovery completed; If everything is OK: Save this file and delete the .swp file");
---
> 	{
> 		MSG("Recovery completed. Check if everything is OK.");
> 		msg_outstr("\n(You might want to write out this file under another name\n");
> 		msg_outstr("and run diff with the original file to check for changes)\n");
> 		msg_outstr("Delete the .swp file afterwards.\n\n");
> 		cmdline_row = msg_row;
> 	}
766,767d882
<  * Stop syncing when character becomes available, but always sync at
<  * least one block.
768a884,885
>  * If 'check_char' is TRUE, stop syncing when character becomes available, but
>  * always sync at least one block.
771c888
< ml_sync_all(check_file)
---
> ml_sync_all(check_file, check_char)
772a890
> 	int		check_char;
782,783c900,902
< 		ml_flush_line(buf);								/* flush buffered line */
< 		(void)ml_find_line(buf, (linenr_t)0, ML_FLUSH);	/* flush locked block */
---
> 		ml_flush_line(buf);					/* flush buffered line */
> 											/* flush locked block */
> 		(void)ml_find_line(buf, (linenr_t)0, ML_FLUSH);
797,798c916,917
< 			mf_sync(buf->b_ml.ml_mfp, FALSE, TRUE);
< 			if (mch_char_avail())			/* character available now */
---
> 			mf_sync(buf->b_ml.ml_mfp, FALSE, check_char);
> 			if (check_char && mch_char_avail())	/* character available now */
843c962,964
< 	 * all data blocks until there are no more translations to be done.
---
> 	 * all data blocks until there are no more translations to be done (or
> 	 * we hit the end of the file, which can only happen in case a write fails,
> 	 * e.g. when file system if full).
850c971
< 		while (mf_need_trans(mfp))
---
> 		while (mf_need_trans(mfp) && lnum <= buf->b_ml.ml_line_count)
926a1048,1050
> 	
> 	if (buf->b_ml.ml_mfp == NULL)		/* there are no lines */
> 		return (char_u *)"";
936,938d1059
< 		if (buf->b_ml.ml_flags & ML_EMPTY)					/* empty buffer */
< 			return (char_u *)"";
< 
1010d1130
< 	BHDR		*hp2;
1016c1136,1137
< 	if (lnum > buf->b_ml.ml_line_count)	/* lnum out of range */
---
> 										/* lnum out of range */
> 	if (lnum > buf->b_ml.ml_line_count || buf->b_ml.ml_mfp == NULL)
1029,1085d1149
<  	if (buf->b_ml.ml_flags & ML_EMPTY)			/* empty file */
< 	{
< /*
<  * Special case: Add first line to empty file.
<  * Create the first data block.
<  * If lnum == 0, line 1 is inserted below.
<  * If lnum == 1, insert an empty line 1 and insert line 2 below.
<  */
< 		/*
< 		 * allocate the first data block
< 		 */
< 		if (lnum == 1)					/* reserve space for line 1 */
< 			space_needed += 1 + INDEX_SIZE;
< 		page_count = ((space_needed + HEADER_SIZE) + page_size - 1) / page_size;
< 		if ((hp = ml_new_data(mfp, newfile, page_count)) == NULL)
< 			return FAIL;
< 
< 		if (lnum == 1)					/* insert line 1 here, empty */
< 		{
< 			dp = (DATA_BL *)(hp->bh_data);
< 			dp->db_index[0] = --dp->db_txt_start;		/* at end of block */
< 			dp->db_free -= 1 + INDEX_SIZE;
< 			dp->db_line_count = 1;
< 			*((char_u *)dp + dp->db_txt_start) = NUL;	/* emtpy line */
< 			space_needed -= 1 + INDEX_SIZE;				/* space for line 1 */
< 		}
< 
< 		/*
< 		 * update the first pointer block
< 		 */
< 		if ((hp2 = mf_get(mfp, (blocknr_t)1, 1)) == NULL)
< 		{
< 			mf_free(mfp, hp);
< 			return FAIL;
< 		}
< 		pp = (PTR_BL *)(hp2->bh_data);	/* must be pointer block */
< 		if (pp->pb_id != PTR_ID)
< 		{
< 			EMSG("pointer block id wrong 5");
< 			mf_free(mfp, hp);
< 			mf_put(mfp, hp2, FALSE, FALSE);
< 			return FAIL;
< 		}
< 		pp->pb_count = 1;
< 		pp->pb_pointer[0].pe_bnum = hp->bh_bnum;
< 		pp->pb_pointer[0].pe_page_count = page_count;
< 		pp->pb_pointer[0].pe_old_lnum = 1;
< 		pp->pb_pointer[0].pe_line_count = lnum + 1;		/* line count after insertion */
< 		mf_put(mfp, hp2, TRUE, FALSE);
< 
< 		buf->b_ml.ml_flags &= ~ML_EMPTY;
< 		line_count = lnum;				/* 0 or 1 line in block before insertion */
< 		buf->b_ml.ml_line_count = lnum;
< 		db_idx = lnum - 1;				/* append new line after -1 or 0 */
< 	}
< 	else			/* not empty file */
< 	{
1091,1092c1155,1157
< 		if ((hp = ml_find_line(buf, lnum == 0 ? (linenr_t)1 : lnum, ML_INSERT)) == NULL)
< 			return FAIL;
---
> 	if ((hp = ml_find_line(buf, lnum == 0 ? (linenr_t)1 : lnum,
> 													ML_INSERT)) == NULL)
> 		return FAIL;
1094,1100c1159
< 		if (lnum == 0)				/* got line one instead, correct db_idx */
< 			db_idx = -1;			/* careful, it is negative! */
< 		else
< 			db_idx = lnum - buf->b_ml.ml_locked_low;
< 					/* get line count before the insertion */
< 		line_count = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low;
< 	}
---
> 	buf->b_ml.ml_flags &= ~ML_EMPTY;
1101a1161,1167
> 	if (lnum == 0)				/* got line one instead, correct db_idx */
> 		db_idx = -1;			/* careful, it is negative! */
> 	else
> 		db_idx = lnum - buf->b_ml.ml_locked_low;
> 				/* get line count before the insertion */
> 	line_count = buf->b_ml.ml_locked_high - buf->b_ml.ml_locked_low;
> 
1208,1213c1274,1279
< 		 * We are going to allocate a new data block. Depending on the situation
< 		 * it will be put to the left or right of the existing block.
< 		 * If possible we put the new line in the left block and move the
< 		 * lines after it to the right block. Otherwise the new line is also put
< 		 * in the right block. This method is more efficient when inserting a lot
< 		 * of lines at one place.
---
> 		 * We are going to allocate a new data block. Depending on the
> 		 * situation it will be put to the left or right of the existing
> 		 * block.  If possible we put the new line in the left block and move
> 		 * the lines after it to the right block. Otherwise the new line is
> 		 * also put in the right block. This method is more efficient when
> 		 * inserting a lot of lines at one place.
1229c1295,1296
< 				data_moved = ((dp->db_index[db_idx]) & DB_INDEX_MASK) - dp->db_txt_start;
---
> 				data_moved = ((dp->db_index[db_idx]) & DB_INDEX_MASK) -
> 															dp->db_txt_start;
1522,1523d1588
< 	int			status;
< 
1527,1555c1592,1596
< 	/*
< 	 * if empty file simply append the one and only line
< 	 */
< 	if (curbuf->b_ml.ml_flags & ML_EMPTY)
< 	{
< 		if (*line == NUL)		/* nothing to do */
< 			return OK;
< 		status = ml_append_int(curbuf, lnum - 1, line, (colnr_t)0, FALSE);
< 		if (!copy)
< 			free(line);
< 		return status;
< 	}
< 
< 	/*
< 	 * if only line replaced by empty line, buffer becomes empty
< 	 */
< 	if (lnum == 1 && *line == NUL && curbuf->b_ml.ml_line_count == 1)
< 	{
< 		status = ml_delete(lnum);
< 		if (!copy)
< 			free(line);
< 		return status;
< 	}
< 
< 	if (curbuf->b_ml.ml_line_lnum != lnum)		/* other line currently buffered */
< 		ml_flush_line(curbuf);					/* flush it */
< 	else if (curbuf->b_ml.ml_flags & ML_LINE_DIRTY)	/* same line has been allocated */
< 		free(curbuf->b_ml.ml_line_ptr);			/* free it */
< 	if (copy && (line = strsave(line)) == NULL)	/* allocate memory for the line */
---
> 	if (curbuf->b_ml.ml_line_lnum != lnum)			/* other line buffered */
> 		ml_flush_line(curbuf);						/* flush it */
> 	else if (curbuf->b_ml.ml_flags & ML_LINE_DIRTY)	/* same line allocated */
> 		free(curbuf->b_ml.ml_line_ptr);				/* free it */
> 	if (copy && (line = strsave(line)) == NULL)		/* allocate memory */
1559c1600
< 	curbuf->b_ml.ml_flags |= ML_LINE_DIRTY;
---
> 	curbuf->b_ml.ml_flags = (curbuf->b_ml.ml_flags | ML_LINE_DIRTY) & ~ML_EMPTY;
1570c1611
< ml_delete(lnum)
---
> ml_delete(lnum, message)
1571a1613
> 	int			message;
1574c1616
< 	return ml_delete_int(curbuf, lnum);
---
> 	return ml_delete_int(curbuf, lnum, message);
1578c1620
< ml_delete_int(buf, lnum)
---
> ml_delete_int(buf, lnum, message)
1580a1623
> 	int			message;
1601,1602c1644,1653
< 	if (buf->b_ml.ml_flags & ML_EMPTY)			/* nothing to delete */
< 		return FAIL;
---
> /*
>  * If the file becomes empty the last line is replaced by an empty line.
>  */
> 	if (buf->b_ml.ml_line_count == 1)		/* file becomes empty */
> 	{
> 		buf->b_ml.ml_flags |= ML_EMPTY;
> 		if (message)
> 			emsg("No lines in buffer");
> 		return ml_replace(1, (char_u *)"", TRUE);
> 	}
1604,1608c1655,1659
< 	/*
< 	 * find the data block containing the line
< 	 * This also fills the stack with the blocks from the root to the data block
< 	 * This also releases any locked block.
< 	 */
---
> /*
>  * find the data block containing the line
>  * This also fills the stack with the blocks from the root to the data block
>  * This also releases any locked block.
>  */
1609a1661,1662
> 	if (mfp == NULL)
> 		return FAIL;
1619,1633c1672
< /*
<  * If the file becomes empty the data block is freed.
<  * The pointer blocks will be updated when the first line is appended.
<  */
< 	if (--buf->b_ml.ml_line_count == 0)		/* file becomes empty */
< 	{
< 		CHECK(count != 1, "ml_delete: count not 1");
< 		CHECK(idx != 0, "ml_delete: idx not 0");
< 		buf->b_ml.ml_line_count = 1;
< 		buf->b_ml.ml_flags |= ML_EMPTY;
< 		mf_free(mfp, hp);						/* free the data block */
< 		buf->b_ml.ml_locked = NULL;
< 		buf->b_ml.ml_stack_top = 0;				/* flush stack */
< 		return OK;
< 	}
---
> 	--buf->b_ml.ml_line_count;
1731,1733c1770,1773
< 
< 	if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count)		/* invalid line number */
< 		return;				/* give error message? */
---
> 									/* invalid line number */
> 	if (lnum < 1 || lnum > curbuf->b_ml.ml_line_count ||
> 												curbuf->b_ml.ml_mfp == NULL)
> 		return;						/* give error message? */
1761a1802,1804
> 	if (curbuf->b_ml.ml_mfp == NULL)
> 		return (linenr_t) 0;
> 
1770,1771c1813,1814
< 		 * This also fills the stack with the blocks from the root to the data block
< 		 * This also releases any locked block.
---
> 		 * This also fills the stack with the blocks from the root to the data
> 		 * block This also releases any locked block.
1802c1845,1846
< 	if ((hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)
---
> 	if (curbuf->b_ml.ml_mfp == NULL ||
> 						(hp = ml_find_line(curbuf, lnum, ML_FIND)) == NULL)
1819a1864,1866
> 	if (curbuf->b_ml.ml_mfp == NULL)		/* nothing to do */
> 		return;
> 
1868c1915,1916
<  	if (buf->b_ml.ml_line_lnum == 0)		/* nothing to do */
---
>  	if (buf->b_ml.ml_line_lnum == 0 ||
> 						buf->b_ml.ml_mfp == NULL)		/* nothing to do */
1878c1926
< 			EMSG2("Cannot fine line %ld", (char_u *)lnum);
---
> 			EMSG2("Cannot find line %ld", (char_u *)lnum);
1926c1974
< 				(void)ml_delete_int(buf, lnum);
---
> 				(void)ml_delete_int(buf, lnum, FALSE);
2211c2259,2260
< 		newstack = (IPTR *)alloc((unsigned)sizeof(IPTR) * (buf->b_ml.ml_stack_size + STACK_INCR));
---
> 		newstack = (IPTR *)alloc((unsigned)sizeof(IPTR) *
> 										(buf->b_ml.ml_stack_size + STACK_INCR));
2214c2263,2264
< 		memmove((char *)newstack, (char *)buf->b_ml.ml_stack, (size_t)top * sizeof(IPTR));
---
> 		memmove((char *)newstack, (char *)buf->b_ml.ml_stack,
> 										(size_t)top * sizeof(IPTR));
2289,2296c2339
< 	s = alloc((unsigned)(STRLEN(pdir) + STRLEN(fname) + 2));
< 	if (s != NULL)
< 	{
< 		STRCPY(s, pdir);
< 		if (*s && !ispathsep(*(s + STRLEN(s) - 1)))	/* don't add '/' after ':' */
< 			STRCAT(s, PATHSEPSTR);
< 		STRCAT(s, fname);
< 	}
---
> 	s = concat_fnames(pdir, fname);
2304a2348,2350
>  *
>  * Note: if MAXNAMLEN is not correct, you will get error messages for
>  *       not being able to open the swapfile
2315d2360
< 	int			r;
2316a2362,2365
> #endif
> 
> #ifndef MSDOS
> 	int			r;
2344c2393,2470
< 		
---
> #if defined(UNIX) && !defined(ARCHIE)
> /*
>  * Some systems have a MS-DOS compatible filesystem that use 8.3 character
>  * file names. If this is the first try and the swap file name does not fit in
>  * 8.3, detect if this is the case, set shortname and try again.
>  */
> 		if (fname[n - 1] == 'p' && !(buf->b_p_sn || buf->b_shortname))
> 		{
> 			char_u			*tail;
> 			char_u			*fname2;
> 			struct stat		s1, s2;
> 			int				f1, f2;
> 			int				created1 = FALSE, created2 = FALSE;
> 			int				equal = FALSE;
> 
> 			/*
> 			 * Check if swapfilename does not fit in 8.3:
> 			 * It either contains two dots or it is longer than 8 chars.
> 			 */
> 			tail = gettail(curbuf->b_xfilename);
> 			if (STRCHR(tail, '.') != NULL || STRLEN(tail) > 8)
> 			{
> 				fname2 = alloc(n + 1);
> 				if (fname2 != NULL)
> 				{
> 					STRCPY(fname2, fname);
> 					if (STRCHR(tail, '.') != NULL)
> 						fname2[n - 1] = 'x';	/* change ".swp" to ".swx" */
> 					else
> 						fname2[n - 5] += 1;		/* change "x.swp" to "y.swp" */
> 					/*
> 					 * may need to create the files to be able to use stat()
> 					 */
> 					f1 = open(fname, O_RDONLY);
> 					if (f1 < 0)
> 					{
> 						f1 = open(fname, O_RDWR|O_CREAT|O_EXCL);
> 						created1 = TRUE;
> 					}
> 					if (f1 >= 0)
> 					{
> 						f2 = open(fname2, O_RDONLY);
> 						if (f2 < 0)
> 						{
> 							f2 = open(fname, O_RDWR|O_CREAT|O_EXCL);
> 							created2 = TRUE;
> 						}
> 						if (f2 >= 0)
> 						{
> 							/*
> 							 * Both files exist now. If stat() returns the
> 							 * same device and inode they are the same file.
> 							 */
> 							if (fstat(f1, &s1) != -1 &&
> 										fstat(f2, &s2) != -1 &&
> 										s1.st_dev == s2.st_dev &&
> 										s1.st_ino == s2.st_ino)
> 								equal = TRUE;
> 							close(f2);
> 							if (created2)
> 								remove((char *)fname2);
> 						}
> 						close(f1);
> 						if (created1)
> 							remove((char *)fname);
> 					}
> 					free(fname2);
> 					if (equal)
> 					{
> 						buf->b_shortname = TRUE;
> 						free(fname);
> 						fname = makeswapname(buf, second_try);
> 						continue;		/* try again with '.' replaced by '_' */
> 					}
> 				}
> 			}
> 		}
> #endif
2371c2497
< #ifdef AMIGA
---
> #ifndef MSDOS
2389,2390c2515,2516
< 					fname = makeswapname(buf, second_try);	/* '.' replaced by '_' */
< 					continue;						/* try again */
---
> 					fname = makeswapname(buf, second_try);
> 					continue;		/* try again with '.' replaced by '_' */
2396c2522,2524
< 			 * Give an error message, unless recovering or no file name.
---
> 			 * Give an error message, unless recovering, no file name or when
> 			 * the path of the file is different (happens when all .swp files
> 			 * are in one directory).
2400,2401c2528,2533
< 						/* call wait_return if not done by emsg() */
< 				if (EMSG2(".swp file exists: An edit of file \"%s\" may not have been finished", buf->b_xfilename))
---
> 				int				fd;
> 				struct block0	b0;
> 				int				differ = FALSE;
> 
> 				fd = open(fname, O_RDONLY);
> 				if (fd >= 0)
2403,2404c2535,2575
< 					msg_outchar('\n');
< 					wait_return(FALSE);		/* do call wait_return now */
---
> 					if (read(fd, &b0, sizeof(b0)) == sizeof(b0) &&
> 							fnamecmp(b0.b0_fname, buf->b_filename) != 0)
> 						differ = TRUE;
> 					close(fd);
> 				}
> 				if (differ == FALSE)
> 				{
> 					struct stat st;
> 
> 					++no_wait_return;
> 					++dont_sleep;
> 					(void)EMSG("ATTENTION");
> 					--dont_sleep;
> 					msg_outstr("\nFound a swap file by the name \"");
> 					msg_outstr(fname);
> 					msg_outstr("\"\n");
> 					if (stat((char *)fname, &st) != -1)
> 					{
> 						msg_outstr((char_u *)"                        dated ");
> 						msg_outstr((char_u *)ctime(&st.st_mtime));
> 					}
> 					msg_outstr("           while opening file \"");
> 					msg_outstr(buf->b_xfilename);
> 					msg_outstr("\"\n");
> 					if (stat((char *)buf->b_xfilename, &st) != -1)
> 					{
> 						msg_outstr((char_u *)"                        dated ");
> 						msg_outstr((char_u *)ctime(&st.st_mtime));
> 					}
> 					msg_outstr("\n(1) Another program may be editing the same file.\n");
> 					msg_outstr("    If this is the case, quit this edit session to avoid problems.\n");
> 					msg_outstr("\n(2) An edit session for this file crashed.\n");
> 					msg_outstr("    If this is the case, use \":recover\" or \"Vim -r ");
> 					msg_outstr(buf->b_xfilename);
> 					msg_outstr("\"\n    to recover the changes.\n");
> 					msg_outstr("    If you did this already, delete the swap file \"");
> 					msg_outstr(fname);
> 					msg_outstr("\"\n    to avoid this message.\n\n");
> 					cmdline_row = msg_row;
> 					--no_wait_return;
> 					need_wait_return = TRUE;		/* call wait_return later */
2418c2589
< #ifdef AMIGA
---
> #ifndef MSDOS
Index: ./src/message.c
diff -r ../vim3.0/src/message.c ./src/message.c
21c21,22
< static int lines_left = -1;			/* lines left for listing */
---
> static int	lines_left = -1;			/* lines left for listing */
> static int	quit_more = FALSE;			/* 'q' hit at "--more--" msg */
47c48
< 	msg_ceol();
---
> 	msg_clr_eos();
51c52,58
< #ifndef PROTO		/* automatic prototype generation does not understand this */
---
> /*
>  * automatic prototype generation does not understand this function
>  */
> #ifndef PROTO
> int smsg __ARGS((char_u *, long, long, long,
> 						long, long, long, long, long, long, long));
> 
53c60
< 	void
---
> 	int
59c66
< 	msg(IObuff);
---
> 	return msg(IObuff);
73a81,86
> 	char_u			Buf[MAXPATHL + 30];
> 	int				retval;
> 
> 	if (emsg_off)				/* no error messages at the moment */
> 		return TRUE;
> 
75c88
< 		beep();					/* also includes flush_buffers() */
---
> 		beep_flush();			/* also includes flush_buffers() */
79a93,106
> 
> /*
>  * First output name of source of error message
>  */
> 	if (sourcing_name)
> 	{
> 		++msg_scroll;			/* don't overwrite this message */
> 		++no_wait_return;
> 		sprintf((char *)Buf, "Error detected while processing %s:",
> 										sourcing_name);
> 		msg(Buf);
> 		msg_highlight = TRUE;
> 		--no_wait_return;
> 	}
87c114
< 		if (dont_sleep)
---
> 		if (dont_sleep || need_wait_return)
89,91c116,118
< 			msg_outchar('\n');	/* one message per line, don't overwrite */
< 			cmdline_row = msg_row;
< 			need_wait_return = TRUE;
---
> 			need_sleep = TRUE;		/* sleep before removing the message */
> 			msg_scroll = TRUE;		/* don't overwrite this message */
> 			sourcing_name = NULL;	/* don't repeat the sourcing name */
95c122,128
< 		return TRUE;
---
> 		retval = TRUE;
> 	}
> 	retval = FALSE;
> 	if (sourcing_name)
> 	{
> 		sourcing_name = NULL;		/* don't repeat the sourcing name */
> 		--msg_scroll;
97c130
< 	return FALSE;
---
> 	return retval;
108a142,159
>  * like msg(), but truncate to a single line if p_shm set to 2
>  */
> 	int
> msg_trunc(s)
> 	char_u	*s;
> {
> 	int		n;
> 
> 	if (p_shm == 2 && (n = STRLEN(s) - sc_col + 1) > 0)
> 	{
> 		s[n] = '<';
> 		return msg(s + n);
> 	}
> 	else
> 		return msg(s);
> }
> 
> /*
121a173,176
> 	if (redraw == TRUE)
> 		must_redraw = CLEAR;
> 	skip_redraw = FALSE;			/* default: don't skip redraw */
> 
134a190,191
> 	need_sleep = FALSE;			/* no need to call sleep() anymore */
> 	msg_didany = FALSE;			/* reset lines_left at next msg_start() */
137,139c194,206
< 	State = HITRETURN;
< 	if (got_int)
< 		msg_outstr((char_u *)"Interrupt: ");
---
> 	if (quit_more)
> 	{
> 		c = CR;						/* just pretend CR was hit */
> 		quit_more = FALSE;
> 		got_int = FALSE;
> 	}
> 	else
> 	{
> 		State = HITRETURN;
> 		if (msg_didout)				/* start on a new line */
> 			msg_outchar('\n');
> 		if (got_int)
> 			msg_outstr((char_u *)"Interrupt: ");
141,142c208,209
< 	(void)set_highlight('r');
< 	start_highlight();
---
> 		(void)set_highlight('r');
> 		start_highlight();
144,150c211,217
< 	msg_outstr("Press RETURN to continue");
< 	stop_highlight();
< 	do {
< 		c = vgetc();
< 	} while (strchr("\r\n: ", c) == NULL);
< 	if (c == ':')			 		/* this can vi too (but not always!) */
< 		stuffcharReadbuff(c);
---
> 		msg_outstr("Press RETURN to continue");
> 		stop_highlight();
> 		do {
> 			c = vgetc();
> 		} while (c >= 0x100 || strchr("\r\n: ", c) == NULL);
> 		if (c == ':')			 		/* this can vi too (but not always!) */
> 			stuffcharReadbuff(c);
152,161c219,228
< 	msg_outstr((char_u *)"Press RETURN or enter command to continue");
< 	stop_highlight();
< 	do
< 	{
< 		c = vgetc();
< 		got_int = FALSE;
< 	} while (c == Ctrl('C'));
< 	breakcheck();
< 	if (strchr("\r\n ", c) == NULL)
< 		stuffcharReadbuff(c);
---
> 		msg_outstr((char_u *)"Press RETURN or enter command to continue");
> 		stop_highlight();
> 		do
> 		{
> 			c = vgetc();
> 			got_int = FALSE;
> 		} while (c == Ctrl('C'));
> 		breakcheck();
> 		if (c >= 0x100 || strchr("\r\n ", c) == NULL)
> 			stuffcharReadbuff(c);
162a230
> 	}
182,189c250
< 	else if (redraw == TRUE)
< 	{
< 		if (c == ':')
< 			must_redraw = CLEAR;
< 		else
< 			updateScreen(CLEAR);
< 	}
< 	else if (msg_scrolled && c != ':' && redraw != -1)
---
> 	else if (c != ':' && (redraw == TRUE || (msg_scrolled && redraw != -1)))
193a255
> 	dont_wait_return = TRUE;		/* don't wait again in main() */
202,204c264,274
< 	did_msg = TRUE;					/* for doglob() */
< 	keep_msg = NULL;				/* don't display old message now */
< 	msg_pos(cmdline_row, 0);
---
> 	keep_msg = NULL;						/* don't display old message now */
> 	if (!msg_scroll && !not_full_screen)	/* overwrite last message */
> 		msg_pos(cmdline_row, 0);
> 	else if (msg_didout)					/* start message on next line */
> 	{
> 		msg_outchar('\n');
> 		cmdline_row = msg_row;
> 	}
> 	if (!msg_didany)
> 		lines_left = cmdline_row;
> 	msg_didout = FALSE;						/* no output on current line yet */
206d275
< 	lines_left = cmdline_row;
228c297
< 	char_u		buf[2];
---
> 	char_u		buf[3];
230,231c299,309
< 	buf[0] = c;
< 	buf[1] = NUL;
---
> 	if (c >= 0x100)
> 	{
> 		buf[0] = K_SPECIAL;
> 		buf[1] = K_SECOND(c);
> 		buf[2] = NUL;
> 	}
> 	else
> 	{
> 		buf[0] = c;
> 		buf[1] = NUL;
> 	}
268a347,435
>  * output the string 'str' upto a NUL character.
>  * return the number of characters it takes on the screen.
>  * If a character is in the range 0x80-0xa3 (0xb0-0xd3 for MSDOS), then it is
>  * shown as <F1>, <C_UP> etc.  In addition, if 'all' is TRUE, then any other
>  * character which has its 8th bit set is shown as M-x, where x is the
>  * equivalent character without its 8th bit set.  If a character is displayed
>  * in one of these special ways, is also highlighted (its highlight name is '8'
>  * in the p_hl variable).  This function is used to show mappings, where we
>  * want to see how to type the character/string.
>  * -- webb
>  */
> 	int
> msg_outtrans_meta(str, all)
> 	register char_u *str;
> 	register int	all;	/* or just C_UP, F1 etc */
> {
> 	int		retval = 0;
> 	char_u	string[20];
> 	char_u	**names;
> 	int		c;
> 
> 	names = get_key_names();
> 	set_highlight('8');
> 	for (; *str; ++str)
> 	{
> 		c = *str;
> 		if (c == K_SPECIAL)
> 		{
> 			c = *++str;
> 			if (c >= KS_UARROW && c <= KS_MAXKEY)
> 			{
> 				start_highlight();
> 				sprintf((char *)string, "<%s>", names[c - KS_UARROW]);
> 				msg_outstr(string);
> 				retval += STRLEN(string);
> 				stop_highlight();
> 				continue;
> 			}
> 			if (c == KS_ZERO)
> 				c = NUL;
> 			else if (c == KS_SPECIAL)
> 				c = K_SPECIAL;
> 			/* else: illegal key code !? */
> 		}
> 		if ((c & 0x80) && all)
> 		{
> 			start_highlight();
> 			msg_outstr((char_u *)"M-");
> 			msg_outstr(transchar(c & 0x7f));
> 			retval += 2 + charsize(c & 0x7f);
> 			stop_highlight();
> 		}
> 		else
> 		{
> 			msg_outstr(transchar(c));
> 			retval += charsize(c);
> 		}
> 	}
> 	return retval;
> }
> 
> /*
>  * Return a list of the names of each special key.  To get the name of the
>  * key with internal code 'key', use the index [key - KS_UARROW] into the
>  * returned list.
>  */
> 	char_u **
> get_key_names()
> {
> 	static char_u *names[] =
> 	{
> 		(char_u *)"C_UP", (char_u *)"C_DOWN", (char_u *)"C_LEFT",
> 		(char_u *)"C_RIGHT", (char_u *)"SC_UP", (char_u *)"SC_DOWN",
> 		(char_u *)"SC_LEFT", (char_u *)"SC_RIGHT", (char_u *)"F1",
> 		(char_u *)"F2", (char_u *)"F3", (char_u *)"F4", (char_u *)"F5",
> 		(char_u *)"F6", (char_u *)"F7", (char_u *)"F8", (char_u *)"F9",
> 		(char_u *)"F10", (char_u *)"SF1", (char_u *)"SF2", (char_u *)"SF3",
> 		(char_u *)"SF4", (char_u *)"SF5", (char_u *)"SF6", (char_u *)"SF7",
> 		(char_u *)"SF8", (char_u *)"SF9", (char_u *)"SF10",
> 		(char_u *)"HELP", (char_u *)"UNDO",
> 		(char_u *)"INSERT", (char_u *)"DEL",
> 		(char_u *)"HOME", (char_u *)"END",
> 		(char_u *)"PAGE_UP", (char_u *)"PAGE_DOWN",
> 		(char_u *)"MOUSE"
> 	};
> 	return names;
> }
> 
> /*
335c502
< 	int		c;
---
> 	int		oldState;
342a510
> 		msg_didout = TRUE;			/* assume that line is not empty */
345a514
> 	msg_didany = TRUE;			/* remember that something was outputted */
361a531
> 			dont_wait_return = FALSE;	/* may need wait_return in main() */
369,378c539,572
< 				windgoto((int)Rows - 1, 0);
< 				outstr((char_u *)"-- more --");
< 				c = vgetc();
< 				if (c == CR || c == NL)
< 					lines_left = 1;
< 				else if (c == 'q' || c == Ctrl('C'))
< 					got_int = TRUE;
< 				else
< 					lines_left = Rows - 1;
< 				outstr((char_u *)"\r          ");
---
> 				oldState = State;
> 				State = ASKMORE;
> 				screen_start();
> 				msg_moremsg();
> 				for (;;)
> 				{
> 					switch (vgetc())
> 					{
> 					case CR:			/* one extra line */
> 					case NL:
> 					case K_DARROW:
> 						lines_left = 1;
> 						break;
> 					case 'q':			/* quit */
> 					case Ctrl('C'):
> 						got_int = TRUE;
> 						quit_more = TRUE;
> 						break;
> 					case 'd':			/* Down half a page */
> 						lines_left = Rows / 2;
> 						break;
> 					case ' ':			/* one extra page */
> 					case K_PAGEDOWN:
> 						lines_left = Rows - 1;
> 						break;
> 					default:			/* no valid response */
> 						continue;
> 					}
> 					break;
> 				}
> 				screen_fill(Rows - 1, Rows, 0, (int)Columns, ' ', ' ');
> 				State = oldState;
> 				if (quit_more)
> 					return;			/* the string is not displayed! */
383a578
> 			msg_didout = FALSE;			/* remember that line is empty */
388a584
> 			msg_didout = TRUE;			/* remember that line is not empty */
399a596,611
> 	void
> msg_moremsg()
> {
> 	/*
> 	 * Need to restore old highlighting when we've finished with it
> 	 * because the output that's paging may be relying on it not
> 	 * changing -- webb
> 	 */
> 	remember_highlight();
> 	set_highlight('m');
> 	start_highlight();
> 	screen_msg((char_u *)"-- More -- (RET: line, SPACE: page, d: half page, q: quit)", (int)Rows - 1, 0);
> 	stop_highlight();
> 	recover_old_highlight();
> }
> 
407c619
< 	if (!screen_valid())
---
> 	if (not_full_screen || !screen_valid())
423c635
< msg_ceol()
---
> msg_clr_eos()
439d650
< 	lines_left = -1;
448d658
< 		msg_outchar('\n');
463d672
< 	lines_left = -1;
466,467c675
< 		if (must_redraw < NOT_VALID)
< 			must_redraw = NOT_VALID;
---
> 		redraw_later(NOT_VALID);
Index: ./src/misccmds.c
diff -r ../vim3.0/src/misccmds.c ./src/misccmds.c
17a18
> static int prefix_in_list __ARGS((char_u *, char_u *));
79c80,81
<  * Add a blank line below or above the current line.
---
>  * Add a new line below or above the current line.
>  * Caller must take care of undo.
85,91c87,93
< Opencmd(dir, redraw, delspaces)
< 	int 		dir;
< 	int			redraw;
< 	int			delspaces;
< {
< 	char_u   *ptr, *p_extra;
< 	FPOS	old_cursor; 			/* old cursor position */
---
> Opencmd(dir, redraw)
> 	int 		dir;			/* FORWARD or BACKWARD */
> 	int			redraw;			/* redraw afterwards */
> {
> 	char_u  *saved_line;		/* copy of the original line */
> 	char_u	*p_extra;
> 	FPOS	old_cursor; 		/* old cursor position */
94,95c96,97
< 	int		n;
< 	int		truncate = FALSE;	/* truncate current line afterwards */
---
> 	int		n = 0;				/* init for gcc */
> 	int		trunc_line = FALSE;	/* truncate current line afterwards */
97a100,106
> 	int		lead_len;
> 	char_u	*leader = NULL;
> 	char_u	*allocated = NULL;
> 	char_u	*p;
> 	int		saved_char;
> 	int		temp;
> 	FPOS	*pos;
99,100c108,112
< 	ptr = strsave(ml_get(curwin->w_cursor.lnum));
< 	if (ptr == NULL)			/* out of memory! */
---
> 	/*
> 	 * make a copy of the current line so we can mess with it
> 	 */
> 	saved_line = strsave(ml_get(curwin->w_cursor.lnum));
> 	if (saved_line == NULL)			/* out of memory! */
102a115,118
> 	saved_char = saved_line[curwin->w_cursor.col];
> 	if (State == INSERT || State == REPLACE)
> 		saved_line[curwin->w_cursor.col] = NUL;
> 
116,117c132,133
< 			 * If we just did an auto-indent, then we didn't type anything on the
< 			 * prior line, and it should be truncated.
---
> 			 * If we just did an auto-indent, then we didn't type anything on
> 			 * the prior line, and it should be truncated.
120,121c136,137
< 			truncate = TRUE;
< 		else if (curbuf->b_p_si && *ptr != NUL)
---
> 			trunc_line = TRUE;
> 		else if (curbuf->b_p_si && *saved_line != NUL)
123d138
< 			char_u	*p;
125c140
< 			int		i, save;
---
> 			int		i;
129,130c144,146
< 				p = ptr + STRLEN(ptr) - 1;
< 				while (p > ptr && isspace(*p))	/* find last non-blank in line */
---
> 				p = saved_line + STRLEN(saved_line) - 1;
> 											/* find last non-blank in line */
> 				while (p > saved_line && isspace(*p))
132c148
< 				if (*p == '{')					/* line ends in '{': do indent */
---
> 				if (*p == '{')				/* line ends in '{': do indent */
134,135c150,151
< 					did_si = TRUE;
< 					no_si = TRUE;
---
> 					did_si = TRUE;			/* do indent */
> 					no_si = TRUE;			/* don't delete it when '{' typed */
137c153
< 				else							/* look for "if" and the like */
---
> 				else						/* look for "if" and the like */
139,140c155,156
< 					p = ptr;
< 					skipspace(&p);
---
> 					p = saved_line;
> 					skipwhite(&p);
143c159
< 					if (!isidchar(*pp))			/* careful for vars starting with "if" */
---
> 					if (!isidchar(*pp))		/* careful for vars starting with "if" */
145c161
< 						save = *pp;
---
> 						temp = *pp;
153c169
< 						*pp = save;
---
> 						*pp = temp;
159,160c175,176
< 				p = ptr;
< 				skipspace(&p);
---
> 				p = saved_line;
> 				skipwhite(&p);
168a185,223
> 	p_extra = NULL;
> 	lead_len = get_leader_len(saved_line);
> 	if (lead_len > 0)
> 	{
> 		for (n = 0; iswhite(saved_line[n]); n++)
> 			;
> 		if (saved_line[n] == '/' && saved_line[n + 1] == '*')
> 		{
> 			if (dir == FORWARD)
> 				n++;
> 			else
> 				lead_len = 0;
> 		}
> 		if (saved_line[n] == '*' && dir == FORWARD)
> 		{
> 			for (p = saved_line + n + 1; *p; p++)
> 			{
> 				if (*p == '/' && p[-1] == '*')
> 				{
> 					/* We have finished a C comment, so do a normal indent to
> 					 * align with the line containing the start of the
> 					 * comment -- webb.
> 					 */
> 					lead_len = 0;
> 					old_cursor = curwin->w_cursor;
> 					curwin->w_cursor.col = p - saved_line;
> 					if ((pos = findmatch(NUL)) != NULL)
> 					{
> 						curwin->w_cursor.lnum = pos->lnum;
> 						newindent = get_indent();
> 					}
> 					curwin->w_cursor = old_cursor;
> 					break;
> 				}
> 			}
> 		}
> 	}
> 	saved_line[curwin->w_cursor.col] = saved_char;
> 
171,173c226,257
< 		p_extra = ptr + curwin->w_cursor.col;
< 		if (curbuf->b_p_ai && delspaces)
< 			skipspace(&p_extra);
---
> 		p_extra = saved_line + curwin->w_cursor.col;
> 		if (curwin->w_cursor.col < lead_len)
> 			lead_len = curwin->w_cursor.col;
> 		if (lead_len > 0)
> 		{
> 				/* save comment leader in leader[] */
> 			leader = allocated = alloc(lead_len + STRLEN(p_extra) + 2);
> 			if (leader != NULL)
> 			{
> 				STRNCPY(leader, saved_line, lead_len);
> 				leader[lead_len] = NUL;
> 				did_si = can_si = FALSE;
> 			}
> 		}
> 		/*
> 		 * When 'ai' set, skip to the first non-blank.
> 		 *
> 		 * When in REPLACE mode, put the deleted blanks on the replace
> 		 * stack, followed by a NUL, so they can be put back when
> 		 * a BS is entered.
> 		 */
> 		if (State == REPLACE)
> 			replace_push(NUL);		/* end of extra blanks */
> 		if (curbuf->b_p_ai)
> 		{
> 			while (*p_extra == ' ' || *p_extra == '\t')
> 			{
> 				if (State == REPLACE)
> 					replace_push(*p_extra);
> 				++p_extra;
> 			}
> 		}
177c261,309
< 	else
---
> 	else if (lead_len > 0)
> 	{
> 		leader = allocated = alloc(lead_len + 2);
> 		if (leader != NULL)
> 		{
> 			STRNCPY(leader, saved_line, lead_len);
> 			leader[lead_len] = NUL;
> 			did_si = can_si = FALSE;
> 		}
> 	}
> 
> 	if (leader != NULL)
> 	{
> 		if (n > 0 && !iswhite(leader[n - 1]))
> 		{
> 			leader[n - 1] = ' ';		/* replace "/" before "*" with " " */
> 			newindent++;
> 		}
> 		/*
> 		 * When doing 'O' on the end of a comment, replace the '/' after the
> 		 * '*' with a space.
> 		 */
> 		if (leader[n] == '*' && leader[n + 1] == '/')
> 			leader[n + 1] = ' ';
> 
> 		/*
> 		 * if the leader ends in '*' make sure there is a space after it
> 		 */
> 		if (lead_len > 1 && leader[lead_len - 1] == '*')
> 		{
> 			leader[lead_len++] = ' ';
> 			leader[lead_len] = NUL;
> 		}
> 		newcol = lead_len - n;
> 		/*
> 		 * if a new indent will be set below, remove the indent that is in
> 		 * the comment leader
> 		 */
> 		if (newindent || did_si)
> 		{
> 			while (lead_len && iswhite(*leader))
> 			{
> 				--lead_len;
> 				++leader;
> 			}
> 		}
> 	}
> 
> 	if (p_extra == NULL)
179a312,318
> 		/* concatenate leader and p_extra, if there is a leader */
> 	if (leader)
> 	{
> 		STRCAT(leader, p_extra);
> 		p_extra = leader;
> 	}
> 
196c335,342
< 		newcol = curwin->w_cursor.col;
---
> 		/*
> 		 * In REPLACE mode the new indent must be put on
> 		 * the replace stack for when it is deleted with BS
> 		 */
> 		if (State == REPLACE)
> 			for (n = 0; n < curwin->w_cursor.col; ++n)
> 				replace_push(NUL);
> 		newcol += curwin->w_cursor.col;
199a346,353
> 	/*
> 	 * In REPLACE mode the extra leader must be put on the replace stack for
> 	 * when it is deleted with BS.
> 	 */
> 	if (State == REPLACE)
> 		while (lead_len-- > 0)
> 			replace_push(NUL);
> 
204c358
< 		if (truncate || State == INSERT || State == REPLACE)
---
> 		if (trunc_line || State == INSERT || State == REPLACE)
206,207c360,366
< 			if (truncate)
< 				*ptr = NUL;
---
> 			if (trunc_line)
> 			{
> 					/* find start of trailing white space */
> 				for (n = strlen(saved_line); n > 0 && iswhite(saved_line[n - 1]); --n)
> 					;
> 				saved_line[n] = NUL;
> 			}
209,211c368,370
< 				*(ptr + curwin->w_cursor.col) = NUL;	/* truncate current line at cursor */
< 			ml_replace(curwin->w_cursor.lnum, ptr, FALSE);
< 			ptr = NULL;
---
> 				*(saved_line + curwin->w_cursor.col) = NUL;	/* truncate current line at cursor */
> 			ml_replace(curwin->w_cursor.lnum, saved_line, FALSE);
> 			saved_line = NULL;
255c414,415
< 	free(ptr);
---
> 	free(saved_line);
> 	free(allocated);
259a420,509
>  * get_leader_len() returns the length of the prefix of the given string
>  * which introduces a comment.  If this string is not a comment then 0 is
>  * returned.  If the FO_COMS_PADDED character in p_fo is present, then
>  * comments must be followed by at least one space or tab.
>  */
> 	int
> get_leader_len(str)
> 	char_u	*str;
> {
> 	int		len;
> 	int		i;
> 	int		got_com = FALSE;
> 
> 	if (!fo_do_comments)		/* don't format comments at all */
> 		return 0;
> 	for (i = 0; str[i]; )
> 	{
> 		if (iswhite(str[i]))
> 		{
> 			++i;
> 			continue;
> 		}
> 		if (!got_com && (len = prefix_in_list(str + i, curbuf->b_p_com)) > 0)
> 		{
> 			got_com = TRUE;
> 			i += len;
> 			break;
> 		}
> 		else if ((len = prefix_in_list(str + i, curbuf->b_p_ncom)) > 0)
> 		{
> 			got_com = TRUE;
> 			i += len;
> 		}
> 		else
> 			break;
> 	}
> 	return (got_com ? i : 0);
> }
> 
> /*
>  * Check whether any word in 'list' is a prefix for 'str'.  Return 0 if no
>  * word is a prefix, or the length of the prefix otherwise.
>  * 'list' must be a comma separated list of strings. The strings cannot
>  * contain a comma.
>  */
> 	static int
> prefix_in_list(str, list)
> 	char_u	*str;
> 	char_u	*list;
> {
> 	int		len;
> 	int		found;
> 
> 	if (list == NULL)		/* can happen if option is not set */
> 		return 0;
> 	while (*list)
> 	{
> 		found = TRUE;
> 		for (len = 0; *list && *list != ','; ++len, ++list)
> 		{
> 		    /*
> 		     * If string contains a ' ', accept any non-empty sequence of
> 		     * blanks, and end-of-line.
> 		     */
> 		    if (*list == ' ' && (iswhite(str[len]) || str[len] == NUL))
> 		    {
> 		  	    while (iswhite(str[len]))
> 			  	    ++len;
> 				while (*list == ' ')
> 					++list;
> 			    if (*list == NUL || *list == ',')
> 				    break;
> 		    }
> 		    if (str[len] != *list)
> 			    found = FALSE;
> 	    }
> 	    if (found)
> 	    {
> 		    /* Match with any trailing blanks */
> 		    while (iswhite(str[len]))
> 			    ++len;
> 		    return len;
> 	    }
> 		if (*list == ',')
> 			++list;
> 	}
> 	return 0;
> }
> 
> /*
285,286c535
< 	while (*s != NUL)
< 		col += chartabsize(*s++, col);
---
> 	col = linetabsize(s);
330c579,580
<  * insert or replace a single character at the cursor position
---
>  * Insert or replace a single character at the cursor position.
>  * When in REPLACE mode, replace any existing character.
337d586
< 	int				rir0;		/* reverse replace in column 0 */
348,349c597
< 	rir0 = (State == REPLACE && p_ri && col == 0);
< 	if (rir0 || State != REPLACE || *(old + col) == NUL)
---
> 	if (State != REPLACE || *(old + col) == NUL)
354c602,610
< 	new = alloc((unsigned)(oldlen + extra));
---
> 	/*
> 	 * a character has to be put on the replace stack if there is a
> 	 * character that is replaced, so it can be put back when BS is used.
> 	 * Otherwise a 0 is put on the stack, indicating that a new character
> 	 * was inserted, which can be deleted when BS is used.
> 	 */
> 	if (State == REPLACE)
> 		replace_push(!extra ? *(old + col) : 0);
> 	new = alloc_check((unsigned)(oldlen + extra));
360,365d615
< 	if (rir0)					/* reverse replace in column 0 */
< 	{
< 		*(p + 1) = c;			/* replace the char that was in column 0 */
< 		c = ' ';				/* insert a space */
< 		extraspace = TRUE;
< 	}
370c620
< 	 * If we're in insert mode and showmatch mode is set, then check for
---
> 	 * If we're in insert or replace mode and 'showmatch' is set, then check for
375,396c625,627
< 	if (p_sm && State == INSERT && (c == ')' || c == '}' || c == ']'))
< 	{
< 		FPOS		   *lpos, csave;
< 
< 		if ((lpos = showmatch(NUL)) == NULL)		/* no match, so beep */
< 			beep();
< 		else if (lpos->lnum >= curwin->w_topline)
< 		{
< 			updateScreen(VALID_TO_CURSCHAR); /* show the new char first */
< 			csave = curwin->w_cursor;
< 			curwin->w_cursor = *lpos; 	/* move to matching char */
< 			cursupdate();
< 			showruler(0);
< 			setcursor();
< 			cursor_on();		/* make sure that the cursor is shown */
< 			flushbuf();
< 			vim_delay();		/* brief pause */
< 			curwin->w_cursor = csave; 	/* restore cursor position */
< 			cursupdate();
< 		}
< 	}
< 	if (!p_ri)							/* normal insert: cursor right */
---
> 	if (p_sm && (State & INSERT) && (c == ')' || c == '}' || c == ']'))
> 		showmatch();
> 	if (!p_ri || State == REPLACE)		/* normal insert: cursor right */
398,399d628
< 	else if (State == REPLACE && !rir0)	/* reverse replace mode: cursor left */
< 		--curwin->w_cursor.col;
404c633,634
<  * insert a string at the cursor position
---
>  * Insert a string at the cursor position.
>  * Note: Nothing special for replace mode.
418c648
< 	new = alloc((unsigned)(oldlen + newlen + 1));
---
> 	new = alloc_check((unsigned)(oldlen + newlen + 1));
451c681
<  * If the old line has been allocated the deleteion can be done in the
---
>  * If the old line has been allocated the deletion can be done in the
470c700
< 	 * want to end up positioned at the newline.
---
> 	 * want to end up positioned at the NUL.
499c729
< 	if (undo && !u_savedel(curwin->w_cursor.lnum, nlines))
---
> 	if (undo && u_savedel(curwin->w_cursor.lnum, nlines) == FAIL)
517c747
< 		ml_delete(curwin->w_cursor.lnum);
---
> 		ml_delete(curwin->w_cursor.lnum, TRUE);
578c808
<  * skipspace: skip over ' ' and '\t'.
---
>  * skipwhite: skip over ' ' and '\t'.
583c813
< skipspace(pp)
---
> skipwhite(pp)
594c824
<  * skiptospace: skip over text until ' ' or '\t'.
---
>  * skiptowhite: skip over text until ' ' or '\t'.
599c829
< skiptospace(pp)
---
> skiptowhite(pp)
703,704c933,934
< 	if (i && must_redraw < NOT_VALID)		/* redraw later */
< 		must_redraw = NOT_VALID;
---
> 	if (i)
> 		redraw_later(NOT_VALID);
725c955
<  * ask for a reply from the user, a 'y' or a 'n'.
---
>  * Ask for a reply from the user, a 'y' or a 'n'.
727a958,959
>  * If direct is TRUE, don't use vgetc but GetChars, don't get characters from
>  * any buffers but directly from the user.
732,735c964,971
< ask_yesno(str)
< 	char_u *str;
< {
< 	int r = ' ';
---
> ask_yesno(str, direct)
> 	char_u	*str;
> 	int		direct;
> {
> 	int		r = ' ';
> 	char	buf[20];
> 	int		len = 0;
> 	int		idx = 0;
739c975
< 		(void)set_highlight('r');		/* same highlighting as for wait_return */
---
> 		(void)set_highlight('r');	/* same highlighting as for wait_return */
742,743c978,989
< 		r = vgetc();
< 		if (r == Ctrl('C'))
---
> 		if (direct)
> 		{
> 			if (idx >= len)
> 			{
> 				len = GetChars(&(buf[0]), 20, -1);
> 				idx = 0;
> 			}
> 			r = buf[idx++];
> 		}
> 		else
> 			r = vgetc();
> 		if (r == Ctrl('C') || r == ESC)
766,767c1012,1028
< 		smsg((char_u *)"%ld %s line%s %s", pn, n > 0 ? "more" : "fewer", plural(pn),
< 											got_int ? "(Interrupted)" : "");
---
> 	{
> 		sprintf((char_u *)msg_buf, (char_u *)"%ld %s line%s %s",
> 				pn, n > 0 ? "more" : "fewer", plural(pn),
> 				got_int ? "(Interrupted)" : "");
> 		if (msg(msg_buf) && !msg_scroll)
> 			keep_msg = msg_buf;
> 	}
> }
> 
> /*
>  * flush map and typeahead buffers and give a warning for an error
>  */
> 	void
> beep_flush()
> {
> 	flush_buffers(FALSE);
> 	beep();
776d1036
< 	flush_buffers(FALSE);		/* flush internal buffers */
798a1059,1060
>  * Note that IObuff must NOT be used as either src or dst!  This is because
>  * vimgetenv() may use IObuff to do its expansion.
810c1072,1073
< 	if (*src == '$' || (*src == '~' && STRCHR("/ \t\n", src[1]) != NULL))
---
> 	skipwhite(&src);
> 	while (*src && dstlen > 0)
812,836c1075
< /*
<  * The variable name is copied into dst temporarily, because it may be
<  * a string in read-only memory.
<  */
< 		if (*src == '$')
< 		{
< 			tail = src + 1;
< 			var = dst;
< 			c = dstlen - 1;
< 			while (c-- > 0 && *tail && isidchar(*tail))
< 				*var++ = *tail++;
< 			*var = NUL;
< /*
<  * It is possible that vimgetenv() uses IObuff for the expansion, and that the
<  * 'dst' is also IObuff. This works, as long as 'var' is the first to be copied
<  * to 'dst'!
<  */
< 			var = vimgetenv(dst);
< 		}
< 		else
< 		{
< 			var = vimgetenv((char_u *)"HOME");
< 			tail = src + 1;
< 		}
< 		if (var && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen))
---
> 		if (*src == '$' || (*src == '~' && STRCHR("/ \t\n", src[1]) != NULL))
838,840c1077,1102
< 			STRCPY(dst, var);
< 			STRCAT(dst, tail);
< 			return;
---
> 			/*
> 			 * The variable name is copied into dst temporarily, because it may
> 			 * be a string in read-only memory.
> 			 */
> 			if (*src == '$')
> 			{
> 				tail = src + 1;
> 				var = dst;
> 				c = dstlen - 1;
> 				while (c-- > 0 && *tail && isidchar(*tail))
> 					*var++ = *tail++;
> 				*var = NUL;
> 				var = vimgetenv(dst);
> 			}
> 			else
> 			{
> 				var = vimgetenv((char_u *)"HOME");
> 				tail = src + 1;
> 			}
> 			if (var && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen))
> 			{
> 				STRCPY(dst, var);
> 				dstlen -= STRLEN(var);
> 				dst += STRLEN(var);
> 				src = tail;
> 			}
841a1104,1107
> 		while (*src && *src != ' ' && --dstlen > 0)
> 			*dst++ = *src++;
> 		while (*src == ' ' && --dstlen > 0)
> 			*dst++ = *src++;
843c1109
< 	STRNCPY(dst, src, (size_t)dstlen);
---
> 	*dst = NUL;
867c1133
< 		skipspace(&src);
---
> 		skipwhite(&src);
924a1191,1192
> 	if (fname == NULL)
> 		return "";
948a1217,1305
> }
> 
> /*
>  * List the names of swap files in current directory and 'directory' option.
>  */
> 	void
> recover_list()
> {
> 	int			num_names = 1;
> 	char_u		*(names[1]);
> 	char_u		*p;
> 	int			num_files;
> 	char_u		**files;
> 	int			i;
> 	int			dir_num;
> 
> 	msg((char_u *)"Swap files found:");
> 	outchar('\n');
> 	expand_interactively = TRUE;
> 	for (dir_num = 0; dir_num <= 1; ++dir_num)
> 	{
> 		if (dir_num == 0)			/* check current dir */
> 			names[0] = (char_u *) "*.sw?";
> 		else						/* check 'directory' dir */
> 		{
> 			p = p_dir;
> 			if (*p == '>')
> 				++p;
> 			if (STRLEN(p) == 0)
> 				num_names = 0;
> 			else
> 			{
> 				names[0] = concat_fnames(p, (char_u *)"*.sw?");
> 				if (names[1] == NULL)
> 					num_names = 0;
> 			}
> 		}
> 
> 		if (dir_num == 0)
> 			outstrn("In current directory:\n");
> 		else
> 		{
> 			outstrn("In directory ");
> 			outstrn(p);
> 			outstrn(":\n");
> 		}
> 
> 		if (num_names == 0)
> 			num_files = 0;
> 		else if (ExpandWildCards(num_names, names,
> 							&num_files, &files, TRUE, FALSE) == FAIL)
> 		{
> 			outstrn((char_u *)files);		/* print error message */
> 			num_files = 0;
> 		}
> 		if (num_files)
> 		{
> 			for (i = 0; i < num_files; ++i)
> 			{
> 				outstrn(files[i]);
> 				outchar('\n');
> 			}
> 		}
> 		else
> 			outstrn((char_u *)"-- none --\n");
> 	}
> 	flushbuf();
> }
> 
> /*
>  * Concatenate filenames fname1 and fname2 into allocated memory.
>  * Only add a '/' when neccesary.
>  */
> 	char_u	*
> concat_fnames(fname1, fname2)
> 	char_u	*fname1;
> 	char_u	*fname2;
> {
> 	char_u	*dest;
> 
> 	dest = alloc((unsigned)(STRLEN(fname1) + STRLEN(fname2) + 2));
> 	if (dest != NULL)
> 	{
> 		STRCPY(dest, fname1);
> 		if (*dest && !ispathsep(*(dest + STRLEN(dest) - 1)))
> 			STRCAT(dest, PATHSEPSTR);
> 		STRCAT(dest, fname2);
> 	}
> 	return dest;
Index: ./src/msdos.c
diff -r ../vim3.0/src/msdos.c ./src/msdos.c
27a28
> static void show_mouse __ARGS((int));
46a48,53
> static int mouse_avail = FALSE;		/* mouse present */
> static int mouse_active;			/* mouse enabled */
> static int mouse_click = 0;			/* mouse status */
> static int mouse_x;					/* mouse x coodinate */
> static int mouse_y;					/* mouse y coodinate */
> 
167a175,176
> #define FOREVER 29999
> 
171a181,183
> 	static int	last_status = 0;
> 	union REGS	regs;
> 
174c186,200
< 		if ((p_biosk ? bioskey(1) : kbhit()) || cbrk_pressed)
---
> 		if (mouse_avail && mouse_active)
> 		{
> 			regs.x.ax = 3;
> 			int86(0x33, &regs, &regs);		/* check mouse status */
> 				/* only recognize button-down event */
> 			if (last_status == 0 && regs.x.bx != 0)
> 			{
> 				mouse_click = regs.x.bx;
> 				mouse_x = regs.x.cx / 8;
> 				mouse_y = regs.x.dx / 8;
> 			}
> 			last_status = regs.x.bx;
> 		}
> 
> 		if ((p_biosk ? bioskey(1) : kbhit()) || cbrk_pressed || mouse_click)
179c205,206
< 		msec -= POLL_SPEED;
---
> 		if (msec != FOREVER)
> 			msec -= POLL_SPEED;
213a241,242
> 	if (time != 0)
> 		show_mouse(TRUE);
216a246,247
> 		{
> 			show_mouse(FALSE);
217a249
> 		}
227a260
> 	WaitForChar(FOREVER);		/* wait for key or mouse click */
242c275,286
< 	if (p_biosk)
---
> 	if (mouse_click && maxlen >= 6)
> 	{
> 		len = 5;
> 		*buf++ = ESC + 128;
> 		*buf++ = 'M';
> 		*buf++ = mouse_click;
> 		*buf++ = mouse_x + '!';
> 		*buf++ = mouse_y + '!';
> 		mouse_click = 0;
> 	}
> 	else if (p_biosk)
> 	{
246,248c290,301
< 			if (c == 0)				/* ctrl-break */
< 				c = 3;				/* return a CTRL-C */
< 			if ((c & 0xff) == 0)
---
> 			/*
> 			 * translate a few things for inchar():
> 			 * 0x0000 == CTRL-break			-> 3	(CTRL-C)
> 			 * 0x0300 == CTRL-@     		-> NUL
> 			 * 0xnn00 == extended key code	-> K_NUL, nn
> 			 * K_NUL					  	-> K_NUL, 3
> 			 */
> 			if (c == 0)
> 				c = 3;
> 			else if (c == 0x0300)
> 				c = NUL;
> 			else if ((c & 0xff) == 0 || c == K_NUL)
250,253c303,305
< 				if (c == 0x0300)		/* CTRL-@ is 0x0300, translated into K_ZERO */
< 					c = K_ZERO;
< 				else		/* extended key code 0xnn00 translated into K_NUL, nn */
< 				{
---
> 				if (c == K_NUL)
> 					c = 3;
> 				else
255,257c307,308
< 					*buf++ = K_NUL;
< 					++len;
< 				}
---
> 				*buf++ = K_NUL;
> 				++len;
262a314
> 	}
263a316
> 	{
270a324,328
> 			case K_NUL:
> 					*buf++ = K_NUL;
> 					*buf++ = 3;
> 					++len;
> 					break;
277c335
< 			len++;
---
> 			++len;
278a337,338
> 	}
> 	show_mouse(FALSE);
297c357
< 	OUTSTR("new shell started\n");
---
> 	msg_outstr("new shell started\n");
307a368,369
> 	union REGS regs;
> 
310a373,400
> 
> /* find out if a MS mouse is available */
> 	regs.x.ax = 0;
> 	mouse_avail = int86(0x33, &regs, &regs);
> }
> 
> 	static void
> show_mouse(on)
> 	int		on;
> {
> 	static int		was_on = FALSE;
> 	union REGS		regs;
> 
> 	if (mouse_avail)
> 	{
> 		if (!mouse_active)
> 			on = FALSE;
> 		/*
> 		 * Careful: Each switch on must be compensated by exactly one switch
> 		 * off
> 		 */
> 		if (on && !was_on || !on && was_on)
> 		{
> 			was_on = on;
> 			regs.x.ax = on ? 1 : 2;
> 			int86(0x33, &regs, &regs);	/* show mouse */
> 		}
> 	}
564c654
< 	ml_close_all(); 				/* remove all memfiles */
---
> 	ml_close_all(TRUE);				/* remove all memfiles */
643a734,744
> 	if (!raw)
> 		setmouse(FALSE);			/* may switch mouse off */
> 	else
> 		setmouse(p_mouse);			/* may switch mouse on */
> }
> 
> 	void
> setmouse(on)
> 	int		on;
> {
> 	mouse_active = on;
705c806,811
< 	set_window();
---
> 	/*
> 	 * don't call set_window() when not doing full screen, since it will move
> 	 * the cursor.
> 	 */
> 	if (!not_full_screen)
> 		set_window();
761c867
< 	outchar('\n');
---
> 	msg_outchar('\n');
765d870
< #ifdef WEBB_COMPLETE
767,769d871
< #else
< 	if (x)
< #endif
771,772c873,874
< 		outnum((long)x);
< 		outstrn((char_u *)" returned\n");
---
> 		msg_outnum((long)x);
> 		msg_outstr((char_u *)" returned\n");
870c972
< 	int		lastn, c, r;
---
> 	int		lastn, c, retval;
909c1011
< 	r = 0;
---
> 	retval = 0;
929c1031
< 				r |= expandpath(fl, buf, fonly, donly, notf);
---
> 				retval |= expandpath(fl, buf, fonly, donly, notf);
934c1036
< 	return r;
---
> 	return retval;
950c1052
< 	int			i, r = 0;
---
> 	int			i, retval = 0;
960c1062
< 			r |= expandpath(&f, pat[i], files_only, 0, list_notfound);
---
> 			retval |= expandpath(&f, pat[i], files_only, 0, list_notfound);
962c1064
< 	if (r == 0)
---
> 	if (retval == 0)
970c1072
< 		*file = NULL;
---
> 		*file = (char_u **)"";			/* Sorry, no error message (yet) */
972c1074
< 	return (r ? FAIL : OK);
---
> 	return (retval ? FAIL : OK);
Index: ./src/msdos.h
diff -r ../vim3.0/src/msdos.h ./src/msdos.h
37a38,43
> #ifdef VIMINFO
> #ifndef VIMINFO_FILE
> # define VIMINFO_FILE	"$VIM\\viminfo"
> #endif
> #endif /* VIMINFO */
> 
65a72,77
> 
> /* codes for msdos mouse event */
> #define MOUSE_MASK		0x07
> #define MOUSE_LEFT		0x01
> #define MOUSE_RIGHT		0x02
> #define MOUSE_MIDDLE	0x04
Index: ./src/normal.c
diff -r ../vim3.0/src/normal.c ./src/normal.c
40d39
< int				redo_Visual_busy = FALSE;	/* TRUE when redo-ing a visual */
48,49d46
< extern int		restart_edit;	/* this is in edit.c */
< 
72a70,71
>  *   15. mouse click
>  *   16. The end (ESC)
89c88
< 	register char_u	*ptr;
---
> 	char_u			*ptr;
91d89
< 	static int		didwarn = FALSE;		/* warned for broken inversion */
93a92
> 	int				old_col = 0;
96,98c95,97
< 	static linenr_t	resel_Visual_nlines;		/* number of lines */
< 	static int		resel_Visual_type = 0;	/* type 'v', 'V' or CTRL-V */
< 	static colnr_t	resel_Visual_col;		/* number of columns or end column */
---
> 	static int		resel_Visual_mode = NUL;
> 	static linenr_t	resel_Visual_nlines;	/* number of lines */
> 	static colnr_t	resel_Visual_col;		/* number of cols or end column */
99a99
> 	static int		redo_Visual_mode = NUL;
101,102c101
< 	static int		redo_Visual_type = 0;	/* type 'v', 'V' or CTRL-V */
< 	static colnr_t	redo_Visual_col;		/* number of columns or end column */
---
> 	static colnr_t	redo_Visual_col;		/* number of cols or end column */
116,117c115
< 	if (p_sc && (vpeekc() == NUL || KeyTyped == TRUE))
< 		premsg(NUL, NUL);
---
> 	premsg(NUL, NUL);
123c121
< 	while ((c >= '1' && c <= '9') || (Prenum != 0 && (c == DEL || c == '0')))
---
> 	while ((c >= '1' && c <= '9') || (Prenum != 0 && (c == DEL || c == K_DEL || c == '0')))
125c123
< 		if (c == DEL)
---
> 		if (c == DEL || c == K_DEL)
179,180c177,179
< 	else if (strchr("@zZtTfF[]mg'`\"", c) || (c == 'q' && !Recording && !Exec_reg) ||
< 										(c == 'r' && !VIsual.lnum))
---
> 	else if (c < 0x100 && (strchr("@zZtTfF[]mg'`\"", c) ||
> 					(c == 'q' && !Recording && !Exec_reg) ||
> 									(c == 'r' && VIsual.lnum == 0)))
182,183c181,183
< 		State = NOMAPPING;
< 		nchar = vgetc();		/* no macro mapping for this char */
---
> 		State = ONLYKEY;
> 		nchar = vgetc();		/* no macro mapping for this char, but allow
> 								 * key codes */
187,188c187,190
< 		flushbuf();		/* flush the premsg() characters onto the screen so we can
< 							see them while the command is being executed */
---
> 		flushbuf();				/* flush the premsg() characters onto the
> 								 * screen so we can see them while the command
> 								 * is being executed
> 								 */
194c196
< 	if (STRCHR("z:/?", c) == NULL)
---
> 	if (c >= 0x100 || STRCHR("z:/?", c) == NULL)
254c256
< 		beginline(TRUE);
---
> 		beginline(MAYBE);
259a262
> 	  case K_PAGEUP:
263a267
> 	  case K_PAGEDOWN:
286c290
< 		if (isdigit(nchar))
---
> 		if (nchar < 0x100 && isdigit(nchar))
299c303
< 				if (nchar == DEL)
---
> 				if (nchar == DEL || c == K_DEL)
301c305
< 				else if (isdigit(nchar))
---
> 				else if (nchar < 0x100 && isdigit(nchar))
377c381
< 	    if (VIsual.lnum)
---
> 	    if (VIsual.lnum != 0)
392c396
< 		docmdline(NULL);
---
> 		docmdline(NULL, FALSE, FALSE);
408c412,413
< 		fileinfo(did_cd || Prenum);	/* print full name if count given or :cd used */
---
> 			/* print full name if count given or :cd used */
> 		fileinfo(did_cd || Prenum);
430a436
> 		if ((n = find_ident_under_cursor(&ptr, c == '*' || c == '#')) == 0)
432,457c438,440
< 			register int 	col;
< 			register int	i;
< 
< 			/*
< 			 * if i == 0: try to find an identifier
< 			 * if i == 1: try to find any string
< 			 */
< 			ptr = ml_get(curwin->w_cursor.lnum);
< 			for (i = 0;	i < 2; ++i)
< 			{
< 				/*
< 				 * skip to start of identifier/string
< 				 */
< 				col = curwin->w_cursor.col;
< 				while (ptr[col] != NUL &&
< 							(i == 0 ? !isidchar(ptr[col]) : iswhite(ptr[col])))
< 					++col;
< 
< 				/*
< 				 * Back up to start of identifier/string. This doesn't match the
< 				 * real vi but I like it a little better and it shouldn't bother
< 				 * anyone.
< 				 */
< 				while (col > 0 && (i == 0 ? isidchar(ptr[col - 1]) :
< 							(!iswhite(ptr[col - 1]) && !isidchar(ptr[col - 1]))))
< 					--col;
---
> 			CLEAROP;
> 			break;
> 		}
459,470c442,453
< 				/*
< 				 * if identifier found or not '*' or '#' command, stop searching
< 				 */
< 				if (isidchar(ptr[col]) || (c != '*' && c != '#'))
< 					break;
< 			}
< 			/*
< 			 * did't find an identifier of string
< 			 */
< 			if (ptr[col] == NUL || (!isidchar(ptr[col]) && i == 0))
< 			{
< 				CLEAROPBEEP;
---
> 		if (Prenum)
> 			stuffnumReadbuff(Prenum);
> 		switch (c)
> 		{
> 			case '*':
> 				stuffReadbuff((char_u *)"/");
> 				goto sow;
> 
> 			case '#':
> 				stuffReadbuff((char_u *)"?");
> sow:			if (isidchar(*ptr))
> 					stuffReadbuff((char_u *)"\\<");
472d454
< 			}
474,486c456,463
< 			if (Prenum)
< 				stuffnumReadbuff(Prenum);
< 			switch (c)
< 			{
< 				case '*':
< 					stuffReadbuff((char_u *)"/");
< 					goto sow;
< 
< 				case '#':
< 					stuffReadbuff((char_u *)"?");
< sow:				if (i == 0)
< 						stuffReadbuff((char_u *)"\\<");
< 					break;
---
> 			case 'K':
> 				stuffReadbuff((char_u *)":! ");
> 				stuffReadbuff(p_kp);
> 				stuffReadbuff((char_u *)" ");
> 				break;
> 			default:
> 				stuffReadbuff((char_u *)":ta ");
> 		}
488,495c465,469
< 				case 'K':
< 					stuffReadbuff((char_u *)":! ");
< 					stuffReadbuff(p_kp);
< 					stuffReadbuff((char_u *)" ");
< 					break;
< 				default:
< 					stuffReadbuff((char_u *)":ta ");
< 			}
---
> 		/*
> 		 * Now grab the chars in the identifier
> 		 */
> 		while (n--)
> 			stuffcharReadbuff(*ptr++);
497,509c471,473
< 			/*
< 			 * Now grab the chars in the identifier
< 			 */
< 			while (i == 0 ? isidchar(ptr[col]) :
< 								(ptr[col] != NUL && !iswhite(ptr[col])))
< 			{
< 				stuffcharReadbuff(ptr[col]);
< 				++col;
< 			}
< 			if ((c == '*' || c == '#') && i == 0)
< 				stuffReadbuff((char_u *)"\\>");
< 			stuffReadbuff((char_u *)"\n");
< 		}
---
> 		if ((c == '*' || c == '#') && isidchar(ptr[-1]))
> 			stuffReadbuff((char_u *)"\\>");
> 		stuffReadbuff((char_u *)"\n");
527c491
< 		beginline(TRUE);
---
> 		beginline(MAYBE);
541c505
< 		beginline(TRUE);
---
> 		beginline(MAYBE);
550c514
< 		beginline(TRUE);
---
> 		beginline(MAYBE);
577c541
< 					beep();
---
> 					beep_flush();
586c550
< 							beep();
---
> 							beep_flush();
597d560
< 	  case DEL:
609,610c572,573
< 				if ((((c == Ctrl('H') || c == DEL) && (p_ww & 1)) ||
< 					 (c == 'h' && (p_ww & 4)) ||
---
> 				if ((((c == Ctrl('H') || c == DEL || c == K_DEL) &&
> 							(p_ww & 1)) || (c == 'h' && (p_ww & 4)) ||
620c583
< 					beep();
---
> 					beep_flush();
667a631
> 		old_col = curwin->w_curswant;
671c635,637
< 		if (operator != YANK)			/* 'Y' does not move cursor */
---
> 		if (operator == DELETE || operator == LSHIFT || operator == RSHIFT)
> 			beginline(MAYBE);
> 		else if (operator != YANK)			/* 'Y' does not move cursor */
677c643
< 		mincl = TRUE;
---
> 		mincl = FALSE;
766a733
> 	  case K_END:
781a749
> 	  case K_HOME:
842c810
< 		if (!searchc(nchar, dir, type, Prenum1))
---
> 		if (nchar >= 0x100 || !searchc(nchar, dir, type, Prenum1))
871a840,869
> 		 * Find the occurence(s) of the identifier or define under cursor
> 		 * in current and included files or jump to the first occurence.
> 		 *
> 		 * 					search 		 list		    jump 
> 		 * 				  fwd   bwd    fwd   bwd     fwd    bwd
> 		 * identifier     "]i"  "[i"   "]I"  "[I"   "]^I"  "[^I"
> 		 * define		  "]d"  "[d"   "]D"  "[D"   "]^D"  "[^D"
> 		 */
> 		if (nchar == 'i' || nchar == 'I' || nchar == Ctrl('I') ||
> 			nchar == 'd' || nchar == 'D' || nchar == Ctrl('D'))
> 		{
> 			int			len;
> 
> 			if ((len = find_ident_under_cursor(&ptr, FALSE)) == 0)
> 			{
> 				CLEAROP;
> 				break;
> 			}
> 			find_pattern_in_path(ptr, len, TRUE,
> 				((nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,
> 				Prenum1,
> 				isupper(nchar) ? ACTION_SHOW_ALL :
> 							islower(nchar) ? ACTION_SHOW : ACTION_GOTO,
> 				c == ']' ? curwin->w_cursor.lnum : (linenr_t)1,
> 				(linenr_t)MAXLNUM);
> 			curwin->w_set_curswant = TRUE;
> 			break;
> 		}
> 
> 		/*
882c880
< 				if ((pos = showmatch(nchar)) == NULL)
---
> 				if ((pos = findmatch(nchar)) == NULL)
911,912c909,910
< 			 * Imitate strange vi behaviour: When using "]]" with an operator we
< 			 * also stop at '}'.
---
> 			 * Imitate strange vi behaviour: When using "]]" with an operator
> 			 * we also stop at '}'.
921c919
< 		 * "[p" and "]p": put with indent adjustment
---
> 		 * "[p", "[P", "]P" and "]p": put with indent adjustment
923c921
< 		if (nchar == 'p')
---
> 		if (nchar == 'p' || nchar == 'P')
925c923,926
< 			doput((c == ']') ? FORWARD : BACKWARD, Prenum1, TRUE);
---
> 			CHECKCLEAROPQ;
> 			prep_redo(Prenum, c, nchar, NUL);
> 			doput((c == ']' && nchar == 'p') ? FORWARD : BACKWARD,
> 															Prenum1, TRUE);
948c949
< 				beginline(TRUE);
---
> 				beginline(MAYBE);
954c955
< 			if ((pos = showmatch(NUL)) == NULL)
---
> 			if ((pos = findmatch(NUL)) == NULL)
998c999,1004
< 		if (start_redo(Prenum) == FAIL)
---
> 		/*
> 		 * if restart_edit is TRUE, the last but one command is repeated
> 		 * instead of the last command (inserting text). This is used for
> 		 * CTRL-O <.> in insert mode
> 		 */
> 		if (start_redo(Prenum, restart_edit && !arrow_used) == FAIL)
1004c1010
< 	    if (VIsual.lnum)
---
> 	    if (VIsual.lnum != 0)
1021c1027
< 	    if (VIsual.lnum)
---
> 	    if (VIsual.lnum != 0)
1030c1036
< 	    if (VIsual.lnum)
---
> 	    if (VIsual.lnum != 0)
1037c1043,1044
< 		if (STRLEN(ptr) < (unsigned)Prenum1)	/* not enough characters to replace */
---
> 			/* special key or not enough characters to replace */
> 		if (nchar >= 0x100 || STRLEN(ptr) < (unsigned)Prenum1)
1061,1063c1068
< 			nchar = get_literal(&type);
< 			if (type)						/* typeahead */
< 				stuffcharReadbuff(type);
---
> 			nchar = get_literal();
1068c1073
< 		if (!u_save_cursor())				/* save line for undo */
---
> 		if (u_save_cursor() == FAIL)		/* save line for undo */
1069a1075,1077
> 		curwin->w_cursor.col--;
> 		while (Prenum1--)					/* replace the characters */
> 		{
1071,1072c1079,1081
< 			 * Get ptr again, because u_save will have released the line.
< 			 * At the same time we let know that the line will be changed.
---
> 			 * Get ptr again, because u_save and/or showmatch() will have
> 			 * released the line.  At the same time we let know that the line
> 			 * will be changed.
1074,1077c1083,1087
< 		ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE) + curwin->w_cursor.col;
< 		curwin->w_cursor.col += Prenum1 - 1;
< 		while (Prenum1--)					/* replace the characters */
< 			*ptr++ = nchar;
---
> 			ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);
> 			ptr[++curwin->w_cursor.col] = nchar;
> 			if (p_sm && (nchar == ')' || nchar == '}' || nchar == ']'))
> 				showmatch();
> 		}
1081a1092
> 		set_last_insert(nchar);
1085,1095c1096,1097
< 	    if (VIsual.lnum)		/* join the visual lines */
< 		{
< 			if (curwin->w_cursor.lnum > VIsual.lnum)
< 			{
< 				Prenum = curwin->w_cursor.lnum - VIsual.lnum + 1;
< 				curwin->w_cursor.lnum = VIsual.lnum;
< 			}
< 			else
< 				Prenum = VIsual.lnum - curwin->w_cursor.lnum + 1;
< 			VIsual.lnum = 0;
< 		}
---
> 	    if (VIsual.lnum != 0)		/* join the visual lines */
> 			goto dooperator;
1099c1101
< 		if (curwin->w_cursor.lnum + Prenum - 1 > curbuf->b_ml.ml_line_count)	/* beyond last line */
---
> 		if (curwin->w_cursor.lnum + Prenum - 1 > curbuf->b_ml.ml_line_count)
1101c1103
< 			CLEAROPBEEP;
---
> 			CLEAROPBEEP;			/* beyond last line */
1141c1143
< 		if (u_save_cursor())
---
> 		if (u_save_cursor() == OK)
1145c1147
< 			startinsert(c, FALSE, Prenum1);
---
> 			command_busy = startinsert(c, FALSE, Prenum1);
1147d1148
< 			command_busy = TRUE;
1155a1157
> 	  case K_INS:
1157c1159
< 		if (u_save_cursor())
---
> 		if (u_save_cursor() == OK)
1159c1161
< 			startinsert(c, FALSE, Prenum1);
---
> 			command_busy = startinsert(c, FALSE, Prenum1);
1161d1162
< 			command_busy = TRUE;
1166c1167
< 	  	if (VIsual.lnum)	/* switch start and end of visual */
---
> 	  	if (VIsual.lnum != 0)	/* switch start and end of visual */
1171,1177c1172,1175
< 			if (VIsual.col != VISUALLINE)
< 			{
< 				n = VIsual.col;
< 				VIsual.col = curwin->w_cursor.col;
< 				curwin->w_cursor.col = (int)n;
< 				curwin->w_set_curswant = TRUE;
< 			}
---
> 			n = VIsual.col;
> 			VIsual.col = curwin->w_cursor.col;
> 			curwin->w_cursor.col = (int)n;
> 			curwin->w_set_curswant = TRUE;
1181,1182c1179,1184
< 		if (u_save(curwin->w_cursor.lnum, (linenr_t)(curwin->w_cursor.lnum + 1)) &&
< 							Opencmd(FORWARD, TRUE, TRUE))
---
> 		if (curbuf->b_p_fo != NULL &&
> 						STRCHR(curbuf->b_p_fo, FO_OPEN_COMS) != NULL)
> 			fo_do_comments = TRUE;
> 		if (u_save(curwin->w_cursor.lnum,
> 								(linenr_t)(curwin->w_cursor.lnum + 1)) == OK &&
> 						Opencmd(FORWARD, TRUE))
1184c1186
< 			startinsert('o', TRUE, Prenum1);
---
> 			command_busy = startinsert('o', TRUE, Prenum1);
1186d1187
< 			command_busy = TRUE;
1187a1189
> 		fo_do_comments = FALSE;
1192c1194,1198
< 		if (u_save((linenr_t)(curwin->w_cursor.lnum - 1), curwin->w_cursor.lnum) && Opencmd(BACKWARD, TRUE, TRUE))
---
> 		if (curbuf->b_p_fo != NULL &&
> 						STRCHR(curbuf->b_p_fo, FO_OPEN_COMS) != NULL)
> 			fo_do_comments = TRUE;
> 		if (u_save((linenr_t)(curwin->w_cursor.lnum - 1),
> 						curwin->w_cursor.lnum) == OK && Opencmd(BACKWARD, TRUE))
1194c1200
< 			startinsert('O', TRUE, Prenum1);
---
> 			command_busy = startinsert('O', TRUE, Prenum1);
1196d1201
< 			command_busy = TRUE;
1197a1203
> 		fo_do_comments = FALSE;
1201c1207
< 	    if (VIsual.lnum)
---
> 	    if (VIsual.lnum != 0)
1204c1210
< 			VIsual.col = VISUALLINE;
---
> 			Visual_mode = 'V';
1208c1214
< 		if (u_save_cursor())
---
> 		if (u_save_cursor() == OK)
1210c1216
< 			startinsert('R', FALSE, Prenum1);
---
> 			command_busy = startinsert('R', FALSE, Prenum1);
1212d1217
< 			command_busy = TRUE;
1224c1229
< 		if (!p_to && !VIsual.lnum)
---
> 		if (!p_to && VIsual.lnum == 0)
1234c1239
< 			if (!u_save_cursor())
---
> 			if (u_save_cursor() == FAIL)
1276a1282,1284
> 	  case DEL:
> 	  case K_DEL:
> 	  		c = 'x';			/* DEL key behaves like 'x' */
1284c1292
< 	  	if (VIsual.lnum)
---
> 	  	if (VIsual.lnum != 0)
1288,1289c1296,1298
< 			if (isupper(c) && !Visual_block)		/* uppercase means linewise */
< 				VIsual.col = VISUALLINE;
---
> 											/* uppercase means linewise */
> 			if (isupper(c) && Visual_mode != Ctrl('V'))
> 				Visual_mode = 'V';
1299,1300d1307
< 		if (c == 'Y' && p_ye)
< 			c = 'Z';
1302,1303c1309,1313
< 				static char_u *(ar[9]) = {(char_u *)"dl", (char_u *)"dh", (char_u *)"d$", (char_u *)"c$", (char_u *)"cl", (char_u *)"cc", (char_u *)"yy", (char_u *)"y$", (char_u *)":s\r"};
< 				static char_u *str = (char_u *)"xXDCsSYZ&";
---
> 				static char_u *(ar[8]) = {(char_u *)"dl", (char_u *)"dh",
> 										  (char_u *)"d$", (char_u *)"c$",
> 										  (char_u *)"cl", (char_u *)"cc",
> 										  (char_u *)"yy", (char_u *)":s\r"};
> 				static char_u *str = (char_u *)"xXDCsSY&";
1384d1393
< 		Visual_block = FALSE;
1386,1387c1395,1396
< 			/* stop Visual */
< 		if (VIsual.lnum)
---
> 			/* change Visual mode */
> 		if (VIsual.lnum != 0)
1389,1390c1398,1399
< 			VIsual.lnum = 0;
< 			updateScreen(NOT_VALID);		/* delete the inversion */
---
> 			Visual_mode = c;				/* may use another mode */
> 			update_curbuf(NOT_VALID);		/* update the inversion */
1392c1401
< 			/* start Visual */
---
> 			/* start Visual mode */
1395,1399c1404
< 			if (!didwarn && set_highlight('v') == FAIL)/* cannot highlight */
< 			{
< 				EMSG("Warning: terminal cannot highlight");
< 				didwarn = TRUE;
< 			}
---
> 			start_visual_highlight();
1402c1407
< 				if (!resel_Visual_type)		/* there is none */
---
> 				if (resel_Visual_mode == NUL)	/* there is none */
1404c1409
< 					beep();
---
> 					beep_flush();
1408c1413,1418
< 				if (resel_Visual_nlines > 1)
---
> 				/*
> 				 * For V and ^V, we multiply the number of lines even if there
> 				 * was only one -- webb
> 				 */
> 				if (resel_Visual_mode != 'v' || resel_Visual_nlines > 1)
> 				{
1410c1420,1424
< 				switch (resel_Visual_type)
---
> 					if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
> 						curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
> 				}
> 				Visual_mode = resel_Visual_mode;
> 				if (Visual_mode == 'v')
1412,1424c1426,1429
< 				case 'V':	VIsual.col = VISUALLINE;
< 							break;
< 
< 				case Ctrl('V'):
< 							Visual_block = TRUE;
< 							break;
< 
< 				case 'v':		
< 							if (resel_Visual_nlines <= 1)
< 								curwin->w_cursor.col += resel_Visual_col * Prenum - 1;
< 							else
< 								curwin->w_cursor.col = resel_Visual_col;
< 							break;
---
> 					if (resel_Visual_nlines <= 1)
> 						curwin->w_cursor.col += resel_Visual_col * Prenum - 1;
> 					else
> 						curwin->w_cursor.col = resel_Visual_col;
1431,1432c1436,1443
< 				else if (Visual_block)
< 					coladvance((colnr_t)(curwin->w_virtcol + resel_Visual_col * Prenum - 1));
---
> 				else if (Visual_mode == Ctrl('V'))
> 				{
> 					curwin->w_curswant = curwin->w_virtcol +
> 											resel_Visual_col * Prenum - 1;
> 					coladvance((colnr_t)curwin->w_curswant);
> 				}
> 				else
> 					curwin->w_set_curswant = TRUE;
1434c1445
< 				updateScreen(NOT_VALID);	/* show the inversion */
---
> 				update_curbuf(NOT_VALID);	/* show the inversion */
1439,1442c1450
< 				if (c == 'V')				/* linewise */
< 					VIsual.col = VISUALLINE;
< 				else if (c == Ctrl('V'))	/* blockwise */
< 					Visual_block = TRUE;
---
> 				Visual_mode = c;
1492c1500
< 							CLEAROPBEEP;
---
> 							CLEAROP;
1504a1513,1564
> 		/*
> 		 * "gd": Find first occurence of pattern under the cursor in the
> 		 *       current function
> 		 * "gD": idem, but in the current file.
> 		 */
> 			case 'd':
> 			case 'D':
> 				{
> 					int			len;
> 					char_u		*pat;
> 					FPOS		old_pos;
> 					int			t;
> 
> 					if ((len = find_ident_under_cursor(&ptr, FALSE)) == 0 ||
> 										(pat = alloc(len + 5)) == NULL)
> 					{
> 						CLEAROPBEEP;
> 						break;
> 					}
> 					sprintf((char *)pat, isidchar(*ptr) ? "\\<%.*s\\>" : "%.*s",
> 												len, ptr);
> 					old_pos = curwin->w_cursor;
> 					n = p_ws;
> 					p_ws = FALSE;		/* don't wrap around end of file now */
> 					fo_do_comments = TRUE;
> 					/*
> 					 * Search back for the end of the previous function.
> 					 * If this fails, and with "gD", go to line 1.
> 					 * Search forward for the identifier, ignore comment lines.
> 					 */
> 					if (nchar == 'D' || !findpar(BACKWARD, 1, '}', FALSE))
> 						curwin->w_cursor.lnum = 1;
> 
> 					while ((t = searchit(&curwin->w_cursor, FORWARD, pat,
> 												1, FALSE, FALSE, 2)) == OK &&
> 							get_leader_len(ml_get(curwin->w_cursor.lnum)) &&
> 							old_pos.lnum > curwin->w_cursor.lnum)
> 						++curwin->w_cursor.lnum;
> 					if (t == FAIL || old_pos.lnum <= curwin->w_cursor.lnum)
> 					{
> 						CLEAROPBEEP;
> 						curwin->w_cursor = old_pos;
> 					}
> 					else
> 						curwin->w_set_curswant = TRUE;
> 
> 					free(pat);
> 					p_ws = n;
> 					fo_do_comments = FALSE;
> 					break;
> 				}
> 
1511c1571,1674
<  * The end
---
>  * 15. mouse click
>  */
> #if defined(UNIX) || defined(MSDOS)
> 	  case K_MOUSE:
> 		{
> 			FPOS	start_visual;
> 			FPOS	end_visual;
> 			BUF		*save_buffer;
> 			int		diff;
> 
> 			mtype = MCHAR;
> 			mincl = TRUE;
> 			/*
> 			 * in visual mode: left click = set end of visual
> 			 *                 right click = change start or end of visual
> 			 * in normal mode: left click = set cursor position
> 			 *                 right click = start visual mode
> 			 */
> 			start_visual.lnum = 0;
> 			if (VIsual.lnum != 0)
> 			{
> 				if ((mouse_code & MOUSE_MASK) == MOUSE_LEFT)
> 				{
> 					VIsual.lnum = 0;
> 					update_curbuf(NOT_VALID);
> 				}
> 				else if ((mouse_code & MOUSE_MASK) == MOUSE_RIGHT)
> 				{
> 					/* remember the start and end of visual before moving the
> 					 * cursor */
> 					if (lt(curwin->w_cursor, VIsual))
> 					{
> 						start_visual = curwin->w_cursor;
> 						end_visual = VIsual;
> 					}
> 					else
> 					{
> 						start_visual = VIsual;
> 						end_visual = curwin->w_cursor;
> 					}
> 				}
> 			}
> 			else if ((mouse_code & MOUSE_MASK) == MOUSE_RIGHT)
> 			{
> 				start_visual_highlight();
> 				VIsual = curwin->w_cursor;
> 			}
> 			save_buffer = curbuf;
> 			jumpto(mouse_row, mouse_col);
> 				/* when jumping to another buffer, stop visual mode */
> 			if (curbuf != save_buffer && VIsual.lnum != 0)
> 			{
> 				VIsual.lnum = 0;
> 				update_curbuf(NOT_VALID);		/* delete the inversion */
> 			}
> 			else if (start_visual.lnum)		/* right click in visual mode */
> 			{
> 				/*
> 				 * If the click is before the start of visual, change the
> 				 * start.  If the click is after the end of visual, change the
> 				 * end.  If the click is insed the visual, change the the
> 				 * closest side.
> 				 */
> 				if (lt(curwin->w_cursor, start_visual))
> 					VIsual = end_visual;
> 				else if (lt(end_visual, curwin->w_cursor))
> 					VIsual = start_visual;
> 				else
> 				{
> 						/* in the same line, compare column number */
> 					if (end_visual.lnum == start_visual.lnum)
> 					{
> 						if (curwin->w_cursor.col - start_visual.col >
> 										end_visual.col - curwin->w_cursor.col)
> 							VIsual = start_visual;
> 						else
> 							VIsual = end_visual;
> 					}
> 						/* in different lines, compare line number */
> 					else
> 					{
> 						diff = (curwin->w_cursor.lnum - start_visual.lnum) -
> 									(end_visual.lnum - curwin->w_cursor.lnum);
> 						if (diff > 0)			/* closest to end */
> 							VIsual = start_visual;
> 						else if (diff < 0)		/* closest to start */
> 							VIsual = end_visual;
> 						else					/* in the middle line */
> 						{
> 							if (curwin->w_cursor.col < (start_visual.col +
> 														end_visual.col) / 2)
> 								VIsual = end_visual;
> 							else
> 								VIsual = start_visual;
> 						}
> 					}
> 				}
> 			}
> 		}
> 		break;
> #endif
> 
> /*
>  * 16. The end
1514c1677,1679
< 	    if (VIsual.lnum)
---
> 		/* Don't drop through and beep if we are canceling a command: */
> 		if (VIsual.lnum == 0 && (operator != NOP ||
> 									opnum || Prenum || yankbuffer))
1516,1517d1680
< 			VIsual.lnum = 0;			/* stop Visual */
< 			updateScreen(NOT_VALID);
1521,1522c1684
< 		/* Don't drop through and beep if we are canceling a command: */
< 		else if (operator != NOP || opnum || Prenum || yankbuffer)
---
> 	    if (VIsual.lnum != 0)
1523a1686,1687
> 			VIsual.lnum = 0;			/* stop Visual */
> 			update_curbuf(NOT_VALID);
1527c1691,1694
< 		/* FALLTHROUGH */
---
> 		/* ESC in normal mode: beep, but don't flush buffers */
> 		CLEAROP;
> 		beep();
> 		break;
1539c1706
< 	if (!finish_op && !operator && strchr("\"DCYSsXx.", c) == NULL)
---
> 	if (!finish_op && !operator && (c >= 0x100 || strchr("\"DCYSsXx.", c) == NULL))
1545c1712
< 	if ((VIsual.lnum || finish_op) && operator != NOP)
---
> 	if ((VIsual.lnum != 0 || finish_op) && operator != NOP)
1547c1714
< 		if (operator != YANK && !VIsual.lnum)		/* can't redo yank */
---
> 		if (operator != YANK && VIsual.lnum == 0)		/* can't redo yank */
1561c1728,1729
< 			switch (redo_Visual_type)
---
> 			Visual_mode = redo_Visual_mode;
> 			if (Visual_mode == 'v')
1563,1575c1731,1734
< 			case 'V':	VIsual.col = VISUALLINE;
< 						break;
< 
< 			case Ctrl('V'):
< 						Visual_block = TRUE;
< 						break;
< 
< 			case 'v':		
< 						if (redo_Visual_nlines <= 1)
< 							curwin->w_cursor.col += redo_Visual_col - 1;
< 						else
< 							curwin->w_cursor.col = redo_Visual_col;
< 						break;
---
> 				if (redo_Visual_nlines <= 1)
> 					curwin->w_cursor.col += redo_Visual_col - 1;
> 				else
> 					curwin->w_cursor.col = redo_Visual_col;
1588c1747,1748
< 		else if (VIsual.lnum)
---
> 		else if (VIsual.lnum != 0)
> 		{
1589a1750,1752
> 			if (Visual_mode == 'V')
> 				curbuf->b_startop.col = 0;
> 		}
1603c1766
< 		if (VIsual.lnum || redo_Visual_busy)
---
> 		if (VIsual.lnum != 0 || redo_Visual_busy)
1605c1768
< 			if (Visual_block)				/* block mode */
---
> 			if (Visual_mode == Ctrl('V'))		/* block mode */
1606a1770
> 				block_mode = TRUE;
1617,1618c1781,1785
< 					for (curwin->w_cursor.lnum = curbuf->b_startop.lnum; curwin->w_cursor.lnum <= curbuf->b_endop.lnum; ++curwin->w_cursor.lnum)
< 						if ((n = getvcol(curwin, &curwin->w_cursor, 3)) > endvcol)
---
> 					for (curwin->w_cursor.lnum = curbuf->b_startop.lnum;
> 							curwin->w_cursor.lnum <= curbuf->b_endop.lnum;
> 													++curwin->w_cursor.lnum)
> 						if ((n = getvcol(curwin, &curwin->w_cursor, 3)) >
> 														endvcol)
1638,1643c1805
< 			if (Visual_block)
< 				resel_Visual_type = Ctrl('V');
< 			else if (VIsual.col == VISUALLINE)
< 				resel_Visual_type = 'V';
< 			else
< 				resel_Visual_type = 'v';
---
> 			resel_Visual_mode = Visual_mode;
1646c1808
< 			else if (Visual_block)
---
> 			else if (Visual_mode == Ctrl('V'))
1651c1813,1814
< 				resel_Visual_col = curbuf->b_endop.col - curbuf->b_startop.col + 1;
---
> 				resel_Visual_col = curbuf->b_endop.col -
> 											curbuf->b_startop.col + 1;
1653c1816,1817
< 			if (operator != YANK && operator != COLON)	/* can't redo yank and : */
---
> 												/* can't redo yank and : */
> 			if (operator != YANK && operator != COLON)
1656c1820
< 				redo_Visual_type = resel_Visual_type;
---
> 				redo_Visual_mode = resel_Visual_mode;
1668c1832
< 			if (VIsual.col == VISUALLINE)
---
> 			if (Visual_mode == 'V')
1694c1858,1859
< 		no_op = (mtype == MCHAR && !mincl && equal(curbuf->b_startop, curbuf->b_endop));
---
> 		no_op = (mtype == MCHAR && !mincl &&
> 								equal(curbuf->b_startop, curbuf->b_endop));
1702c1867,1868
< 		if (mtype == MCHAR && mincl == FALSE && curbuf->b_endop.col == 0 && nlines > 1)
---
> 		if (mtype == MCHAR && mincl == FALSE &&
> 										curbuf->b_endop.col == 0 && nlines > 1)
1725a1892,1903
> 		  case JOIN:
> 			if (nlines < 2)
> 				nlines = 2;
> 			if (curwin->w_cursor.lnum + nlines - 1 > curbuf->b_ml.ml_line_count)
> 				beep_flush();
> 			else
> 			{
> 				dodojoin(nlines, TRUE, TRUE);
> 				modified = TRUE;
> 			}
> 			break;
> 
1740c1918
< 			dochange();
---
> 			command_busy = dochange();
1742d1919
< 			command_busy = TRUE;
1746c1923
< 			bangredo = TRUE;			/* dobang() will put cmd in redo buffer */
---
> 			bangredo = TRUE;		/* dobang() will put cmd in redo buffer */
1751c1928,1930
< 			sprintf((char *)IObuff, ":%ld,%ld", (long)curbuf->b_startop.lnum, (long)curbuf->b_endop.lnum);
---
> 			sprintf((char *)IObuff, ":%ld,%ld",
> 						(long)curbuf->b_startop.lnum,
> 						(long)curbuf->b_endop.lnum);
1787a1967,1972
> 		/*
> 		 * if 'sol' not set, go back to old column for some commands
> 		 */
> 		if (!p_sol && mtype == MLINE && (operator == LSHIFT ||
> 								operator == RSHIFT || operator == DELETE))
> 			coladvance(curwin->w_curswant = old_col);
1789c1974,1975
< 		Visual_block = FALSE;
---
> 		VIsual.lnum = 0;
> 		block_mode = FALSE;
1796c1982,1983
< 	if (restart_edit && operator == NOP && VIsual.lnum == 0 && !command_busy && stuff_empty() && yankbuffer == 0)
---
> 	if (restart_edit && operator == NOP && VIsual.lnum == 0
> 					&& !command_busy && stuff_empty() && yankbuffer == 0)
1798c1985
< 		startinsert(restart_edit, FALSE, 1L);
---
> 		(void)startinsert(restart_edit, FALSE, 1L);
1820a2008,2091
> /*
>  * start highlighting for visual mode
>  */
> 	void
> start_visual_highlight()
> {
> 	static int		didwarn = FALSE;		/* warned for broken inversion */
> 
> 	if (!didwarn && set_highlight('v') == FAIL)/* cannot highlight */
> 	{
> 		EMSG("Warning: terminal cannot highlight");
> 		didwarn = TRUE;
> 	}
> }
> 
> /*
>  * Find the identifier under or to the right of the cursor.  If none is
>  * found and try_string is TRUE, then find any non-white string.  The length
>  * of the string is returned, or zero if no string is found.  If a string is
>  * found, a pointer to the string is put in *string, but note that the caller
>  * must use the length returned as this string may not be NUL terminated.
>  */
> 	int
> find_ident_under_cursor(string, try_string)
> 	char_u	**string;
> 	int		try_string;
> {
> 	char_u	*ptr;
> 	int		col;
> 	int		i;
> 
> 	/*
> 	 * if i == 0: try to find an identifier
> 	 * if i == 1: try to find any string
> 	 */
> 	ptr = ml_get(curwin->w_cursor.lnum);
> 	for (i = 0;	i < 2; ++i)
> 	{
> 		/*
> 		 * skip to start of identifier/string
> 		 */
> 		col = curwin->w_cursor.col;
> 		while (ptr[col] != NUL &&
> 					(i == 0 ? !isidchar(ptr[col]) : iswhite(ptr[col])))
> 			++col;
> 
> 		/*
> 		 * Back up to start of identifier/string. This doesn't match the
> 		 * real vi but I like it a little better and it shouldn't bother
> 		 * anyone.
> 		 */
> 		while (col > 0 && (i == 0 ? isidchar(ptr[col - 1]) :
> 					(!iswhite(ptr[col - 1]) && !isidchar(ptr[col - 1]))))
> 			--col;
> 
> 		/*
> 		 * if we don't want just any old string, or we've found an identifier,
> 		 * stop searching.
> 		 */
> 		if (!try_string || isidchar(ptr[col]))
> 			break;
> 	}
> 	/*
> 	 * didn't find an identifier or string
> 	 */
> 	if (ptr[col] == NUL || (!isidchar(ptr[col]) && i == 0))
> 	{
> 		if (try_string)
> 			EMSG("No identifier or string under cursor");
> 		else
> 			EMSG("No identifier under cursor");
> 		return 0;
> 	}
> 	ptr += col;
> 	*string = ptr;
> 	col = 0;
> 	while (i == 0 ? isidchar(*ptr) : (*ptr != NUL && !iswhite(*ptr)))
> 	{
> 		++ptr;
> 		++col;
> 	}
> 	return col;
> }
> 
1875c2146
< 	beep();
---
> 	beep_flush();
1889c2160
< 	if (!p_sc || !(KeyTyped || c1 == -1 || c1 == ' '))
---
> 	if (!(p_sc && (!char_avail() || KeyTyped || c1 == -1 || c1 == ' ')))
Index: ./src/ops.c
diff -r ../vim3.0/src/ops.c ./src/ops.c
30c30,31
< } y_buf[36];					/* 0..9 = number buffers, 10..35 = char buffers */
---
> } y_buf[37];					/* 0..9 = number registers, 10..35 = char
> 								 * registers, 36 = delete register */
40a42
> static int		same_leader __ARGS((char_u *, char_u *, int));
61c63,64
< 	if (!u_save((linenr_t)(curwin->w_cursor.lnum - 1), (linenr_t)(curwin->w_cursor.lnum + nlines)))
---
> 	if (u_save((linenr_t)(curwin->w_cursor.lnum - 1),
> 					(linenr_t)(curwin->w_cursor.lnum + nlines)) == FAIL)
74c77
< 			/* if (Visual_block)
---
> 			/* if (block_mode)
82a86
> 	{
83a88,89
> 		beginline(MAYBE);	/* shift_line() may have changed cursor.col */
> 	}
144c150
< is_yank_buffer(c, write)
---
> is_yank_buffer(c, writing)
146c152
< 	int		write;		/* if TRUE check for writable buffers */
---
> 	int		writing;		/* if TRUE check for writable buffers */
148c154,156
< 	if (isalnum(c) || (!write && strchr(".%:", c) != NULL) || c == '"')
---
> 	if (c >= 0x100)
> 		return FALSE;
> 	if (isalnum(c) || (!writing && strchr(".%:", c) != NULL) || c == '"' || c == '-')
181c189,191
< 	else			/* not 0-9, a-z or A-Z: use buffer 0 */
---
> 	else if (yankbuffer == '-')
> 		i = 36;
> 	else				/* not 0-9, a-z, A-Z or '-': use buffer 0 */
203c213,214
< 		if (!isalnum(c) && c != '"')	/* registers 0-9, a-z and " are allowed */
---
> 						/* registers 0-9, a-z and " are allowed */
> 		if (c >= 0x100 || (!isalnum(c) && c != '"'))
264c275,276
< 		if ((y_current->y_array = (char_u **)alloc((unsigned)sizeof(char_u *))) == NULL)
---
> 		if ((y_current->y_array =
> 						(char_u **)alloc((unsigned)sizeof(char_u *))) == NULL)
301c313
< 		free(new_last_cmdline);		/* don't keep the command line containing @: */
---
> 		free(new_last_cmdline);		/* don't keep the cmdline containing @: */
303c315
< 		if (ins_typestr((char_u *)"\n", FALSE) == FAIL)
---
> 		if (ins_typestr((char_u *)"\n", FALSE, 0, TRUE) == FAIL)
305c317
< 		if (ins_typestr(last_cmdline, FALSE) == FAIL)
---
> 		if (ins_typestr(last_cmdline, FALSE, 0, TRUE) == FAIL)
306a319,320
> 		if (ins_typestr((char_u *)":", FALSE, 0, TRUE) == FAIL)
> 			return FAIL;
320c334
< 				if (ins_typestr((char_u *)"\n", FALSE) == FAIL)
---
> 				if (ins_typestr((char_u *)"\n", FALSE, 0, TRUE) == FAIL)
323c337
< 			if (ins_typestr(y_current->y_array[i], FALSE) == FAIL)
---
> 			if (ins_typestr(y_current->y_array[i], FALSE, 0, TRUE) == FAIL)
408,412c422,426
< 	/*
< 	 * Imitate the strange Vi behaviour: If the delete spans more than one line
< 	 * and mtype == MCHAR and the result is a blank line, make the delete
< 	 * linewise. Don't do this for the change command.
< 	 */
---
> /*
>  * Imitate the strange Vi behaviour: If the delete spans more than one line
>  * and mtype == MCHAR and the result is a blank line, make the delete
>  * linewise. Don't do this for the change command.
>  */
416c430
< 		skipspace(&ptr);
---
> 		skipwhite(&ptr);
421a436,447
>  * Check for trying to delete (e.g. "D") in an empty line.
>  * Note: For change command it is ok.
>  */
> 	if (mtype == MCHAR && nlines == 1 &&
> 				operator == DELETE && *ml_get(curbuf->b_startop.lnum) == NUL)
> 	{
> 		beep_flush();
> 		return;
> 	}
> 
> /*
>  * Do a yank of whatever we're about to delete.
429c455
< 			beep();
---
> 			beep_flush();
439,440c465
<  * the delete contains a line break.
<  * Overruled when a yankbuffer has been specified!
---
>  * the delete contains a line break, or when a yankbuffer has been specified!
452a478,479
> 	{
> 		yankbuffer = '-';				/* use special delete buffer */
453a481,482
> 		yankbuffer = 0;
> 	}
455,460d483
< 	/*
< 	 * Do a yank of whatever we're about to delete. If there's too much stuff
< 	 * to fit in the yank buffer, then get a confirmation before doing the
< 	 * delete. This is crude, but simple. And it avoids doing a delete of
< 	 * something we can't put back if we want.
< 	 */
463a487,491
> /*
>  * If there's too much stuff to fit in the yank buffer, then get a
>  * confirmation before doing the delete. This is crude, but simple. And it
>  * avoids doing a delete of something we can't put back if we want.
>  */
466c494
< 		if (ask_yesno((char_u *)"cannot yank; delete anyway") != 'y')
---
> 		if (ask_yesno((char_u *)"cannot yank; delete anyway", TRUE) != 'y')
474c502
<  * block mode
---
>  * block mode delete
476c504
< 	if (Visual_block)
---
> 	if (block_mode)
478c506
< 		if (!u_save((linenr_t)(curbuf->b_startop.lnum - 1), (linenr_t)(curbuf->b_endop.lnum + 1)))
---
> 		if (u_save((linenr_t)(curbuf->b_startop.lnum - 1), (linenr_t)(curbuf->b_endop.lnum + 1)) == FAIL)
493c521
< 			new = alloc((unsigned)STRLEN(old) + 1 - n);
---
> 			new = alloc_check((unsigned)STRLEN(old) + 1 - n);
517c545
< 			if (!u_save_cursor())
---
> 			if (u_save_cursor() == FAIL)
538c566
< 		if (!u_save_cursor())
---
> 		if (u_save_cursor() == FAIL)
547c575
< 		if (!u_save_cursor())	/* save first line for undo */
---
> 		if (u_save_cursor() == FAIL)	/* save first line for undo */
558c586
< 		if (!u_save_cursor())	/* save last line for undo */
---
> 		if (u_save_cursor() == FAIL)	/* save last line for undo */
580c608
< 	if (Visual_block)
---
> 	if (block_mode)
594c622,623
< 	if (!u_save((linenr_t)(curbuf->b_startop.lnum - 1), (linenr_t)(curbuf->b_endop.lnum + 1)))
---
> 	if (u_save((linenr_t)(curbuf->b_startop.lnum - 1),
> 								(linenr_t)(curbuf->b_endop.lnum + 1)) == FAIL)
598c627
< 	if (Visual_block)		/* block mode */
---
> 	if (block_mode)					/* Visual block mode */
632c661
< 	if (mtype == MCHAR && nlines == 1 && !Visual_block)
---
> 	if (mtype == MCHAR && nlines == 1 && !block_mode)
669a699,700
>  * 
>  * return TRUE if edit() returns because of a CTRL-O command
671c702
< 	void
---
> 	int
684c715
< 	startinsert(NUL, FALSE, (linenr_t)1);
---
> 	return startinsert(NUL, FALSE, (linenr_t)1);
757c788
< 		beep();
---
> 		beep_flush();
796,797d826
< 	if (Visual_block)
< 	{
799c828
<  * block mode
---
>  * Visual block mode
800a830,831
> 	if (block_mode)
> 	{
830c861,862
< 					if ((y_current->y_array[0] = strnsave(ml_get(lnum) + curbuf->b_startop.col, (int)j)) == NULL)
---
> 					if ((y_current->y_array[0] = strnsave(ml_get(lnum) +
> 										curbuf->b_startop.col, (int)j)) == NULL)
833c865
< 							free_yank(i);	/* free the lines that we allocated */
---
> 							free_yank(i);	/* free the allocated lines */
839c871,872
< 			if ((y_current->y_array[0] = strsave(ml_get(lnum++) + curbuf->b_startop.col)) == NULL)
---
> 			if ((y_current->y_array[0] = strsave(ml_get(lnum++) +
> 										curbuf->b_startop.col)) == NULL)
896c929
< 		if (yanktype == MCHAR && !Visual_block)
---
> 		if (yanktype == MCHAR && !block_mode)
928c961
< 	long 		nlines = 0;
---
> 	long 		nr_lines = 0;
930c963
< 	int			delchar;
---
> 	int			delcount;
939a973
> 	FPOS		old_pos;
1002c1036
< 		if (!u_save(curwin->w_cursor.lnum - 1, lnum))
---
> 		if (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)
1005c1039
< 	else if (!u_save_cursor())
---
> 	else if (u_save_cursor() == FAIL)
1032c1066
< 			delchar = 0;
---
> 			delcount = 0;
1038c1072
< 				++nlines;
---
> 				++nr_lines;
1058c1092
< 				delchar = 1;
---
> 				delcount = 1;
1062c1096
< 			new = alloc((unsigned)totlen + oldlen + 1);
---
> 			new = alloc_check((unsigned)totlen + oldlen + 1);
1082,1083c1116,1117
< 			memmove((char *)ptr, (char *)old + textcol + delchar,
< 							(size_t)(oldlen - textcol - delchar + 1));
---
> 			memmove((char *)ptr, (char *)old + textcol + delcount,
> 							(size_t)(oldlen - textcol - delcount + 1));
1125c1159
< 				new = alloc((unsigned)(STRLEN(old) + totlen + 1));
---
> 				new = alloc_check((unsigned)(STRLEN(old) + totlen + 1));
1127c1161
< 					return; 				/* alloc() will give error message */
---
> 					return; 			/* alloc() will give error message */
1144,1145d1177
< 			if (y_type == MCHAR)
< 				--y_size;
1157,1158c1189,1190
< 					totlen = STRLEN(y_array[y_size]);
< 					new = alloc((unsigned)(STRLEN(ptr) + totlen + 1));
---
> 					totlen = STRLEN(y_array[y_size - 1]);
> 					new = alloc_check((unsigned)(STRLEN(ptr) + totlen + 1));
1161c1193
< 					STRCPY(new, y_array[y_size]);
---
> 					STRCPY(new, y_array[y_size - 1]);
1165d1196
< 					++nlines;
1168c1199
< 					new = alloc((unsigned)(col + yanklen + 1));
---
> 					new = alloc_check((unsigned)(col + yanklen + 1));
1184,1185c1215,1219
< 					if (ml_append(lnum++, y_array[i++], (colnr_t)0, FALSE) == FAIL)
< 						goto error;
---
> 					if ((y_type != MCHAR || i < y_size - 1) &&
> 						ml_append(lnum, y_array[i], (colnr_t)0, FALSE) == FAIL)
> 							goto error;
> 					lnum++;
> 					i++;
1187a1222
> 						old_pos = curwin->w_cursor;
1189,1190c1224,1228
< 						if (curbuf->b_p_si && *ml_get(lnum) == '#')
< 							indent = 0;		/* Leave # lines at start */
---
> 						ptr = ml_get(lnum);
> 						if (curbuf->b_p_si && *ptr == '#')
> 							indent = 0;     /* Leave # lines at start */
> 						else if (*ptr == NUL)
> 							indent = 0;     /* Ignore empty lines */
1199a1238
> 						curwin->w_cursor = old_pos;
1201c1240
< 					++nlines;
---
> 					++nr_lines;
1203,1204d1241
< 				if (y_type == MCHAR)
< 					++lnum; 	/* lnum is now number of line below inserted lines */
1236c1273
< 			mark_adjust(curbuf->b_startop.lnum + (y_type == MCHAR), MAXLNUM, nlines);
---
> 			mark_adjust(curbuf->b_startop.lnum + (y_type == MCHAR), MAXLNUM, nr_lines);
1241c1278
< 	msgmore(nlines);
---
> 	msgmore(nr_lines);
1256,1259c1293,1294
< 	gotocmdline(TRUE, NUL);
< 
< 	msg_outstr((char_u *)"--- Registers ---");
< 	for (i = -1; i < 36; ++i)
---
> 	msg_outstr((char_u *)"\n--- Registers ---");
> 	for (i = -1; i < 37; ++i)
1279a1315,1316
> 				else if (i == 36)
> 					msg_outchar('-');
1326,1327d1362
< 
< 	msg_end();
1356c1391,1392
< 	if (!u_save((linenr_t)(curwin->w_cursor.lnum - 1), (linenr_t)(curwin->w_cursor.lnum + count)))
---
> 	if (u_save((linenr_t)(curwin->w_cursor.lnum - 1),
> 					(linenr_t)(curwin->w_cursor.lnum + count)) == FAIL)
1362,1363c1398,1399
< 				beep();
< 				break;
---
> 			beep_flush();
> 			break;
1390,1391c1426,1427
< 	if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)		/* on last line */
< 		return FAIL;
---
> 	if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)
> 		return FAIL;			/* can't join on last line */
1409c1445
< 		skipspace(&next);
---
> 		skipwhite(&next);
1427c1463
< 	new = alloc((unsigned)(currsize + nextsize + spaces + 1));
---
> 	new = alloc_check((unsigned)(currsize + nextsize + spaces + 1));
1481a1518,1545
>  * Return TRUE if the two comment leaders given are the same.  White-space
>  * is ignored.  Note that the whole of 'leader1' must match 'leader2_len'
>  * characters from 'leader2' -- webb
>  */
> 	static int
> same_leader(leader1, leader2, leader2_len)
> 	char_u	*leader1;
> 	char_u	*leader2;
> 	int		leader2_len;
> {
> 	int		i;
> 
> 	if (leader1 == NULL)
> 		return (leader2_len == 0);
> 	skipwhite(&leader1);
> 	for (i = 0; i < leader2_len; i++)
> 	{
> 		if (!iswhite(leader2[i]))
> 		{
> 			if (*leader1++ != leader2[i])
> 				return FAIL;
> 			skipwhite(&leader1);
> 		}
> 	}
> 	return (*leader1 == NUL);
> }
> 
> /*
1487,1488c1551,1565
< 		/* prepare undo and join the lines */
< 	dodojoin((long)nlines, TRUE, FALSE);
---
> 	char_u		*ptr;
> 	long		old_line_count = curbuf->b_ml.ml_line_count;
> 	int			is_blank = FALSE;
> 	int			next_is_blank = FALSE;
> 	char_u		*leader = NULL;
> 	int			leader_len = 0;
> 	int			next_leader_len = 0;
> 	int			advance = TRUE;
> 	int			i;
> 
> 	if (u_save((linenr_t)(curwin->w_cursor.lnum - 1),
> 							(linenr_t)(curwin->w_cursor.lnum + nlines)) == FAIL)
> 		return;
> 	if (curbuf->b_p_fo != NULL && STRCHR(curbuf->b_p_fo, FO_Q_COMS) != NULL)
> 		fo_do_comments = TRUE;
1490,1499c1567,1668
< 		/* put cursor on last non-space */
< 	coladvance(MAXCOL);
< 	while (curwin->w_cursor.col && isspace(gchar_cursor()))
< 		dec_cursor();
< 	curs_columns(FALSE);			/* update curwin->w_virtcol */
< 
< 		/* do the formatting */
< 	State = INSERT;		/* for Opencmd() */
< 	insertchar(NUL);
< 	State = NORMAL;
---
> 	/*
> 	 * Blank lines, and lines containing only the comment leader, are left
> 	 * untouched by the formatting.  The variable is_blank is TRUE in this
> 	 * case.  It is also set when a line starts with the end of a C comment
> 	 * (star-slash), so that this line is skipped, and not joined to the
> 	 * previous line.  A new paragraph starts after a blank line, or when the
> 	 * comment leader changes -- webb.
> 	 */
> 	ptr = ml_get(curwin->w_cursor.lnum);
> 	skipwhite(&ptr);
> 	next_leader_len = get_leader_len(ptr);
> 	next_is_blank = (ptr[next_leader_len] == NUL ||
> 			(next_leader_len > 0 && ptr[0] == '*' && ptr[1] == '/') ||
> 			startPS(curwin->w_cursor.lnum, NUL, FALSE));
> 	curwin->w_cursor.lnum--;
> 	while (--nlines >= 0)
> 	{
> 		if (advance)
> 		{
> 			curwin->w_cursor.lnum++;
> 			ptr = ml_get(curwin->w_cursor.lnum);
> 			skipwhite(&ptr);
> 			is_blank = next_is_blank;
> 			free(leader);
> 			leader = NULL;
> 			leader_len = next_leader_len;
> 			if (leader_len > 0)
> 			{
> 				for (i = leader_len - 1; i >= 0 && iswhite(ptr[i]); i--)
> 					leader_len--;
> 				if (ptr[0] == '/' && ptr[1] == '*')
> 				{
> 					ptr++;
> 					leader_len--;
> 				}
> 				if ((leader = alloc(leader_len + 1)) != NULL)
> 				{
> 					STRNCPY(leader, ptr, leader_len);
> 					leader[leader_len] = NUL;
> 				}
> 				else
> 					leader_len = 0;
> 			}
> 		}
> 		if (nlines == 0)
> 		{
> 			next_is_blank = TRUE;
> 			next_leader_len = 0;
> 		}
> 		else
> 		{
> 			ptr = ml_get(curwin->w_cursor.lnum + 1);
> 			skipwhite(&ptr);
> 			next_leader_len = get_leader_len(ptr);
> 			next_is_blank = (nlines == 0 || ptr[next_leader_len] == NUL ||
> 					(next_leader_len > 0 && ptr[0] == '*' && ptr[1] == '/') ||
> 					startPS(curwin->w_cursor.lnum + 1, NUL, FALSE));
> 		}
> 		advance = TRUE;
> 		if (is_blank)
> 		{
> 			/* Skip blank lines */
> 		}
> 		else if (next_is_blank || !same_leader(leader, ptr, next_leader_len))
> 		{
> 			/* We have got to the end of a paragraph, so format it */
> 				/* put cursor on last non-space */
> 			coladvance(MAXCOL);
> 			while (curwin->w_cursor.col && isspace(gchar_cursor()))
> 				dec_cursor();
> 			curs_columns(FALSE);			/* update curwin->w_virtcol */
> 
> 				/* do the formatting */
> 			State = INSERT;		/* for Opencmd() */
> 			insertchar(NUL, TRUE);
> 			State = NORMAL;
> 		}
> 		else
> 		{
> 			/*
> 			 * Still in same paragraph, so join the lines together.
> 			 * But first delete the comment leader from the second line.
> 			 */
> 			advance = FALSE;
> 			curwin->w_cursor.lnum++;
> 			curwin->w_cursor.col = 0;
> 			ptr = ml_get(curwin->w_cursor.lnum);
> 			for (; iswhite(*ptr); ++ptr)
> 				curwin->w_cursor.col++;
> 			while (next_leader_len--)
> 				delchar(FALSE);
> 			curwin->w_cursor.lnum--;
> 			if (dojoin(TRUE, FALSE) == FAIL)
> 			{
> 				beep_flush();
> 				break;
> 			}
> 		}
> 	}
> 	fo_do_comments = FALSE;
> 	/* leave the cursor at the first non-blank of the last formatted line */
> 	beginline(TRUE);
1500a1670
> 	msgmore(curbuf->b_ml.ml_line_count - old_line_count);
1503c1673,1676
< 	void
---
> /*
>  * startinsert() returns TRUE if edit was ended by a CTRL-O command
>  */
> 	int
1513c1686
< 	if (initstr != NUL)
---
> 	if (initstr != NUL && !restart_edit)
1529c1702
< 	edit(count);
---
> 	return edit(count);
1656c1829
< 	if (isdigit(ptr[col]) && u_save_cursor())
---
> 	if (isdigit(ptr[col]) && u_save_cursor() == OK)
1732c1905
< 		beep();
---
> 		beep_flush();
1735a1909,2044
> 
> #ifdef VIMINFO
> 	int
> read_viminfo_register(line, lnum, fp, force)
> 	char_u	*line;
> 	linenr_t *lnum;
> 	FILE	*fp;
> 	int		force;
> {
> 	int		eof;
> 	int		do_it = TRUE;
> 	int		size;
> 	int		limit;
> 	int		i;
> 	int		set_prev = FALSE;
> 	char_u	*str;
> 	char_u	**array = NULL;
> 
> 	/* We only get here (hopefully) if line[0] == '"' */
> 	str = line + 1;
> 	if (*str == '"')
> 	{
> 		set_prev = TRUE;
> 		str++;
> 	}
> 	if (!isalnum(*str))
> 	{
> 		sprintf((char *)IObuff, "viminfo, %ld: Illegal register name <\"%c>",
> 																*lnum, *str);
> 		emsg(IObuff);
> 		do_it = FALSE;
> 	}
> 	yankbuffer = *str++;
> 	get_yank_buffer(FALSE);
> 	yankbuffer = 0;
> 	if (!force && y_current->y_array != NULL)
> 		do_it = FALSE;
> 	size = 0;
> 	limit = 100;		/* Optimized for registers containing <= 100 lines */
> 	if (do_it)
> 	{
> 		if (set_prev)
> 			y_previous = y_current;
> 		free(y_current->y_array);
> 		array = y_current->y_array = (char_u **) alloc(limit * sizeof(char_u *));
> 		skipwhite(&str);
> 		if (STRNCMP(str, "CHAR", 4) == 0)
> 			y_current->y_type = MCHAR;
> 		else if (STRNCMP(str, "BLOCK", 5) == 0)
> 			y_current->y_type = MBLOCK;
> 		else
> 			y_current->y_type = MLINE;
> 	}
> 	while (!(eof = vim_fgets(line, LSIZE, fp, lnum)) && line[0] == TAB)
> 	{
> 		if (do_it)
> 		{
> 			if (size >= limit)
> 			{
> 				y_current->y_array = (char_u **)
> 									alloc(limit * 2 * sizeof(char_u *));
> 				for (i = 0; i < limit; i++)
> 					y_current->y_array[i] = array[i];
> 				free(array);
> 				limit *= 2;
> 				array = y_current->y_array;
> 			}
> 			viminfo_readstring(line);
> 			str = strsave(line + 1);
> 			if (str != NULL)
> 				array[size++] = str;
> 			else
> 				do_it = FALSE;
> 		}
> 	}
> 	if (do_it)
> 	{
> 		if (size == 0)
> 		{
> 			free(array);
> 			y_current->y_array = NULL;
> 		}
> 		else if (size < limit)
> 		{
> 			y_current->y_array = (char_u **) alloc(size * sizeof(char_u *));
> 			for (i = 0; i < size; i++)
> 				y_current->y_array[i] = array[i];
> 			free(array);
> 		}
> 		y_current->y_size = size;
> 	}
> 	return eof;
> }
> 
> 	void
> write_viminfo_registers(fp)
> 	FILE	*fp;
> {
> 	int		i, j;
> 	char_u	*type;
> 
> 	fprintf(fp, "\n# Registers:\n");
> 
> 	for (i = 0; i < 36; i++)
> 	{
> 		if (y_buf[i].y_array == NULL)
> 			continue;
> 		switch (y_buf[i].y_type)
> 		{
> 			case MLINE:
> 				type = (char_u *)"LINE";
> 				break;
> 			case MCHAR:
> 				type = (char_u *)"CHAR";
> 				break;
> 			case MBLOCK:
> 				type = (char_u *)"BLOCK";
> 				break;
> 			default:
> 				sprintf((char *)IObuff, "Unknown register type %d",
> 					y_buf[i].y_type);
> 				emsg(IObuff);
> 				type = (char_u *)"LINE";
> 				break;
> 		}
> 		if (y_previous == &y_buf[i])
> 			fprintf(fp, "\"");
> 		fprintf(fp, "\"%c\t%s\n", (i < 10) ? ('0' + i) : ('a' + i - 10), type);
> 		for (j = 0; j < y_buf[i].y_size; j++)
> 		{
> 			putc('\t', fp);
> 			viminfo_writestring(fp, y_buf[i].y_array[j]);
> 		}
> 	}
> }
> #endif /* VIMINFO */
Index: ./src/ops.h
diff -r ../vim3.0/src/ops.h ./src/ops.h
28a29
> #define JOIN	13				/* only for visual mode */
33c34
< EXTERN char_u *opchars INIT(= (char_u *)"dyc<>!~=Q:Uu");
---
> EXTERN char_u *opchars INIT(= (char_u *)"dyc<>!~=Q:UuJ");
Index: ./src/param.c
diff -r ../vim3.0/src/param.c ./src/param.c
31d30
<  * Note: Don't use P_STRING and P_IND at the same time
53c52,53
< #define PV_BIN		13
---
> #define PV_BIN		12
> #define PV_COM		13
55a56
> #define PV_FO		16
56a58
> #define PV_NCOM		18
64a67
> #define PV_ID		35
81a85
>  		{"backupext",	"bex",	P_STRING,			(char_u *)&p_bex},
88a93
> 		{"comments",	"com",	P_STRING|P_IND,		(char_u *)PV_COM},
89a95,96
> 		{"define",		"def",	P_STRING,			(char_u *)&p_def},
> 		{"dictionary",	"dict",	P_STRING|P_EXPAND,	(char_u *)&p_dict},
103a111,112
> 		{"flash",		"fl",	P_BOOL,				(char_u *)NULL},
> 		{"formatoptions","fo",	P_STRING|P_IND,		(char_u *)PV_FO},
112a122
> 		{"identchars",	"id",	P_STRING|P_IND,		(char_u *)PV_ID},
113a124,125
> 		{"incsearch",	"is",	P_BOOL,				(char_u *)&p_is},
> 		{"infercase",	"inf",	P_BOOL,				(char_u *)&p_inf},
114a127
> 		{"include",		"inc",	P_STRING,			(char_u *)&p_inc},
127a141
> 		{"mouse",		NULL,	P_BOOL,				(char_u *)&p_mouse},
128a143
> 		{"nestedcomments","ncom", P_STRING|P_IND,	(char_u *)PV_NCOM},
129a145
> 		{"novice",		NULL,	P_BOOL,				(char_u *)NULL},
149a166
> 		{"shellredir",	"srr",	P_STRING,			(char_u *)&p_srr},
152a170
> 		{"shortmess",	"shm",	P_NUM,				(char_u *)&p_shm},
161a180
> 		{"smartmatch",	"sma",	P_BOOL,				(char_u *)&p_sma},
164a184
> 		{"startofline",	"sol",	P_BOOL,				(char_u *)&p_sol},
184a205,207
> #ifdef VIMINFO
> 		{"viminfo",		"vi",	P_NUM,				(char_u *)&p_viminfo},
> #endif /* VIMINFO */
200d222
< 		{"yankendofline", "ye",	P_BOOL,				(char_u *)&p_ye},
222a245,246
> 		{"t_ue",		NULL,	P_STRING,	(char_u *)&term_strings.t_ue},
> 		{"t_us",		NULL,	P_STRING,	(char_u *)&term_strings.t_us},
258a283,288
> 		{"t_ins",		NULL,	P_STRING,	(char_u *)&term_strings.t_ins},
> 		{"t_del",		NULL,	P_STRING,	(char_u *)&term_strings.t_del},
> 		{"t_home",		NULL,	P_STRING,	(char_u *)&term_strings.t_home},
> 		{"t_end",		NULL,	P_STRING,	(char_u *)&term_strings.t_end},
> 		{"t_pu",		NULL,	P_STRING,	(char_u *)&term_strings.t_pu},
> 		{"t_pd",		NULL,	P_STRING,	(char_u *)&term_strings.t_pd},
259a290
> 		{"t_mouse",		NULL,	P_STRING,	(char_u *)&term_strings.t_mouse},
294c325
< 	 * Default for p_sp is "| tee".
---
> 	 * Default for p_sp is "| tee", for p_srr is ">".
300a332
> 	{
301a334,335
> 		p_srr = (char_u *)">&";
> 	}
304a339
> 	{
305a341,342
> 		p_srr = (char_u *)"2>&1 1>";
> 	}
320a358,362
> 		/* the string options are always in allocated memory */
> 	curbuf->b_p_fo = strsave((char_u *)FO_DFLT);
> 	curbuf->b_p_id = strsave((char_u *)"_");
> 	curbuf->b_p_com	= strsave((char_u *)"/* ,* ,//,*/,# ,%,XCOMM");
> 	curbuf->b_p_ncom = strsave((char_u *)">");
352a395
> 	char_u		errbuf[80];
360a404
> 	long		oldColumns = Columns;	/* remember old Columns */
434c478
< 				gotocmdline(TRUE, NUL);	/* cursor at status line */
---
> 				gotocmdline(TRUE);		/* cursor at status line */
470a515,520
> 					free(curbuf->b_p_fo);
> 					curbuf->b_p_fo = strsave((char_u *)"t");
> 									/* Use textwidth for formatting, don't
> 									 * format comments */
> 					free(curbuf->b_p_id);
> 					curbuf->b_p_id = strsave((char_u *)"_");
486a537,538
> 					p_shm = 0;		/* no short message */
> 					p_sma = 0;		/* no smart matching */
489a542
> 					p_sol = TRUE;	/* Move cursor to start-of-line */
500d552
< 					p_ye = 0;		/* no yank to end of line */
542a595
> 							buf->b_p_wm = buf->b_p_wm_save;
569a623
> #ifdef NOSTRTOL
570a625,627
> #else
> 					*(long *)(varp) = strtol((char *)arg + len + 1, NULL, 0);
> #endif
595c652,656
< 					if (flags & P_CHANGED)
---
> 						/*
> 						 * String options that have been changed or are
> 						 * indirect are in allocated memory, free them first.
> 						 */
> 					if ((flags & P_CHANGED) || (flags & P_IND))
631c692,698
< 		if (Rows < 2)
---
> 		if (Rows < min_rows())
> 		{
> 			sprintf((char *)errbuf, "Need at least %ld lines", min_rows());
> 			errmsg = errbuf;
> 			Rows = min_rows();
> 		}
> 		if (Columns < MIN_COLUMNS)
633,634c700,702
< 			Rows = 2;
< 			errmsg = (char_u *)"Need at least 2 lines";
---
> 			sprintf((char *)errbuf, "Need at least %ld columns", MIN_COLUMNS);
> 			errmsg = errbuf;
> 			Columns = MIN_COLUMNS;
640c708
< 		if (oldRows != Rows)
---
> 		if (oldRows != Rows || oldColumns != Columns)
642c710
< 			screen_new_rows();
---
> 			check_winsize();				/* in case 'columns' changed */
671,672c739,745
< 			errmsg = e_scroll;
< 			p_sj = 1;
---
> 			if (Rows != oldRows)		/* Rows changed, just adjust p_sj */
> 				p_sj = Rows / 2;
> 			else
> 			{
> 				errmsg = e_scroll;
> 				p_sj = 1;
> 			}
693a767,778
> 		if (p_shm < 0 || p_shm > 2)
> 		{
> 			errmsg = (char_u *)"Must be between 0 and 2";
> 			p_shm = (p_shm < 0) ? 0 : 2;
> 		}
> #ifdef VIMINFO
> 		if (p_viminfo < 0)
> 		{
> 			errmsg = e_positive;
> 			p_viminfo = 0;
> 		}
> #endif /* VIMINFO */
709,710c794,795
< 		skiptospace(&arg);				/* skip to next white space */
< 		skipspace(&arg);				/* skip spaces */
---
> 		skiptowhite(&arg);				/* skip to next white space */
> 		skipwhite(&arg);				/* skip spaces */
719c804
< 	if (p_ch != oldch)					/* p_ch changed value */
---
> 	if (p_ch != oldch)				/* p_ch changed value */
721c806,814
< 	comp_col();
---
> #ifdef UNIX
> 	if (is_xterm(term_strings.t_name))
> 		setmouse(p_mouse);				/* in case 'mouse' changed */
> #endif
> #ifdef MSDOS
> 	setmouse(p_mouse);
> #endif
> 	comp_col();						/* in case 'ruler' or 'showcmd' changed */
> 	curwin->w_set_curswant = TRUE;	/* in case 'list' changed */
726,728c819
< 	 * If we messed up the screen by showing more than one line of param
< 	 * values or an error message, call wait_return(), which will also
< 	 * update the screen.
---
> 	 * Also update the cursor position, in case 'wrap' is changed.
734,740c825
< 	if (did_show && msg_check())
< 	{
< 		msg_outchar('\n');
< 		wait_return(TRUE);
< 	}
< 	else
< 		updateScreen(NOT_VALID);
---
> 	updateScreen(CURSUPD);
745c830
<  * expand environment variable at the start of some string options
---
>  * expand environment variables for some string options
752c837,838
< 	char_u *p;
---
> 	char_u		*p;
> 	int			offset = 0;
754,765c840,862
< 	if ((params[i].flags & P_EXPAND) &&
< 				(p = *(char_u **)(params[i].var)) != NULL &&
< 				(*p == '$' || *p == '~'))
< 	{
< 		expand_env(*(char_u **)(params[i].var), IObuff, IOSIZE);
< 		p = strsave(IObuff);
< 		if (p)
< 		{
< 			if (dofree)
< 				free(*(char_u **)(params[i].var));
< 			*(char_u **)(params[i].var) = p;
< 		}
---
> 	if (!(params[i].flags & P_EXPAND) ||
> 				(p = *(char_u **)(params[i].var)) == NULL)
> 		return;
> 
> 	if ((
> #ifdef UNIX
> 			params[i].var == (char_u *)&p_bdir ||
> #endif
> 			params[i].var == (char_u *)&p_dir) && *p == '>')
> 		offset = 1;
> 
> 	/*
> 	 * Expanding this with NameBuff, expand_env() must not be passed IObuff.
> 	 */
> 	expand_env(p + offset, NameBuff, MAXPATHL);
> 	p = alloc(offset + STRLEN(NameBuff) + 1);
> 	if (p)
> 	{
> 		p[0] = '>';		/* Will be overwritten if offset is 0 */
> 		STRCPY(p + offset, NameBuff);
> 		if (dofree)
> 			free(*(char_u **)(params[i].var));
> 		*(char_u **)(params[i].var) = p;
837,838c934,937
< 	gotocmdline(TRUE, NUL);
< 	msg_outstr((char_u *)"--- Parameters ---\n");
---
> 	set_highlight('t');		/* Highlight title */
> 	start_highlight();
> 	msg_outstr((char_u *)"\n--- Parameters ---");
> 	stop_highlight();
882a982
> 			msg_outchar('\n');						/* go to next line */
890d989
< 			msg_outchar('\n');				/* scroll screen one line up */
895,896d993
< 
< 	wait_return(FALSE);
908a1006
> 	char_u			*var;
929c1027,1033
< 				home_replace(*(char_u **)(varp), NameBuff, MAXPATHL);
---
> 				var = *(char_u **)(varp);
> 				if (*var == '>')	/* So home_replace() works for dir/bdir */
> 				{
> 					msg_outchar('>');
> 					++var;
> 				}
> 				home_replace(var, NameBuff, MAXPATHL);
1024c1128
< 	int last_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));
---
> 	int last_has_status = (p_ls == 2 || (p_ls == 1 && firstwin != lastwin));
1032c1136
< 		if (!last_status)
---
> 		if (!last_has_status)
1038c1142
< 		if (!p_ru || last_status)		/* no need for separating space */
---
> 		if (!p_ru || last_has_status)		/* no need for separating space */
1064a1169
> 		case PV_COM:	return (char_u *)&(curbuf->b_p_com);
1066a1172,1173
> 		case PV_FO:		return (char_u *)&(curbuf->b_p_fo);
> 		case PV_ID:		return (char_u *)&(curbuf->b_p_id);
1067a1175
> 		case PV_NCOM:	return (char_u *)&(curbuf->b_p_ncom);
1108c1216
< 	bp_to->b_p_ro = bp_from->b_p_ro;
---
> 	bp_to->b_p_ro = FALSE;				/* don't copy readonly */
1117a1226,1233
> 	if (bp_from->b_p_com != NULL)
> 		bp_to->b_p_com = strsave(bp_from->b_p_com);
> 	if (bp_from->b_p_ncom != NULL)
> 		bp_to->b_p_ncom = strsave(bp_from->b_p_ncom);
> 	if (bp_from->b_p_fo != NULL)
> 		bp_to->b_p_fo = strsave(bp_from->b_p_fo);
> 	if (bp_from->b_p_id != NULL)
> 		bp_to->b_p_id = strsave(bp_from->b_p_id);
1120c1236,1237
< #ifdef WEBB_COMPLETE
---
> static expand_param = -1;
> 
1186a1304,1310
> 	if (expand_context != EXPAND_BOOL_SETTINGS && p[1] == NUL)
> 	{
> 		expand_context = EXPAND_OLD_SETTING;
> 		expand_param = i;
> 		expand_pattern = p + 1;
> 		return;
> 	}
1204a1329,1334
> 		if ((
> #ifdef UNIX
> 				p == (char_u *)&p_bdir ||
> #endif
> 				p == (char_u *)&p_dir) && *expand_pattern == '>')
> 			++expand_pattern;
1292c1422,1867
< #endif /* WEBB_COMPLETE */
---
> 
> 	int
> ExpandOldSetting(num_file, file)
> 	int		*num_file;
> 	char_u	***file;
> {
> 	int		extra = 0;
> 	char_u	*varp;
> 	char_u	*var;
> 	char_u	*p;
> 	char_u	*p2;
> 	char_u	string[20];
> 	char_u	*old_val;
> 
> 	varp = get_varp(&params[expand_param]);
> 	if (params[expand_param].flags & P_NUM)
> 	{
> 		sprintf((char *)string, "%ld", *(long *)varp);
> 		old_val = strsave(string);
> 	}
> 	else
> 	{
> 		var = *(char_u **)varp;
> 		if (var == NULL)
> 			var = (char_u *)"";
> 		p = var;
> 		for (; *p; p++)
> 			if (*p == ' ')
> 				extra++;
> 		p = var;
> 		p2 = old_val = alloc(STRLEN(p) + 1 + extra);
> 		if (old_val != NULL)
> 		{
> 			for (; *p; p++, p2++)
> 			{
> 				if (*p == ' ')
> 					*p2++ = '\\';
> 				*p2 = *p;
> 			}
> 			*p2 = NUL;
> 		}
> 	}
> 	*file = (char_u **) alloc(sizeof(char_u *));
> 	if (old_val == NULL || *file == NULL)
> 		return FAIL;
> 	*file[0] = old_val;
> 	*num_file = 1;
> 	return OK;
> }
> 
> /*
>  * structures and functions for automatic commands
>  */
> 
> typedef struct AutoCmd
> {
> 	char_u			*cmd;
> 	struct AutoCmd	*next;
> } AutoCmd;
> 
> typedef struct AutoPat
> {
> 	char_u			*pat;
> 	char_u			*reg_pat;
> 	AutoCmd			*cmds;
> 	struct AutoPat	*next;
> } AutoPat;
> 
> static AutoPat *first_autopat = NULL;
> 
> 	char_u *
> file_pat_to_reg_pat(pat)
> 	char_u	*pat;
> {
> 	int		size;
> 	char_u	*endp;
> 	char_u	*reg_pat;
> 	char_u	*p;
> 	int		i;
> 	int		nested = 0;
> 	int		add_dollar = TRUE;
> 
> 	size = 2;				/* '^' at start, '$' at end */
> 	for (p = pat; *p; p++)
> 	{
> 		switch (*p)
> 		{
> 			case '*':
> 			case '.':
> 			case ',':
> 			case '{':
> 			case '}':
> 				size += 2;
> 				break;
> 			default:
> 				size++;
> 				break;
> 		}
> 	}
> 	reg_pat = alloc(size + 1);
> 	if (reg_pat == NULL)
> 		return NULL;
> 	i = 0;
> 	if (pat[0] == '*')
> 		while (pat[0] == '*' && pat[1] != NUL)
> 			pat++;
> 	else
> 		reg_pat[i++] = '^';
> 	endp = pat + STRLEN(pat) - 1;
> 	if (*endp == '*')
> 	{
> 		while (endp - pat > 0 && *endp == '*')
> 			endp--;
> 		add_dollar = FALSE;
> 	}
> 	for (p = pat; *p && nested >= 0 && p <= endp; p++)
> 	{
> 		switch (*p)
> 		{
> 			case '*':
> 				reg_pat[i++] = '.';
> 				reg_pat[i++] = '*';
> 				break;
> 			case '.':
> 				reg_pat[i++] = '\\';
> 				reg_pat[i++] = '.';
> 				break;
> 			case '?':
> 				reg_pat[i++] = '.';
> 				break;
> 			case '\\':
> 				if (p[1] == NUL)
> 					break;
> 				if (*++p == '?')
> 					reg_pat[i++] = '?';
> 				else if (*p == ',')
> 					reg_pat[i++] = ',';
> 				else
> 				{
> 					reg_pat[i++] = '\\';
> 					reg_pat[i++] = *p;
> 				}
> 				break;
> 			case '{':
> 				reg_pat[i++] = '\\';
> 				reg_pat[i++] = '(';
> 				nested++;
> 				break;
> 			case '}':
> 				reg_pat[i++] = '\\';
> 				reg_pat[i++] = ')';
> 				--nested;
> 				break;
> 			case ',':
> 				if (nested)
> 				{
> 					reg_pat[i++] = '\\';
> 					reg_pat[i++] = '|';
> 				}
> 				else
> 					reg_pat[i++] = ',';
> 				break;
> 			default:
> 				reg_pat[i++] = *p;
> 				break;
> 		}
> 	}
> 	if (add_dollar)
> 		reg_pat[i++] = '$';
> 	reg_pat[i] = NUL;
> 	if (nested != 0)
> 	{
> 		if (nested < 0)
> 			EMSG("Missing {.");
> 		else
> 			EMSG("Missing }.");
> 		free(reg_pat);
> 		reg_pat = NULL;
> 	}
> 	return reg_pat;
> }
> 
> 	static void
> show_autocmd(ap, did_show)
> 	AutoPat	*ap;
> 	int		did_show;
> {
> 	AutoCmd *ac;
> 
> 	if (did_show)
> 		msg_outstr((char_u *)"\n");
> 	msg_outstr(ap->pat);
> 	for (ac = ap->cmds; ac != NULL; ac = ac->next)
> 	{
> 		msg_outstr((char_u *)"\n    ");
> 		msg_outstr(ac->cmd);
> 		did_show = TRUE;
> 	}
> }
> 
> /*
>  * do_autocmd() -- implements the :autocmd command.  Can be used in the
>  *	following ways:
>  *
>  *	  :autocmd <pat> <cmd>	Add <cmd> to the list of commands that will be
>  *							automatically executed when editing a file
>  *							matching <pat>.
>  *	  :autocmd <pat>		Show the auto-commands associated with <pat>.
>  *	  :autocmd				Show all auto-commands.
>  *	  :autocmd! <pat> <cmd>	Remove all auto-commands associated with <pat>,
>  *							and add the command <cmd>.
>  *	  :autocmd! <pat>		Remove all auto-commands associated with <pat>.
>  *	  :autocmd!				Remove ALL auto-commands.
>  *	<pat> may be "default" for commands that should be used when no
>  *	other pattern matches.  Multiple patterns may be given separated by
>  *	commas.  Here are some examples:
>  *	  :autocmd *.c,*.h	set tw=0 smartindent noic
>  *	  :autocmd default	set tw=79 nosmartindent ic infercase
>  */
> 	void
> do_autocmd(arg, force)
> 	char_u	*arg;
> 	int		force;
> {
> 	char_u	*cmd;
> 	char_u	*p;
> 	AutoPat	*ap;
> 	AutoPat	*ap2;
> 	AutoCmd	*ac;
> 	int		did_show = FALSE;
> 	int		show_all = TRUE;
> 	int		nested;
> 
> 	cmd = arg;
> 	while (*cmd && (!iswhite(*cmd) || cmd[-1] == '\\'))
> 		cmd++;
> 	if (*cmd)
> 		*cmd++ = NUL;
> 	skipwhite(&cmd);
> 	p = arg;
> 	if (!force)
> 	{
> 		/*
> 		 * When listing all autocommands: keep the command line, there will be
> 		 * scrolling anyway.
> 		 * When listing one autocommand: overwrite the command line to avoid
> 		 * scrolling.
> 		 */
> 		if (*arg == NUL)
> 		{
> 			set_highlight('t');		/* Highlight title */
> 			start_highlight();
> 			msg_outstr((char_u *)"\n--- Auto-Commands ---");
> 			stop_highlight();
> 			did_show = TRUE;
> 		}
> 		else if (*cmd == NUL)
> 			gotocmdline(TRUE);
> 	}
> 	for(;;)
> 	{
> 		arg = p;
> 		if (*arg == NUL)
> 			break;
> 		show_all = FALSE;
> 		nested = 0;
> 		while (*p && (*p != ',' || nested || p[-1] == '\\'))
> 		{
> 			if (*p == '{')
> 				nested++;
> 			else if (*p == '}')
> 				nested--;
> 			p++;
> 		}
> 		if (*p == ',')
> 			*p++ = NUL;
> 		ap = first_autopat;
> 		while (ap != NULL && STRCMP(arg, ap->pat) != 0)
> 			ap = ap->next;
> 		if (ap == NULL)
> 		{
> 			/* It's a new pattern */
> 			if (*cmd == NUL)
> 			{
> 				if (!force)
> 				{
> 					if (did_show)
> 						msg_outchar('\n');
> 					sprintf((char *)IObuff, "No autocmd for '%s'", arg);
> 					msg_outstr(IObuff);
> 					did_show = TRUE;
> 					continue;
> 				}
> 			}
> 			else
> 			{
> 				ap = (AutoPat *) alloc(sizeof(AutoPat));
> 				if (ap == NULL)
> 					return;
> 				ap->next = first_autopat;
> 				ap->pat = strsave(arg);
> 				ap->reg_pat = file_pat_to_reg_pat(ap->pat);
> 				ap->cmds = NULL;
> 				if (ap->reg_pat == NULL)
> 					return;
> 				first_autopat = ap;
> 			}
> 		}
> 		else if (force)
> 		{
> 			/* Remove old autocmd's first */
> 			while (ap->cmds != NULL)
> 			{
> 				ac = ap->cmds;
> 				ap->cmds = ac->next;
> 				free(ac->cmd);
> 				free(ac);
> 			}
> 			if (*cmd == NUL)
> 			{
> 				/*
> 				 * We are not adding any new autocmd's for this pattern,
> 				 * so delete the pattern from the autopat list
> 				 */
> 				free(ap->pat);
> 				free(ap->reg_pat);
> 				if (ap == first_autopat)
> 					first_autopat = ap->next;
> 				else
> 				{
> 					for (ap2 = first_autopat; ap2->next != ap; ap2 = ap2->next)
> 						;
> 					ap2->next = ap->next;
> 				}
> 				free(ap);
> 			}
> 		}
> 		if (*cmd == NUL && !force)
> 		{
> 			/* Show autocmd's for this autopat */
> 			if (did_show)
> 				msg_outchar('\n');
> 			show_autocmd(ap, did_show);
> 			did_show = TRUE;
> 		}
> 		else if (*cmd != NUL)
> 		{
> 			/* Add the autocmd if it's not already there */
> 			ac = ap->cmds;
> 			while (ac != NULL && STRCMP(cmd, ac->cmd) != 0)
> 				ac = ac->next;
> 			if (ac == NULL)
> 			{
> 				ac = (AutoCmd *) alloc(sizeof(AutoCmd));
> 				if (ac == NULL)
> 					return;
> 				ac->next = ap->cmds;
> 				ac->cmd = strsave(cmd);
> 				if (ac->cmd == NULL)
> 					return;
> 				ap->cmds = ac;
> 			}
> 		}
> 	}
> 	if (show_all)
> 	{
> 		if (force)
> 		{
> 			/* ":autocmd!": delete all autocmd's */
> 			while (first_autopat != NULL)
> 			{
> 				ap = first_autopat;
> 				first_autopat = ap->next;
> 				free(ap->pat);
> 				free(ap->reg_pat);
> 				while (ap->cmds != NULL)
> 				{
> 					ac = ap->cmds;
> 					ap->cmds = ac->next;
> 					free(ac->cmd);
> 					free(ac);
> 				}
> 				free(ap);
> 			}
> 		}
> 		else
> 		{
> 			if (first_autopat == NULL)
> 				msg_outstr((char_u *)"There are no autocmd's");
> 			else
> 			{
> 				for (ap = first_autopat; ap != NULL; ap = ap->next)
> 				{
> 					if (did_show)
> 						msg_outchar('\n');
> 					show_autocmd(ap, did_show);
> 					did_show = TRUE;
> 				}
> 			}
> 		}
> 	}
> }
> 
> 	void
> apply_autocmds(fname)
> 	char_u			*fname;		/* NULL means use actual file name */
> {
> 	struct regexp	*prog;
> 	AutoPat			*ap;
> 	AutoPat			*def_ap = NULL;
> 	AutoCmd			*ac;
> 	int				matched = FALSE;
> 	int				temp;
> 
> 		/* Don't redraw while doing auto commands. */
> 	temp = RedrawingDisabled;
> 	RedrawingDisabled = TRUE;
> 
> 	if (fname == NULL || *fname == NUL)
> 		fname = curbuf->b_filename;
> 	if (fname != NULL)
> 		fname = gettail(fname);
> 	for (ap = first_autopat; ap != NULL; ap = ap->next)
> 	{
> 		if (STRCMP(ap->pat, "default") == 0)
> 		{
> 			def_ap = ap;
> 			continue;
> 		}
> 		reg_ic = FALSE;		/* Don't ever ignore case */
> 		reg_magic = TRUE;	/* Always use magic */
> 		prog = regcomp(ap->reg_pat);
> 		if (prog != NULL && fname != NULL && regexec(prog, fname, TRUE))
> 		{
> 			for (ac = ap->cmds; ac != NULL; ac = ac->next)
> 				docmdline(ac->cmd, TRUE, TRUE);
> 			matched = TRUE;
> 		}
> 		free(prog);
> 	}
> 	if (!matched && def_ap != NULL)
> 		for (ac = def_ap->cmds; ac != NULL; ac = ac->next)
> 			docmdline(ac->cmd, TRUE, TRUE);
> 
> 	RedrawingDisabled = temp;
> }
Index: ./src/param.h
diff -r ../vim3.0/src/param.h ./src/param.h
30c30
< #if defined(COMPATIBLE) || defined(NOBACKUP)
---
> EXTERN char_u *p_bex INIT(= (char_u *) ".~");	/* extension for backup file */
32,34d31
< #else
< EXTERN int	p_bk	INIT(= TRUE);		/* make backups when writing out files */
< #endif
42a40,42
> EXTERN char_u *p_def INIT(= (char_u *)"^#[ \t]*define");
> 									/* Pattern for recognising definitions */
> EXTERN char_u *p_dict	INIT(= (char_u *)"");	/* Dictionaries for ^P/^N */
71c71
< EXTERN char_u *p_fp	INIT(= (char_u *)"");			/* name of format program */
---
> EXTERN char_u *p_fp	INIT(= (char_u *)"");/* name of format program */
82c82
< EXTERN char_u *p_hl	INIT(= (char_u *)"db,es,hs,rs,vi,si");
---
> EXTERN char_u *p_hl	INIT(= (char_u *)"8b,db,es,hs,mb,nu,rs,si,tb,vi");
84a85,86
> EXTERN int	p_is	INIT(= FALSE);		/* incremental search */
> EXTERN int	p_inf	INIT(= TRUE);		/* infer case of ^N/^P completions */
85a88,89
> EXTERN char_u *p_inc INIT(= (char_u *)"^#[ \t]*include");
> 										/* Pattern for including other files */
87c91
< EXTERN char_u *p_kp	INIT(= (char_u *)"ref");		/* keyword program */
---
> EXTERN char_u *p_kp	INIT(= (char_u *)"man");	/* keyword program */
94a99
> EXTERN int	p_mouse	INIT(= TRUE);		/* enable mouse clicks (for xterm) */
137a143,144
> EXTERN char_u *p_srr INIT(= (char_u *)">");	/* string for output of filter */
> EXTERN long	p_shm	INIT(= 0);			/* Use short message for ^G */
148a156
> EXTERN int	p_sma	INIT(= FALSE);		/* smart paren matching */
150a159
> EXTERN int	p_sma	INIT(= TRUE);		/* smart paren matching */
154c163,164
< EXTERN char_u *p_su	INIT(= (char_u *)".bak.o.h.info.swp");	/* suffixes for wildcard expansion */
---
> EXTERN int	p_sol	INIT(= TRUE);		/* Move cursor to start-of-line? */
> EXTERN char_u *p_su	INIT(= (char_u *)".bak.~.o.h.info.swp");	/* suffixes for wildcard expansion */
181a192,194
> # ifdef UNIX
> EXTERN long p_ul	INIT(= 1000);		/* number of Undo Levels */
> # else
182a196
> # endif
186a201,204
> #ifdef VIMINFO
> /* Minimum # of files whose marks are remembered, 0 means no .viminfo file: */
> EXTERN long	p_viminfo	INIT(= 0);
> #endif /* VIMINFO */
206d223
< EXTERN int	p_ye	INIT(= FALSE);		/* Y yanks to end of line */
Index: ./src/proto/alloc.pro
diff -r ../vim3.0/src/proto/alloc.pro ./src/proto/alloc.pro
2,8c2,12
< unsigned char *alloc __PARMS((unsigned int size));
< unsigned char *lalloc __PARMS((unsigned long size, int message));
< unsigned char *strsave __PARMS((unsigned char *string));
< unsigned char *strnsave __PARMS((unsigned char *string, int len));
< void copy_spaces __PARMS((unsigned char *ptr, unsigned long count));
< void del_spaces __PARMS((unsigned char *ptr));
< int vim_strnicmp __PARMS((unsigned char *s1, unsigned char *s2, unsigned long len));
---
> char_u *alloc __PARMS((unsigned size));
> char_u *alloc_check __PARMS((unsigned size));
> char_u *lalloc __PARMS((long_u size, int message));
> void do_outofmem_msg __PARMS((void));
> char_u *strsave __PARMS((char_u *string));
> char_u *strnsave __PARMS((char_u *string, int len));
> void copy_spaces __PARMS((char_u *ptr, size_t count));
> void del_trailing_spaces __PARMS((char_u *ptr));
> void nofreeNULL __PARMS((void *x));
> char *bsdmemset __PARMS((char *ptr, int c, long size));
> int vim_strnicmp __PARMS((char_u *s1, char_u *s2, size_t len));
Index: ./src/proto/amiga.pro
diff -r ../vim3.0/src/proto/amiga.pro ./src/proto/amiga.pro
4,5c4,5
< void mch_write __PARMS((unsigned char *p, int len));
< int GetChars __PARMS((unsigned char *buf, int maxlen, int time));
---
> void mch_write __PARMS((char_u *p, int len));
> int GetChars __PARMS((char_u *buf, int maxlen, int time));
13,14c13,14
< void fname_case __PARMS((unsigned char *name));
< void mch_settitle __PARMS((unsigned char *title, unsigned char *icon));
---
> void fname_case __PARMS((char_u *name));
> void mch_settitle __PARMS((char_u *title, char_u *icon));
16,21c16,21
< int vim_dirname __PARMS((unsigned char *buf, int len));
< int FullName __PARMS((unsigned char *fname, unsigned char *buf, int len));
< int isFullName __PARMS((unsigned char *fname));
< long getperm __PARMS((unsigned char *name));
< int setperm __PARMS((unsigned char *name, long perm));
< int isdir __PARMS((unsigned char *name));
---
> int vim_dirname __PARMS((char_u *buf, int len));
> int FullName __PARMS((char_u *fname, char_u *buf, int len));
> int isFullName __PARMS((char_u *fname));
> long getperm __PARMS((char_u *name));
> int setperm __PARMS((char_u *name, long perm));
> int isdir __PARMS((char_u *name));
24c24
< int mch_screenmode __PARMS((unsigned char *arg));
---
> int mch_screenmode __PARMS((char_u *arg));
27c27
< int call_shell __PARMS((unsigned char *cmd, int filter, int cooked));
---
> int call_shell __PARMS((char_u *cmd, int filter, int cooked));
30,33c30,33
< int ExpandWildCards __PARMS((int num_pat, unsigned char **pat, int *num_file, unsigned char ***file, int files_only, int list_notfound));
< void FreeWild __PARMS((int num, unsigned char **file));
< int has_wildcard __PARMS((unsigned char *p));
< unsigned char *vimgetenv __PARMS((unsigned char *var));
---
> int ExpandWildCards __PARMS((int num_pat, char_u **pat, int *num_file, char_u ***file, int files_only, int list_notfound));
> void FreeWild __PARMS((int num, char_u **file));
> int has_wildcard __PARMS((char_u *p));
> char_u *vimgetenv __PARMS((char_u *var));
Index: ./src/proto/buffer.pro
diff -r ../vim3.0/src/proto/buffer.pro ./src/proto/buffer.pro
3,5c3,5
< void close_buffer __PARMS((struct buffer *buf, int free_buf, int remove));
< void buf_clear __PARMS((struct buffer *buf));
< void buf_freeall __PARMS((struct buffer *buf));
---
> void close_buffer __PARMS((BUF *buf, int free_buf, int del_buf));
> void buf_clear __PARMS((BUF *buf));
> void buf_freeall __PARMS((BUF *buf));
7,8c7,8
< struct buffer *buflist_new __PARMS((unsigned char *fname, unsigned char *sfname, long lnum, int use_curbuf));
< int buflist_getfile __PARMS((int n, long lnum, int setpm));
---
> BUF *buflist_new __PARMS((char_u *fname, char_u *sfname, linenr_t lnum, int use_curbuf));
> int buflist_getfile __PARMS((int n, linenr_t lnum, int setpm));
10c10,12
< unsigned char *buflist_nr2name __PARMS((int n));
---
> BUF *buflist_findname __PARMS((char_u *fname));
> BUF *buflist_findnr __PARMS((int nr));
> char_u *buflist_nr2name __PARMS((int n));
12,15c14,17
< int buflist_name_nr __PARMS((int fnum, unsigned char **fname, long *lnum));
< int setfname __PARMS((unsigned char *fname, unsigned char *sfname, int message));
< void setaltfname __PARMS((unsigned char *fname, unsigned char *sfname, long lnum));
< int buflist_add __PARMS((unsigned char *fname));
---
> int buflist_name_nr __PARMS((int fnum, char_u **fname, linenr_t *lnum));
> int setfname __PARMS((char_u *fname, char_u *sfname, int message));
> void setaltfname __PARMS((char_u *fname, char_u *sfname, linenr_t lnum));
> int buflist_add __PARMS((char_u *fname));
17c19
< int otherfile __PARMS((unsigned char *fname));
---
> int otherfile __PARMS((char_u *fname));
21,22c23,24
< unsigned char *fix_fname __PARMS((unsigned char *fname));
< void fname_expand __PARMS((unsigned char **fname, unsigned char **sfname));
---
> char_u *fix_fname __PARMS((char_u *fname));
> void fname_expand __PARMS((char_u **fname, char_u **sfname));
Index: ./src/proto/charset.pro
diff -r ../vim3.0/src/proto/charset.pro ./src/proto/charset.pro
2c2
< unsigned char *transchar __PARMS((int c));
---
> char_u *transchar __PARMS((int c));
4,5c4,6
< int strsize __PARMS((unsigned char *s));
< int chartabsize __PARMS((int c, long col));
---
> int strsize __PARMS((char_u *s));
> int chartabsize __PARMS((register int c, long col));
> int linetabsize __PARMS((char_u *s));
Index: ./src/proto/cmdcmds.pro
diff -r ../vim3.0/src/proto/cmdcmds.pro ./src/proto/cmdcmds.pro
2,7c2,12
< void do_align __PARMS((long start, long end, int width, int type));
< int do_move __PARMS((long line1, long line2, long n));
< void do_copy __PARMS((long line1, long line2, long n));
< void dobang __PARMS((int addr_count, long line1, long line2, int forceit, unsigned char *arg));
< void doshell __PARMS((unsigned char *cmd));
< void dofilter __PARMS((long line1, long line2, unsigned char *buff, int do_in, int do_out));
---
> void do_align __PARMS((linenr_t start, linenr_t end, int width, int type));
> void do_retab __PARMS((linenr_t start, linenr_t end, int new_ts, int force));
> int do_move __PARMS((linenr_t line1, linenr_t line2, linenr_t n));
> void do_copy __PARMS((linenr_t line1, linenr_t line2, linenr_t n));
> void dobang __PARMS((int addr_count, linenr_t line1, linenr_t line2, int forceit, char_u *arg));
> void doshell __PARMS((char_u *cmd));
> void dofilter __PARMS((linenr_t line1, linenr_t line2, char_u *buff, int do_in, int do_out));
> int read_viminfo __PARMS((char_u *file, int want_info, int want_marks, int force));
> void write_viminfo __PARMS((char_u *file, int force));
> void viminfo_readstring __PARMS((char_u *p));
> void viminfo_writestring __PARMS((FILE *fd, char_u *p));
Index: ./src/proto/cmdline.pro
diff -r ../vim3.0/src/proto/cmdline.pro ./src/proto/cmdline.pro
2c2
< int getcmdline __PARMS((int firstc, unsigned char *buff));
---
> int getcmdline __PARMS((int firstc, char_u *buff));
6,7c6,7
< int docmdline __PARMS((unsigned char *cmdline));
< int autowrite __PARMS((struct buffer *buf));
---
> int docmdline __PARMS((char_u *cmdline, int sourcing, int repeating));
> int autowrite __PARMS((BUF *buf));
9,11c9,10
< int doecmd __PARMS((unsigned char *fname, unsigned char *sfname, unsigned char *command, int hide, long newlnum));
< void gotocmdline __PARMS((int clr, int firstc));
< void gotocmdend __PARMS((void));
---
> int doecmd __PARMS((int fnum, char_u *fname, char_u *sfname, char_u *command, int hide, linenr_t newlnum));
> void gotocmdline __PARMS((int clr));
13,15c12,19
< int getfile __PARMS((unsigned char *fname, unsigned char *sfname, int setpm, long lnum));
< unsigned char *ExpandOne __PARMS((unsigned char *str, int list_notfound, int mode));
< int dosource __PARMS((unsigned char *fname));
---
> int getfile __PARMS((int fnum, char_u *fname, char_u *sfname, int setpm, linenr_t lnum));
> char_u *ExpandOne __PARMS((char_u *str, int list_notfound, int mode));
> char_u *addstar __PARMS((char_u *fname, int len));
> int dosource __PARMS((register char_u *fname));
> void prepare_viminfo_history __PARMS((int len));
> int read_viminfo_history __PARMS((char_u *line, linenr_t *lnum, FILE *fp, int force));
> void finish_viminfo_history __PARMS((void));
> void write_viminfo_history __PARMS((FILE *fp));
Index: ./src/proto/csearch.pro
diff -r ../vim3.0/src/proto/csearch.pro ./src/proto/csearch.pro
2,3c2,5
< void dosub __PARMS((long lp, long up, unsigned char *cmd, unsigned char **nextcommand, int use_old));
< void doglob __PARMS((int type, long lp, long up, unsigned char *cmd));
---
> void dosub __PARMS((linenr_t lp, linenr_t up, char_u *cmd, char_u **nextcommand, int use_old));
> void doglob __PARMS((int type, linenr_t lp, linenr_t up, char_u *cmd));
> int read_viminfo_sub_string __PARMS((char_u *line, linenr_t *lnum, FILE *fp, int force));
> void write_viminfo_sub_string __PARMS((FILE *fp));
Index: ./src/proto/digraph.pro
diff -r ../vim3.0/src/proto/digraph.pro ./src/proto/digraph.pro
4c4
< void putdigraph __PARMS((unsigned char *str));
---
> void putdigraph __PARMS((char_u *str));
Index: ./src/proto/edit.pro
diff -r ../vim3.0/src/proto/edit.pro ./src/proto/edit.pro
2,4c2,7
< void edit __PARMS((long count));
< int get_literal __PARMS((int *nextc));
< void insertchar __PARMS((unsigned int c));
---
> int edit __PARMS((long count));
> int is_ctrl_x_key __PARMS((int c));
> int add_completion_and_infercase __PARMS((char_u *str, int len, int dir));
> int get_literal __PARMS((void));
> void insertchar __PARMS((unsigned c, int force_formatting));
> void set_last_insert __PARMS((int c));
12c15,18
< unsigned char *get_last_insert __PARMS((void));
---
> char_u *get_last_insert __PARMS((void));
> void replace_push __PARMS((int c));
> int replace_pop __PARMS((void));
> void replace_flush __PARMS((void));
Index: ./src/proto/fileio.pro
diff -r ../vim3.0/src/proto/fileio.pro ./src/proto/fileio.pro
2,7c2,8
< void filemess __PARMS((unsigned char *name, unsigned char *s));
< int readfile __PARMS((unsigned char *fname, unsigned char *sfname, long from, int newfile, long skip_lnum, long nlines));
< int buf_write __PARMS((struct buffer *buf, unsigned char *fname, unsigned char *sfname, long start, long end, int append, int forceit, int reset_changed));
< unsigned char *modname __PARMS((unsigned char *fname, unsigned char *ext));
< unsigned char *buf_modname __PARMS((struct buffer *buf, unsigned char *fname, unsigned char *ext));
< int vim_fgets __PARMS((unsigned char *buf, int size, struct __stdio *fp, int *lnum));
---
> void filemess __PARMS((char_u *name, char_u *s));
> int readfile __PARMS((char_u *fname, char_u *sfname, linenr_t from, int newfile, linenr_t skip_lnum, linenr_t nlines));
> int buf_write __PARMS((BUF *buf, char_u *fname, char_u *sfname, linenr_t start, linenr_t end, int append, int forceit, int reset_changed));
> char_u *modname __PARMS((char_u *fname, char_u *ext));
> char_u *buf_modname __PARMS((BUF *buf, char_u *fname, char_u *ext));
> int vim_fgets __PARMS((char_u *buf, int size, FILE *fp, linenr_t *lnum));
> int vim_rename __PARMS((char_u *from, char_u *to));
Index: ./src/proto/getchar.pro
diff -r ../vim3.0/src/proto/getchar.pro ./src/proto/getchar.pro
2,3c2,3
< unsigned char *get_recorded __PARMS((void));
< unsigned char *get_inserted __PARMS((void));
---
> char_u *get_recorded __PARMS((void));
> char_u *get_inserted __PARMS((void));
7c7
< void AppendToRedobuff __PARMS((unsigned char *s));
---
> void AppendToRedobuff __PARMS((char_u *s));
10c10
< void stuffReadbuff __PARMS((unsigned char *s));
---
> void stuffReadbuff __PARMS((char_u *s));
13,14c13
< void copy_redo __PARMS((void));
< int start_redo __PARMS((long count));
---
> int start_redo __PARMS((long count, int old));
18,20c17,19
< int ins_typestr __PARMS((unsigned char *str, int noremap));
< void del_typestr __PARMS((int len));
< int openscript __PARMS((unsigned char *name));
---
> int ins_typestr __PARMS((char_u *str, int noremap, int offset, int nottyped));
> void del_typestr __PARMS((int len, int offset));
> int openscript __PARMS((char_u *name));
24,27c23,28
< int domap __PARMS((int maptype, unsigned char *keys, int mode));
< int check_abbr __PARMS((int c, unsigned char *ptr, int col, int mincol));
< int makemap __PARMS((struct __stdio *fd));
< int putescstr __PARMS((struct __stdio *fd, unsigned char *str, int set));
---
> int char_avail __PARMS((void));
> void vungetc __PARMS((int c));
> int domap __PARMS((int maptype, char_u *keys, int mode));
> int check_abbr __PARMS((int c, char_u *ptr, int col, int mincol));
> int makemap __PARMS((FILE *fd));
> int putescstr __PARMS((FILE *fd, char_u *str, int set));
Index: ./src/proto/linefunc.pro
diff -r ../vim3.0/src/proto/linefunc.pro ./src/proto/linefunc.pro
2c2
< void coladvance __PARMS((unsigned int wcol));
---
> void coladvance __PARMS((colnr_t wcol));
4,5c4,5
< int inc __PARMS((struct fpos *lp));
< int incl __PARMS((struct fpos *lp));
---
> int inc __PARMS((register FPOS *lp));
> int incl __PARMS((register FPOS *lp));
7,8c7,8
< int dec __PARMS((struct fpos *lp));
< int decl __PARMS((struct fpos *lp));
---
> int dec __PARMS((register FPOS *lp));
> int decl __PARMS((register FPOS *lp));
Index: ./src/proto/mark.pro
diff -r ../vim3.0/src/proto/mark.pro ./src/proto/mark.pro
5,8c5,8
< struct fpos *movemark __PARMS((int count));
< struct fpos *getmark __PARMS((int c, int changefile));
< void clrallmarks __PARMS((struct buffer *buf));
< unsigned char *fm_getname __PARMS((struct filemark *fmark));
---
> FPOS *movemark __PARMS((int count));
> FPOS *getmark __PARMS((int c, int changefile));
> void clrallmarks __PARMS((BUF *buf));
> char_u *fm_getname __PARMS((struct filemark *fmark));
11c11
< void mark_adjust __PARMS((long line1, long line2, long inc));
---
> void mark_adjust __PARMS((linenr_t line1, linenr_t line2, long amount));
Index: ./src/proto/memfile.pro
diff -r ../vim3.0/src/proto/memfile.pro ./src/proto/memfile.pro
2,9c2,9
< struct memfile *mf_open __PARMS((unsigned char *fname, int new, int fail_nofile));
< int mf_open_file __PARMS((struct memfile *mfp, unsigned char *fname));
< void mf_close __PARMS((struct memfile *mfp, int delete));
< struct block_hdr *mf_new __PARMS((struct memfile *mfp, int negative, int page_count));
< struct block_hdr *mf_get __PARMS((struct memfile *mfp, long nr, int page_count));
< void mf_put __PARMS((struct memfile *mfp, struct block_hdr *hp, int dirty, int infile));
< void mf_free __PARMS((struct memfile *mfp, struct block_hdr *hp));
< int mf_sync __PARMS((struct memfile *mfp, int all, int check_char));
---
> MEMFILE *mf_open __PARMS((char_u *fname, int new, int fail_nofile));
> int mf_open_file __PARMS((MEMFILE *mfp, char_u *fname));
> void mf_close __PARMS((MEMFILE *mfp, int delete));
> BHDR *mf_new __PARMS((MEMFILE *mfp, int negative, int page_count));
> BHDR *mf_get __PARMS((MEMFILE *mfp, blocknr_t nr, int page_count));
> void mf_put __PARMS((MEMFILE *mfp, BHDR *hp, int dirty, int infile));
> void mf_free __PARMS((MEMFILE *mfp, BHDR *hp));
> int mf_sync __PARMS((MEMFILE *mfp, int all, int check_char));
11,13c11,13
< long mf_trans_del __PARMS((struct memfile *mfp, long old));
< void mf_fullname __PARMS((struct memfile *mfp));
< int mf_need_trans __PARMS((struct memfile *mfp));
---
> blocknr_t mf_trans_del __PARMS((MEMFILE *mfp, blocknr_t old));
> void mf_fullname __PARMS((MEMFILE *mfp));
> int mf_need_trans __PARMS((MEMFILE *mfp));
Index: ./src/proto/memline.pro
diff -r ../vim3.0/src/proto/memline.pro ./src/proto/memline.pro
2a3
> void ml_setname __PARMS((void));
4,6c5,7
< void ml_close __PARMS((struct buffer *buf));
< void ml_close_all __PARMS((void));
< void ml_timestamp __PARMS((struct buffer *buf));
---
> void ml_close __PARMS((BUF *buf, int delete));
> void ml_close_all __PARMS((int delete));
> void ml_timestamp __PARMS((BUF *buf));
8,13c9,14
< void ml_sync_all __PARMS((int check_file));
< void ml_preserve __PARMS((struct buffer *buf, int message));
< unsigned char *ml_get __PARMS((long lnum));
< unsigned char *ml_get_pos __PARMS((struct fpos *pos));
< unsigned char *ml_get_cursor __PARMS((void));
< unsigned char *ml_get_buf __PARMS((struct buffer *buf, long lnum, int will_change));
---
> void ml_sync_all __PARMS((int check_file, int check_char));
> void ml_preserve __PARMS((BUF *buf, int message));
> char_u *ml_get __PARMS((linenr_t lnum));
> char_u *ml_get_pos __PARMS((FPOS *pos));
> char_u *ml_get_cursor __PARMS((void));
> char_u *ml_get_buf __PARMS((BUF *buf, linenr_t lnum, int will_change));
15,20c16,21
< int ml_append __PARMS((long lnum, unsigned char *line, unsigned int len, int newfile));
< int ml_replace __PARMS((long lnum, unsigned char *line, int copy));
< int ml_delete __PARMS((long lnum));
< void ml_setmarked __PARMS((long lnum));
< long ml_firstmarked __PARMS((void));
< int ml_has_mark __PARMS((long lnum));
---
> int ml_append __PARMS((linenr_t lnum, char_u *line, colnr_t len, int newfile));
> int ml_replace __PARMS((linenr_t lnum, char_u *line, int copy));
> int ml_delete __PARMS((linenr_t lnum, int message));
> void ml_setmarked __PARMS((linenr_t lnum));
> linenr_t ml_firstmarked __PARMS((void));
> int ml_has_mark __PARMS((linenr_t lnum));
Index: ./src/proto/message.pro
diff -r ../vim3.0/src/proto/message.pro ./src/proto/message.pro
2,4c2,5
< int msg __PARMS((unsigned char *s));
< int emsg __PARMS((unsigned char *s));
< int emsg2 __PARMS((unsigned char *s, unsigned char *a1));
---
> int msg __PARMS((char_u *s));
> int emsg __PARMS((char_u *s));
> int emsg2 __PARMS((char_u *s, char_u *a1));
> int msg_trunc __PARMS((char_u *s));
10,13c11,17
< int msg_outtrans __PARMS((unsigned char *str, int len));
< void msg_prt_line __PARMS((unsigned char *s));
< void msg_outstr __PARMS((unsigned char *s));
< void msg_ceol __PARMS((void));
---
> int msg_outtrans __PARMS((register char_u *str, register int len));
> int msg_outtrans_meta __PARMS((register char_u *str, register int all));
> char_u **get_key_names __PARMS((void));
> void msg_prt_line __PARMS((char_u *s));
> void msg_outstr __PARMS((char_u *s));
> void msg_moremsg __PARMS((void));
> void msg_clr_eos __PARMS((void));
Index: ./src/proto/misccmds.pro
diff -r ../vim3.0/src/proto/misccmds.pro ./src/proto/misccmds.pro
3,8c3,9
< void set_indent __PARMS((int size, int delete));
< int Opencmd __PARMS((int dir, int redraw, int delspaces));
< int plines __PARMS((long p));
< int plines_win __PARMS((struct window *wp, long p));
< int plines_m __PARMS((long first, long last));
< int plines_m_win __PARMS((struct window *wp, long first, long last));
---
> void set_indent __PARMS((register int size, int delete));
> int Opencmd __PARMS((int dir, int redraw));
> int get_leader_len __PARMS((char_u *str));
> int plines __PARMS((linenr_t p));
> int plines_win __PARMS((WIN *wp, linenr_t p));
> int plines_m __PARMS((linenr_t first, linenr_t last));
> int plines_m_win __PARMS((WIN *wp, linenr_t first, linenr_t last));
10c11
< void insstr __PARMS((unsigned char *s));
---
> void insstr __PARMS((register char_u *s));
13c14
< int gchar __PARMS((struct fpos *pos));
---
> int gchar __PARMS((FPOS *pos));
17,21c18,22
< void skipspace __PARMS((unsigned char **pp));
< void skiptospace __PARMS((unsigned char **pp));
< void skiptodigit __PARMS((unsigned char **pp));
< long getdigits __PARMS((unsigned char **pp));
< unsigned char *plural __PARMS((long n));
---
> void skipwhite __PARMS((char_u **pp));
> void skiptowhite __PARMS((char_u **pp));
> void skiptodigit __PARMS((char_u **pp));
> long getdigits __PARMS((char_u **pp));
> char_u *plural __PARMS((long n));
23c24
< void unset_Changed __PARMS((struct buffer *buf));
---
> void unset_Changed __PARMS((BUF *buf));
25c26
< int ask_yesno __PARMS((unsigned char *str));
---
> int ask_yesno __PARMS((char_u *str, int dirent));
26a28
> void beep_flush __PARMS((void));
28,31c30,33
< void expand_env __PARMS((unsigned char *src, unsigned char *dst, int dstlen));
< void home_replace __PARMS((unsigned char *src, unsigned char *dst, int dstlen));
< int fullpathcmp __PARMS((unsigned char *s1, unsigned char *s2));
< unsigned char *gettail __PARMS((unsigned char *fname));
---
> void expand_env __PARMS((char_u *src, char_u *dst, int dstlen));
> void home_replace __PARMS((char_u *src, char_u *dst, int dstlen));
> int fullpathcmp __PARMS((char_u *s1, char_u *s2));
> char_u *gettail __PARMS((char_u *fname));
32a35,36
> void recover_list __PARMS((void));
> char_u *concat_fnames __PARMS((char_u *fname1, char_u *fname2));
Index: ./src/proto/msdos.pro
diff -r ../vim3.0/src/proto/msdos.pro ./src/proto/msdos.pro
1,40c1,34
< /* vi:ts=4:sw=4
<  *
<  * VIM - Vi IMproved		by Bram Moolenaar
<  *
<  * Read the file "credits.txt" for a list of people who contributed.
<  * Read the file "uganda.txt" for copying and usage conditions.
<  */
< 
< /* prototypes from msdos.c */
< long	mch_avail_mem __ARGS((int));
< void	vim_delay __ARGS((void));
< int		vim_remove __ARGS((char_u *));
< void	mch_write __ARGS((char_u *, int));
< int 	GetChars __ARGS((char_u *, int, int));
< int		mch_char_avail __ARGS((void));
< void	mch_suspend __ARGS((void));
< void	mch_windinit __ARGS((void));
< void	check_win __ARGS((int, char **));
< void	fname_case __ARGS((char_u *));
< void	mch_settitle __ARGS((char_u *, char_u *));
< void	mch_restore_title __PARMS((int which));
< int		vim_dirname __ARGS((char_u *, int));
< int		FullName __ARGS((char_u *, char_u *, int));
< int		isFullName __ARGS((char_u *));
< long	getperm __ARGS((char_u *));
< int		setperm __ARGS((char_u *, long));
< int		isdir __ARGS((char_u *));
< void	mch_windexit __ARGS((int));
< void	mch_settmode __ARGS((int));
< int		mch_screenmode __ARGS((char_u *));
< int		mch_get_winsize __ARGS((void));
< void	set_window __ARGS((void));
< void	mch_set_winsize __ARGS((void));
< int		call_shell __ARGS((char_u *, int, int));
< void	breakcheck __ARGS((void));
< char_u	*modname __ARGS((char_u *, char_u *));
< int		has_wildcard __ARGS((char_u *));
< int		ExpandWildCards __ARGS((int, char_u **, int *, char_u ***, int, int));
< void	FreeWild __ARGS((int, char_u **));
< int		vim_chdir __ARGS((char_u *));
---
> /* msdos.c */
> long mch_avail_mem __PARMS((int special));
> void vim_delay __PARMS((void));
> int vim_remove __PARMS((char_u *name));
> void mch_write __PARMS((char_u *s, int len));
> int GetChars __PARMS((char_u *buf, int maxlen, int time));
> int mch_char_avail __PARMS((void));
> void mch_suspend __PARMS((void));
> void mch_windinit __PARMS((void));
> void check_win __PARMS((int argc, char **argv));
> void fname_case __PARMS((char_u *name));
> void mch_settitle __PARMS((char_u *title, char_u *icon));
> void mch_restore_title __PARMS((int which));
> int vim_dirname __PARMS((char_u *buf, int len));
> int FullName __PARMS((char_u *fname, char_u *buf, int len));
> int isFullName __PARMS((char_u *fname));
> long getperm __PARMS((char_u *name));
> int setperm __PARMS((char_u *name, long perm));
> int isdir __PARMS((char_u *name));
> void mch_windexit __PARMS((int r));
> void interrupt catch_cbrk __PARMS((void));
> void interrupt catch_cint __PARMS((unsigned bp, unsigned di, unsigned si, unsigned ds, unsigned es, unsigned dx, unsigned cx, unsigned bx, unsigned ax));
> void mch_settmode __PARMS((int raw));
> void setmouse __PARMS((int on));
> int mch_screenmode __PARMS((char_u *arg));
> int mch_get_winsize __PARMS((void));
> void set_window __PARMS((void));
> void mch_set_winsize __PARMS((void));
> int call_shell __PARMS((char_u *cmd, int filter, int cooked));
> void breakcheck __PARMS((void));
> int has_wildcard __PARMS((char_u *s));
> int ExpandWildCards __PARMS((int num_pat, char_u **pat, int *num_file, char_u ***file, int files_only, int list_notfound));
> void FreeWild __PARMS((int num, char_u **file));
> int vim_chdir __PARMS((char_u *path));
Index: ./src/proto/normal.pro
diff -r ../vim3.0/src/proto/normal.pro ./src/proto/normal.pro
2a3,4
> void start_visual_highlight __PARMS((void));
> int find_ident_under_cursor __PARMS((char_u **string, int try_string));
Index: ./src/proto/ops.pro
diff -r ../vim3.0/src/proto/ops.pro ./src/proto/ops.pro
4c4
< int is_yank_buffer __PARMS((int c, int write));
---
> int is_yank_buffer __PARMS((int c, int writing));
10,11c10,11
< void swapchar __PARMS((struct fpos *pos));
< void dochange __PARMS((void));
---
> void swapchar __PARMS((FPOS *pos));
> int dochange __PARMS((void));
16c16
< void dis_msg __PARMS((unsigned char *p, int skip_esc));
---
> void dis_msg __PARMS((char_u *p, int skip_esc));
20,21c20,23
< void startinsert __PARMS((int initstr, int startln, long count));
< int doaddsub __PARMS((int command, long Prenum1));
---
> int startinsert __PARMS((int initstr, int startln, long count));
> int doaddsub __PARMS((int command, linenr_t Prenum1));
> int read_viminfo_register __PARMS((char_u *line, linenr_t *lnum, FILE *fp, int force));
> void write_viminfo_registers __PARMS((FILE *fp));
Index: ./src/proto/param.pro
diff -r ../vim3.0/src/proto/param.pro ./src/proto/param.pro
3,5c3,5
< int doset __PARMS((unsigned char *arg));
< void paramchanged __PARMS((unsigned char *arg));
< int makeset __PARMS((struct __stdio *fd));
---
> int doset __PARMS((char_u *arg));
> void paramchanged __PARMS((char_u *arg));
> int makeset __PARMS((FILE *fd));
8,11c8,15
< void win_copy_options __PARMS((struct window *wp_from, struct window *wp_to));
< void buf_copy_options __PARMS((struct buffer *bp_from, struct buffer *bp_to));
< void set_context_in_set_cmd __PARMS((unsigned char *arg));
< int ExpandSettings __PARMS((struct regexp *prog, int *num_file, unsigned char ***file));
---
> void win_copy_options __PARMS((WIN *wp_from, WIN *wp_to));
> void buf_copy_options __PARMS((BUF *bp_from, BUF *bp_to));
> void set_context_in_set_cmd __PARMS((char_u *arg));
> int ExpandSettings __PARMS((regexp *prog, int *num_file, char_u ***file));
> int ExpandOldSetting __PARMS((int *num_file, char_u ***file));
> char_u *file_pat_to_reg_pat __PARMS((char_u *pat));
> void do_autocmd __PARMS((char_u *arg, int force));
> void apply_autocmds __PARMS((char_u *fname));
Index: ./src/proto/quickfix.pro
diff -r ../vim3.0/src/proto/quickfix.pro ./src/proto/quickfix.pro
4,5c4,5
< void qf_list __PARMS((void));
< void qf_mark_adjust __PARMS((long line1, long line2, long inc));
---
> void qf_list __PARMS((int all));
> void qf_mark_adjust __PARMS((linenr_t line1, linenr_t line2, long amount));
Index: ./src/proto/regexp.pro
diff -r ../vim3.0/src/proto/regexp.pro ./src/proto/regexp.pro
2,6c2,6
< unsigned char *skip_regexp __PARMS((unsigned char *p, int dirc));
< struct regexp *regcomp __PARMS((unsigned char *exp));
< int regexec __PARMS((struct regexp *prog, unsigned char *string, int at_bol));
< int cstrncmp __PARMS((unsigned char *s1, unsigned char *s2, int n));
< unsigned char *cstrchr __PARMS((unsigned char *s, int c));
---
> char_u *skip_regexp __PARMS((char_u *p, int dirc));
> regexp *regcomp __PARMS((char_u *exp));
> int regexec __PARMS((register regexp *prog, register char_u *string, int at_bol));
> int cstrncmp __PARMS((char_u *s1, char_u *s2, int n));
> char_u *cstrchr __PARMS((char_u *s, register int c));
Index: ./src/proto/regsub.pro
diff -r ../vim3.0/src/proto/regsub.pro ./src/proto/regsub.pro
2,3c2,3
< unsigned char *regtilde __PARMS((unsigned char *source, int magic));
< int regsub __PARMS((struct regexp *prog, unsigned char *source, unsigned char *dest, int copy, int magic));
---
> char_u *regtilde __PARMS((char_u *source, int magic));
> int regsub __PARMS((regexp *prog, char_u *source, char_u *dest, int copy, int magic));
Index: ./src/proto/screen.pro
diff -r ../vim3.0/src/proto/screen.pro ./src/proto/screen.pro
2a3
> void update_curbuf __PARMS((int type));
4c5
< void win_update __PARMS((struct window *wp));
---
> void win_update __PARMS((WIN *wp));
6c7
< void win_redr_status __PARMS((struct window *wp));
---
> void win_redr_status __PARMS((WIN *wp));
8c9
< void screen_msg __PARMS((unsigned char *msg, int row, int col));
---
> void screen_msg __PARMS((char_u *text, int row, int col));
12a14,15
> void remember_highlight __PARMS((void));
> void recover_old_highlight __PARMS((void));
15c18,19
< void comp_Botline __PARMS((struct window *wp));
---
> void comp_Botline __PARMS((WIN *wp));
> void screenalloc __PARMS((int clear));
20c24
< int getvcol __PARMS((struct window *wp, struct fpos *pos, int type));
---
> int getvcol __PARMS((WIN *wp, FPOS *pos, int type));
23,25c27,31
< int win_ins_lines __PARMS((struct window *wp, int row, int nlines, int invalid, int mayclear));
< int win_del_lines __PARMS((struct window *wp, int row, int nlines, int invalid, int mayclear));
< void win_rest_invalid __PARMS((struct window *wp));
---
> void scrolldown_clamp __PARMS((void));
> void scrollup_clamp __PARMS((void));
> int win_ins_lines __PARMS((WIN *wp, int row, int nlines, int invalid, int mayclear));
> int win_del_lines __PARMS((WIN *wp, int row, int nlines, int invalid, int mayclear));
> void win_rest_invalid __PARMS((WIN *wp));
30c36
< void win_redr_ruler __PARMS((struct window *wp, int always));
---
> void win_redr_ruler __PARMS((WIN *wp, int always));
31a38,39
> int jumpto __PARMS((int row, int col));
> void redraw_later __PARMS((int type));
Index: ./src/proto/search.pro
diff -r ../vim3.0/src/proto/search.pro ./src/proto/search.pro
2,6c2,8
< struct regexp *myregcomp __PARMS((unsigned char *pat, int sub_cmd, int which_pat));
< int searchit __PARMS((struct fpos *pos, int dir, unsigned char *str, long count, int end, int message));
< int dosearch __PARMS((int dirc, unsigned char *str, int reverse, long count, int echo, int message));
< int searchc __PARMS((int c, int dir, int type, long count));
< struct fpos *showmatch __PARMS((int initc));
---
> regexp *myregcomp __PARMS((char_u *pat, int sub_cmd, int which_pat));
> int searchit __PARMS((FPOS *pos, int dir, char_u *str, long count, int end, int message, int which_pat));
> int dosearch __PARMS((int dirc, char_u *str, int reverse, long count, int echo, int message));
> int search_for_exact_line __PARMS((FPOS *pos, int dir, char_u *pat));
> int searchc __PARMS((int c, register int dir, int type, long count));
> FPOS *findmatch __PARMS((int initc));
> void showmatch __PARMS((void));
9,10c11,12
< int findpar __PARMS((int dir, long count, int what, int both));
< int startPS __PARMS((long lnum, int para, int both));
---
> int findpar __PARMS((register int dir, long count, int what, int both));
> int startPS __PARMS((linenr_t lnum, int para, int both));
14a17,19
> void find_pattern_in_path __PARMS((char_u *ptr, int len, int whole, int type, int count, int action, linenr_t start_lnum, linenr_t end_lnum));
> int read_viminfo_search_pattern __PARMS((char_u *line, linenr_t *lnum, FILE *fp, int force));
> void write_viminfo_search_pattern __PARMS((FILE *fp));
Index: ./src/proto/tag.pro
diff -r ../vim3.0/src/proto/tag.pro ./src/proto/tag.pro
2c2
< void dotag __PARMS((unsigned char *tag, int type, int count));
---
> void dotag __PARMS((char_u *tag, int type, int count));
4c4
< int ExpandTags __PARMS((struct regexp *prog, int *num_file, unsigned char ***file));
---
> int ExpandTags __PARMS((regexp *prog, int *num_file, char_u ***file));
Index: ./src/proto/term.pro
diff -r ../vim3.0/src/proto/term.pro ./src/proto/term.pro
2,4c2,4
< void set_term __PARMS((unsigned char *term));
< char *tgoto __PARMS((char *cm, int x, int y));
< void termcapinit __PARMS((unsigned char *term));
---
> void set_term __PARMS((char_u *term));
> void getlinecol __PARMS((void));
> void termcapinit __PARMS((char_u *term));
6,8c6,8
< void outchar __PARMS((unsigned int c));
< void outstrn __PARMS((unsigned char *s));
< void outstr __PARMS((unsigned char *s));
---
> void outchar __PARMS((unsigned c));
> void outstrn __PARMS((char_u *s));
> void outstr __PARMS((register char_u *s));
12,14c12,15
< int inchar __PARMS((unsigned char *buf, int maxlen, int time));
< int check_termcode __PARMS((unsigned char *buf));
< void outnum __PARMS((long n));
---
> int inchar __PARMS((char_u *buf, int maxlen, int wait_time));
> int check_termcode __PARMS((void));
> void replace_termcodes __PARMS((char_u *buf));
> void outnum __PARMS((register long n));
19a21
> void scroll_start __PARMS((void));
22c24
< void scroll_region_set __PARMS((struct window *wp));
---
> void scroll_region_set __PARMS((WIN *wp));
Index: ./src/proto/undo.pro
diff -r ../vim3.0/src/proto/undo.pro ./src/proto/undo.pro
3,6c3,6
< int u_save __PARMS((long top, long bot));
< int u_savesub __PARMS((long lnum));
< int u_inssub __PARMS((long lnum));
< int u_savedel __PARMS((long lnum, long nlines));
---
> int u_save __PARMS((linenr_t top, linenr_t bot));
> int u_savesub __PARMS((linenr_t lnum));
> int u_inssub __PARMS((linenr_t lnum));
> int u_savedel __PARMS((linenr_t lnum, long nlines));
10,12c10,12
< void u_unchanged __PARMS((struct buffer *buf));
< void u_clearall __PARMS((struct buffer *buf));
< void u_saveline __PARMS((long lnum));
---
> void u_unchanged __PARMS((BUF *buf));
> void u_clearall __PARMS((BUF *buf));
> void u_saveline __PARMS((linenr_t lnum));
15c15
< void u_blockfree __PARMS((struct buffer *buf));
---
> void u_blockfree __PARMS((BUF *buf));
Index: ./src/proto/unix.pro
diff -r ../vim3.0/src/proto/unix.pro ./src/proto/unix.pro
1,42c1,31
< /* vi:ts=4:sw=4
<  *
<  * VIM - Vi IMproved		by Bram Moolenaar
<  *
<  * Read the file "credits.txt" for a list of people who contributed.
<  * Read the file "uganda.txt" for copying and usage conditions.
<  */
< 
< /*
<  * functions in unix.c
<  */
< void	mch_write __ARGS((char_u *, int));
< int 	GetChars __ARGS((char_u *, int, int));
< int		mch_char_avail __ARGS((void));
< long	mch_avail_mem __ARGS((int));
< void	vim_delay __ARGS((void));
< void	mch_suspend __ARGS((void));
< void	mch_windinit __ARGS((void));
< void	check_win __ARGS((int, char **));
< void	fname_case __ARGS((char_u *));
< void	mch_settitle __ARGS((char_u *, char_u *));
< void	mch_restore_title __PARMS((int which));
< int 	vim_dirname __ARGS((char_u *, int));
< int		FullName __ARGS((char_u *, char_u *, int));
< int		isFullName __ARGS((char_u *));
< long	getperm __ARGS((char_u *));
< int		setperm __ARGS((char_u *, int));
< int		isdir __ARGS((char_u *));
< void	mch_windexit __ARGS((int));
< void	mch_settmode __ARGS((int));
< int		mch_screenmode __ARGS((char_u *));
< int		mch_get_winsize __ARGS((void));
< void	mch_set_winsize __ARGS((void));
< int		call_shell __ARGS((char_u *, int, int));
< void	breakcheck __ARGS((void));
< int		ExpandWildCards __ARGS((int, char_u **, int *, char_u ***, int, int));
< void	FreeWild __ARGS((int, char_u **));
< int		has_wildcard __ARGS((char_u *));
< int		have_wildcard __ARGS((int, char_u **));
< #if defined(M_XENIX) || defined(UTS2)
< int		rename __ARGS((char_u *, char_u *));
< #endif
---
> /* unix.c */
> void mch_write __PARMS((char_u *s, int len));
> int GetChars __PARMS((char_u *buf, int maxlen, int wtime));
> int mch_char_avail __PARMS((void));
> long mch_avail_mem __PARMS((int special));
> void vim_delay __PARMS((void));
> void mch_suspend __PARMS((void));
> void mch_windinit __PARMS((void));
> void check_win __PARMS((int argc, char **argv));
> void fname_case __PARMS((char_u *name));
> void mch_settitle __PARMS((char_u *title, char_u *icon));
> int is_xterm __PARMS((char_u *name));
> void mch_restore_title __PARMS((int which));
> int vim_dirname __PARMS((char_u *buf, int len));
> int FullName __PARMS((char_u *fname, char_u *buf, int len));
> int isFullName __PARMS((char_u *fname));
> long getperm __PARMS((char_u *name));
> int setperm __PARMS((char_u *name, int perm));
> int isdir __PARMS((char_u *name));
> void mch_windexit __PARMS((int r));
> void mch_settmode __PARMS((int raw));
> void setmouse __PARMS((int on));
> int mch_screenmode __PARMS((char_u *arg));
> int mch_get_winsize __PARMS((void));
> void mch_set_winsize __PARMS((void));
> int call_shell __PARMS((char_u *cmd, int dummy, int cooked));
> void breakcheck __PARMS((void));
> int ExpandWildCards __PARMS((int num_pat, char_u **pat, int *num_file, char_u ***file, int files_only, int list_notfound));
> void FreeWild __PARMS((int num, char_u **file));
> int has_wildcard __PARMS((char_u *p));
> int have_wildcard __PARMS((int num, char_u **file));
Index: ./src/proto/window.pro
diff -r ../vim3.0/src/proto/window.pro ./src/proto/window.pro
5,6c5,7
< void win_equal __PARMS((struct window *next_curwin, int redraw));
< void close_window __PARMS((int free_buf));
---
> void win_equal __PARMS((WIN *next_curwin, int redraw));
> void close_windows __PARMS((BUF *buf));
> void close_window __PARMS((WIN *win, int free_buf));
8,13c9,14
< void win_init __PARMS((struct window *wp));
< void win_enter __PARMS((struct window *wp, int undo_sync));
< struct window *win_alloc __PARMS((struct window *after));
< void win_free __PARMS((struct window *wp));
< int win_alloc_lsize __PARMS((struct window *wp));
< void win_free_lsize __PARMS((struct window *wp));
---
> void win_init __PARMS((WIN *wp));
> void win_enter __PARMS((WIN *wp, int undo_sync));
> WIN *win_alloc __PARMS((WIN *after));
> void win_free __PARMS((WIN *wp));
> int win_alloc_lsize __PARMS((WIN *wp));
> void win_free_lsize __PARMS((WIN *wp));
16c17
< void win_comp_scroll __PARMS((struct window *wp));
---
> void win_comp_scroll __PARMS((WIN *wp));
19c20,23
< unsigned char *file_name_at_cursor __PARMS((void));
---
> char_u *file_name_at_cursor __PARMS((void));
> char_u *get_file_name_in_path __PARMS((char_u *ptr, int col, int mess));
> int isfilechar __PARMS((int c));
> int min_rows __PARMS((void));
Index: ./src/proto.h
diff -r ../vim3.0/src/proto.h ./src/proto.h
18a19,23
>  * don't include these while generating prototypes, prevents problems when
>  * files are missing
>  */
> #ifndef PROTO
> /*
21,44c26,37
< #ifdef AMIGA
< # include "proto/amiga.pro"
< #endif
< #ifdef UNIX
< # include "proto/unix.pro"
< #endif
< #ifdef MSDOS
< # include "proto/msdos.pro"
< #endif
< 
< #include "proto/alloc.pro"
< #include "proto/buffer.pro"
< #include "proto/charset.pro"
< #include "proto/cmdcmds.pro"
< #include "proto/cmdline.pro"
< #include "proto/csearch.pro"
< #include "proto/digraph.pro"
< #include "proto/edit.pro"
< #include "proto/fileio.pro"
< #include "proto/getchar.pro"
< #include "proto/help.pro"
< #include "proto/linefunc.pro"
< #include "proto/main.pro"
< #include "proto/mark.pro"
---
> # ifdef AMIGA
> #  include "proto/amiga.pro"
> # endif
> # ifdef UNIX
> #  include "proto/unix.pro"
> #  if defined(M_XENIX) || defined(UTS2)
> 	int rename __PARMS((char_u *, char_u *));
> #  endif
> # endif
> # ifdef MSDOS
> #  include "proto/msdos.pro"
> # endif
45a39,52
> # include "proto/alloc.pro"
> # include "proto/buffer.pro"
> # include "proto/charset.pro"
> # include "proto/cmdcmds.pro"
> # include "proto/cmdline.pro"
> # include "proto/csearch.pro"
> # include "proto/digraph.pro"
> # include "proto/edit.pro"
> # include "proto/fileio.pro"
> # include "proto/getchar.pro"
> # include "proto/help.pro"
> # include "proto/linefunc.pro"
> # include "proto/main.pro"
> # include "proto/mark.pro"
64a72,73
> 
> #endif /* PROTO */
Index: ./src/quickfix.c
diff -r ../vim3.0/src/quickfix.c ./src/quickfix.c
260a261,264
> 	struct qf_line	*old_qf_ptr;
> 	int				old_qf_index;
> 	static char_u	*e_no_more_errors = (char_u *)"No more errors";
> 	char_u			*err = e_no_more_errors;
268a273,274
> 	old_qf_ptr = qf_ptr;
> 	old_qf_index = qf_index;
272a279,280
> 			old_qf_ptr = qf_ptr;
> 			old_qf_index = qf_index;
275a284,292
> 				{
> 					qf_ptr = old_qf_ptr;
> 					qf_index = old_qf_index;
> 					if (err != NULL)
> 					{
> 						emsg(err);
> 						return;
> 					}
> 					errornr = 0;
276a294
> 				}
279a298
> 			err = NULL;
285a305,306
> 			old_qf_ptr = qf_ptr;
> 			old_qf_index = qf_index;
288a310,318
> 				{
> 					qf_ptr = old_qf_ptr;
> 					qf_index = old_qf_index;
> 					if (err != NULL)
> 					{
> 						emsg(err);
> 						return;
> 					}
> 					errornr = 0;
289a320
> 				}
292a324
> 			err = NULL;
325,326c357,363
< 		curwin->w_cursor.col = qf_ptr->qf_col;
< 		adjust_cursor();
---
> 		if (qf_ptr->qf_col > 0)
> 		{
> 			curwin->w_cursor.col = qf_ptr->qf_col;
> 			adjust_cursor();
> 		}
> 		else
> 			beginline(TRUE);
328,329c365,366
< 		smsg((char_u *)"(%d of %d) %s%s: %s", qf_index, qf_count, 
< 					qf_ptr->qf_cleared ? (char_u *)"(line deleted) " : (char_u *)"",
---
> 		smsg((char_u *)"(%d of %d)%s%s: %s", qf_index, qf_count, 
> 					qf_ptr->qf_cleared ? (char_u *)" (line deleted)" : (char_u *)"",
330a368,372
> 		/*
> 		 * if the message is short, redisplay after redrawing the screen
> 		 */
> 		if (linetabsize(IObuff) < sc_col)
> 			keep_msg = IObuff;
331a374,382
> 	else if (qf_ptr->qf_fnum != 0)
> 	{
> 		/*
> 		 * Couldn't open file, so put index back where it was.  This could
> 		 * happen if the file was readonly and we changed something - webb
> 		 */
> 		qf_ptr = old_qf_ptr;
> 		qf_index = old_qf_index;
>   	}
338c389,390
< qf_list()
---
> qf_list(all)
> 	int all;		/* If not :cl!, only show recognised errors */
340,341c392,395
< 	struct qf_line *qfp;
< 	int i;
---
> 	BUF				*buf;
> 	char_u			*fname;
> 	struct qf_line	*qfp;
> 	int				i;
347a402,404
> 
> 	if (qf_nonevalid)
> 		all = TRUE;
349c406
< 	gotocmdline(TRUE, NUL);
---
> 	set_highlight('d');		/* Same as for directories */
352,359c409,433
< 		sprintf((char *)IObuff, "%2d line %3ld col %2d %s: %s",
< 			i,
< 			(long)qfp->qf_lnum,
< 			qfp->qf_col,
< 			qf_types(qfp->qf_type, qfp->qf_nr),
< 			qfp->qf_text);
< 		msg_outstr(IObuff);
< 		msg_outchar('\n');
---
> 		if (qfp->qf_valid || all)
> 		{
> 			msg_outchar('\n');
> 			start_highlight();
> 			fname = NULL;
> 			if (qfp->qf_fnum != 0 && (buf = buflist_findnr(qfp->qf_fnum)) != NULL)
> 				fname = buf->b_xfilename;
> 			if (fname == NULL)
> 				sprintf((char *)IObuff, "%2d", i);
> 			else
> 				sprintf((char *)IObuff, "%2d %s", i, fname);
> 			msg_outstr(IObuff);
> 			stop_highlight();
> 			if (qfp->qf_lnum == 0)
> 				IObuff[0] = NUL;
> 			else if (qfp->qf_col == 0)
> 				sprintf((char *)IObuff, ":%d", qfp->qf_lnum);
> 			else
> 				sprintf((char *)IObuff, ":%d, col %d", qfp->qf_lnum, qfp->qf_col);
> 			sprintf((char *)IObuff + STRLEN(IObuff), "%s: ",
> 										qf_types(qfp->qf_type, qfp->qf_nr));
> 			msg_outstr(IObuff);
> 			msg_prt_line(qfp->qf_text);
> 			flushbuf();					/* show one line at a time */
> 		}
361d434
< 		flushbuf();					/* show one line at a time */
364d436
< 	wait_return(FALSE);
389c461
< qf_mark_adjust(line1, line2, inc)
---
> qf_mark_adjust(line1, line2, amount)
392c464
< 	long		inc;
---
> 	long		amount;
402c474
< 				if (inc == MAXLNUM)
---
> 				if (amount == MAXLNUM)
405c477
< 					qfp->qf_lnum += inc;
---
> 					qfp->qf_lnum += amount;
414c486
<  *  other     0			 ""
---
>  *  other     0			""
Index: ./src/regexp.c
diff -r ../vim3.0/src/regexp.c ./src/regexp.c
367c367
< 		EMSG_RETURN(e_outofmem);
---
> 		return NULL;
701a702,703
> 		EMSG_RETURN((char_u *)"\\= follows nothing");
> 		/* break; Not Reached */
702a705,706
> 		EMSG_RETURN((char_u *)"\\+ follows nothing");
> 		/* break; Not Reached */
704c708,715
< 		EMSG_RETURN((char_u *)"=+* follows nothing");
---
> 		if (reg_magic)
> 		{
> 			EMSG_RETURN((char_u *)"* follows nothing");
> 		}
> 		else
> 		{
> 			EMSG_RETURN((char_u *)"\\* follows nothing");
> 		}
927a939,944
> /*
>  * Note: prevchr is sometimes -1 when we are not at the start,
>  * eg in /[ ^I]^ the pattern was never found even if it existed, because ^ was
>  * taken to be magic -- webb
>  */
> static int		at_start;	/* True when we are on the first character */
934a952
> 	at_start = TRUE;
943d960
< 		case '*':
950a968,972
> 		case '*':
> 			/* * is not magic as the very first character, eg "?*ptr" */
> 			if (reg_magic && !at_start)
> 				curchr = Magic('*');
> 			break;
953c975
< 			if (prevchr < 0)
---
> 			if (at_start)
973a996
> 				at_start = FALSE;			/* We still want to be able to say "/\*ptr" */
995a1019
> 	at_start = FALSE;
1183d1206
< #define isidchar(x)	(isalnum(x) || ((x) == '_'))
Index: ./src/regsub.c
diff -r ../vim3.0/src/regsub.c ./src/regsub.c
57,58d56
< #define CASECONVERT
< 
75c73,78
< #ifdef CASECONVERT
---
> 	/* This stuff below really confuses cc on an SGI -- webb */
> #ifdef __sgi
> # undef __ARGS
> # define __ARGS(x)	()
> #endif
> 
83d85
< static fptr strnfcpy __ARGS((fptr, char_u *, char_u *, int));
85d86
< static fptr do_Copy __ARGS((char_u *, int));
92,101d92
< do_Copy(d, c)
< 	char_u *d;
< 	int c;
< {
< 	*d = c;
< 
< 	return (fptr)do_Copy;
< }
< 
< 	static fptr
108c99
< 	return (fptr)do_Copy;
---
> 	return (fptr)NULL;
128c119
< 	return (fptr)do_Copy;
---
> 	return (fptr)NULL;
141,158d131
< 	static fptr
< strnfcpy(f, d, s, n)
< 	fptr f;
< 	char_u *d;
< 	char_u *s;
< 	int n;
< {
< 	while (n-- > 0) {
< 		f = (fptr)(f(d, *s));		/* Turbo C complains without the typecast */
< 		if (!*s++)
< 			break;
< 		d++;
< 	}
< 
< 	return f;
< }
< #endif
< 
231a205,206
>  * If copy is TRUE really copy into dest, otherwise dest is not written to.
>  *
242,249c217,222
< 	register char_u  *src;
< 	register char_u  *dst;
< 	register int	c;
< 	register int	no;
< 	register int	len;
< #ifdef CASECONVERT
< 	fptr			func = (fptr)do_Copy;
< #endif
---
> 	register char_u  	*src;
> 	register char_u  	*dst;
> 	register char_u	 	*s;
> 	register int		c;
> 	register int		no;
> 	fptr				func = (fptr)NULL;
280d252
< #ifdef CASECONVERT
294c266
< 				case 'E':	func = (fptr)do_Copy;
---
> 				case 'E':	func = (fptr)NULL;
298d269
< #endif
306,307c277,280
< #ifdef CASECONVERT
< 				func = (fptr)(func(dst, c));
---
> 				if (func == (fptr)NULL)		/* just copy */
> 					*dst = c;
> 				else						/* change case */
> 					func = (fptr)(func(dst, c));
309,311d281
< #else
< 				*dst = c;
< #endif
317,318c287
< 			len = (int)(prog->endp[no] - prog->startp[no]);
< 			if (copy)
---
> 			for (s = prog->startp[no]; s < prog->endp[no]; ++s)
320,329c289,318
< #ifdef CASECONVERT
< 				func = strnfcpy(func, dst, prog->startp[no], len);
< #else
< 				(void) STRNCPY(dst, prog->startp[no], len);
< #endif
< 			}
< 			dst += len;
< 			if (copy && len != 0 && *(dst - 1) == '\0') { /* strncpy hit NUL. */
< 				emsg(e_re_damg);
< 				goto exit;
---
> 				if (copy && *s == '\0') /* we hit NUL. */
> 				{
> 					emsg(e_re_damg);
> 					goto exit;
> 				}
> 				/*
> 				 * Insert a CTRL-V in front of a CR, otherwise
> 				 * it will be replaced by a line break.
> 				 */
> 				if (*s == CR)
> 				{
> 					if (copy)
> 					{
> 						dst[0] = Ctrl('V');
> 						dst[1] = CR;
> 					}
> 					dst += 2;
> 				}
> 				else
> 				{
> 					if (copy)
> 					{
> 						if (func == (fptr)NULL)		/* just copy */
> 							*dst = *s;
> 						else						/* change case */
> 							func = (fptr)(func(dst, *s));
> 									/* Turbo C complains without the typecast */
> 					}
> 					++dst;
> 				}
Index: ./src/screen.c
diff -r ../vim3.0/src/screen.c ./src/screen.c
19a20,24
> /*
>  * The characters that are currently on the screen are kept in Nextscreen.
>  * Each line in it has two parts: First the characters and then the
>  * attributes.
>  */
23a29,36
>  * Attributes for Nextscreen.
>  */
> #define CHAR_INVERT		1
> #define CHAR_UNDERL		2
> #define CHAR_BOLD		3
> #define CHAR_STDOUT		4
> 
> /*
31c44
< static int		Cline_height;			/* current size of cursor line */
---
> static int		Cline_height;	/* current size of cursor line */
33c46
< static int		Cline_row;				/* starting row of the cursor line on screen */
---
> static int		Cline_row;		/* starting row of the cursor line on screen */
35,38c48,50
< static FPOS		old_cursor = {0, 0};	/* last known end of visual part */
< static int		oldCurswant = 0;		/* last known value of Curswant */
< static int		canopt;					/* TRUE when cursor goto can be optimized */
< static int		invert = 0;				/* set to INVERTCODE when inverting */
---
> static int		canopt;			/* TRUE when cursor goto can be optimized */
> static int		attributes = 0;	/* current attributes for screen character*/
> static int 		highlight_attr = 0;	/* attributes when highlighting on */
40,41d51
< #define INVERTCODE		0x80
< 
44d53
< static void screenalloc __ARGS((int));
88c97,98
< 				win_ins_lines(curwin, Cline_row + Cline_height, n - Cline_height, FALSE, TRUE);
---
> 				win_ins_lines(curwin, Cline_row + Cline_height,
> 										n - Cline_height, FALSE, TRUE);
94a105,119
>  * update all windows that are editing the current buffer
>  */
> 	void
> update_curbuf(type)
> 	int			type;
> {
> 	WIN				*wp;
> 
> 	for (wp = firstwin; wp; wp = wp->w_next)
> 		if (wp->w_buffer == curbuf && wp->w_redr_type < type)
> 			wp->w_redr_type = type;
> 	updateScreen(type);
> }
> 
> /*
118c143
< 	if (type == CURSUPD)		/* update cursor and then redraw NOT_VALID*/
---
> 	if (type == CURSUPD)		/* update cursor and then redraw NOT_VALID */
124c149
< 	if (curwin->w_lsize_valid == 0 && type != CLEAR)
---
> 	if (curwin->w_lsize_valid == 0 && type < NOT_VALID)
129a155
> 		curwin->w_redr_type = type;
161,162c187,192
< 	if (clear_cmdline)
< 		gotocmdline(TRUE, NUL);	/* first clear cmdline */
---
> 	if (clear_cmdline)			/* first clear cmdline */
> 	{
> 		msg_row = cmdline_row;
> 		msg_col = 0;
> 		msg_clr_eos();			/* will reset clear_cmdline */
> 	}
166,167c196,199
< 			(type == INVERTED && old_cursor.lnum == curwin->w_cursor.lnum &&
< 					old_cursor.col == curwin->w_cursor.col && curwin->w_curswant == oldCurswant))
---
> 			(type == INVERTED &&
> 					curwin->w_old_cursor.lnum == curwin->w_cursor.lnum &&
> 					curwin->w_old_cursor.col == curwin->w_cursor.col &&
> 					curwin->w_old_curswant == curwin->w_curswant))
200,203c232,235
< 	linenr_t		lastline = 0; /* only valid if endrow != Rows -1 */
< 	int				done;		/* if TRUE, we hit the end of the file */
< 	int				didline;	/* if TRUE, we finished the last line */
< 	int 			srow = 0;	/* starting row of the current line */
---
> 	linenr_t		lastline = 0;	/* only valid if endrow != Rows -1 */
> 	int				done;			/* if TRUE, we hit the end of the file */
> 	int				didline;		/* if TRUE, we finished the last line */
> 	int 			srow = 0;		/* starting row of the current line */
258,259c290,291
< 				else if (lastwin == firstwin)	/* far off: clearing the screen is faster */
< 					screenclear();
---
> 				else if (lastwin == firstwin)
> 					screenclear();	/* far off: clearing the screen is faster */
261,262c293,294
< 			else if (lastwin == firstwin)	/* far off: clearing the screen is faster */
< 				screenclear();
---
> 			else if (lastwin == firstwin)
> 				screenclear();		/* far off: clearing the screen is faster */
267c299,300
< 			for (i = 0; i < wp->w_lsize_valid; i++) /* try to find wp->w_topline in wp->w_lsize_lnum[] */
---
> 						/* try to find wp->w_topline in wp->w_lsize_lnum[] */
> 			for (i = 0; i < wp->w_lsize_valid; i++)
280c313
< 					screenclear();   /* far off: clearing the screen is faster */
---
> 					screenclear();	/* far off: clearing the screen is faster */
288c321,322
< 				if ((row == 0 || win_del_lines(wp, 0, row, FALSE, wp == firstwin) == OK) && wp->w_lsize_valid)
---
> 				if ((row == 0 || win_del_lines(wp, 0, row,
> 							FALSE, wp == firstwin) == OK) && wp->w_lsize_valid)
294c328,329
< 						if (type == VALID_TO_CURSCHAR && lnum == wp->w_cursor.lnum)
---
> 						if (type == VALID_TO_CURSCHAR &&
> 													lnum == wp->w_cursor.lnum)
316c351
< 	screen_start();	/* init cursor position of screen_char() */
---
> 	screen_start();			/* init cursor position of screen_char() */
318c353
< 	if (VIsual.lnum)				/* check if we are updating the inverted part */
---
> 	if (VIsual.lnum != 0)	/* check if we are updating the inverted part */
323c358
< 		if (wp->w_cursor.lnum < old_cursor.lnum)
---
> 		if (curwin->w_cursor.lnum < wp->w_old_cursor.lnum)
325,326c360,361
< 			from = wp->w_cursor.lnum;
< 			to = old_cursor.lnum;
---
> 			from = curwin->w_cursor.lnum;
> 			to = wp->w_old_cursor.lnum;
330,331c365,366
< 			from = old_cursor.lnum;
< 			to = wp->w_cursor.lnum;
---
> 			from = wp->w_old_cursor.lnum;
> 			to = curwin->w_cursor.lnum;
333,334c368,369
< 	/* if in block mode and changed column or wp->w_curswant: update all lines */
< 		if (Visual_block && (wp->w_cursor.col != old_cursor.col || wp->w_curswant != oldCurswant))
---
> 			/* if VIsual changed, update the maximal area */
> 		if (VIsual.lnum != wp->w_old_visual_lnum)
335a371,385
> 			if (wp->w_old_visual_lnum < from)
> 				from = wp->w_old_visual_lnum;
> 			if (wp->w_old_visual_lnum > to)
> 				to = wp->w_old_visual_lnum;
> 			if (VIsual.lnum < from)
> 				from = VIsual.lnum;
> 			if (VIsual.lnum > to)
> 				to = VIsual.lnum;
> 		}
> 	/* if in block mode and changed column or wp->w_curswant: update all
> 	 * lines */
> 		if (Visual_mode == Ctrl('V') &&
> 						(curwin->w_cursor.col != wp->w_old_cursor.col ||
> 						wp->w_curswant != wp->w_old_curswant))
> 		{
343a394,395
> 		if (from >= wp->w_botline)
> 			from = wp->w_botline - 1;
365,366c417,419
< 			old_cursor = wp->w_cursor;
< 			oldCurswant = wp->w_curswant;
---
> 			wp->w_old_cursor = curwin->w_cursor;
> 			wp->w_old_visual_lnum = VIsual.lnum;
> 			wp->w_old_curswant = wp->w_curswant;
371,372c424,426
< 			old_cursor = wp->w_cursor;
< 			oldCurswant = wp->w_curswant;
---
> 			wp->w_old_cursor = curwin->w_cursor;
> 			wp->w_old_visual_lnum = VIsual.lnum;
> 			wp->w_old_curswant = wp->w_curswant;
374a429,433
> 	else
> 	{
> 		wp->w_old_cursor.lnum = 0;
> 		wp->w_old_visual_lnum = 0;
> 	}
384c443
< 		if (lnum > wp->w_buffer->b_ml.ml_line_count)		/* hit the end of the file */
---
> 		if (lnum > wp->w_buffer->b_ml.ml_line_count)
386c445
< 			done = TRUE;
---
> 			done = TRUE;		/* hit the end of the file */
391,393c450,452
< 		if (row > endrow)	/* past end of screen */
< 		{
< 			wp->w_lsize[idx] = plines_win(wp, lnum);	/* we may need the size of that */
---
> 		if (row > endrow)		/* past end of screen */
> 		{						/* we may need the size of that */
> 			wp->w_lsize[idx] = plines_win(wp, lnum);
426c485
< 		else if (row > wp->w_height)		/* Need to blank out the last line */
---
> 		else if (row > wp->w_height)	/* Need to blank out the last line */
452c511,512
< 			screen_fill(wp->w_winpos + wp->w_height - 1, wp->w_winpos + wp->w_height, 0, (int)Columns, '@', '@');
---
> 			screen_fill(wp->w_winpos + wp->w_height - 1,
> 					wp->w_winpos + wp->w_height, 0, (int)Columns, '@', '@');
460c520,521
< 			screen_fill(wp->w_winpos + srow, wp->w_winpos + wp->w_height, 0, (int)Columns, '@', ' ');
---
> 			screen_fill(wp->w_winpos + srow,
> 					wp->w_winpos + wp->w_height, 0, (int)Columns, '@', ' ');
469c530,531
< 		screen_fill(wp->w_winpos + row, wp->w_winpos + wp->w_height, 0, (int)Columns, '~', ' ');
---
> 		screen_fill(wp->w_winpos + row,
> 					wp->w_winpos + wp->w_height, 0, (int)Columns, '~', ' ');
570,571c632,633
< 	int				row;				/* row in the window, excluding w_winpos */
< 	int				screen_row;			/* row on the screen, including w_winpos */
---
> 	int				row;				/* row in the window, excl w_winpos */
> 	int				screen_row;			/* row on the screen, incl w_winpos */
582a645,647
> 	if (startrow > endrow)				/* past the end already! */
> 		return startrow;
> 
590c655,659
< 	if (VIsual.lnum && wp == curwin)			/* visual active in this window */
---
> 
> 	/*
> 	 * handle visual active in this window
> 	 */
> 	if (VIsual.lnum != 0 && wp->w_buffer == curwin->w_buffer)
592c661,662
< 		if (ltoreq(wp->w_cursor, VIsual))		/* Visual is after wp->w_cursor */
---
> 										/* Visual is after curwin->w_cursor */
> 		if (ltoreq(curwin->w_cursor, VIsual))
594c664
< 			top = &wp->w_cursor;
---
> 			top = &curwin->w_cursor;
597c667
< 		else							/* Visual is before wp->w_cursor */
---
> 		else							/* Visual is before curwin->w_cursor */
600c670
< 			bot = &wp->w_cursor;
---
> 			bot = &curwin->w_cursor;
602c672
< 		if (Visual_block)						/* block mode */
---
> 		if (Visual_mode == Ctrl('V'))	/* block mode */
630c700
< 			if (VIsual.col == VISUALLINE)		/* linewise */
---
> 			if (Visual_mode == 'V')		/* linewise */
634c704
< 				tocol = VISUALLINE;
---
> 				tocol = MAXCOL;
637,639c707,710
< 			/* if the cursor can't be switched off, don't invert the character
< 						where the cursor is */
< 		if ((T_CI == NULL || *T_CI == NUL) && lnum == wp->w_cursor.lnum)
---
> 			/* if the cursor can't be switched off, don't invert the
> 			 * character where the cursor is */
> 		if (!highlight_match && (T_CI == NULL || *T_CI == NUL) &&
> 							lnum == curwin->w_cursor.lnum && wp == curwin)
644c715,716
< 		else if (fromcol >= 0 && fromcol < wp->w_leftcol)	/* start of invert is left of screen */
---
> 										/* start of invert is left of screen */
> 		else if (fromcol >= 0 && fromcol < wp->w_leftcol)
650a723,736
> 	/*
> 	 * handle incremental search position highlighting
> 	 */
> 	else if (highlight_match && wp == curwin)
> 	{
> 		if (lnum == curwin->w_cursor.lnum)
> 		{
> 			fromcol = getvcol(curwin, &(curwin->w_cursor), 2);
> 			curwin->w_cursor.col += search_match_len;
> 			tocol = getvcol(curwin, &(curwin->w_cursor), 2);
> 			curwin->w_cursor.col -= search_match_len;
> 			canopt = FALSE;
> 		}
> 	}
678c764
< 		if (!canopt)	/* Visual in this line */
---
> 		if (!canopt)	/* Visual or match highlighting in this line */
681,682c767,768
< 					(noinvcur && vcol == wp->w_virtcol + 1 && vcol >= fromcol)) &&
< 					vcol < tocol)
---
> 					(noinvcur && vcol == wp->w_virtcol + 1 &&
> 							vcol >= fromcol)) && vcol < tocol)
684c770,771
< 			else if (invert && (vcol == tocol || (noinvcur && vcol == wp->w_virtcol)))
---
> 			else if (attributes && (vcol == tocol ||
> 									(noinvcur && vcol == wp->w_virtcol)))
688c775
< 		/* Get the next character to put on the screen. */
---
> 	/* Get the next character to put on the screen. */
709,710c796,798
< 				 * when getting a character from the file, we may have to turn it
< 				 * into something else on the way to putting it into 'Nextscreen'.
---
> 				 * when getting a character from the file, we may have to turn
> 				 * it into something else on the way to putting it into
> 				 * 'Nextscreen'.
715c803,804
< 					n_spaces = (int)wp->w_buffer->b_p_ts - vcol % (int)wp->w_buffer->b_p_ts - 1;
---
> 					n_spaces = (int)wp->w_buffer->b_p_ts -
> 									vcol % (int)wp->w_buffer->b_p_ts - 1;
735c824
< 			if (invert)
---
> 			if (attributes)
739c828
< 					if (*screenp != (' ' ^ INVERTCODE))
---
> 					if (*screenp != ' ' || *(screenp + Columns) != attributes)
741c830,831
< 							*screenp = (' ' ^ INVERTCODE);
---
> 							*screenp = ' ';
> 							*(screenp + Columns) = attributes;
752c842,843
< 			while (col < Columns && *screenp == ' ')
---
> 			while (col < Columns && *screenp == ' ' &&
> 											*(screenp + Columns) == 0)
759c850,851
< 				screen_fill(screen_row, screen_row + 1, col, (int)Columns, ' ', ' ');
---
> 				screen_fill(screen_row, screen_row + 1,
> 												col, (int)Columns, ' ', ' ');
783,784d874
< 		 * Be careful with characters where (c ^ INVERTCODE == ' '), they may be
< 		 * confused with spaces inserted by scrolling.
786c876
< 		if (*screenp != (c ^ invert) || c == (' ' ^ INVERTCODE))
---
> 		if (*screenp != c || *(screenp + Columns) != attributes)
788c878,879
< 			*screenp = (c ^ invert);
---
> 			*screenp = c;
> 			*(screenp + Columns) = attributes;
796c887
< 	if (invert)
---
> 	if (attributes)
819c910
<  * put string '*msg' on the screen at position 'row' and 'col'
---
>  * put string '*text' on the screen at position 'row' and 'col'
826,827c917,918
< screen_msg(msg, row, col)
< 	char_u	*msg;
---
> screen_msg(text, row, col)
> 	char_u	*text;
834c925
< 	while (*msg && col < Columns)
---
> 	while (*text && col < Columns)
836c927
< 		if (*screenp != (*msg ^ invert) || *msg == (' ' ^ INVERTCODE))
---
> 		if (*screenp != *text || *(screenp + Columns) != attributes)
838c929,930
< 			*screenp = (*msg ^ invert);
---
> 			*screenp = *text;
> 			*(screenp + Columns) = attributes;
843c935
< 		++msg;
---
> 		++text;
885a978
> 					highlight_attr = CHAR_BOLD;
888a982
> 					highlight_attr = CHAR_STDOUT;
891a986
> 					highlight_attr = 0;
892a988,991
> 		case 'u':	highlight = T_US;		/* underline */
> 					unhighlight = T_UE;
> 					highlight_attr = CHAR_UNDERL;
> 					break;
894a994
> 					highlight_attr = CHAR_INVERT;
912c1012
< 		invert = INVERTCODE;
---
> 		attributes = highlight_attr;
919c1019
< 	if (invert)
---
> 	if (attributes)
922c1022
< 		invert = 0;
---
> 		attributes = 0;
926a1027,1051
>  * variables used for one level depth of highlighting
>  * Used for "-- More --" message.
>  */
> 
> static char_u	*old_highlight = NULL;
> static char_u	*old_unhighlight = NULL;
> static int		old_highlight_attr = 0;
> 
> 	void
> remember_highlight()
> {
> 	old_highlight = highlight;
> 	old_unhighlight = unhighlight;
> 	old_highlight_attr = highlight_attr;
> }
> 
> 	void
> recover_old_highlight()
> {
> 	highlight = old_highlight;
> 	unhighlight = old_unhighlight;
> 	highlight_attr = old_highlight_attr;
> }
> 
> /*
942c1067
< 	if (row == Rows - 1 && col == Columns - 1)
---
> 	if (col == Columns - 1 && row == Rows - 1)
947c1072
< 		if (invert && !p_wi && (T_MS == NULL || *T_MS == NUL))
---
> 		if (attributes && !p_wi && (T_MS == NULL || *T_MS == NUL))
957c1082,1083
< 		 * This can't be used when inverting (a part of) the line.
---
> 		 * This can't be used when switching between inverting and not
> 		 * inverting.
964c1090
< 			if (i <= 4 + noinvcurs && canopt)
---
> 			if (i <= 4 + noinvcurs)
966c1092,1094
< 				while (i)
---
> 				/* stop at the first character that has different attributes
> 				 * from the ones that are active */
> 				while (i && *(p - i + Columns) == attributes)
969c1097
< 					outchar(c ^ invert);
---
> 					outchar(c);
972c1100
< 			else
---
> 			if (i)
995a1124
> 
1002c1131
< 		if (invert)                                      
---
> 		if (attributes)                                      
1007c1136
< 	outchar(*p ^ invert);
---
> 	outchar(*p);
1030,1031d1158
< 	c1 ^= invert;
< 	c2 ^= invert;
1035c1162,1163
< 		if (c2 == ' ' && end_col == Columns && T_EL != NULL && *T_EL != NUL)
---
> 		if (attributes == 0 && c2 == ' ' &&
> 						end_col == Columns && T_EL != NULL && *T_EL != NUL)
1047c1175,1176
< 			while (col < end_col && *screenp == ' ')	/* skip blanks */
---
> 			while (col < end_col && *screenp == ' ' &&
> 								*(screenp + Columns) == 0)	/* skip blanks */
1065c1194
< 			if (*screenp != c)
---
> 			if (*screenp != c || *(screenp + Columns) != attributes)
1067a1197
> 				*(screenp + Columns) = attributes;
1110c1240,1241
< 	wp->w_botline = lnum;		/* wp->w_botline is the line that is just below the window */
---
> 	wp->w_botline = lnum;		/* wp->w_botline is the line that is just
> 								 * below the window */
1113c1244
< 	static void
---
> 	void
1127c1258,1259
< 	if ((Nextscreen != NULL && Rows == old_Rows && Columns == old_Columns) || Rows == 0 || Columns == 0)
---
> 	if ((Nextscreen != NULL && Rows == old_Rows && Columns == old_Columns)
> 								|| Rows == 0 || Columns == 0)
1142c1274
< 	Nextscreen = (char_u *)malloc((size_t) (Rows * Columns));
---
> 	Nextscreen = (char_u *)malloc((size_t) (Rows * Columns * 2));
1155c1287
< 		emsg(e_outofmem);
---
> 		do_outofmem_msg();
1162c1294
< 			LinePointers[i] = Nextscreen + i * Columns;
---
> 			LinePointers[i] = Nextscreen + i * Columns * 2;
1178a1311,1312
> 	int		i;
> 
1185c1319,1323
< 	memset((char *)Nextscreen, ' ', (size_t)(Rows * Columns));
---
> 	for (i = 0; i < Rows; ++i)
> 	{
> 		memset((char *)LinePointers[i], ' ', (size_t)Columns);
> 		memset((char *)LinePointers[i] + Columns, 0, (size_t)Columns);
> 	}
1190a1329,1332
> 	compute_cmdrow();
> 	msg_scrolled = 0;				/* can't scroll back */
> 	msg_didany = FALSE;
> 	msg_didout = FALSE;
1225c1367
< 		if (curwin->w_lsize_valid == 0)		/* don't know about screen contents */
---
> 		if (curwin->w_lsize_valid == 0)	/* don't know about screen contents */
1240c1382,1383
< 		if (curwin->w_topline - curwin->w_cursor.lnum >= temp)		/* not very close */
---
> 								/* not very close */
> 		if (curwin->w_topline - curwin->w_cursor.lnum >= temp)
1249c1392,1393
< 			if (i > curwin->w_height)		/* cursor line won't fit, backup one line */
---
> 								/* cursor line won't fit, backup one line */
> 			if (i > curwin->w_height)
1254c1398,1399
< 			for (i = 0; i < p_sj && curwin->w_topline > 1; i += plines(--curwin->w_topline))
---
> 			for (i = 0; i < p_sj && curwin->w_topline > 1;
> 										i += plines(--curwin->w_topline))
1275,1276c1420,1423
< 			temp = plines_m(curwin->w_botline, curwin->w_cursor.lnum) - curwin->w_empty_rows;
< 			if (temp <= 0)				/* curwin->w_empty_rows is larger, no need to scroll */
---
> 			temp = plines_m(curwin->w_botline,
> 							curwin->w_cursor.lnum) - curwin->w_empty_rows;
> 				/* curwin->w_empty_rows is larger, no need to scroll */
> 			if (temp <= 0)
1278c1425,1426
< 			else if (temp > curwin->w_height)		/* more than a screenfull, don't scroll */
---
> 				/* more than a screenfull, don't scroll */
> 			else if (temp > curwin->w_height)
1285c1433,1434
< 				for (i = 0, p = curwin->w_topline; i < temp && p < curwin->w_botline; ++p)
---
> 				for (i = 0, p = curwin->w_topline;
> 								i < temp && p < curwin->w_botline; ++p)
1287c1436
< 				if (i >= temp)				/* it's possible to scroll */
---
> 				if (i >= temp)		/* it's possible to scroll */
1289c1438
< 				else						/* below curwin->w_botline, don't scroll */
---
> 				else				/* below curwin->w_botline, don't scroll */
1313c1462
< 	else if (curwin->w_lsize_valid == 0)		/* don't know about screen contents */
---
> 	else if (curwin->w_lsize_valid == 0)/* don't know about screen contents */
1333,1334c1482,1483
< 
< 		curs_columns(!RedrawingDisabled);	/* compute curwin->w_virtcol and curwin->w_col */
---
> 							/* compute curwin->w_virtcol and curwin->w_col */
> 		curs_columns(!RedrawingDisabled);
1361c1510
< 	if (curwin->w_p_wrap)			/* long line wrapping, adjust curwin->w_row */
---
> 	if (curwin->w_p_wrap)		/* long line wrapping, adjust curwin->w_row */
1367,1368c1516,1518
< 	else if (scroll)	/* no line wrapping, compute curwin->w_leftcol if scrolling is on */
< 						/* if scrolling is off, curwin->w_leftcol is assumed to be 0 */
---
> 	else if (scroll)	/* no line wrapping, compute curwin->w_leftcol if
> 						 * scrolling is on.  If scrolling is off,
> 						 * curwin->w_leftcol is assumed to be 0 */
1375,1377c1525,1527
< 						/* screen has to be redrawn with new curwin->w_leftcol */
< 			if (curwin->w_leftcol != 0 && must_redraw < NOT_VALID)
< 				must_redraw = NOT_VALID;
---
> 						/* screen needs redrawing with new curwin->w_leftcol */
> 			if (curwin->w_leftcol != 0)
> 				redraw_later(NOT_VALID);
1381,1382c1531,1532
< 					- curwin->w_col) > 0 ||
< 					(diff = curwin->w_col - (curwin->w_leftcol + Columns) + 1) > 0))
---
> 					- curwin->w_col) > 0 || (diff = curwin->w_col
> 							- (curwin->w_leftcol + Columns) + 1) > 0))
1397,1398c1547,1548
< 			if (must_redraw < NOT_VALID)
< 				must_redraw = NOT_VALID;	/* screen has to be redrawn with new curwin->w_leftcol */
---
> 					/* screen has to be redrawn with new curwin->w_leftcol */
> 			redraw_later(NOT_VALID);
1402,1403c1552,1555
< 	if (curwin->w_row > curwin->w_height - 1)	/* Cursor past end of screen */
< 		curwin->w_row = curwin->w_height - 1;	/* happens with line that does not fit on screen */
---
> 		/* Cursor past end of screen */
> 		/* happens with line that does not fit on screen */
> 	if (curwin->w_row > curwin->w_height - 1)
> 		curwin->w_row = curwin->w_height - 1;
1496a1649,1681
> 	void
> scrolldown_clamp()
> {
> 	long old_row;
> 
> 	if (curwin->w_topline == 1)
> 		return;
> 
> 	/*
> 	 * Compute the row number of the last row of the cursor line
> 	 * and make sure it doesn't go off the screen.
> 	 */
> 	old_row = curwin->w_row;
> 	curwin->w_row += plines(--curwin->w_topline);
> 	if (curwin->w_p_wrap)
> 		curwin->w_row += plines(curwin->w_cursor.lnum) - 1 - curwin->w_virtcol / Columns;
> 	if (curwin->w_row >= curwin->w_height && curwin->w_cursor.lnum > 1)
> 	{
> 		curwin->w_row = old_row;
> 		++curwin->w_topline;
> 	}
> }
> 
> 	void
> scrollup_clamp()
> {
> 	if (curwin->w_topline == curbuf->b_ml.ml_line_count)
> 		return;
> 	if (curwin->w_cursor.lnum == curwin->w_topline)
> 		return;
> 	curwin->w_topline++;
> }
> 
1771a1957
> 		memset((char *)temp + Columns, 0, (size_t)Columns);
1857a2044
> 		memset((char *)temp + Columns, 0, (size_t)Columns);
1877c2064
< 		gotocmdline(clear_cmdline, NUL);
---
> 		gotocmdline(clear_cmdline);
1883,1884d2069
< 				if (p_ri)
< 					msg_outstr((char_u *)"REVERSE ");
1886c2071,2075
< 					msg_outstr((char_u *)"INSERT --");
---
> 				{
> 					if (p_ri)
> 						msg_outstr((char_u *)"REVERSE ");
> 					msg_outstr((char_u *)"INSERT");
> 				}
1888c2077,2083
< 					msg_outstr((char_u *)"REPLACE --");
---
> 					msg_outstr((char_u *)"REPLACE");
> 				if (edit_submode != NULL)
> 				{
> 					msg_outstr((char_u *)": ");
> 					msg_outstr(edit_submode);
> 				}
> 				msg_outstr((char_u *)" --");
1898c2093
< 			msg_ceol();
---
> 			msg_clr_eos();
1932,1933c2127,2128
< 	static linenr_t	oldlnum = 0;
< 	static colnr_t	oldcol = 0;
---
> 	static linenr_t	old_lnum = 0;
> 	static colnr_t	old_col = 0;
1938c2133,2134
< 	if (p_ru && (redraw_cmdline || always || wp->w_cursor.lnum != oldlnum || wp->w_virtcol != oldcol))
---
> 	if (p_ru && (redraw_cmdline || always ||
> 				wp->w_cursor.lnum != old_lnum || wp->w_virtcol != old_col))
1968,1969c2164,2165
< 		oldlnum = wp->w_cursor.lnum;
< 		oldcol = wp->w_virtcol;
---
> 		old_lnum = wp->w_cursor.lnum;
> 		old_col = wp->w_virtcol;
1983a2180,2286
> }
> 
> /*
>  * Move the cursor to the specified row and column on the screen.
>  * Change current window if neccesary.
>  */
> 	int
> jumpto(row, col)
> 	int		row;
> 	int		col;
> {
> 	WIN		*wp;
> 	int		count;
> 	int		first;
> 
> 	if (row < 0 || col < 0)		/* check if it makes sense */
> 		return FAIL;
> 
> 	/* find the window where the row is in */
> 	for (wp = firstwin; wp->w_next; wp = wp->w_next)
> 		if (row < wp->w_next->w_winpos)
> 			break;
> 	row -= wp->w_winpos;		/* winpos may change in win_enter()! */
> 	win_enter(wp, TRUE);
> 
> 	/*
> 	 * click on status line only changes to other window, cursor does not move
> 	 */
> 	if (row >= wp->w_height && wp->w_status_height)
> 		return OK;
> 
> 	curwin->w_cursor.lnum = curwin->w_topline;
> 
> 	/*
> 	 * When clicking in the first line, scroll the screen
> 	 * up to 'scrolljump' lines down.
> 	 */
> 	if (row == 0)
> 	{
> 		count = 0;
> 		for (first = TRUE; curwin->w_topline > 1; --curwin->w_topline)
> 		{
> 			count += plines(curwin->w_topline - 1);
> 			if (!first && count > p_sj)
> 				break;
> 			first = FALSE;
> 		}
> 		redraw_later(VALID);
> 	}
> 	else if (row == curwin->w_height - 1)
> 	{
> 		count = 0;
> 		for (first = TRUE; curwin->w_topline < curbuf->b_ml.ml_line_count;
> 									++curwin->w_topline)
> 		{
> 			count += plines(curwin->w_topline);
> 			if (!first && count > p_sj)
> 				break;
> 			first = FALSE;
> 		}
> 		redraw_later(VALID);
> 	}
> 
> 	if (curwin->w_p_nu)			/* skip number in front of the line */
> 		if ((col -= 8) < 0)
> 			col = 0;
> 
> 	if (curwin->w_p_wrap)		/* lines wrap */
> 	{
> 		while (row)
> 		{
> 			count = plines(curwin->w_cursor.lnum);
> 			if (count > row)
> 			{
> 				col += row * Columns;
> 				break;
> 			}
> 			if (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)
> 				break;
> 			row -= count;
> 			++curwin->w_cursor.lnum;
> 		}
> 	}
> 	else						/* lines don't wrap */
> 	{
> 		curwin->w_cursor.lnum += row;
> 		if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)
> 			curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
> 		col += curwin->w_leftcol;
> 	}
> 	coladvance(col);
> 	curwin->w_curswant = col;
> 
> 	return OK;
> }
> 
> /*
>  * Redraw the screen later, with UpdateScreen(type).
>  * Set must_redraw only of not already set to a higher value.
>  * e.g. if must_redraw is CLEAR, type == NOT_VALID will do nothing.
>  */
> 	void
> redraw_later(type)
> 	int		type;
> {
> 	if (must_redraw < type)
> 		must_redraw = type;
Index: ./src/search.c
diff -r ../vim3.0/src/search.c ./src/search.c
22a23
> static void show_pat_in_path __ARGS((char_u *, int, int, int, FILE *, linenr_t *));
59a61
> static int		did_emsg;				/* myregcomp() called emsg() */
61a64,74
>  * Type used by find_pattern_in_path() to remember which included files have
>  * been searched already.
>  */
> typedef struct SearchedFile
> {
> 	FILE		*fp;		/* File pointer */
> 	char_u		*name;		/* Full name of file */
> 	linenr_t	lnum;		/* Line we were up to in file */
> } SearchedFile;
> 
> /*
78,79c91
< 	regexp *retval;
< 
---
> 	did_emsg = FALSE;
86a99
> 				did_emsg = TRUE;
95a109
> 				did_emsg = TRUE;
104a119
> 				did_emsg = TRUE;
141,142c156
< 	retval = regcomp(pat);
< 	return retval;
---
> 	return regcomp(pat);
152c166
< searchit(pos, dir, str, count, end, message)
---
> searchit(pos, dir, str, count, end, message, which_pat)
158a173
> 	int		which_pat;
167c182
< 	register char_u		*match, *matchend;
---
> 	register char_u		*match = NULL, *matchend = NULL;	/* init for GCC */
170c185
< 	if ((prog = myregcomp(str, 0, 2)) == NULL)
---
> 	if ((prog = myregcomp(str, 0, which_pat)) == NULL)
172c187
< 		if (message)
---
> 		if (message && !did_emsg)
240,241c255,256
< 				if (loop && lnum == startlnum)  /* if second loop stop where started */
< 					break;
---
> 				if (loop && lnum == startlnum)
> 					break;  		/* if second loop stop where started */
243c258,259
< 	/* stop the search if wrapscan isn't set, after an interrupt and after a match */
---
> 	/* stop the search if wrapscan isn't set, after an interrupt and after a
> 	 * match */
259,260c275,278
< 					msg(top_bot_msg);
< 					keep_msg = top_bot_msg;
---
> 					if (msg(top_bot_msg) && !msg_scroll)
> 						keep_msg = top_bot_msg;
> 					msg_didout = FALSE;		/* overwrite this message */
> 					msg_col = 0;
268,269c286,289
< 					msg(bot_top_msg);
< 					keep_msg = bot_top_msg;
---
> 					if (msg(bot_top_msg) && !msg_scroll)
> 						keep_msg = bot_top_msg;
> 					msg_didout = FALSE;		/* overwrite this message */
> 					msg_col = 0;
288c308
< 				EMSG("search hit TOP without match");
---
> 				EMSG(e_top_search);
290c310
< 				EMSG("search hit BOTTOM without match");
---
> 				EMSG(e_bot_search);
293a314
> 	search_match_len = matchend - match;
432c453
< 		msg_ceol();
---
> 		msg_clr_eos();
435c456
< 		gotocmdline(FALSE, NUL);
---
> 		gotocmdline(FALSE);
441c462,463
< 	c = searchit(&pos, dirc == '/' ? FORWARD : BACKWARD, searchstr, count, lastend, message);
---
> 	c = searchit(&pos, dirc == '/' ? FORWARD : BACKWARD,
> 								searchstr, count, lastend, message, 2);
504a527,604
> /*
>  * search_for_exact_line(pos, dir, pat)
>  *
>  * Search for a line starting with the given pattern (ignoring leading
>  * white-space), starting from pos and going in direction dir.  pos will
>  * contain the position of the match found.  Return OK for success, or FAIL
>  * if no line found.  Blank lines will never match.
>  */
> 	int
> search_for_exact_line(pos, dir, pat)
> 	FPOS		*pos;
> 	int			dir;
> 	char_u		*pat;
> {
> 	linenr_t	start = 0;
> 	char_u		*ptr;
> 	char_u		*p;
> 	char_u		*m = e_patnotf;
> 
> 	if (curbuf->b_ml.ml_line_count == 0)
> 		return FAIL;
> 	for (;;)
> 	{
> 		pos->lnum += dir;
> 		if (pos->lnum < 1)
> 		{
> 			if (p_ws)
> 			{
> 				pos->lnum = curbuf->b_ml.ml_line_count;
> 				if (msg(top_bot_msg) && !msg_scroll)
> 					keep_msg = top_bot_msg;
> 			}
> 			else
> 			{
> 				pos->lnum = 1;
> 				m = (char_u *)"search hit TOP without match";
> 				break;
> 			}
> 		}
> 		else if (pos->lnum > curbuf->b_ml.ml_line_count)
> 		{
> 			if (p_ws)
> 			{
> 				pos->lnum = 1;
> 				if (msg(bot_top_msg) && !msg_scroll)
> 					keep_msg = bot_top_msg;
> 			}
> 			else
> 			{
> 				pos->lnum = 1;
> 				m = (char_u *)"search hit BOTTOM without match";
> 				break;
> 			}
> 		}
> 		if (pos->lnum == start)
> 			break;
> 		if (start == 0)
> 			start = pos->lnum;
> 		ptr = p = ml_get(pos->lnum);
> 		skipwhite(&p);
> 		pos->col = p - ptr;
> 		if (*p != NUL && STRNCMP(p, pat, STRLEN(pat)) == 0)
> 			return OK;
> 		else if (*p != NUL && p_ic)
> 		{
> 			ptr = pat;
> 			while (*p && TO_LOWER(*p) == TO_LOWER(*ptr))
> 			{
> 				++p;
> 				++ptr;
> 			}
> 			if (*ptr == NUL)
> 				return OK;
> 		}
> 	}
> 	emsg(m);
> 	return FAIL;
> }
580c680
<  * showmatch - move the cursor to the matching paren or brace
---
>  * findmatch - find the matching paren or brace
585c685
< showmatch(initc)
---
> findmatch(initc)
594c694
< 	int 			inquote = 0;		/* non-zero when inside quotes */
---
> 	int 			inquote = FALSE;	/* TRUE when inside quotes */
597a698
> 	int				at_start;			/* do_quotes value at start position */
599a701,702
> 	FPOS			match_pos;			/* Where last slash-star was found */
> 	int				start_in_quotes;	/* start position is in quotes */
624c727,735
< 			hash_dir = 1;
---
> 		{
> 			/* If it's not #if, #else etc, we should look for a brace instead */
> 			for (c = 1; iswhite(linep[c]); c++)
> 				;
> 			if (STRNCMP(linep + c, "if", (size_t)2) == 0 ||
> 				STRNCMP(linep + c, "endif", (size_t)5) == 0 ||
> 				STRNCMP(linep + c, "el", (size_t)2) == 0)
> 					hash_dir = 1;
> 		}
634a746
> 				pos.col++;
639a752
> 				pos.col--;
642c755
< 		if (linep[pos.col] == '*')
---
> 		else if (linep[pos.col] == '*')
665a779
> 			idx = 6;					/* error if this line is empty */
756a871
> 	start_in_quotes = MAYBE;
801,805c916,950
< 			if (linep[pos.col] != '/' ||
< 							(comment_dir == 1 && pos.col == 0) ||
< 							linep[pos.col - comment_dir] != '*')
< 				continue;
< 			return &pos;
---
> 			if (comment_dir == 1)
> 			{
> 				if (linep[pos.col] == '*' && linep[pos.col + 1] == '/')
> 				{
> 					pos.col++;
> 					return &pos;
> 				}
> 			}
> 			else	/* Searching backwards */
> 			{
> 				/*
> 				 * A comment may contain slash-star, it may also start or end
> 				 * with slash-star-slash.  I'm not using real examples though
> 				 * because "gcc -Wall" would complain -- webb
> 				 */
> 				if (pos.col == 0)
> 					continue;
> 				else if (linep[pos.col - 1] == '/' && linep[pos.col] == '*')
> 				{
> 					count++;
> 					match_pos = pos;
> 					match_pos.col--;
> 				}
> 				else if (linep[pos.col - 1] == '*' && linep[pos.col] == '/')
> 				{
> 					if (count > 0)
> 						pos = match_pos;
> 					else if (pos.col > 1 && linep[pos.col - 2] == '/')
> 						pos.col -= 2;
> 					else
> 						return NULL;
> 					return &pos;
> 				}
> 			}
> 			continue;
807,808c952,958
< 
< 		if (do_quotes == -1)		/* count number of quotes in this line */
---
> 		/*
> 		 * If 'smartmatch' is set, braces inside of quotes are ignored,
> 		 * but only if there is an even number of quotes in the line.
> 		 */
> 		if (!p_sma)
> 			do_quotes = 0;
> 		else if (do_quotes == -1)
812a963
> 			at_start = do_quotes;
813a965,967
> 			{
> 				if (ptr == linep + curwin->w_cursor.col)
> 					at_start = (do_quotes & 1);
816a971
> 			}
829c984,990
< 					if (idx)					/* backward search */
---
> 					if (start_in_quotes == MAYBE)
> 					{
> 						inquote = !at_start;
> 						if (inquote)
> 							start_in_quotes = TRUE;
> 					}
> 					else if (idx)				/* backward search */
838c999,1005
< 						if (!idx)				/* forward search */
---
> 						if (start_in_quotes == MAYBE)
> 						{
> 							inquote = at_start;
> 							if (inquote)
> 								start_in_quotes = TRUE;
> 						}
> 						else if (!idx)				/* forward search */
843a1011,1012
> 		if (start_in_quotes == MAYBE)
> 			start_in_quotes = FALSE;
846,848c1015,1018
< 		 * Things inside quotes are ignored by setting 'inquote'.
< 		 * If we find a quote without a preceding '\' invert 'inquote'.
< 		 * At the end of a line not ending in '\' we reset 'inquote'.
---
> 		 * If 'smartmatch' is set:
> 		 *   Things inside quotes are ignored by setting 'inquote'.  If we
> 		 *   find a quote without a preceding '\' invert 'inquote'.  At the
> 		 *   end of a line not ending in '\' we reset 'inquote'.
850,854c1020,1023
< 		 * In lines with an uneven number of quotes (without preceding '\')
< 		 * we do not know which part to ignore. Therefore we only set
< 		 * inquote if the number of quotes in a line is even,
< 		 * unless this line or the previous one ends in a '\'.
< 		 * Complicated, isn't it?
---
> 		 *   In lines with an uneven number of quotes (without preceding '\')
> 		 *   we do not know which part to ignore. Therefore we only set
> 		 *   inquote if the number of quotes in a line is even, unless this
> 		 *   line or the previous one ends in a '\'.  Complicated, isn't it?
859c1028,1033
< 			inquote = FALSE;
---
> 				/* at end of line without trailing backslash, reset inquote */
> 			if (pos.col == 0 || linep[pos.col - 1] != '\\')
> 			{
> 				inquote = FALSE;
> 				start_in_quotes = FALSE;
> 			}
864a1039
> 			{
865a1041,1042
> 				start_in_quotes = FALSE;
> 			}
869,872c1046,1049
< 		 * Skip things in single quotes: 'x' or '\x'.
< 		 * Be careful for single single quotes, eg jon's.
< 		 * Things like '\233' or '\x3f' are not skipped, there is never a
< 		 * brace in them.
---
> 		 * If 'smartmatch' is set:
> 		 *   Skip things in single quotes: 'x' or '\x'.  Be careful for single
> 		 *   single quotes, eg jon's.  Things like '\233' or '\x3f' are not
> 		 *   skipped, there is never a brace in them.
875c1052
< 			if (idx)						/* backward search */
---
> 			if (p_sma)
877c1054
< 				if (pos.col > 1)
---
> 				if (idx)						/* backward search */
879,882c1056,1063
< 					if (linep[pos.col - 2] == '\'')
< 						pos.col -= 2;
< 					else if (linep[pos.col - 2] == '\\' && pos.col > 2 && linep[pos.col - 3] == '\'')
< 						pos.col -= 3;
---
> 					if (pos.col > 1)
> 					{
> 						if (linep[pos.col - 2] == '\'')
> 							pos.col -= 2;
> 						else if (linep[pos.col - 2] == '\\' &&
> 									pos.col > 2 && linep[pos.col - 3] == '\'')
> 							pos.col -= 3;
> 					}
884,890c1065,1072
< 			}
< 			else if (linep[pos.col + 1])	/* forward search */
< 			{
< 				if (linep[pos.col + 1] == '\\' && linep[pos.col + 2] && linep[pos.col + 3] == '\'')
< 					pos.col += 3;
< 				else if (linep[pos.col + 2] == '\'')
< 					pos.col += 2;
---
> 				else if (linep[pos.col + 1])	/* forward search */
> 				{
> 					if (linep[pos.col + 1] == '\\' &&
> 							linep[pos.col + 2] && linep[pos.col + 3] == '\'')
> 						pos.col += 3;
> 					else if (linep[pos.col + 2] == '\'')
> 						pos.col += 2;
> 				}
895c1077,1079
< 			if (!inquote)      /* only check for match outside of quotes */
---
> 					/* Check for match outside of quotes, and inside of
> 					 * quotes when the start is also inside of quotes */
> 			if (!inquote || start_in_quotes == TRUE)
907a1092,1097
> 
> 	if (comment_dir == -1 && count > 0)
> 	{
> 		pos = match_pos;
> 		return &pos;
> 	}
911a1102,1127
>  * move cursor briefly to character matching the one under the cursor
>  */
> 	void
> showmatch()
> {
> 	FPOS		   *lpos, csave;
> 
> 	if ((lpos = findmatch(NUL)) == NULL)		/* no match, so beep */
> 		beep_flush();
> 	else if (lpos->lnum >= curwin->w_topline)
> 	{
> 		updateScreen(VALID_TO_CURSCHAR); /* show the new char first */
> 		csave = curwin->w_cursor;
> 		curwin->w_cursor = *lpos; 	/* move to matching char */
> 		cursupdate();
> 		showruler(0);
> 		setcursor();
> 		cursor_on();		/* make sure that the cursor is shown */
> 		flushbuf();
> 		vim_delay();		/* brief pause */
> 		curwin->w_cursor = csave; 	/* restore cursor position */
> 		cursupdate();
> 	}
> }
> 
> /*
1375a1592,2056
> 
> 	void
> find_pattern_in_path(ptr, len, whole, type, count, action, start_lnum, end_lnum)
> 	char_u	*ptr;	/* pointer to search pattern */
> 	int		len;	/* length of search pattern */
> 	int		whole;	/* match whole words only */
> 	int		type;	/* Type of search; are we looking for a type?  a macro? */
> 	int		count;
> 	int		action;			/* What to do when we find it */
> 	linenr_t	start_lnum;	/* first line to start searching */
> 	linenr_t	end_lnum;	/* last line for searching */
> {
> 	SearchedFile *files;				/* Stack of included files */
> 	SearchedFile *bigger;				/* When we need more space */
> 	int			max_path_depth = 50;
> 
> 	char_u		*pat;
> 	char_u		*new_fname;
> 	char_u		*curr_fname = curbuf->b_xfilename;
> 	char_u		*prev_fname = NULL;
> 	linenr_t	lnum;
> 	int			depth;
> 	int			depth_displayed;		/* For type==CHECK_PATH */
> 	int			old_files;
> 	char_u		file_line[LSIZE];
> 	char_u		*line;
> 	char_u		*p;
> 	char_u		save_char;
> 	struct regexp *prog = NULL;
> 	struct regexp *include_prog = NULL;
> 	struct regexp *define_prog = NULL;
> 	int			matched = FALSE;
> 	int			did_show = FALSE;
> 	int			found = FALSE;
> 	int			break_count = 0;
> 	int			i;
> 
> 	reg_ic = p_ic;
> 	reg_magic = p_magic;
> 	if (type != CHECK_PATH)
> 	{
> 		pat = alloc(len + 5);
> 		if (pat == NULL)
> 			return;
> 		sprintf((char *)pat, whole ? "\\<%.*s\\>" : "%.*s", len, ptr);
> 		prog = regcomp(pat);
> 		free(pat);
> 		if (prog == NULL)
> 			return;
> 	}
> 	if (p_inc != NULL && *p_inc != NUL)
> 	{
> 		include_prog = regcomp(p_inc);
> 		if (include_prog == NULL)
> 		{
> 			free(prog);
> 			return;
> 		}
> 	}
> 	if (type == FIND_DEFINE && p_def != NULL && *p_def != NUL)
> 	{
> 		define_prog = regcomp(p_def);
> 		if (define_prog == NULL)
> 		{
> 			free(prog);
> 			free(include_prog);
> 			return;
> 		}
> 	}
> 	files = (SearchedFile *)lalloc(max_path_depth * sizeof(SearchedFile), TRUE);
> 	if (files == NULL)
> 	{
> 		free(prog);
> 		free(include_prog);
> 		free(define_prog);
> 		return;
> 	}
> 	for (i = 0; i < max_path_depth; i++)
> 	{
> 		files[i].fp = NULL;
> 		files[i].name = NULL;
> 		files[i].lnum = 0;
> 	}
> 	old_files = max_path_depth;
> 	depth = depth_displayed = -1;
> 
> 	lnum = start_lnum;
> 	if (end_lnum > curbuf->b_ml.ml_line_count)
> 		end_lnum = curbuf->b_ml.ml_line_count;
> 	if (lnum > end_lnum)				/* do at least one line */
> 		lnum = end_lnum;
> 	line = ml_get(lnum);
> 
> 	for (;;)
> 	{
> 		if (include_prog != NULL && regexec(include_prog, line, TRUE))
> 		{
> 			new_fname = get_file_name_in_path(include_prog->endp[0] + 1,
> 																0, FALSE);
> 			if (new_fname == NULL)
> 			{
> 				if (type == CHECK_PATH)
> 				{
> 					if (did_show)
> 						msg_outchar('\n');		/* cursor below last one */
> 					else
> 					{
> 						gotocmdline(TRUE);		/* cursor at status line */
> 						set_highlight('t');		/* Same as for directories */
> 						start_highlight();
> 						msg_outstr((char_u *)"--- Included files not found in path ---\n");
> 						stop_highlight();
> 					}
> 					did_show = TRUE;
> 					while (depth_displayed < depth && !got_int)
> 					{
> 						++depth_displayed;
> 						for (i = 0; i < depth_displayed; i++)
> 							msg_outstr((char_u *)"  ");
> 						msg_outstr(files[depth_displayed].name);
> 						msg_outstr((char_u *)" -->\n");
> 					}
> 					if (!got_int)				/* don't display if 'q' typed
> 													for "--more--" message */
> 					{
> 						for (i = 0; i <= depth_displayed; i++)
> 							msg_outstr((char_u *)"  ");
> 						set_highlight('d');			/* Same as for directories */
> 						start_highlight();
> 						for (p = include_prog->endp[0] + 1; !isfilechar(*p); p++)
> 							;
> 						for (i = 0; isfilechar(p[i]); i++)
> 							;
> 						save_char = p[i];
> 						p[i] = NUL;
> 						msg_outstr(p);
> 						p[i] = save_char;
> 						stop_highlight();
> 					}
> 				}
> 			}
> 			else
> 			{
> 				/* Check whether we have already searched in this file */
> 				for (i = 0;; i++)
> 				{
> 					if (i == depth + 1)
> 						i = old_files;
> 					if (i == max_path_depth)
> 						break;
> 					if (STRCMP(new_fname, files[i].name) == 0)
> 					{
> 						free(new_fname);
> 						new_fname = NULL;
> 						break;
> 					}
> 				}
> 			}
> 			if (new_fname != NULL)
> 			{
> 				/* Push the new file onto the file stack */
> 				if (depth + 1 == old_files)
> 				{
> 					bigger = (SearchedFile *)lalloc(max_path_depth * 2
> 												* sizeof(SearchedFile), TRUE);
> 					if (bigger != NULL)
> 					{
> 						for (i = 0; i <= depth; i++)
> 							bigger[i] = files[i];
> 						for (i = depth + 1; i < old_files + max_path_depth; i++)
> 						{
> 							bigger[i].fp = NULL;
> 							bigger[i].name = NULL;
> 							bigger[i].lnum = 0;
> 						}
> 						for (i = old_files; i < max_path_depth; i++)
> 							bigger[i + max_path_depth] = files[i];
> 						old_files += max_path_depth;
> 						max_path_depth *= 2;
> 						free(files);
> 						files = bigger;
> 					}
> 				}
> 				if ((files[depth + 1].fp = fopen((char *)new_fname, "r"))
> 																	== NULL)
> 					free(new_fname);
> 				else
> 				{
> 					if (++depth == old_files)
> 					{
> 						/*
> 						 * lalloc() for 'bigger' must have failed above.  We
> 						 * will forget one of our already visited files now.
> 						 */
> 						free(files[old_files].name);
> 						++old_files;
> 					}
> 					files[depth].name = curr_fname = new_fname;
> 					files[depth].lnum = 0;
> 				}
> 			}
> 		}
> 		else if (prog != NULL && regexec(prog, line, TRUE))
> 		{
> 			matched = TRUE;
> 			/*
> 			 * Check if the line is a define
> 			 */
> 			if (type == FIND_DEFINE && define_prog != NULL)
> 			{
> 				if (!regexec(define_prog, line, TRUE))
> 					matched = FALSE;
> 				else
> 				{
> 					/* Pattern must be first identifier after 'define' */
> 					p = define_prog->endp[0] + 1;
> 					while (p < prog->startp[0])
> 						if (isidchar(*p++))
> 						{
> 							matched = FALSE;
> 							break;
> 						}
> 				}
> 			}
> 			/*
> 			 * Check if the line is not a comment line
> 			 */
> 			else if (action == ACTION_SHOW || action == ACTION_GOTO ||
> 											action == ACTION_SPLIT)
> 			{
> 				fo_do_comments = TRUE;
> 				if (get_leader_len(line))
> 					matched = FALSE;
> 				fo_do_comments = FALSE;
> 			}
> 		}
> 		if (matched)
> 		{
> 			if (action == ACTION_EXPAND)
> 			{
> 				if (depth == -1 && lnum == curwin->w_cursor.lnum)
> 					break;
> 				found = TRUE;
> 				p = prog->startp[0];
> 				while (isidchar(*p))
> 					++p;
> 				if (add_completion_and_infercase(prog->startp[0],
> 						p - prog->startp[0], FORWARD) == RET_ERROR)
> 					break;
> 			}
> 			else if (action == ACTION_SHOW_ALL)
> 			{
> 				found = TRUE;
> 				if (!did_show)
> 					gotocmdline(TRUE);			/* cursor at status line */
> 				if (curr_fname != prev_fname)
> 				{
> 					if (did_show)
> 						msg_outchar('\n');		/* cursor below last one */
> 					if (!got_int)				/* don't display if 'q' typed
> 													at "--more--" mesage */
> 					{
> 						set_highlight('d');		/* Same as for directories */
> 						start_highlight();
> 						msg_outstr(curr_fname);
> 						stop_highlight();
> 					}
> 					prev_fname = curr_fname;
> 				}
> 				did_show = TRUE;
> 				if (!got_int)
> 					show_pat_in_path(line, type, did_show, action,
> 							(depth == -1) ? NULL : files[depth].fp,
> 							(depth == -1) ? &lnum : &files[depth].lnum);
> 			}
> 			else if (--count <= 0)
> 			{
> 				found = TRUE;
> 				if (depth == -1 && lnum == curwin->w_cursor.lnum)
> 					EMSG("Match is on current line");
> 				else if (action == ACTION_SHOW)
> 				{
> 					show_pat_in_path(line, type, did_show, action,
> 						(depth == -1) ? NULL : files[depth].fp,
> 						(depth == -1) ? &lnum : &files[depth].lnum);
> 					did_show = TRUE;
> 				}
> 				else
> 				{
> 					if (action == ACTION_SPLIT)
> 					{
> 						if (win_split(0L, FALSE) == FAIL)
> 							break;
> 					}
> 					if (depth == -1)
> 					{
> 						setpcmark();
> 						curwin->w_cursor.lnum = lnum;
> 					}
> 					else
> 						if (getfile(0, files[depth].name, NULL, TRUE,
> 														files[depth].lnum) > 0)
> 							break;		/* failed to jump to file */
> 				}
> 				if (action != ACTION_SHOW)
> 					curwin->w_cursor.col = prog->startp[0] - line;
> 				break;
> 			}
> 			matched = FALSE;
> 		}
> 		if ((++break_count & 15) == 0)
> 			breakcheck();
> 		if (got_int)
> 			break;
> 		while (depth >= 0 && vim_fgets(line = file_line, LSIZE,
> 							files[depth].fp, &files[depth].lnum) == VIM_EOF)
> 		{
> 			fclose(files[depth].fp);
> 			files[--old_files].name = files[depth--].name;
> 			curr_fname = (depth == -1) ? curbuf->b_xfilename
> 									   : files[depth].name;
> 			if (depth < depth_displayed)
> 				depth_displayed = depth;
> 		}
> 		if (depth < 0)
> 		{
> 			if (++lnum > end_lnum)
> 				break;
> 			line = ml_get(lnum);
> 		}
> 	}
> 	for (i = 0; i <= depth; i++)
> 	{
> 		fclose(files[i].fp);
> 		free(files[i].name);
> 	}
> 	for (i = old_files; i < max_path_depth; i++)
> 		free(files[i].name);
> 	free(files);
> 	free(prog);
> 	free(include_prog);
> 	free(define_prog);
> 	if (type == CHECK_PATH)
> 	{
> 		if (!did_show)
> 			MSG("All included files were found");
> 	}
> 	else if (!found && action != ACTION_EXPAND)
> 	{
> 		if (got_int)
> 			emsg(e_interr);
> 		else if (type == FIND_DEFINE)
> 			EMSG("Couldn't find definition");
> 		else
> 			EMSG("Couldn't find pattern");
> 	}
> 	if (action == ACTION_SHOW || action == ACTION_SHOW_ALL)
> 		msg_end();
> }
> 
> 	static void
> show_pat_in_path(line, type, did_show, action, fp, lnum)
> 	char_u	*line;
> 	int		type;
> 	int		did_show;
> 	int		action;
> 	FILE	*fp;
> 	linenr_t *lnum;
> {
> 	char_u	*p;
> 
> 	if (did_show)
> 		msg_outchar('\n');		/* cursor below last one */
> 	else
> 		gotocmdline(TRUE);		/* cursor at status line */
> 	if (got_int)				/* 'q' typed at "--more--" message */
> 		return;
> 	for (;;)
> 	{
> 		p = line + STRLEN(line) - 1;
> 		if (fp != NULL)
> 		{
> 			/* We used fgets(), so get rid of newline at end */
> 			if (p >= line && *p == '\n')
> 				--p;
> 			*(p + 1) = NUL;
> 		}
> 		if (action == ACTION_SHOW_ALL)
> 		{
> 			set_highlight('n');			/* Highlight line numbers */
> 			start_highlight();
> 			sprintf((char *)IObuff, "%7ld ", *lnum);
> 			msg_outstr(IObuff);
> 			stop_highlight();
> 		}
> 		msg_prt_line(line);
> 		flushbuf();						/* show one line at a time */
> 
> 		/* Definition continues until line that doesn't end with '\' */
> 		if (got_int || type != FIND_DEFINE || p < line || *p != '\\')
> 			break;
> 		
> 		if (fp != NULL)
> 		{
> 			if (vim_fgets(line, LSIZE, fp, lnum) == VIM_EOF)
> 				break;
> 		}
> 		else
> 		{
> 			if (++*lnum > curbuf->b_ml.ml_line_count)
> 				break;
> 			line = ml_get(*lnum);
> 		}
> 		msg_outchar('\n');
> 	}
> }
> 
> #ifdef VIMINFO
> 	int
> read_viminfo_search_pattern(line, lnum, fp, force)
> 	char_u	*line;
> 	linenr_t *lnum;
> 	FILE	*fp;
> 	int		force;
> {
> 	char_u	*lp;
> 	char_u	**pattern;
> 
> 	lp = line;
> 	if (lp[0] == '~')
> 		lp++;
> 	if (lp[0] == '/')
> 		pattern = &search_pattern;
> 	else
> 		pattern = &subst_pattern;
> 	if (*pattern != NULL && force)
> 		free(*pattern);
> 	if (force || *pattern == NULL)
> 	{
> 		viminfo_readstring(lp);
> 		*pattern = strsave(lp + 1);
> 		if (line[0] == '~')
> 			last_pattern = *pattern;
> 	}
> 	return vim_fgets(line, LSIZE, fp, lnum);
> }
> 
> 	void
> write_viminfo_search_pattern(fp)
> 	FILE	*fp;
> {
> 	if (search_pattern != NULL)
> 	{
> 		fprintf(fp, "\n# Last Search Pattern:\n");
> 		fprintf(fp, "%s/", (last_pattern == search_pattern) ? "~" : "");
> 		viminfo_writestring(fp, search_pattern);
> 	}
> 	if (subst_pattern != NULL)
> 	{
> 		fprintf(fp, "\n# Last Substitute Search Pattern:\n");
> 		fprintf(fp, "%s&", (last_pattern == subst_pattern) ? "~" : "");
> 		viminfo_writestring(fp, subst_pattern);
> 	}
> }
> #endif /* VIMINFO */
Index: ./src/structs.h
diff -r ../vim3.0/src/structs.h ./src/structs.h
250c250
< #define ML_EMPTY		1		/* empty buffer (one empty line */
---
> #define ML_EMPTY		1		/* empty buffer */
325a326,329
> 	
> #ifdef VIMINFO
> 	int				 b_marks_read;		/* Have we read viminfo marks yet? */
> #endif /* VIMINFO */
359a364
> 	char_u			*b_p_fo, *b_p_com, *b_p_ncom, *b_p_id;
406a412,418
> 
> 	/*
> 	 * the next three are used to update the visual part
> 	 */
> 	FPOS		w_old_cursor;		/* last known end of visual part */
> 	linenr_t	w_old_visual_lnum;	/* last known start of visual part */
> 	int			w_old_curswant;		/* last known value of Curswant */
Index: ./src/tag.c
diff -r ../vim3.0/src/tag.c ./src/tag.c
38a39
> 	int				oldtagstackidx = tagstackidx;
56a58
> 			--oldtagstackidx;
90c92
< 		if (tagstack[tagstackidx].fmark.fnum != curbuf->b_fnum)	/* jump to other file */
---
> 		if (tagstack[tagstackidx].fmark.fnum != curbuf->b_fnum)
92c94,99
< 			if (buflist_getfile(tagstack[tagstackidx].fmark.fnum, tagstack[tagstackidx].fmark.mark.lnum, TRUE) == FAIL)
---
> 			/*
> 			 * Jump to other file. If this fails (e.g. because the file was
> 			 * changed) keep original position in tag stack.
> 			 */
> 			if (buflist_getfile(tagstack[tagstackidx].fmark.fnum,
> 						tagstack[tagstackidx].fmark.mark.lnum, TRUE) == FAIL)
94c101
< 				/* emsg(e_notopen); */
---
> 				tagstackidx = oldtagstackidx;	/* back to old position */
107a115,118
> 			/*
> 			 * beyond the last one, just give an error message and go to the
> 			 * last one
> 			 */
125a137,139
> 	/* curwin will change in the call to findtag() if ^W^] was used -- webb */
> 	curwin->w_tagstackidx = tagstackidx;
> 	curwin->w_tagstacklen = tagstacklen;
146,147c160
< 	gotocmdline(TRUE, NUL);
< 	msg_outstr((char_u *)"\n  # TO tag      FROM line in file\n");
---
> 	msg_outstr((char_u *)"\n  # TO tag      FROM line in file");
156c169
< 			sprintf((char *)IObuff, "%c%2d %-15s %4ld  %s\n",
---
> 			sprintf((char *)IObuff, "\n%c%2d %-15s %4ld  %s",
167,168c180
< 		msg_outstr((char_u *)">\n");
< 	wait_return(FALSE);
---
> 		msg_outstr((char_u *)"\n>");
182a195,196
> 	char_u	   *tagname;
> 	char_u	   *tail;
192a207
> 	int			tried_local = FALSE;	/* tried tags file local to file */
196a212,213
> 	tail = (curbuf->b_filename == NULL) ? NULL : gettail(curbuf->b_filename);
> 
201c218
< 	for (np = p_tags; *np; )
---
> 	for (np = p_tags; tried_local == FALSE; )
203c220,224
< 		for (i = 0; i < CMDBUFFSIZE && *np; ++i)	/* copy next file name into lbuf */
---
> 		/*
> 		 * after trying all the names in the 'tags' option, try the 'tags' file
> 		 * in the same directory as the current file (unless it is the same as "./tags").
> 		 */
> 		if (*np == NUL)
205,207c226,230
< 			if (*np == ' ')
< 			{
< 				++np;
---
> 			if (curbuf->b_filename == NULL)				/* no file name */
> 				break;
> 			np = gettail(curbuf->b_filename);
> 			i = np - curbuf->b_filename;
> 			if (i + 5 >= CMDBUFFSIZE)
208a232,249
> 			STRNCPY(sbuf, curbuf->b_filename, i);
> 
> 			STRCPY(sbuf + i, "tags");
> 			if (FullName((char_u *)"tags", lbuf, LSIZE) == OK &&
> 												STRCMP(sbuf, lbuf) == 0)
> 				break;									/* same as ./tags */
> 			tried_local = TRUE;
> 		}
> 		else
> 		{
> 			for (i = 0; i < CMDBUFFSIZE && *np; ++i)	/* copy next file name into sbuf */
> 			{
> 				if (*np == ' ')
> 				{
> 					++np;
> 					break;
> 				}
> 				sbuf[i] = *np++;
210c251
< 			sbuf[i] = *np++;
---
> 			sbuf[i] = 0;
212d252
< 		sbuf[i] = 0;
221,223c261,282
< 		/* find start of file name, after first white space */
< 			fname = lbuf;
< 			skiptospace(&fname);	/* skip tag */
---
> 			/* Find start of file name, after first white space */
> 			fname = tagname = lbuf;
> 			while (*fname != ' ' && *fname != '\t' && *fname != NUL)
> 			{
> 				/*
> 				 * Static tags produced by elvis's ctags program have the
> 				 * format: 'file:tag  file  /pattern$'. jw.
> 				 */
> 				if (*fname == ':')
> 				{
> 					/*
> 					 * Static tag must be in current file
> 					 * If it is not, set tagname to NULL
> 					 */
> 					*fname = '\0';
> 					if (tail != NULL && STRCMP(tail, gettail(lbuf)) == 0)
> 						tagname = fname + 1;
> 					else
> 						tagname = NULL;
> 				}
> 				++fname;
> 			}
228c287,288
< 			if (cstrncmp(lbuf, tag, cmplen) == 0)	/* Tag found */
---
> 			if (tagname != NULL && cstrncmp(tagname, tag, cmplen) == 0)
> 											/* Tag found */
231c291
< 				skipspace(&fname);
---
> 				skipwhite(&fname);
235c295
< 				skiptospace(&str);
---
> 				skiptowhite(&str);
239c299
< 				skipspace(&str);
---
> 				skipwhite(&str);
321c381
< 				RedrawingDisabled = TRUE;
---
> 				++RedrawingDisabled;
327c387
< 				i = getfile(fname, NULL, TRUE, (linenr_t)0);
---
> 				i = getfile(0, fname, NULL, TRUE, (linenr_t)0);
335c395
< 					RedrawingDisabled = FALSE;
---
> 					--RedrawingDisabled;
338c398
< 					tag_busy = TRUE;			/* don't set marks for this search */
---
> 					tag_busy = TRUE;	/* don't set marks for this search */
352,353c412,414
< 						p_ws = TRUE;		/* Switch wrap-scan on temporarily */
< 						if (!dosearch(pbuf[0], pbuf + 1, FALSE, (long)1, FALSE, FALSE))
---
> 						p_ws = TRUE;	/* Switch wrap-scan on temporarily */
> 						if (!dosearch(pbuf[0], pbuf + 1,
> 												FALSE, (long)1, FALSE, FALSE))
360,361c421,423
< 							sprintf((char *)pbuf, "^%s(", lbuf);
< 							if (!dosearch('/', pbuf, FALSE, (long)1, FALSE, FALSE))
---
> 							sprintf((char *)pbuf, "^%s(", tagname);
> 							if (!dosearch('/', pbuf, FALSE,
> 												(long)1, FALSE, FALSE))
364,365c426,429
< 								sprintf((char *)pbuf, "^[#a-zA-Z_].*%s(", lbuf);
< 								if (!dosearch('/', pbuf, FALSE, (long)1, FALSE, FALSE))
---
> 								sprintf((char *)pbuf,
> 												"^[#a-zA-Z_].*%s(", tagname);
> 								if (!dosearch('/', pbuf,
> 												FALSE, (long)1, FALSE, FALSE))
379,381c443,445
< 					{
< 						curwin->w_cursor.lnum = 1;	/* start command in line 1 */
< 						docmdline(pbuf);
---
> 					{							/* start command in line 1 */
> 						curwin->w_cursor.lnum = 1;
> 						docmdline(pbuf, TRUE, TRUE);
386c450,451
< 					if (secure == 2)			/* done something that is not allowed */
---
> 									/* done something that is not allowed */
> 					if (secure == 2)
390,394c455,458
< 						/* print the file message after redraw */
< 					if (p_im && i == -1)
< 						stuffReadbuff((char_u *)"\033\007i");	/* ESC CTRL-G i */
< 					else
< 						stuffcharReadbuff('\007');		/* CTRL-G */
---
> 						/* print the file message after redraw if jumped to
> 						 * another file */
> 					if (i == -1)
> 						need_fileinfo = TRUE;
397c461
< 				RedrawingDisabled = FALSE;
---
> 				--RedrawingDisabled;
400c464
< 					close_window(FALSE);
---
> 					close_window(curwin, FALSE);
420d483
< #ifdef WEBB_COMPLETE
429a493,494
> 	char_u	*tagname;
> 	char_u	*tail;			/* Tail of current file name */
433c498
< 	int		index;
---
> 	int		idx;
435c500
< 	int		lnum;
---
> 	linenr_t lnum;
441c506,507
< 	index = 0;
---
> 	tail = (curbuf->b_filename == NULL) ? NULL : gettail(curbuf->b_filename);
> 	idx = 0;
447c513
< 		skipspace(&np);
---
> 		skipwhite(&np);
453c519,520
< 			if (regexec(prog, line, TRUE))
---
> 			p = tagname = line;
> 			while (*p != ' ' && *p != '\t' && *p != NUL)
455,458c522,541
< 				p = line;
< 				skiptospace(&p);
< 				*p = NUL;
< 				if (index == limit)
---
> 				/*
> 				 * Static tags produced by elvis's ctags program have the
> 				 * format: 'file:tag  file  /pattern$'. jw.
> 				 */
> 				if (*p == ':')
> 				{
> 					/* Static tags must be in current file */
> 					*p = NUL;
> 					if (tail != NULL && STRCMP(tail, gettail(line)) == 0)
> 						tagname = p + 1;
> 					else
> 						tagname = NULL;
> 				}
> 				++p;
> 			}
> 			*p = NUL;
> 
> 			if (tagname != NULL && regexec(prog, tagname, TRUE))
> 			{
> 				if (idx == limit)
466c549
< 						*num_file = index;
---
> 						*num_file = idx;
469c552
< 					for (i = 0; i < index; i++)
---
> 					for (i = 0; i < idx; i++)
474c557
< 				matches[index++] = strsave(line);
---
> 				matches[idx++] = strsave(tagname);
478c561
< 	if (index > 0)
---
> 	if (idx > 0)
480c563
< 		new_matches = *file = (char_u **) alloc((unsigned)(index * sizeof(char_u *)));
---
> 		new_matches = *file = (char_u **) alloc((unsigned)(idx * sizeof(char_u *)));
484c567
< 			*num_file = index;
---
> 			*num_file = idx;
487c570
< 		for (i = 0; i < index; i++)
---
> 		for (i = 0; i < idx; i++)
491c574
< 	*num_file = index;
---
> 	*num_file = idx;
494d576
< #endif /* WEBB_COMPLETE */
Index: ./src/term.c
diff -r ../vim3.0/src/term.c ./src/term.c
32a33,35
> #  else
> 	/* for those systems that don't have tgoto in termcap.h */
> 	extern char *tgoto __ARGS((char *, int, int));
37,38d39
< static void parse_builtin_tcap __ARGS((Tcarr *tc, char_u *s));
< 
40,41c41,43
<  * Builtin_tcaps must always contain DFLT_TCAP as the first entry!
<  * DFLT_TCAP is used, when no terminal is specified with -T option or $TERM.
---
>  * Here are the builtin termcap entries.  They not stored as complete Tcarr
>  * structures, as such a structure is to big. 
>  *
43,45c45,50
<  * TERMCAP is defined.
<  * When TERMCAP is defined, the builtin entries can be accessed with
<  * "builtin_amiga", "builtin_ansi", "builtin_debug", etc.
---
>  * TERMCAP is defined.  When TERMCAP is defined, the builtin entries can be
>  * accessed with "builtin_amiga", "builtin_ansi", "builtin_debug", etc.
>  *
>  * Each termcap is list a builtin_term structures. It always starts with
>  * KS_NAME, which separates the entries.  See parse_builtin_tcap() for all
>  * details.
47c52
< static char_u *builtin_tcaps[] =
---
> struct builtin_term
48a54,63
> 	char		bt_entry;
> 	char		*bt_string;
> };
> 
> static struct builtin_term *find_builtin_term __ARGS((char_u *name));
> static void parse_builtin_tcap __ARGS((Tcarr *tc, char_u *s));
> static void gather_termleader __ARGS((void));
> 
> struct builtin_term builtin_termcaps[] = {
> 
50,55c65,131
<   (char_u *)DFLT_TCAP,		/* almost allways included */
< # if !defined(UNIX) && (defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS))
<   (char_u *)ANSI_TCAP,		/* default for unix */
< # endif
< # if !defined(AMIGA) && (defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS))
<   (char_u *)AMIGA_TCAP,		/* default for amiga */
---
> 
> # if defined(AMIGA) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)
> /*
>  * Amiga console window, default for Amiga
>  */
> 	{KS_NAME,	"amiga"},
> 	{KS_EL,     "\033[K"},
> 	{KS_IL,     "\033[L"},
> #  ifdef TERMINFO
> 	{KS_CIL,    "\033[%p1%dL"},
> #  else
> 	{KS_CIL,	"\033[%dL"},
> #  endif
> 	{KS_DL,      "\033[M"},
> #  ifdef TERMINFO
> 	{KS_CDL,     "\033[%p1%dM"},
> #  else
> 	{KS_CDL,     "\033[%dM"},
> #  endif
> 	{KS_ED,      "\014"},
> 	{KS_CI,      "\033[0 p"},
> 	{KS_CV,      "\033[1 p"},
> 	{KS_TP,      "\033[0m"},
> 	{KS_TI,      "\033[7m"},
> 	{KS_TB,      "\033[1m"},
> 	{KS_SE,      "\033[0m"},
> 	{KS_SO,      "\033[33m"},
> 	{KS_MS,      "\001"},
> #  ifdef TERMINFO
> 	{KS_CM,      "\033[%i%p1%d;%p2%dH"},
> #  else
> 	{KS_CM,      "\033[%i%d;%dH"},
> #  endif
> #  ifdef TERMINFO
> 	{KS_CRI,     "\033[%p1%dC"},
> #  else
> 	{KS_CRI,     "\033[%dC"},
> #  endif
> 	{KS_UARROW,  "\233A"},
> 	{KS_DARROW,  "\233B"},
> 	{KS_LARROW,  "\233D"},
> 	{KS_RARROW,  "\233C"},
> 	{KS_SUARROW, "\233T"},
> 	{KS_SDARROW, "\233S"},
> 	{KS_SLARROW, "\233 A"},
> 	{KS_SRARROW, "\233 @"},
> 	{KS_F1,      "\233\060~"},	/* some compilers don't understand "\2330" */
> 	{KS_F2,      "\233\061~"},
> 	{KS_F3,      "\233\062~"},
> 	{KS_F4,      "\233\063~"},
> 	{KS_F5,      "\233\064~"},
> 	{KS_F6,      "\233\065~"},
> 	{KS_F7,      "\233\066~"},
> 	{KS_F8,      "\233\067~"},
> 	{KS_F9,      "\233\070~"},
> 	{KS_F10,     "\233\071~"},
> 	{KS_SF1,     "\233\061\060~"},
> 	{KS_SF2,     "\233\061\061~"},
> 	{KS_SF3,     "\233\061\062~"},
> 	{KS_SF4,     "\233\061\063~"},
> 	{KS_SF5,     "\233\061\064~"},
> 	{KS_SF6,     "\233\061\065~"},
> 	{KS_SF7,     "\233\061\066~"},
> 	{KS_SF8,     "\233\061\067~"},
> 	{KS_SF9,     "\233\061\070~"},
> 	{KS_SF10,    "\233\061\071~"},
> 	{KS_HELP,    "\233?~"},
57,58c133,165
< # if !defined(MSDOS) && (defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS))
<   (char_u *)PCTERM_TCAP,		/* default for MSdos */
---
> 
> # if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)
> /*
>  * standard ANSI terminal, default for unix
>  */
> 	{KS_NAME,	"ansi"},
> 	{KS_EL,		"\033[2K"},
> 	{KS_IL,		"\033[L"},
> #  ifdef TERMINFO
> 	{KS_CIL,	"\033[%p1%dL"},
> #  else
> 	{KS_CIL,	"\033[%dL"},
> #  endif
> 	{KS_DL,		"\033[M"},
> #  ifdef TERMINFO
> 	{KS_CDL,	"\033[%p1%dM"},
> #  else
> 	{KS_CDL,	"\033[%dM"},
> #  endif
> 	{KS_ED,		"\033[2J"},
> 	{KS_TP,		"\033[0m"},
> 	{KS_TI,		"\033[7m"},
> 	{KS_MS,		"\001"},
> #  ifdef TERMINFO
> 	{KS_CM,		"\033[%i%p1%d;%p2%dH"},
> #  else
> 	{KS_CM,		"\033[%i%d;%dH"},
> #  endif
> #  ifdef TERMINFO
> 	{KS_CRI,	"\033[%p1%dC"},
> #  else
> 	{KS_CRI,	"\033[%dC"},
> #  endif
59a167
> 
61c169,224
<   (char_u *)PCANSI_TCAP,
---
> /*
>  * These codes are valid when nansi.sys or equivalent has been installed.
>  * Function keys on a PC are preceded with a NUL. These are converted into
>  * K_NUL '\316' in GetChars(), because we cannot handle NULs in key codes.
>  * CTRL-arrow is used instead of SHIFT-arrow.
>  */
> 	{KS_NAME,	 "pcansi"},
> 	{KS_EL,      "\033[K"},
> 	{KS_IL,      "\033[L"},
> 	{KS_DL,      "\033[M"},
> 	{KS_ED,      "\033[2J"},
> 	{KS_TP,      "\033[0m"},
> 	{KS_TI,      "\033[7m"},
> 	{KS_MS,      "\001"},
> #  ifdef TERMINFO
> 	{KS_CM,      "\033[%i%p1%d;%p2%dH"},
> #  else
> 	{KS_CM,      "\033[%i%d;%dH"},
> #  endif
> #  ifdef TERMINFO
> 	{KS_CRI,     "\033[%p1%dC"},
> #  else
> 	{KS_CRI,     "\033[%dC"},
> #  endif
> 	{KS_UARROW,  "\316H"},
> 	{KS_DARROW,  "\316P"},
> 	{KS_LARROW,  "\316K"},
> 	{KS_RARROW,  "\316M"},
> 	{KS_SLARROW, "\316s"},
> 	{KS_SRARROW, "\316t"},
> 	{KS_F1,      "\316;"},
> 	{KS_F2,      "\316<"},
> 	{KS_F3,      "\316="},
> 	{KS_F4,      "\316>"},
> 	{KS_F5,      "\316?"},
> 	{KS_F6,      "\316@"},
> 	{KS_F7,      "\316A"},
> 	{KS_F8,      "\316B"},
> 	{KS_F9,      "\316C"},
> 	{KS_F10,     "\316D"},
> 	{KS_SF1,     "\316T"},
> 	{KS_SF2,     "\316U"},
> 	{KS_SF3,     "\316V"},
> 	{KS_SF4,     "\316W"},
> 	{KS_SF5,     "\316X"},
> 	{KS_SF6,     "\316Y"},
> 	{KS_SF7,     "\316Z"},
> 	{KS_SF8,     "\316["},
> 	{KS_SF9,     "\316\\"},
> 	{KS_SF10,    "\316]"},
> 	{KS_INS,	 "\316R"},
> 	{KS_DEL,	 "\316S"},
> 	{KS_HOME,	 "\316G"},
> 	{KS_END,	 "\316O"},
> 	{KS_PAGEDOWN,"\316Q"},
> 	{KS_PAGEUP,	 "\316I"},
63,64c226,284
< # if !defined(ATARI) && defined(ALL_BUILTIN_TCAPS)
<   (char_u *)ATARI_TCAP,		/* default for Atari */
---
>     
> # if defined(MSDOS) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)
> /*
>  * These codes are valid for the pc video.  The entries that start with ESC |
>  * are translated into conio calls in msdos.c. Default for MSDOS.
>  */
> 	{KS_NAME,	 "pcterm"},
> 	{KS_EL,      "\033|K"},
> 	{KS_IL,      "\033|L"},
> 	{KS_DL,      "\033|M"},
> #  ifdef TERMINFO
> 	{KS_CS,      "\033|%i%p1%d;%p2%dr"},
> #  else
> 	{KS_CS,      "\033|%i%d;%dr"},
> #  endif
> 	{KS_ED,      "\033|J"},
> 	{KS_TP,      "\033|0m"},
> 	{KS_TI,      "\033|112m"},
> 	{KS_TB,      "\033|63m"},
> 	{KS_SE,      "\033|0m"},
> 	{KS_SO,      "\033|31m"},
> 	{KS_MS,      "\001"},
> #  ifdef TERMINFO
> 	{KS_CM,      "\033|%i%p1%d;%p2%dH"},
> #  else
> 	{KS_CM,      "\033|%i%d;%dH"},
> #  endif
> 	{KS_UARROW,  "\316H"},
> 	{KS_DARROW,  "\316P"},
> 	{KS_LARROW,  "\316K"},
> 	{KS_RARROW,  "\316M"},
> 	{KS_SLARROW, "\316s"},
> 	{KS_SRARROW, "\316t"},
> 	{KS_F1,      "\316;"},
> 	{KS_F2,      "\316<"},
> 	{KS_F3,      "\316="},
> 	{KS_F4,      "\316>"},
> 	{KS_F5,      "\316?"},
> 	{KS_F6,      "\316@"},
> 	{KS_F7,      "\316A"},
> 	{KS_F8,      "\316B"},
> 	{KS_F9,      "\316C"},
> 	{KS_F10,     "\316D"},
> 	{KS_SF1,     "\316T"},
> 	{KS_SF2,     "\316U"},
> 	{KS_SF3,     "\316V"},
> 	{KS_SF4,     "\316W"},
> 	{KS_SF5,     "\316X"},
> 	{KS_SF6,     "\316Y"},
> 	{KS_SF7,     "\316Z"},
> 	{KS_SF8,     "\316["},
> 	{KS_SF9,     "\316\\"},
> 	{KS_SF10,    "\316]"},
> 	{KS_INS,	 "\316R"},
> 	{KS_DEL,	 "\316S"},
> 	{KS_HOME,	 "\316G"},
> 	{KS_END,	 "\316O"},
> 	{KS_PAGEDOWN,"\316Q"},
> 	{KS_PAGEUP,	 "\316I"},
66,67c286,351
< # if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)
<   (char_u *)XTERM_TCAP,		/* always included on unix */
---
> 
> # if defined(NT) || defined(ALL_BUILTIN_TCAPS)
> /*
>  * These codes are valid for the NT Console .  The entries that start with
>  * ESC | are translated into console calls in winnt.c.
>  */
> 	{KS_NAME,	 "ntconsole"},
> 	{KS_EL,      "\033|K"},
> 	{KS_IL,      "\033|L"},
> #  ifdef TERMINFO
> 	{KS_CIL,	 "\033|%p1%dL"},
> #  else
> 	{KS_CIL,	 "\033|%dL"},
> #  endif
> 	{KS_DL,      "\033|M"},
> #  ifdef TERMINFO
> 	{KS_CDL,     "\033|%p1%dM"},
> #  else
> 	{KS_CDL,     "\033|%dM"},
> #  endif
> 	{KS_ED,      "\033|J"},
> 	{KS_CI,      "\033|v"},
> 	{KS_CV,      "\033|V"},
> 	{KS_TP,      "\033|0m"},
> 	{KS_TI,      "\033|112m"},
> 	{KS_TB,      "\033|63m"},
> 	{KS_SE,      "\033|0m"},
> 	{KS_SO,      "\033|31m"},
> 	{KS_MS,      "\001"},
> #  ifdef TERMINFO
> 	{KS_CM,      "\033|%i%p1%d;%p2%dH"},
> #  else
> 	{KS_CM,      "\033|%i%d;%dH"},
> #  endif
> 	{KS_UARROW,  "\316H"},
> 	{KS_DARROW,  "\316P"},
> 	{KS_LARROW,  "\316K"},
> 	{KS_RARROW,  "\316M"},
> 	{KS_SLARROW, "\316s"},
> 	{KS_SRARROW, "\316t"},
> 	{KS_F1,      "\316;"},
> 	{KS_F2,      "\316<"},
> 	{KS_F3,      "\316="},
> 	{KS_F4,      "\316>"},
> 	{KS_F5,      "\316?"},
> 	{KS_F6,      "\316@"},
> 	{KS_F7,      "\316A"},
> 	{KS_F8,      "\316B"},
> 	{KS_F9,      "\316C"},
> 	{KS_F10,     "\316D"},
> 	{KS_SF1,     "\316T"},
> 	{KS_SF2,     "\316U"},
> 	{KS_SF3,     "\316V"},
> 	{KS_SF4,     "\316W"},
> 	{KS_SF5,     "\316X"},
> 	{KS_SF6,     "\316Y"},
> 	{KS_SF7,     "\316Z"},
> 	{KS_SF8,     "\316["},
> 	{KS_SF9,     "\316\\"},
> 	{KS_SF10,    "\316]"},
> 	{KS_INS,	 "\316R"},
> 	{KS_DEL,	 "\316S"},
> 	{KS_HOME,	 "\316G"},
> 	{KS_END,	 "\316O"},
> 	{KS_PAGEDOWN,"\316Q"},
> 	{KS_PAGEUP,	 "\316I"},
68a353
> 
70c355,366
<   (char_u *)VT52_TCAP,
---
> /*
>  * Ordinary vt52
>  */
> 	{KS_NAME,	 "vt52"},
> 	{KS_EL,      "\033K"},
> 	{KS_IL,      "\033T"},
> 	{KS_DL,      "\033U"},
> 	{KS_ED,      "\014"},
> 	{KS_TP,      "\033SO"},
> 	{KS_TI,      "\033S2"},
> 	{KS_MS,      "\001"},
> 	{KS_CM,      "\033Y%+ %+ "},
71a368,451
> 
> # if defined(UNIX) || defined(ALL_BUILTIN_TCAPS) || defined(SOME_BUILTIN_TCAPS)
> /*
>  * The xterm termcap is missing F14 and F15, because they send the same
>  * codes as the undo and help key, although they don't work on all keyboards.
>  */
> 	{KS_NAME,	 "xterm"},
> 	{KS_EL,      "\033[K"},
> 	{KS_IL,      "\033[L"},
> #  ifdef TERMINFO
> 	{KS_CIL,     "\033[%p1%dL"},
> #  else
> 	{KS_CIL,     "\033[%dL"},
> #  endif
> 	{KS_DL,      "\033[M"},
> #  ifdef TERMINFO
> 	{KS_CDL,     "\033[%p1%dM"},
> #  else
> 	{KS_CDL,     "\033[%dM"},
> #  endif
> #  ifdef TERMINFO
> 	{KS_CS,      "\033[%i%p1%d;%p2%dr"},
> #  else
> 	{KS_CS,      "\033[%i%d;%dr"},
> #  endif
> 	{KS_ED,      "\033[H\033[2J"},
> 	{KS_TP,      "\033[m"},
> 	{KS_TI,      "\033[7m"},
> 	{KS_TB,      "\033[1m"},
> 	{KS_UE,      "\033[m"},
> 	{KS_US,      "\033[4m"},
> 	{KS_MS,      "\001"},
> #  ifdef TERMINFO
> 	{KS_CM,      "\033[%i%p1%d;%p2%dH"},
> #  else
> 	{KS_CM,      "\033[%i%d;%dH"},
> #  endif
> 	{KS_SR,      "\033M"},
> #  ifdef TERMINFO
> 	{KS_CRI,     "\033[%p1%dC"},
> #  else
> 	{KS_CRI,     "\033[%dC"},
> #  endif
> 	{KS_KS,      "\033[?1h\033="},
> 	{KS_KE,      "\033[?1l\033>"},
> #  if 0					/* these seem not to work very well */
> 	{KS_TS,      "\0337\033[?47h"},
> 	{KS_TE,      "\033[2J\033[?47l\0338"},
> #  endif
> 	{KS_UARROW,  "\033OA"},
> 	{KS_DARROW,  "\033OB"},
> 	{KS_LARROW,  "\033OD"},
> 	{KS_RARROW,  "\033OC"},
> 	{KS_SUARROW, "\033Ox"},
> 	{KS_SDARROW, "\033Or"},
> 	{KS_SLARROW, "\033Ot"},
> 	{KS_SRARROW, "\033Ov"},
> 	{KS_F1,      "\033[11~"},
> 	{KS_F2,      "\033[12~"},
> 	{KS_F3,      "\033[13~"},
> 	{KS_F4,      "\033[14~"},
> 	{KS_F5,      "\033[15~"},
> 	{KS_F6,      "\033[17~"},
> 	{KS_F7,      "\033[18~"},
> 	{KS_F8,      "\033[19~"},
> 	{KS_F9,      "\033[20~"},
> 	{KS_F10,     "\033[21~"},
> 	{KS_SF1,     "\033[23~"},
> 	{KS_SF2,     "\033[24~"},
> 	{KS_SF3,     "\033[25~"},
> 	{KS_SF6,     "\033[29~"},
> 	{KS_SF7,     "\033[31~"},
> 	{KS_SF8,     "\033[32~"},
> 	{KS_SF9,     "\033[33~"},
> 	{KS_SF10,    "\033[34~"},
> 	{KS_HELP,    "\033[28~"},
> 	{KS_UNDO,    "\033[26~"},
> 	{KS_INS,	 "\033[2~"},
> 	{KS_HOME,	 "\033[7~"},
> 	{KS_END,	 "\033[8~"},
> 	{KS_PAGEUP,	 "\033[5~"},
> 	{KS_PAGEDOWN,"\033[6~"},
> # endif
> 
73c453,539
<   (char_u *)DEBUG_TCAP,		/* always included when debugging */
---
> /*
>  * for debugging
>  */
> 	{KS_NAME,	 "debug"},
> 	{KS_EL,      "[EL]"},
> 	{KS_IL,      "[IL]"},
> #  ifdef TERMINFO
> 	{KS_CIL,     "[CIL%p1%d]"},
> #  else
> 	{KS_CIL,     "[CIL%d]"},
> #  endif
> 	{KS_DL,      "[DL]"},
> #  ifdef TERMINFO
> 	{KS_CDL,     "[CDL%p1%d]"},
> #  else
> 	{KS_CDL,     "[CDL%d]"},
> #  endif
> #  ifdef TERMINFO
> 	{KS_CS,      "[%dCS%p1%d]"},
> #  else
> 	{KS_CS,      "[%dCS%d]"},
> #  endif
> 	{KS_ED,      "[ED]"},
> 	{KS_CI,      "[CI]"},
> 	{KS_CV,      "[CV]"},
> 	{KS_CVV,     "[CVV]"},
> 	{KS_TP,      "[TP]"},
> 	{KS_TI,      "[TI]"},
> 	{KS_TB,      "[TB]"},
> 	{KS_SE,      "[SE]"},
> 	{KS_SO,      "[SO]"},
> 	{KS_UE,      "[UE]"},
> 	{KS_US,      "[US]"},
> 	{KS_MS,      "[MS]"},
> #  ifdef TERMINFO
> 	{KS_CM,      "[%p1%dCM%p2%d]"},
> #  else
> 	{KS_CM,      "[%dCM%d]"},
> #  endif
> 	{KS_SR,      "[SR]"},
> #  ifdef TERMINFO
> 	{KS_CRI,     "[CRI%p1%d]"},
> #  else
> 	{KS_CRI,     "[CRI%d]"},
> #  endif
> 	{KS_VB,      "[VB]"},
> 	{KS_KS,      "[KS]"},
> 	{KS_KE,      "[KE]"},
> 	{KS_TS,      "[TI]"},
> 	{KS_TE,      "[TE]"},
> 	{KS_UARROW,  "[KU]"},
> 	{KS_DARROW,  "[KD]"},
> 	{KS_LARROW,  "[KL]"},
> 	{KS_RARROW,  "[KR]"},
> 	{KS_SUARROW, "[SKU]"},
> 	{KS_SDARROW, "[SKD]"},
> 	{KS_SLARROW, "[SKL]"},
> 	{KS_SRARROW, "[SKR]"},
> 	{KS_F1,      "[F1]"},
> 	{KS_F2,      "[F2]"},
> 	{KS_F3,      "[F3]"},
> 	{KS_F4,      "[F4]"},
> 	{KS_F5,      "[F5]"},
> 	{KS_F6,      "[F6]"},
> 	{KS_F7,      "[F7]"},
> 	{KS_F8,      "[F8]"},
> 	{KS_F9,      "[F9]"},
> 	{KS_F10,     "[F10]"},
> 	{KS_SF1,     "[SF1]"},
> 	{KS_SF2,     "[SF2]"},
> 	{KS_SF3,     "[SF3]"},
> 	{KS_SF4,     "[SF4]"},
> 	{KS_SF5,     "[SF5]"},
> 	{KS_SF6,     "[SF6]"},
> 	{KS_SF7,     "[SF7]"},
> 	{KS_SF8,     "[SF8]"},
> 	{KS_SF9,     "[SF9]"},
> 	{KS_SF10,    "[SF10]"},
> 	{KS_HELP,    "[HELP]"},
> 	{KS_UNDO,    "[UNDO]"},
> 	{KS_INS,	 "[INS]"},
> 	{KS_DEL,	 "[DEL]"},
> 	{KS_HOME,    "[HOME]"},
> 	{KS_END,     "[END]"},
> 	{KS_PAGEUP,  "[PAGEUP]"},
> 	{KS_PAGEDOWN,"[PAGEDOWN]"},
> 	{KS_MOUSE,   "[MOUSE]"},
75,76c541
< #else /* NO_BUILTIN_TCAPS */
<   (char_u *)DUMB_TCAP,		/* minimal termcap, used when everything else fails */
---
> 
78,79c543,580
<   NULL,
< };
---
> 
> /*
>  * The most minimal terminal: only clear screen and cursor positioning
>  * Always included.
>  */
> 	{KS_NAME,	 "dumb"},
> 	{KS_ED,      "\014"},
> #ifdef TERMINFO
> 	{KS_CM,      "\033[%i%p1%d;%p2%dH"},
> #else
> 	{KS_CM,      "\033[%i%d;%dH"},
> #endif
> 
> /*
>  * end marker
>  */
>  	{KS_NAME,	 ""}
> 
> };		/* end of builtin_termcaps */
> 
> /*
>  * DEFAULT_TERM is used, when no terminal is specified with -T option or $TERM.
>  */
> #ifdef AMIGA
> # define DEFAULT_TERM	"amiga"
> #endif /* AMIGA */
> 
> #ifdef NT
> # define DEFAULT_TERM	"ntconsole"
> #else
> # ifdef MSDOS
> #  define DEFAULT_TERM	"pcterm"
> # endif /* MSDOS */                                   
> #endif /* NT */ 
> 
> #ifdef UNIX
> # define DEFAULT_TERM	"ansi"
> #endif /* UNIX */
87a589,606
> static char	*termleader;			/* for check_termcode() */
> 
> 	static struct builtin_term *
> find_builtin_term(name)
> 	char_u		*name;
> {
> 	struct builtin_term *p;
> 
> 	for (p = &(builtin_termcaps[0]);
> 				p->bt_string[0] != NUL && STRCMP(name, p->bt_string); )
> 	{
> 		do
> 			++p;
> 		while (p->bt_entry != KS_NAME);
> 	}
> 	return p;
> }
> 
89a609
>  * Caller should check if 'name' is a valid builtin term.
91,95d610
<  * Chop builtin termcaps, string entries are already '\0' terminated.
<  * not yet implemented:
<  *   boolean entries could be empty strings;
<  *   numeric entries would need a flag (e.g. high bit of the skip byte),
<  *   so that parse_builtin_tcap can handle them.
98,113c613,621
< parse_builtin_tcap(tc, s)
< 	Tcarr *tc;
< 	char_u *s;
< {
< 	char_u **p = &tc->t_name;
< 
< 	p++;
< 	for (;;)
<     {
< 		while (*s++)
< 			;
< 		p += *s++;
< 		if (!*s)
< 			return;
< 		*p++ = s;
<     }
---
> parse_builtin_tcap(tc, name)
> 	Tcarr	*tc;
> 	char_u	*name;
> {
> 	struct builtin_term		*p;
> 
> 	p = find_builtin_term(name);
> 	for (++p; p->bt_entry != KS_NAME; ++p)
> 		((char **)tc)[p->bt_entry] = p->bt_string;
119,122c627,634
< int				tgetent();
< int				tgetnum();
< char			*tgetstr();
< int				tgetflag();
---
> int				tgetent __PARMS((char *, char *));
> int				tgetnum __PARMS((char *));
> #if defined(linux) || defined(__sgi)
> char			*tgetstr __PARMS((char *, char **));
> #else
> char			*tgetstr __PARMS((char *, char *));
> #endif
> int				tgetflag __PARMS((char *));
134c646,651
< #ifdef linux
---
> 	/* I don't understand this.  Whether we use vim's tgetstr or not, we
> 	 * still have the prototype for it in proto/termlib.c as needing a
> 	 * (char **) for the second argument, so why didn't any compilers
> 	 * complain when it was passed a (char *) as cast below???? -- webb
> 	 */
> #if defined(linux) || defined(__sgi)
138a656
> #define TGETENT(b, t)	tgetent((char *)b, (char *)t)
144c662
< 	char_u **p = builtin_tcaps;
---
> 	struct builtin_term *termp;
166c684
< 		i = tgetent(tbuf, term);
---
> 		i = TGETENT(tbuf, term);
195a714,715
> 			T_UE = TGETSTR("ue", &tp);
> 			T_US = TGETSTR("us", &tp);
246a767,772
> 			term_strings.t_ins = TGETSTR("kI", &tp);
> 			term_strings.t_del = TGETSTR("kD", &tp);
> 			term_strings.t_home = TGETSTR("kh", &tp);
> 			term_strings.t_end = TGETSTR("@7", &tp);
> 			term_strings.t_pu = TGETSTR("kP", &tp);
> 			term_strings.t_pd = TGETSTR("kN", &tp);
266,268c792,796
< 		while (*p && STRCMP(term, *p))
< 			p++;
< 		if (!*p)
---
> 		/*
> 		 * search for 'term' in builtin_termcaps[]
> 		 */
> 		termp = find_builtin_term(term);
> 		if (termp->bt_string[0] == NUL)		/* did not find it */
270,271c798,800
< 			fprintf(stderr, "'%s' not builtin. Available terminals are:\r\n", term);
< 			for (p = builtin_tcaps; *p; p++)
---
> 			fprintf(stderr, "'%s' not known. Available builtin terminals are:\r\n", term);
> 			for (termp = &(builtin_termcaps[0]); termp->bt_string[0] != NUL; )
> 			{
273c802
< 				fprintf(stderr, "\tbuiltin_%s\r\n", *p);
---
> 				fprintf(stderr, "\tbuiltin_%s\r\n", termp->bt_string);
275c804
< 				fprintf(stderr, "\t%s\r\n", *p);
---
> 				fprintf(stderr, "\t%s\r\n", termp->bt_string);
276a806,809
> 				do
> 					++termp;
> 				while (termp->bt_entry != KS_NAME);
> 			}
283c816,817
< 			fprintf(stderr, "defaulting to '%s'\r\n", *builtin_tcaps);
---
> 			term = DEFAULT_TERM;
> 			fprintf(stderr, "defaulting to '%s'\r\n", term);
285d818
< 			p = builtin_tcaps;
287c820
< 			term_strings.t_name = strsave(term = *p);
---
> 			term_strings.t_name = strsave(term);
290c823
< 		parse_builtin_tcap(&term_strings, *p);
---
> 		parse_builtin_tcap(&term_strings, term);
293,295c826,829
<  * special: There is no info in the termcap about whether the cursor positioning
<  * is relative to the start of the screen or to the start of the scrolling region.
<  * We just guess here. Only msdos pcterm is known to do it relative.
---
>  * special: There is no info in the termcap about whether the cursor
>  * positioning is relative to the start of the screen or to the start of the
>  * scrolling region.  We just guess here. Only msdos pcterm is known to do it
>  * relative.
301a836,846
> 	/*
> 	 * recognize mouse events in the input stream for xterm or msdos
> 	 */
> #ifdef UNIX
> 	if (is_xterm(term))
> 		term_strings.t_mouse = strsave("\033[M");
> #endif
> #ifdef MSDOS
> 	term_strings.t_mouse = strsave("\233M");
> #endif
> 
303,304c848,849
< 		/* DFLT_TCAP indicates that it is the machine console. */
< 	if (STRCMP(term, *builtin_tcaps))
---
> 		/* DEFAULT_TERM indicates that it is the machine console. */
> 	if (STRCMP(term, DEFAULT_TERM))
341c886
< 	if (term_strings.t_name != NULL && tgetent(tbuf, term_strings.t_name) > 0)
---
> 	if (term_strings.t_name != NULL && TGETENT(tbuf, term_strings.t_name) > 0)
437c982
< 		term = *builtin_tcaps;
---
> 		term = DEFAULT_TERM;
516c1061
< 		tputs(s, 1, TPUTSFUNCAST outchar);
---
> 		tputs((char *)s, 1, TPUTSFUNCAST outchar);
581a1127,1128
> 		if ((!T_US || !*T_US) ^ (!T_UE || !*T_UE))
> 			T_US = T_UE = NULL;
601a1149
> 	gather_termleader();
614,616c1162,1164
<  *  If time == 0  there is no waiting for the char.
<  *  If time == n  we wait for n msec for a character to arrive.
<  *  If time == -1 we wait forever for a character to arrive.
---
>  *  If wait_time == 0  there is no waiting for the char.
>  *  If wait_time == n  we wait for n msec for a character to arrive.
>  *  If wait_time == -1 we wait forever for a character to arrive.
622c1170
< inchar(buf, maxlen, time)
---
> inchar(buf, maxlen, wait_time)
625c1173
< 	int		time;						/* milli seconds */
---
> 	int		wait_time;						/* milli seconds */
627c1175
< 	int				len;
---
> 	int				len = 0;			/* init for GCC */
632c1180
< 	if (time == -1 || time > 100)	/* flush output before waiting */
---
> 	if (wait_time == -1 || wait_time > 100)	/* flush output before waiting */
637a1186,1187
> 	did_swapwrite_msg = FALSE;	/* display swap file write error again */
> 	undo_off = FALSE;			/* restart undo now */
643,644c1193,1194
< retry:
< 	if (scriptin[curscript] != NULL)
---
> 	c = -1;
> 	while (scriptin[curscript] != NULL && c < 0)
656c1206,1210
< 			goto retry;		/* may read other script if this one was nested */
---
> 		}
> 		else
> 		{
> 			buf[0] = c;
> 			len = 1;
658,662d1211
< 		if (c == 0)
< 			c = K_ZERO;		/* replace ^@ with special code */
< 		*buf++ = c;
< 		*buf = NUL;
< 		return 1;
665,669c1214
< /*
<  * If we got an interrupt, skip all previously typed characters and
<  * return TRUE if quit reading script file.
<  */
< 	if (got_int)			/* skip typed characters */
---
> 	if (c < 0)			/* did not get a character from script */
671,673c1216,1228
< 		while (GetChars(buf, maxlen, T_PEEK))
< 			;
< 		return retesc;
---
> 	/*
> 	 * If we got an interrupt, skip all previously typed characters and
> 	 * return TRUE if quit reading script file.
> 	 */
> 		if (got_int)			/* skip typed characters */
> 		{
> 			while (GetChars(buf, maxlen, T_PEEK))
> 				;
> 			return retesc;
> 		}
> 			/* fill up to half the buffer, because each character may be
> 			 * doubled below */
> 		len = GetChars(buf, maxlen / 2, wait_time);
675d1229
< 	len = GetChars(buf, maxlen, time);
676a1231,1235
> 	/*
> 	 * Two characters are special: NUL and K_SPECIAL.
> 	 * Replace       NUL by K_SPECIAL KS_ZERO
> 	 * Replace K_SPECIAL by K_SPECIAL KS_SPECIAL
> 	 */
678,679c1237,1246
< 		if (*buf == 0)
< 			*(char_u *)buf = K_ZERO;		/* replace ^@ with special code */
---
> 	{
> 		if (buf[0] == NUL || buf[0] == K_SPECIAL)
> 		{
> 			memmove(buf + 2, buf + 1, i);
> 			buf[1] = (buf[0] == NUL ? KS_ZERO : KS_SPECIAL);
> 			buf[0] = K_SPECIAL;
> 			++buf;
> 			++len;
> 		}
> 	}
685c1252
<  * Check if buf[] begins with a terminal key code.
---
>  * Check if typestr[] contains a terminal key code.
687,690c1254,1255
<  * With a match the replacement code is put in buf[0], the match is
<  * removed and the number characters in buf is returned.
<  *
<  * Note: should always be called with buf == typestr!
---
>  * With a match, the match is removed, the replacement code is inserted in
>  * typestr[] and the number of characters in typestr[] is returned.
693,694c1258
< check_termcode(buf)
< 	char_u	*buf;
---
> check_termcode()
698a1263
> 	int		offset;
700,701c1265,1268
< 	len = STRLEN(buf);
< 	for (p = (char_u **)&term_strings.t_ku; p != (char_u **)&term_strings.t_undo + 1; ++p)
---
> 	/*
> 	 * Check at all positions in typestr[], to catch something like "x<C_UP>"
> 	 */
> 	for (offset = 0; typestr[offset] != NUL; ++offset)
703c1270,1282
< 		if (*p == NULL || (slen = STRLEN(*p)) == 0)		/* empty entry */
---
> 		/*
> 		 * Skip this position if the character does not appear as the first
> 		 * character in term_strings. This speeds up a lot, since most
> 		 * termcodes start with the same character.
> 		 */
> 		if (STRCHR(termleader, typestr[offset]) == NULL)
> 			continue;
> 
> 		/*
> 		 * skip this position if p_ek is not set and typestr[offset] is an ESC
> 		 * and we are in insert mode
> 		 */
> 		if (typestr[offset] == ESC && !p_ek && (State & INSERT))
705c1284,1286
< 		if (STRNCMP(*p, buf, (size_t)(slen > len ? len : slen)) == 0)
---
> 		len = STRLEN(typestr + offset);
> 		for (p = (char_u **)&term_strings.T_FIRST_KEY;
> 						p != (char_u **)&term_strings.T_LAST_KEY + 1; ++p)
707c1288,1297
< 			if (len >= slen)		/* got the complete sequence */
---
> 			/*
> 			 * Ignore the entry if it is blank or when we are not at the
> 			 * start of typestr[] and there are not enough characters to make
> 			 * a match
> 			 */
> 			if (*p == NULL || (slen = STRLEN(*p)) == 0 ||
> 											(offset && len < slen))
> 				continue;
> 			if (STRNCMP(*p, typestr + offset, (size_t)(slen > len ?
> 														len : slen)) == 0)
709,711c1299,1330
< 				len -= slen;
< 					/* remove matched chars, taking care of noremap */
< 				del_typestr(slen - 1);
---
> 				if (len < slen)				/* got a partial sequence */
> 					return -1;				/* need to get more chars */
> 			
> #if defined(UNIX) || defined(MSDOS)
> 				/*
> 				 * If it is an xterm or msdos mouse click, get the coordinates.
> 				 * we get "ESC[Mscr" for xterm and "CSIMscr" for msdos, where
> 				 *	s == encoded mouse button state (0x20 = left, 0x22 = right)
> 				 *	c == column + ' ' + 1 == column + 33
> 				 *	r == row + ' ' + 1 == row + 33
> 				 *
> 				 * The coordinates are passed on through global variables. Ugly,
> 				 * but this avoids trouble with mouse clicks at an unexpected
> 				 * moment.
> 				 */
> 				if (p == (char_u **)&term_strings.t_mouse)
> 				{
> 					if (len < slen + 3)		/* not enough coordinates */
> 						return -1;
> 					mouse_code = typestr[slen + offset];
> 					mouse_col = typestr[slen + offset + 1] - '!';
> 					mouse_row = typestr[slen + offset + 2] - '!';
> 					slen += 3;
> 				}
> #endif
> 				if (slen > 2)
> 						/* remove matched chars, taking care of noremap */
> 					del_typestr(slen - 2, offset);
> 				else if (slen == 1)
> 						/* insert an extra space for K_SPECIAL */
> 					ins_typestr((char_u *)" ", FALSE, offset, FALSE);
> 
713,714c1332,1335
< 				buf[0] = K_UARROW + (p - (char_u **)&term_strings.t_ku);
< 				return (len + 1);
---
> 				typestr[offset] = K_SPECIAL;
> 				typestr[offset + 1] = KS_UARROW +
> 								(p - (char_u **)&term_strings.T_FIRST_KEY);
> 				return (len - slen + 2 + offset);
716d1336
< 			return -1;				/* got a partial sequence */
722a1343,1436
>  * Replace any terminal code strings in buf[] with the equivalent internal vim
>  * representation.  Any strings like "<C_UP>" are also replaced -- webb
>  * buf[] should have extra space for inserting K_SPECIAL codes!
>  */
> 	void
> replace_termcodes(buf)
> 	char_u	*buf;
> {
> 	char_u	**names = get_key_names();
> 	char_u	*namep;
> 	int		n;
> 	char_u 	**p;
> 	char_u	*bp;
> 	int		slen;
> 
> 	while (*buf != NUL)
> 	{
> 		/* See if it's a string like "<C_UP>" */
> 		if (buf[0] == '<')
> 		{
> 			for (n = KS_UARROW; n <= KS_MAXKEY; n++)
> 			{
> 				namep = names[n - KS_UARROW];
> 				bp = buf + 1;
> 				for (; *namep != NUL; namep++, bp++)
> 					if (TO_LOWER(*namep) != TO_LOWER(*bp))
> 						break;
> 				if (*namep == NUL && *bp == '>')
> 				{
> 					*buf++ = K_SPECIAL;
> 					*buf = n;
> 					STRCPY(buf + 1, bp + 1);
> 					break;
> 				}
> 			}
> 		}
> 		else
> 		{
> 			/* See if it's an actual key-code */
> 			for (p = (char_u **)&term_strings.T_FIRST_KEY;
> 				p != (char_u **)&term_strings.T_LAST_KEY + 1; ++p)
> 			{
> 				if (*p == NULL || (slen = STRLEN(*p)) == 0)	/* empty entry */
> 					continue;
> 				if (STRNCMP(*p, buf, (size_t)slen) == 0)
> 				{
> 					if (slen > 2)		/* delete extra characters */
> 						STRCPY(buf + 2, buf + slen);
> 					else if (slen == 1)	/* make room for one more character */
> 						memmove(buf + 1, buf, STRLEN(buf) + 1);
> 					buf[0] = K_SPECIAL;
> 						/* This relies on the Key numbers to be consecutive! */
> 					buf[1] = KS_UARROW + (p - (char_u **)&term_strings.T_FIRST_KEY);
> 					break;
> 				}
> 			}
> 		}
> 		buf++;
> 	}
> }
> 
> /*
>  * Gather the first characters in the terminal key codes into a string.
>  * Used to speed up check_termcode().
>  */
> 	static void
> gather_termleader()
> {
> 	char_u	*string;
> 	char_u 	**p;
> 	int		len;
> 
> 	string = alloc(KS_MAXKEY + 1);
> 	if (string == NULL)
> 		return;
> 	*string = NUL;
> 	len = 0;
> 
> 	for (p = (char_u **)&term_strings.T_FIRST_KEY;
> 						p != (char_u **)&term_strings.T_LAST_KEY + 1; ++p)
> 	{
> 		if (*p == NULL || **p == NUL)		/* empty entry */
> 			continue;
> 		if (STRCHR(string, **p) == NULL)	/* found a new character */
> 		{
> 			string[len++] = **p;
> 			string[len] = NUL;
> 		}
> 	}
> 	free(termleader);
> 	termleader = string;
> }
> 
> /*
739,740c1453,1454
< 	if (Rows < MIN_ROWS + 1)	/* need room for one window and command line */
< 		Rows = MIN_ROWS + 1;
---
> 	if (Rows < min_rows())		/* need room for one window and command line */
> 		Rows = min_rows();
761c1475,1476
< 	if (State == HITRETURN || State == SETWSIZE)	/* postpone the resizing */
---
> 									/* postpone the resizing */
> 	if (State == HITRETURN || State == SETWSIZE)
766c1481,1482
< 	screenclear();
---
> 	if (State != ASKMORE)
> 		screenclear();
768c1484,1485
< 	flushbuf(); 		/* must do this before mch_get_winsize for some obscure reason */
---
> 	flushbuf(); 		/* must do this before mch_get_winsize for some
> 							obscure reason */
783,784d1499
< 		tmp = RedrawingDisabled;
< 		RedrawingDisabled = FALSE;
786,789c1501,1506
< 		updateScreen(CURSUPD);
< 		RedrawingDisabled = tmp;
< 		if (State == CMDLINE)
< 			redrawcmdline();
---
> 		if (State == ASKMORE)	/* don't redraw, just adjust screen size */
> 		{
> 			screenalloc(FALSE);
> 			msg_moremsg();		/* display --more-- message again */
> 			msg_row = Rows - 1;
> 		}
791c1508,1517
< 			setcursor();
---
> 		{
> 			tmp = RedrawingDisabled;
> 			RedrawingDisabled = FALSE;
> 			updateScreen(CURSUPD);
> 			RedrawingDisabled = tmp;
> 			if (State == CMDLINE)
> 				redrawcmdline();
> 			else
> 				setcursor();
> 		}
828a1555,1569
>  * By outputting the 'cursor very visible' termcap code, for some windowed
>  * terminals this makes the screen scrolled to the right position
>  * Used when starting Vim or returning from a shell.
>  */
> 	void
> scroll_start()
> {
> 	if (T_CVV != NULL && *T_CVV)
> 	{
> 		outstr(T_CVV);
> 		outstr(T_CV);
> 	}
> }
> 
> /*
836c1577
< 	if (cursor_is_off && (!VIsual.lnum || highlight == NULL))
---
> 	if (cursor_is_off && (VIsual.lnum == 0 || highlight == NULL))
Index: ./src/term.h
diff -r ../vim3.0/src/term.h ./src/term.h
26c26,30
<  * keep in sync with array in term.c
---
>  * IMPORTANT: When making changes, note the following:
>  * - keep the arrays in term.c and get_key_names() in sync
>  * - adjust the definitions in keymap.h
>  * - avoid changing the order of the key codes, add new ones at the end
>  *   (Otherwise special keys in script files will break)
30d33
< /* output codes */
32,55d34
<   char_u *t_el;		/* el       ce	clear to end of line */
<   char_u *t_il;		/* il1      al	add new blank line */
<   char_u *t_cil;	/* il       AL	add number of blank lines */
<   char_u *t_dl;		/* dl1      dl	delete line */
<   char_u *t_cdl;	/* dl       DL	delete number of lines */
<   char_u *t_cs;		/*          cs	scroll region */
<   char_u *t_ed;		/* clear    cl	clear screen */
<   char_u *t_ci;		/* civis    vi	cursur invisible */
<   char_u *t_cv;		/* cnorm    ve	cursur visible */
<   char_u *t_cvv;	/* cvvis    vs  cursor very visible */
<   char_u *t_tp;		/* sgr0     me	normal mode */
<   char_u *t_ti;		/* rev      mr	reverse mode */
<   char_u *t_tb;		/* bold     md	bold mode */
<   char_u *t_se;		/* rmso     se	normal mode */
<   char_u *t_so;		/* smso     so	standout mode */
<   char_u *t_ms;		/* msgr     ms	save to move cursor in reverse mode */
<   char_u *t_cm;		/* cup      cm	cursor motion */
<   char_u *t_sr;		/* ri       sr	scroll reverse (backward) */
<   char_u *t_cri;	/* cuf      RI	cursor number of chars right */
<   char_u *t_vb;		/* flash    vb	visual bell */
<   char_u *t_ks;		/* smkx     ks	put terminal in "keypad transmit" mode */
<   char_u *t_ke;		/* rmkx     ke	out of "keypad transmit" mode */
<   char_u *t_ts;		/*          ti	put terminal in termcap mode */
<   char_u *t_te;		/*          te	out of termcap mode */
57a37
> #define T_FIRST_KEY	t_ku
62,63c42,43
<   char_u *t_sku;	/* shift arrow up */
<   char_u *t_skd;	/* shift arrow down */
---
>   char_u *t_sku;	/*				shift arrow up */
>   char_u *t_skd;	/*				shift arrow down */
65a46
> 
75a57
> 
85a68
> 
88c71,77
<   /* adjust inchar() for last key entry! */
---
> 
>   char_u *t_ins;	/* kins		kI  insert key */
>   char_u *t_del;	/* kdel		kD  delete key */
>   char_u *t_home;	/* khome    kh	home key */
>   char_u *t_end;	/* kend     @7	end key */
>   char_u *t_pu;		/* kpp      kP	page up key */
>   char_u *t_pd;		/* knp      kN	page down key */
89a79,109
>   char_u *t_mouse;	/*				start of mouse click */
> #define T_LAST_KEY t_mouse
> 
> /* output codes */
>   char_u *t_el;		/* el       ce	clear to end of line */
>   char_u *t_il;		/* il1      al	add new blank line */
>   char_u *t_cil;	/* il       AL	add number of blank lines */
>   char_u *t_dl;		/* dl1      dl	delete line */
>   char_u *t_cdl;	/* dl       DL	delete number of lines */
>   char_u *t_cs;		/*          cs	scroll region */
>   char_u *t_ed;		/* clear    cl	clear screen */
>   char_u *t_ci;		/* civis    vi	cursor invisible */
>   char_u *t_cv;		/* cnorm    ve	cursor visible */
>   char_u *t_cvv;	/* cvvis    vs  cursor very visible */
>   char_u *t_tp;		/* sgr0     me	normal mode */
>   char_u *t_ti;		/* rev      mr	reverse mode */
>   char_u *t_tb;		/* bold     md	bold mode */
>   char_u *t_se;		/* rmso     se	normal mode */
>   char_u *t_so;		/* smso     so	standout mode */
>   char_u *t_ue;		/* rmul     ue	exit underscore mode */
>   char_u *t_us;		/* smul     us	underscore mode */
>   char_u *t_ms;		/* msgr     ms	save to move cursor in reverse mode */
>   char_u *t_cm;		/* cup      cm	cursor motion */
>   char_u *t_sr;		/* ri       sr	scroll reverse (backward) */
>   char_u *t_cri;	/* cuf      RI	cursor number of chars right */
>   char_u *t_vb;		/* flash    vb	visual bell */
>   char_u *t_ks;		/* smkx     ks	put terminal in "keypad transmit" mode */
>   char_u *t_ke;		/* rmkx     ke	out of "keypad transmit" mode */
>   char_u *t_ts;		/*          ti	put terminal in termcap mode */
>   char_u *t_te;		/*          te	out of termcap mode */
> 
112a133,134
> #define T_UE	(term_strings.t_ue)
> #define T_US	(term_strings.t_us)
123,865d144
< 
< 
< #ifndef TERMINFO
< # ifndef NO_BUILTIN_TCAPS
< /*
<  * here are the builtin termcap entries.
<  * They not stored as complete Tcarr structures, as such a structure 
<  * is to big. 
<  * Each termcap is a concatenated string of entries, where '\0' characters
<  * followed by a skip character sepereate the capabilities. The skip 
<  * character is the relative structure offset for the following entry.
<  * See parse_builtin_tcap() in term.c for all details.
<  */
< #  define AMIGA_TCAP "amiga\0\
< \0\033[K\0\
< \0\033[L\0\
< \0\033[%dL\0\
< \0\033[M\0\
< \0\033[%dM\0\
< \1\014\0\
< \0\033[0 p\0\
< \0\033[1 p\0\
< \1\033[0m\0\
< \0\033[7m\0\
< \0\033[1m\0\
< \0\033[0m\0\
< \0\033[33m\0\
< \0\001\0\
< \0\033[%i%d;%dH\0\
< \1\033[%dC\0\
< \5\233A\0\
< \0\233B\0\
< \0\233D\0\
< \0\233C\0\
< \0\233T\0\
< \0\233S\0\
< \0\233 A\0\
< \0\233 @\0\
< \0\233\060~\0\
< \0\233\061~\0\
< \0\233\062~\0\
< \0\233\063~\0\
< \0\233\064~\0\
< \0\233\065~\0\
< \0\233\066~\0\
< \0\233\067~\0\
< \0\233\070~\0\
< \0\233\071~\0\
< \0\233\061\060~\0\
< \0\233\061\061~\0\
< \0\233\061\062~\0\
< \0\233\061\063~\0\
< \0\233\061\064~\0\
< \0\233\061\065~\0\
< \0\233\061\066~\0\
< \0\233\061\067~\0\
< \0\233\061\070~\0\
< \0\233\061\071~\0\
< \0\233?~\0\
< \0\0"
< 
< #  define ATARI_TCAP "atari\0\
< \0\033l\0\
< \0\033L\0\
< \1\033M\0\
< \2\033E\0\
< \0\033f\0\
< \0\033e\0\
< \0\0"
< 
< #  define ANSI_TCAP "ansi\0\
< \0\033[2K\0\
< \0\033[L\0\
< \0\033[%dL\0\
< \0\033[M\0\
< \0\033[%dM\0\
< \1\033[2J\0\
< \3\033[0m\0\
< \0\033[7m\0\
< \3\001\0\
< \0\033[%i%d;%dH\0\
< \1\033[%dC\0\
< \0\0"
< 
< /*
<  * These codes are valid when nansi.sys or equivalent has been installed.
<  * Function keys on a PC are preceded with a NUL. These are converted into
<  * K_NUL '\316' in GetChars(), because we cannot handle NULs in key codes.
<  * CTRL-arrow is used instead of SHIFT-arrow.
<  */
< #  define PCANSI_TCAP "pcansi\0\
< \0\033[K\0\
< \0\033[L\0\
< \1\033[M\0\
< \2\033[2J\0\
< \3\033[0m\0\
< \0\033[7m\0\
< \3\001\0\
< \0\033[%i%d;%dH\0\
< \1\033[%dC\0\
< \5\316H\0\
< \0\316P\0\
< \0\316K\0\
< \0\316M\0\
< \2\316s\0\
< \0\316t\0\
< \0\316;\0\
< \0\316<\0\
< \0\316=\0\
< \0\316>\0\
< \0\316?\0\
< \0\316@\0\
< \0\316A\0\
< \0\316B\0\
< \0\316C\0\
< \0\316D\0\
< \0\316T\0\
< \0\316U\0\
< \0\316V\0\
< \0\316W\0\
< \0\316X\0\
< \0\316Y\0\
< \0\316Z\0\
< \0\316[\0\
< \0\316\\\0\
< \0\316]\0\
< \0\0"
< 
< /*
<  * These codes are valid for the pc video.
<  * The entries that start with ESC | are translated into conio calls in msdos.c.
<  */
< #  define PCTERM_TCAP "pcterm\0\
< \0\033|K\0\
< \0\033|L\0\
< \1\033|M\0\
< \1\033|%i%d;%dr\0\
< \0\033|J\0\
< \3\033|0m\0\
< \0\033|112m\0\
< \0\033|63m\0\
< \0\033|0m\0\
< \0\033|31m\0\
< \0\001\0\
< \0\033|%i%d;%dH\0\
< \7\316H\0\
< \0\316P\0\
< \0\316K\0\
< \0\316M\0\
< \2\316s\0\
< \0\316t\0\
< \0\316;\0\
< \0\316<\0\
< \0\316=\0\
< \0\316>\0\
< \0\316?\0\
< \0\316@\0\
< \0\316A\0\
< \0\316B\0\
< \0\316C\0\
< \0\316D\0\
< \0\316T\0\
< \0\316U\0\
< \0\316V\0\
< \0\316W\0\
< \0\316X\0\
< \0\316Y\0\
< \0\316Z\0\
< \0\316[\0\
< \0\316\\\0\
< \0\316]\0\
< \0\0"
< 
< /*
<  * These codes are valid for the NT Console 
<  * The entries that start with ESC | are translated into console calls 
<  * in winnt.c.
<  */
< #  define NTCONSOLE_TCAP "ntconsole\0\
< \0\033|K\0\
< \0\033|L\0\
< \0\033|%dL\0\
< \0\033|M\0\
< \0\033|%dM\0\
< \1\033|J\0\
< \0\033|v\0\
< \0\033|V\0\
< \1\033|0m\0\
< \0\033|112m\0\
< \0\033|63m\0\
< \0\033|0m\0\
< \0\033|31m\0\
< \0\001\0\
< \0\033|%i%d;%dH\0\
< \7\316H\0\
< \0\316P\0\
< \0\316K\0\
< \0\316M\0\
< \2\316s\0\
< \0\316t\0\
< \0\316;\0\
< \0\316<\0\
< \0\316=\0\
< \0\316>\0\
< \0\316?\0\
< \0\316@\0\
< \0\316A\0\
< \0\316B\0\
< \0\316C\0\
< \0\316D\0\
< \0\316T\0\
< \0\316U\0\
< \0\316V\0\
< \0\316W\0\
< \0\316X\0\
< \0\316Y\0\
< \0\316Z\0\
< \0\316[\0\
< \0\316\\\0\
< \0\316]\0\
< \0\0"
< 
< 
< #  define VT52_TCAP "vt52\0\
< \0\033K\0\
< \0\033T\0\
< \1\033U\0\
< \2\014\0\
< \3\033SO\0\
< \0\033S2\0\
< \3\001\0\
< \0\033Y%+ %+ \0\
< \0\0"
< 
< /*
<  * The xterm termcap is missing F14 and F15, because they send the same
<  * codes as the undo and help key, although they don't work on all keyboards.
<  */
< #  define XTERM_TCAP "xterm\0\
< \0\033[K\0\
< \0\033[L\0\
< \0\033[%dL\0\
< \0\033[M\0\
< \0\033[%dM\0\
< \0\033[%i%d;%dr\0\
< \0\033[H\033[2J\0\
< \3\033[m\0\
< \0\033[7m\0\
< \0\033[1m\0\
< \2\001\0\
< \0\033[%i%d;%dH\0\
< \0\033M\0\
< \0\033[%dC\0\
< \1\033[?1h\033=\0\
< \0\033[?1l\033>\0\
< \0\0337\033[?47h\0\
< \0\033[2J\033[?47l\0338\0\
< \0\033OA\0\
< \0\033OB\0\
< \0\033OD\0\
< \0\033OC\0\
< \0\033Ox\0\
< \0\033Or\0\
< \0\033Ot\0\
< \0\033Ov\0\
< \0\033[11~\0\
< \0\033[12~\0\
< \0\033[13~\0\
< \0\033[14~\0\
< \0\033[15~\0\
< \0\033[17~\0\
< \0\033[18~\0\
< \0\033[19~\0\
< \0\033[20~\0\
< \0\033[21~\0\
< \0\033[23~\0\
< \0\033[24~\0\
< \0\033[25~\0\
< \2\033[29~\0\
< \0\033[31~\0\
< \0\033[32~\0\
< \0\033[33~\0\
< \0\033[34~\0\
< \0\033[28~\0\
< \0\033[26~\0\
< \0\0"
< 
< #  define DEBUG_TCAP "debug\0\
< \0[EL]\0\
< \0[IL]\0\
< \0[CIL%d]\0\
< \0[DL]\0\
< \0[CDL%d]\0\
< \0[%dCS%d]\0\
< \0[ED]\0\
< \0[CI]\0\
< \0[CV]\0\
< \0[CVV]\0\
< \0[TP]\0\
< \0[TI]\0\
< \0[TB]\0\
< \0[SE]\0\
< \0[SO]\0\
< \0[MS]\0\
< \0[%dCM%d]\0\
< \0[SR]\0\
< \0[CRI%d]\0\
< \0[VB]\0\
< \0[KS]\0\
< \0[KE]\0\
< \0[TI]\0\
< \0[TE]\0\
< \0[KU]\0\
< \0[KD]\0\
< \0[KL]\0\
< \0[KR]\0\
< \0[SKU]\0\
< \0[SKD]\0\
< \0[SKL]\0\
< \0[SKR]\0\
< \0[F1]\0\
< \0[F2]\0\
< \0[F3]\0\
< \0[F4]\0\
< \0[F5]\0\
< \0[F6]\0\
< \0[F7]\0\
< \0[F8]\0\
< \0[F9]\0\
< \0[F10]\0\
< \0[SF1]\0\
< \0[SF2]\0\
< \0[SF3]\0\
< \0[SF4]\0\
< \0[SF5]\0\
< \0[SF6]\0\
< \0[SF7]\0\
< \0[SF8]\0\
< \0[SF9]\0\
< \0[SF10]\0\
< \0[HELP]\0\
< \0[UNDO]\0\
< \0\0"
< 
< #  ifdef ATARI
< #   define DFLT_TCAP ATARI_TCAP
< #  endif /* ATARI */
< 
< #  ifdef AMIGA
< #   define DFLT_TCAP AMIGA_TCAP
< #  endif /* AMIGA */
< 
< #  ifdef NT
< #   define DFLT_TCAP NTCONSOLE_TCAP
< #  else
< #   ifdef MSDOS
< #    define DFLT_TCAP PCTERM_TCAP                       
< #   endif /* MSDOS */                                   
< #  endif /* NT */ 
< 
< #  ifdef UNIX
< #   define DFLT_TCAP ANSI_TCAP
< #  endif /* UNIX */
< 
< # else /* NO_BUILTIN_TCAPS */
< #  define DUMB_TCAP "dumb\0\
< \6\014\0\
< \9\033[%i%d;%dH\0\
< \0\0"
< # endif /* NO_BUILTIN_TCAPS */
< 
< #else /* TERMINFO */
< # ifndef NO_BUILTIN_TCAPS
< /*
<  * here are the builtin termcap entries.
<  * They not stored as complete Tcarr structures, as such a structure 
<  * is to big. 
<  * Each termcap is a concatenated string of entries, where '\0' characters
<  * followed by a skip character sepereate the capabilities. The skip 
<  * character is the relative structure offset for the following entry.
<  * See parse_builtin_tcap() in term.c for all details.
<  */
< #  define AMIGA_TCAP "amiga\0\
< \0\033[K\0\
< \0\033[L\0\
< \0\033[%p1%dL\0\
< \0\033[M\0\
< \0\033[%p1%dM\0\
< \1\014\0\
< \0\033[0 p\0\
< \0\033[1 p\0\
< \1\033[0m\0\
< \0\033[7m\0\
< \0\033[1m\0\
< \0\033[0m\0\
< \0\033[33m\0\
< \0\001\0\
< \0\033[%i%p1%d;%p2%dH\0\
< \1\033[%p1%dC\0\
< \5\233A\0\
< \0\233B\0\
< \0\233D\0\
< \0\233C\0\
< \0\233T\0\
< \0\233S\0\
< \0\233 A\0\
< \0\233 @\0\
< \0\233\060~\0\
< \0\233\061~\0\
< \0\233\062~\0\
< \0\233\063~\0\
< \0\233\064~\0\
< \0\233\065~\0\
< \0\233\066~\0\
< \0\233\067~\0\
< \0\233\070~\0\
< \0\233\071~\0\
< \0\233\061\060~\0\
< \0\233\061\061~\0\
< \0\233\061\062~\0\
< \0\233\061\063~\0\
< \0\233\061\064~\0\
< \0\233\061\065~\0\
< \0\233\061\066~\0\
< \0\233\061\067~\0\
< \0\233\061\070~\0\
< \0\233\061\071~\0\
< \0\233?~\0\
< \0\0"
< 
< #  define ATARI_TCAP "atari\0\
< \0\033l\0\
< \0\033L\0\
< \1\033M\0\
< \2\033E\0\
< \0\033f\0\
< \0\033e\0\
< \0\0"
< 
< #  define ANSI_TCAP "ansi\0\
< \0\033[2K\0\
< \0\033[L\0\
< \0\033[%p1%dL\0\
< \0\033[M\0\
< \0\033[%p1%dM\0\
< \1\033[2J\0\
< \3\033[0m\0\
< \0\033[7m\0\
< \3\001\0\
< \0\033[%i%p1%d;%p2%dH\0\
< \1\033[%p1%dC\0\
< \0\0"
< 
< /*
<  * These codes are valid when nansi.sys or equivalent has been installed.
<  * Function keys on a PC are preceded with a NUL. These are converted into
<  * K_NUL '\316' in GetChars(), because we cannot handle NULs in key codes.
<  * CTRL-arrow is used instead of SHIFT-arrow.
<  */
< #  define PCANSI_TCAP "pcansi\0\
< \0\033[K\0\
< \0\033[L\0\
< \1\033[M\0\
< \2\033[2J\0\
< \3\033[0m\0\
< \0\033[7m\0\
< \3\001\0\
< \0\033[%i%p1%d;%p2%dH\0\
< \1\033[%p1%dC\0\
< \5\316H\0\
< \0\316P\0\
< \0\316K\0\
< \0\316M\0\
< \2\316s\0\
< \0\316t\0\
< \0\316;\0\
< \0\316<\0\
< \0\316=\0\
< \0\316>\0\
< \0\316?\0\
< \0\316@\0\
< \0\316A\0\
< \0\316B\0\
< \0\316C\0\
< \0\316D\0\
< \0\316T\0\
< \0\316U\0\
< \0\316V\0\
< \0\316W\0\
< \0\316X\0\
< \0\316Y\0\
< \0\316Z\0\
< \0\316[\0\
< \0\316\\\0\
< \0\316]\0\
< \0\0"
< 
< /*
<  * These codes are valid for the pc video.
<  * The entries that start with ESC | are translated into conio calls in msdos.c.
<  */
< #  define PCTERM_TCAP "pcterm\0\
< \0\033|K\0\
< \0\033|L\0\
< \1\033|M\0\
< \1\033|%i%p1%d;%p2%dr\0\
< \0\033|J\0\
< \3\033|0m\0\
< \0\033|112m\0\
< \0\033|63m\0\
< \0\033|0m\0\
< \0\033|31m\0\
< \0\001\0\
< \0\033|%i%p1%d;%p2%dH\0\
< \7\316H\0\
< \0\316P\0\
< \0\316K\0\
< \0\316M\0\
< \2\316s\0\
< \0\316t\0\
< \0\316;\0\
< \0\316<\0\
< \0\316=\0\
< \0\316>\0\
< \0\316?\0\
< \0\316@\0\
< \0\316A\0\
< \0\316B\0\
< \0\316C\0\
< \0\316D\0\
< \0\316T\0\
< \0\316U\0\
< \0\316V\0\
< \0\316W\0\
< \0\316X\0\
< \0\316Y\0\
< \0\316Z\0\
< \0\316[\0\
< \0\316\\\0\
< \0\316]\0\
< \0\0"
< 
< /*
<  * These codes are valid for the NT Console 
<  * The entries that start with ESC | are translated into console calls 
<  * in winnt.c.
<  */
< #  define NTCONSOLE_TCAP "ntconsole\0\
< \0\033|K\0\
< \0\033|L\0\
< \0\033|%dL\0\
< \0\033|M\0\
< \0\033|%dM\0\
< \1\033|J\0\
< \0\033|v\0\
< \0\033|V\0\
< \1\033|0m\0\
< \0\033|112m\0\
< \0\033|63m\0\
< \0\033|0m\0\
< \0\033|31m\0\
< \0\001\0\
< \0\033|%i%p1%d;%p2%dH\0\
< \7\316H\0\
< \0\316P\0\
< \0\316K\0\
< \0\316M\0\
< \2\316s\0\
< \0\316t\0\
< \0\316;\0\
< \0\316<\0\
< \0\316=\0\
< \0\316>\0\
< \0\316?\0\
< \0\316@\0\
< \0\316A\0\
< \0\316B\0\
< \0\316C\0\
< \0\316D\0\
< \0\316T\0\
< \0\316U\0\
< \0\316V\0\
< \0\316W\0\
< \0\316X\0\
< \0\316Y\0\
< \0\316Z\0\
< \0\316[\0\
< \0\316\\\0\
< \0\316]\0\
< \0\0"
< 
< 
< #  define VT52_TCAP "vt52\0\
< \0\033K\0\
< \0\033T\0\
< \1\033U\0\
< \2\014\0\
< \3\033SO\0\
< \0\033S2\0\
< \3\001\0\
< \0\033Y%+ %+ \0\
< \0\0"
< 
< /*
<  * The xterm termcap is missing F14 and F15, because they send the same
<  * codes as the undo and help key, although they don't work on all keyboards.
<  */
< #  define XTERM_TCAP "xterm\0\
< \0\033[K\0\
< \0\033[L\0\
< \0\033[%p1%dL\0\
< \0\033[M\0\
< \0\033[%p1%dM\0\
< \0\033[%i%p1%d;%p2%dr\0\
< \0\033[H\033[2J\0\
< \3\033[m\0\
< \0\033[7m\0\
< \3\001\0\
< \0\033[%i%p1%d;%p2%dH\0\
< \0\033M\0\
< \0\033[%p1%dC\0\
< \1\033[?1h\033=\0\
< \0\033[?1l\033>\0\
< \0\0337\033[?47h\0\
< \0\033[2J\033[?47l\0338\0\
< \0\033OA\0\
< \0\033OB\0\
< \0\033OD\0\
< \0\033OC\0\
< \0\033Ox\0\
< \0\033Or\0\
< \0\033Ot\0\
< \0\033Ov\0\
< \0\033[11~\0\
< \0\033[12~\0\
< \0\033[13~\0\
< \0\033[14~\0\
< \0\033[15~\0\
< \0\033[17~\0\
< \0\033[18~\0\
< \0\033[19~\0\
< \0\033[20~\0\
< \0\033[21~\0\
< \0\033[23~\0\
< \0\033[24~\0\
< \0\033[25~\0\
< \2\033[29~\0\
< \0\033[31~\0\
< \0\033[32~\0\
< \0\033[33~\0\
< \0\033[34~\0\
< \0\033[28~\0\
< \0\033[26~\0\
< \0\0"
< 
< #  define DEBUG_TCAP "debug\0\
< \0[EL]\0\
< \0[IL]\0\
< \0[CIL%p1%d]\0\
< \0[DL]\0\
< \0[CDL%p1%d]\0\
< \0[%p1%dCS%p2%d]\0\
< \0[ED]\0\
< \0[CI]\0\
< \0[CV]\0\
< \0[CVV]\0\
< \0[TP]\0\
< \0[TI]\0\
< \0[TB]\0\
< \0[SE]\0\
< \0[SO]\0\
< \0[MS]\0\
< \0[%p1%dCM%p2%d]\0\
< \0[SR]\0\
< \0[CRI%p1%d]\0\
< \0[VB]\0\
< \0[KS]\0\
< \0[KE]\0\
< \0[TI]\0\
< \0[TE]\0\
< \0[KU]\0\
< \0[KD]\0\
< \0[KL]\0\
< \0[KR]\0\
< \0[SKU]\0\
< \0[SKD]\0\
< \0[SKL]\0\
< \0[SKR]\0\
< \0[F1]\0\
< \0[F2]\0\
< \0[F3]\0\
< \0[F4]\0\
< \0[F5]\0\
< \0[F6]\0\
< \0[F7]\0\
< \0[F8]\0\
< \0[F9]\0\
< \0[F10]\0\
< \0[SF1]\0\
< \0[SF2]\0\
< \0[SF3]\0\
< \0[SF4]\0\
< \0[SF5]\0\
< \0[SF6]\0\
< \0[SF7]\0\
< \0[SF8]\0\
< \0[SF9]\0\
< \0[SF10]\0\
< \0[HELP]\0\
< \0[UNDO]\0\
< \0\0"
< 
< #  ifdef ATARI
< #   define DFLT_TCAP ATARI_TCAP
< #  endif /* ATARI */
< 
< #  ifdef AMIGA
< #   define DFLT_TCAP AMIGA_TCAP
< #  endif /* AMIGA */
< 
< #  ifdef NT
< #   define DFLT_TCAP NTCONSOLE_TCAP
< #  else
< #   ifdef MSDOS
< #    define DFLT_TCAP PCTERM_TCAP                       
< #   endif /* MSDOS */                                   
< #  endif /* NT */ 
< 
< #  ifdef UNIX
< #   define DFLT_TCAP ANSI_TCAP
< #  endif /* UNIX */
< 
< # else /* NO_BUILTIN_TCAPS */
< /*
<  * The most minimal terminal: only clear screen and cursor positioning
<  */
< #  define DUMB_TCAP "dumb\0\
< \6\014\0\
< \9\033[%i%p1%d;%p2%dH\0\
< \0\0"
< # endif /* NO_BUILTIN_TCAPS */
< 
< #endif
Index: ./src/undo.c
diff -r ../vim3.0/src/undo.c ./src/undo.c
78c78
<  * Returns FALSE when lines could not be saved.
---
>  * Returns FAIL when lines could not be saved, OK otherwise.
84c84,88
< 	if (top > curbuf->b_ml.ml_line_count || top >= bot || bot > curbuf->b_ml.ml_line_count + 1)
---
> 	if (undo_off)
> 		return OK;
> 
> 	if (top > curbuf->b_ml.ml_line_count ||
> 							top >= bot || bot > curbuf->b_ml.ml_line_count + 1)
100a105,107
> 	if (undo_off)
> 		return OK;
> 
111a119,121
> 	if (undo_off)
> 		return OK;
> 
117c127,128
<  * The lines are deleted, so the new bottom line is lnum.
---
>  * The lines are deleted, so the new bottom line is lnum, unless the buffer
>  * becomes empty.
124c135,139
< 	return (u_savecommon(lnum - 1, lnum + nlines, lnum));
---
> 	if (undo_off)
> 		return OK;
> 
> 	return (u_savecommon(lnum - 1, lnum + nlines,
> 						nlines == curbuf->b_ml.ml_line_count ? 2 : lnum));
157c172
< 			return TRUE;
---
> 			return OK;
205,206c220,221
< 		 * use 0 for ue_bot if bot is below last line or if the buffer is empty, in
< 		 * which case the last line may be replaced (e.g. with 'O' command).
---
> 		 * Use 0 for ue_bot if bot is below last line.
> 		 * Otherwise we have to compute ue_bot later.
208c223
< 	else if (bot > curbuf->b_ml.ml_line_count || bufempty())
---
> 	else if (bot > curbuf->b_ml.ml_line_count)
211c226
< 		uep->ue_lcount = curbuf->b_ml.ml_line_count;	/* we have to compute ue_bot later */
---
> 		uep->ue_lcount = curbuf->b_ml.ml_line_count;
232c247
< 	return TRUE;
---
> 	return OK;
235,237c250,256
< 	if (ask_yesno((char_u *)"no undo possible; continue anyway") == 'y')
< 		return TRUE;
< 	return FALSE;
---
> 	if (ask_yesno((char_u *)"No undo possible; continue anyway", TRUE) == 'y')
> 	{
> 		undo_off = TRUE;			/* will be reset when character typed */
> 		return OK;
> 	}
> 	do_outofmem_msg();
> 	return FAIL;
269c288
< 			beep();
---
> 			beep_flush();
288c307
< 			beep();
---
> 			beep_flush();
318a338
> 	int			empty_buffer = FALSE;		/* buffer became empty */
323a344,345
> 	setpcmark();
> 
355a378
> 				do_outofmem_msg();
371,372c394,401
< 				newarray[i] = u_save_line(lnum);
< 				ml_delete(lnum);
---
> 					/* what can we do when we run out of memory? */
> 				if ((newarray[i] = u_save_line(lnum)) == NULL)
> 					do_outofmem_msg();
> 					/* remember we deleted the last line in the buffer, and a
> 					 * dummy empty line will be inserted */
> 				if (curbuf->b_ml.ml_line_count == 1)
> 					empty_buffer = TRUE;
> 				ml_delete(lnum, FALSE);
381c410,417
< 				ml_append(lnum, uep->ue_array[i], (colnr_t)0, FALSE);
---
> 				/*
> 				 * If the file is empty, there is an empty line 1 that we
> 				 * should get rid of, by replacing it with the new line
> 				 */
> 				if (empty_buffer && lnum == 0)
> 					ml_replace(1, uep->ue_array[i], TRUE);
> 				else
> 					ml_append(lnum, uep->ue_array[i], (colnr_t)0, FALSE);
422a459,465
> 	else if (curwin->w_cursor.lnum <= curbuf->b_ml.ml_line_count)
> 		beginline(MAYBE);
> 	/* We still seem to need the case below because sometimes we get here with
> 	 * the current cursor line being one past the end (eg after adding lines
> 	 * at the end of the file, and then undoing it).  Is it fair enough that
> 	 * this happens? -- webb
> 	 */
582c625,626
< 	curbuf->b_u_line_ptr = u_save_line(lnum);	/* when out of mem alloc() will give a warning */
---
> 	if ((curbuf->b_u_line_ptr = u_save_line(lnum)) == NULL)
> 		do_outofmem_msg();
611c655,659
< 	if (curbuf->b_u_line_ptr == NULL || curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)
---
> 	if (undo_off)
> 		return;
> 
> 	if (curbuf->b_u_line_ptr == NULL ||
> 						curbuf->b_u_line_lnum > curbuf->b_ml.ml_line_count)
613c661
< 		beep();
---
> 		beep_flush();
617c665,667
< 	u_savecommon(curbuf->b_u_line_lnum - 1, curbuf->b_u_line_lnum + 1, (linenr_t)0);
---
> 	if (u_savecommon(curbuf->b_u_line_lnum - 1,
> 								curbuf->b_u_line_lnum + 1, (linenr_t)0) == FAIL)
> 		return;
619a670,671
> 	{
> 		do_outofmem_msg();
620a673
> 	}
711c764
< 	p = (struct m_block *)lalloc(size + sizeof(struct m_block), TRUE);
---
> 	p = (struct m_block *)lalloc(size + sizeof(struct m_block), FALSE);
Index: ./src/unix.c
diff -r ../vim3.0/src/unix.c ./src/unix.c
30a31,42
> /*
>  * On an alpha where "uname -v" gives "358", USE_SYSTEM must be defined.  If it
>  * is not, then the status returned is 256 even when the shell command was
>  * successful!  I don't know what's happening here, but file completion never
>  * worked.  It does work though with USE_SYSTEM defined.  Note that it works
>  * fine either way on an alpha where "uname -v" gives "113".  I don't know
>  * about other alphas.  -- webb
>  */
> #ifdef __alpha
> # define USE_SYSTEM
> #endif
> 
33c45
< # if !defined(SCO) && !defined(SOLARIS) && !defined(hpux) && !defined(__NetBSD__) && !defined(__FreeBSD__) && !defined(_SEQUENT_) && !defined(UNISYS)	/* SCO returns pid_t */
---
> # if !defined(__sgi) && !defined(__COHERENT__) && !defined(SCO) && !defined(SOLARIS) && !defined(hpux) && !defined(__NetBSD__) && !defined(__FreeBSD__) && !defined(_SEQUENT_) && !defined(UNISYS)	/* SCO returns pid_t */
36c48
< # if !defined(linux) && !defined(SOLARIS) && !defined(USL) && !defined(sun) && !(defined(hpux) && defined(__STDC__)) && !defined(__NetBSD__) && !defined(__FreeBSD__) && !defined(USL) && !defined(UNISYS)
---
> # if !defined(__sgi) && !defined(linux) && !defined(SOLARIS) && !defined(USL) && !defined(sun) && !(defined(hpux) && defined(__STDC__)) && !defined(__NetBSD__) && !defined(__FreeBSD__) && !defined(USL) && !defined(UNISYS)
100d111
< #ifdef BUGGY
104d114
< #endif
108a119
> static int is_iris_ansi __ARGS((char_u *));
114a126
> static void deathtrap __ARGS((int));
117a130
> static void deathtrap __ARGS((int, int, struct sigcontext *));
119a133
> static void catch_signals __ARGS((void (*func)()));
264a279,325
>  * This function handles deadly signals.
>  * It tries to preserve any swap file and exit properly.
>  * (partly from Elvis).
>  */
> 	static void
> #if defined(__alpha) || (defined(mips) && !defined(USL))
> deathtrap()
> #else
> # if defined(_SEQUENT_) || defined(SCO) || defined(ISC)
> deathtrap(sig, code)
> 	int		sig;
> 	int		code;
> # else
> #  if defined(USL)
> deathtrap(sig)
> 	int		sig;
> #  else
> deathtrap(sig, code, scp)
> 	int		sig;
> 	int		code;
> 	struct sigcontext *scp;
> #  endif
> # endif
> #endif
> {
> 	static int		entered = FALSE;
> 	BUF		*buf;
> 
> 	if (entered)				/* double signal, exit now */
> 		getout(1);
> 	entered = TRUE;
> 
> 	windgoto((int)Rows - 1, 0);
> 	outstr("Vim: deadly signal caught, preserving files...\n");
> 	flushbuf();
> 
> 	for (buf = firstbuf; buf != NULL; buf = buf->b_next)
> 		if (!buf->b_changed)
> 			ml_close(buf, TRUE);	/* close all not-modified buffers */
> 
> 	ml_sync_all(FALSE, TRUE);		/* preserve all swap files */
> 	ml_close_all(FALSE);			/* close all memfiles, without deleting */
> 
> 	getout(1);
> }
> 
> /*
271a333
> 	flushbuf();				/* needed to make cursor visible on some systems */
272a335
> 	flushbuf();				/* needed to disable mouse on some systems */
276c339
< 	OUTSTR("new shell started\n");
---
> 	msg_outstr((char_u *)"new shell started\n");
289a353,355
> 	/*
> 	 * arrange for signals to be handled
> 	 */
292a359,409
> #ifdef SIGTSTP
> 	signal(SIGTSTP, SIG_DFL);
> #endif
> 	catch_signals(deathtrap);
> }
> 
> 	static void
> catch_signals(func)
> 	void (*func)();
> {
> #ifdef SIGHUP
> 	signal(SIGHUP, func);
> #endif
> #ifdef SIGINT
> 	signal(SIGINT, func);
> #endif
> #ifndef DEBUG
> # ifdef SIGILL
> 	signal(SIGILL, func);
> # endif
> # ifdef SIGFPE
> 	signal(SIGFPE, func);
> # endif
> # ifdef SIGBUS
> 	signal(SIGBUS, func);
> # endif
> # ifdef SIGSEGV
> 	signal(SIGSEGV, func);
> # endif
> # ifdef SIGSYS
> 	signal(SIGSYS, func);
> # endif
> #endif /* !DEBUG */
> #ifdef SIGPIPE
> 	signal(SIGPIPE, func);
> #endif
> #ifdef SIGTERM
> 	signal(SIGTERM, func);
> #endif
> #ifdef SIGXCPU
> 	signal(SIGXCPU, func);
> #endif
> #ifdef SIGXFSZ
> 	signal(SIGXFSZ, func);
> #endif
> #ifdef SIGUSR1
> 	signal(SIGUSR1, func);
> #endif
> #ifdef SIGUSR2
> 	signal(SIGUSR2, func);
> #endif
312,316c429,432
< 	if (!isatty(0) || !isatty(1))
<     {
< 		fprintf(stderr, "VIM: no controlling terminal\n");
< 		exit(2);
<     }
---
> 	if (!isatty(0))
> 		fprintf(stderr, "VIM: Warning: input does not come from a terminal\n");
> 	if (!isatty(1))
> 		fprintf(stderr, "VIM: Warning: output is not to a terminal\n");
407,412d522
< #if BUGGY
< 
< This is not included, because it probably does not work at all.
< On my FreeBSD/Xfree86 in a shelltool I get all kinds of error messages and
< Vim is stopped in an uncontrolled way.
< 
418c528
< 	static void
---
>     static void
420c530
< 	char_u		*title;
---
>     char_u      *title;
422c532,533
< 	XTextProperty text_prop;
---
> #if XtSpecificationRelease >= 4
>     XTextProperty text_prop;
424,429c535,543
< 		/* Get icon name if any */
< 	text_prop.value = title;
< 	text_prop.nitems = STRLEN(title);
< 	XSetWMName(x11_display, x11_window, &text_prop);
< 	if (XGetWMName(x11_display, x11_window, &text_prop)) 	/* required? */
< 		XFree((void *)text_prop.value);
---
>     text_prop.value = title;
>     text_prop.nitems = STRLEN(title);
>     text_prop.encoding = XA_STRING;
>     text_prop.format = 8;
>     XSetWMName(x11_display, x11_window, &text_prop);
> #else
>     XStoreName(x11_display, x11_window, (char *)title);
> #endif
>     XFlush(x11_display);
437c551
< 	static void
---
>     static void
439c553
< 	char_u		*icon;
---
>     char_u      *icon;
441c555,556
< 	XTextProperty text_prop;
---
> #if XtSpecificationRelease >= 4
>     XTextProperty text_prop;
443,449c558,564
< 		/* Get icon name if any */
< 	text_prop.value = icon;
< 	text_prop.nitems = STRLEN(icon);
< 	XSetWMIconName(x11_display, x11_window, &text_prop);
< 	if (XGetWMIconName(x11_display, x11_window, &text_prop)) /* required? */
< 		XFree((void *)text_prop.value);
< }
---
>     text_prop.value = icon;
>     text_prop.nitems = STRLEN(icon);
>     text_prop.encoding = XA_STRING;
>     text_prop.format = 8;
>     XSetWMIconName(x11_display, x11_window, &text_prop);
> #else
>     XSetIconName(x11_display, x11_window, (char *)icon);
450a566,567
>     XFlush(x11_display);
> }
495c612
< 	 * note: if terminal is xterm, title is set with escape sequence rather
---
> 	 * Note: if terminal is xterm, title is set with escape sequence rather
496a614
> 	 * Check only if the start of the terminal name is "xterm", also catch "xterms".
498,499c616
< 	if (	STRCMP(term_strings.t_name, "xterm") == 0 ||
< 			STRCMP(term_strings.t_name, "builtin_xterm") == 0)
---
> 	if (is_xterm(term_strings.t_name))
502,508c619
< 		/*
< 		 * Note: getting the old window title for iris-ansi will only
< 		 * currently work if you set WINDOWID by hand, it is not
< 		 * done automatically like an xterm.
< 		 */
< 	if (STRCMP(term_strings.t_name, "iris-ansi") == 0 ||
< 			 STRCMP(term_strings.t_name, "iris-ansi-net") == 0)
---
> 	if (is_iris_ansi(term_strings.t_name))
521d631
< #ifdef BUGGY
525d634
< #endif
548d656
< #ifdef BUGGY
552d659
< #endif
568a676,694
> 	int
> is_xterm(name)
> 	char_u *name;
> {
> 	if (name == NULL)
> 		return FALSE;
> 	return (STRNCMP(name, "xterm", 5) == 0 ||
> 						STRCMP(name, "builtin_xterm") == 0);
> }
> 
> 	static int
> is_iris_ansi(name)
> 	char_u	*name;
> {
> 	if (name == NULL)
> 		return FALSE;
> 	return (STRNCMP(name, "iris-ansi", 9) == 0);
> }
> 
748c874
< 	ml_close_all(); 				/* remove all memfiles */
---
> 	ml_close_all(TRUE); 				/* remove all memfiles */
814a941,963
> 
> 	if (!raw)
> 		setmouse(FALSE);			/* may switch mouse off */
> 	else if (is_xterm(term_strings.t_name))
> 		setmouse(p_mouse);			/* may switch mouse on */
> }
> 
> /*
>  * set mouse clicks on or off (only works for xterms)
>  */
> 	void
> setmouse(on)
> 	int		on;
> {
> 	static int	ison = FALSE;
> 
> 	if (on && !ison)
> 		outstrn((char_u *)"\033[?9h"); /* xterm: enable mouse events */
> 
> 	if (!on && ison)
> 		outstrn((char_u *)"\033[?9l"); /* xterm: disable mouse events */
> 	
> 	ison = on;
914c1063,1071
< 	/* should try to set the window size to Rows and Columns */
---
> 	char_u	string[10];
> 
> 	/* try to set the window size to Rows and Columns */
> 	if (is_iris_ansi(term_strings.t_name))
> 	{
> 		sprintf((char *)string, "\033[203;%d;%d/y", Rows, Columns);
> 		outstrn(string);
> 		flushbuf();
> 	}
938c1095,1096
< 						extra_shell_arg == NULL ? "" : extra_shell_arg, cmd);
---
> 					extra_shell_arg == NULL ? "" : (char *)extra_shell_arg,
> 					(char *)cmd);
943c1101
< 		outstrn((char_u *)"\nCannot execute shell sh\n");
---
> 		msg_outstr((char_u *)"\nCannot execute shell sh\n");
945d1102
< #ifdef WEBB_COMPLETE
947,949d1103
< #else
< 	else if (x)
< #endif
951,953c1105,1107
< 		outchar('\n');
< 		outnum((long)x);
< 		outstrn((char_u *)" returned\n");
---
> 		msg_outchar('\n');
> 		msg_outnum((long)x);
> 		msg_outstr((char_u *)" returned\n");
961c1115
< #else /* USE_SYSTEM */		/* first attempt at not using system() */
---
> #else /* USE_SYSTEM */		/* don't use system(), use fork()/exec() */
973d1126
< 	signal(SIGINT, SIG_IGN);	/* we don't want to be killed here */
1002c1155
< 			skipspace(&p);
---
> 			skipwhite(&p);
1022c1175
< 		outstrn((char_u *)"\nCannot fork\n");
---
> 		msg_outstr((char_u *)"\nCannot fork\n");
1026d1178
< 		signal(SIGINT, SIG_DFL);
1032c1184,1189
< 		execvp(argv[0], (char **)argv);
---
> 	/*
> 	 * There is no type cast for the argv, because the type may be different
> 	 * on different machines. This may cause a warning message with strict
> 	 * compilers, don't worry about it.
> 	 */
> 		execvp(argv[0], argv);
1036a1194,1197
> 		/*
> 		 * While child is running, ignore terminating signals
> 		 */
> 		catch_signals(SIG_IGN);
1037a1199
> 		catch_signals(deathtrap);
1041d1202
< #ifdef WEBB_COMPLETE
1044,1046c1205,1207
< 				outstrn((char_u *)"\nCannot execute shell ");
< 				outstrn(p_sh);
< 				outchar('\n');
---
> 				msg_outstr((char_u *)"\nCannot execute shell ");
> 				msg_outstr(p_sh);
> 				msg_outchar('\n');
1050,1064c1211,1213
< 				outchar('\n');
< 				outnum((long)status);
< 				outstrn((char_u *)" returned\n");
< 			}
< #else
< 			outchar('\n');
< 			if (status == 127)
< 			{
< 				outstrn((char_u *)"Cannot execute shell ");
< 				outstrn(p_sh);
< 			}
< 			else
< 			{
< 				outnum((long)status);
< 				outstrn((char_u *)" returned");
---
> 				msg_outchar('\n');
> 				msg_outnum((long)status);
> 				msg_outstr((char_u *)" returned\n");
1066,1067d1214
< 			outchar('\n');
< #endif /* WEBB_COMPLETE */
1076d1222
< 	signal(SIGINT, SIG_DFL);
1127a1274
> 		windgoto((int)Rows - 1, 0);
1129c1276
< 		exit(1);
---
> 		getout(1);
1191c1338
< #if !defined(__alpha) && !defined(mips) && !defined(SCO) && !defined(remove) && !defined(CONVEX)
---
> #if !defined(__FreeBSD__) && !defined(__alpha) && !defined(mips) && !defined(SCO) && !defined(remove) && !defined(CONVEX)
1206c1353
<  * Mool: return 0 for success, 1 for error (you may loose some memory) and
---
>  * Mool: return OK for success, FAIL for error (you may loose some memory) and
1304d1450
< #ifdef WEBB_COMPLETE
1307d1452
< #endif /* WEBB_COMPLETE */
1317d1461
< #ifdef WEBB_COMPLETE
1320d1463
< #endif /* WEBB_COMPLETE */
1376c1519
< 			skipspace(&p);					/* skip to next entry */
---
> 			skipwhite(&p);					/* skip to next entry */
1406c1549
< 				skipspace(&p);					/* skip to next entry */
---
> 				skipwhite(&p);					/* skip to next entry */
Index: ./src/unix.h
diff -r ../vim3.0/src/unix.h ./src/unix.h
36a37,42
> #ifdef VIMINFO
> #ifndef VIMINFO_FILE
> # define VIMINFO_FILE	"$HOME/.viminfo"
> #endif
> #endif /* VIMINFO */
> 
84a91
> #  ifndef __COHERENT__
86a94
> #  endif /* __COHERENT__ */
88c96
< #  define memmove(to, from, len) bcopy(from, to, len)
---
> #  define memmove(to, from, len) bcopy((char *)(from), (char *)(to), len)
127a136,142
> 
> /* codes for xterm mouse event */
> #define MOUSE_MASK		0x03
> #define MOUSE_LEFT		0x00
> #define MOUSE_MIDDLE	0x01
> #define MOUSE_RIGHT		0x02
> #define MOUSE_UP		0x03
Index: ./src/version.c
diff -r ../vim3.0/src/version.c ./src/version.c
1c1
< /* vi:ts=4:sw=4:tw=78
---
> /* vi:ts=4:sw=4:tw=78:
9a10
> 
37,38c38,39
<  VIM 1.11 - removed bug that caused :e of same file, but with name in upper case,
< 			to re-edit that file.
---
>  VIM 1.11 - removed bug that caused :e of same file, but with name in upper
> 			case, to re-edit that file.
247c248
<  Vim 1.29 to 1.31 and Vim 2.0	See ../readme2.0.
---
>  Vim 1.29 to 1.31 and Vim 2.0	See ../CHANGES2.0.
249c250,251
<  Vim 2.0	When reading and writing files and in some other cases use short
---
>  Vim 2.0 (released 1993 December 14)
>  			When reading and writing files and in some other cases use short
271c273,1034
<  Vim 2.1 to 3.0: see readme3.0
---
>  Vim 2.1 to 3.0: see ../CHANGES3.0 (released 1994 August 12)
> 
>  Vim 3.1 (finished 1995 January 16)
> 
> Fixed :s/\(.*\)/\1/ , was replacing CR with line break.
> 
> Doing CTRL-@ when there is no inserted text yet quits insert mode.
> 
> "r" sets the last inserted text.
> 
> Added mkproto to makefile.unix. You need a special version of mkproto.
> 
> If file system full and write to swap file failed, was getting error message
> for lnum > line_count (with ":preserve").
> 
> Changed method to save characters for BS in replace mode. Now works correctly
> also when 'et' set and entering a TAB and replacing with CR several times.
> 
> Removed reverse replace mode. It is too complicated to do right and nobody
> will probably use it anyway. Reverse insert is still possible.
> 
> Made keyword completion work in replace mode.
> 
> When writing part of the buffer to the current file ! is required.
> 
> When CTRL-T fails (e.g. when buffer was changed) don't change position
> in tag stack.
> 
> The 'Q' operator no longer affects empty lines. (Webb)
> 
> Added CTRL-W CTRL-T (got to top window) and CTRL-W CTRL-B (go to bottom
> window)
> 
> Fixed cursor not visible when doing CTRL-Z for unix (White).
> 
> When in insert mode and wrapping from column one to the last character, don't
> stick at the end but in the column (Demirel).
> 
> The command "aY did not put anything in register a if 'ye' was set. (Demirel)
> 
> Inserting a tab with 'et' set did not work correctly when there was a real tab
> in front of it (Brown).
> 
> Added support for static tags "file:tag ..." (Weigert).
> 
> Added 'startofline' option (Waggoner/Webb).
> 
> Restore 'wrapmargin' when 'paste' is reset (Colon).
> 
> Recognize a terminal name as xterm when it starts with "xterm". Also catch
> "xterms" (Riehm).
> 
> Added special keys page-up, page-down, end and home (Cornelius).
> 
> Fixed '^' appearing in first window when CTRL-V entered in second window.
> 
> Added ":stag", same as ":tag", but also split window.
> 
> Fixed core dump when using CTRL-W ] twice (tag stack was invalid) (Webb).
> 
> Added patches for Coherent from Fred Smith (fredex@fcshome.stoneham.ma.us).
> 
> Give error message when doing "Vim -r" without a file name (used to crash).
> 
> Changed error message when doing ":n" while editing last file in file list.
> 
> The commands ":print", ":number" and ":list" did not leave the cursor on the
> last line.
> 
> Added completion of old setting in command line editing (Webb).
> 
> Fixed using count to reselect visual area when area was one line (Webb).
> 
> Fixed setting curswant properly after visual selection (Webb).
> 
> Fixed problem that column number was ridiculous when using V with : (Webb).
> 
> Added column number to ":marks" command (Demirel).
> 
> Removed 'yankendofline' option, you can just use ":map Y y$" (Demirel).
> 
> Added highlighting for ":number" command (Webb).
> 
> When ex command is given that is not implemented in Vim give better error
> message (Webb).
> 
> After truncating an autoindent leave curswant after the indent (Webb).
> 
> Put cursor on first non-white after a few ex commands and after "2>>" (Webb).
> 
> When deleting/inserting lines also adjust the marks in the tag stack (Webb).
> 
> Added ":retab" command (Webb).
> 
> Made file message a bit shorter and added 'shortmess' option (Webb).
> 
> Fixed ":n #", put the cursor on the right line like ":e #" (Webb).
> 
> Recompute column for shown command when rearranging windows (Webb).
> 
> Added "[P" and "]P" as synonym for "[p". These commands are now redoable.
> Fixed cursor positioning and characterwise text (Webb).
> 
> When a command line is already in the history, the old entry is removed. When
> searching through the command history, the entry where started from is
> remembered. (Webb).
> 
> Renamed showmatch() to findmatch() (it didn't show anything).
> 
> Fixed paging for showing matches on command line. This can also be interrupted
> (Webb).
> 
> Fixed commandline completion when in the range. Fixed ":tag *s^D". Added
> support for completion of static tags (from elvis's ctags program). (Webb).
> 
> Check screen size after Vim has been suspended (Webb).
> 
> Fixed bug where } would only be smart-indented to line up with the line
> containing the { when there was some spacing before the }. (Webb).
> 
> For setting numeric options hex and octal can be used (Webb).
> 
> Added ":ls", synonym for ":files" (Webb).
> 
> Added "[g", "[d", ":checkpath" and friends, find identifier or macro in
> included files (Webb).
> 
> Added tags to documentation. Made "doctags" program to produce the tags file.
> 
> Added completion commands for insert mode and CTRL-X sub-mode (Webb).
> 
> In a search pattern '*' is not magic when used as the first character. Fixed
> '^' recognized as start of line in "/[ ^I]^". (Webb)
> 
> When jumping to file under cursor, give proper error message instead of beep.
> After using 'path' option, also look relative to the current file. (Webb).
> 
> "%" now works to match comments of the form "/ * Comment / * * /". (Webb)
> 
> Show meta keys in mappings as M-x. Use highlight option '8' for higlighting
> the meta keys. Special keys are displayed with their name, e.g. <C_UP>. When
> using CTRL-V special-key in a mapping, this is replaced by the internal key
> code. Can use "#C_UP" for cursor-up key in mapping. (Webb).
> 
> Added the VIMINFO stuff (Webb).
> 
> Added 'infercase' option (Webb).
> 
> After undo, put cursor on first non-blank instead of in column 0 (Webb).
> 
> Accept CTRL-E and CTRL-Y when waiting for confirmation to replace (Webb).
> 
> Allow tags to start with a number (Webb).
> 
> Added options "flash" and "novice", they are not used (Demirel).
> 
> When searching for a tag, after files 'tags' option failed, also try the tags
> file in the same directory as the current file.
> 
> Added the automatic commands: execute commands after starting to edit a file 
> (Webb).
> 
> When moving the cursor to the end of the line in insert mode with CTRL-O $,
> put it one beyond the line.
> 
> Added automatic formatting of comments, the 'comments', 'nestedcomments' and
> 'formatoptions' options (Webb).
> 
> When creating a new buffer, set 'readonly' to false by default. Fixes getting
> an emtpy readonly buffer after ":new" in a readonly buffer.
> 
> Give error message that includes the commandline for ":" commands that are not
> typed by the user.
> 
> Fixed cursor positioned at '@' of not fitting line after doing the auto
> commands.
> 
> Removed extra redraw when doing CTRL-] caused by executing autocommands.
> 
> Added "[n" (show next occurence of pattern under the cursor), "[N" (show all
> occurences of pattern under the cursor after current line), and "]n" (jump to
> next occurence of pattern under the cursor)
> 
> Changed "--more--" prompt to be more informative.
> 
> Added check on close() for writing the .bak file.
> 
> Adjusted formatting of comments for use of replace stack.
> 
> Changed 'comments and 'nestedcomments' to be comma separated, so they can
> include trailing spaces. Removed 's' from  'formatoptions. Allows for "/""*"
> to be recognized but not "*".
> 
> Init terminal to CBREAK instead of RAW in unix.c. (Weigert)
> 
>  Vim 3.2 (finished 1995 January 24)
> 
> After 'Q' put cursor at first non-blank of the last formatted line.
> 
> Use standard cproto instead of a home brew version of mkproto.
> 
> Updated automatic formatting of comments to add a space where neccesary; fixed
> problem with indent after comment leader.
> 
> Changed CBREAK back into RAW, CTRL-C exited the program.
> 
> Made 'formatoptions', 'comments' and 'nestedcomments' options local to buffer.
> 
>  Vim 3.3 (finished 1995 February 10)
> 
> Don't map the key for the y/n question for the :s///c command.
> 
> Fixed problem when auto-formatting with space after the cursor.
> 
> Fixed problem with CTRL-O . in insert mode when repeated command also involves
> insert mode.
> 
> Fixed "line count wrong" error with undo that deletes the first line.
> 
> After undo "''" puts the cursor back to where it was before the undo.
> 
> Allow "map a ab", head recursive mapping (just like vi).
> 
> Don't truncate line when doing ESC after CR when entering a comment.
> 
> Improved ":center", ":right" and ":left"; blank lines are no longer affected,
> tabs are taken into account.
> 
> Fixed premsg() to show command when first key of an operator was not typed
> (e.g. from a wait-for-return), and have to wait for the second key to be
> typed.
> 
> Fixed outputting meta characters when switching highlighting on/off.
> 
> Added '-' register for deletes of less than one line.
> 
> Added argument file-number to getfile() and doecmd() to be able to edit a
> specific buffer. Fixes problem with CTRL-^ to buffer without a file name.
> 
> When :bdel and :bunload are used to remove buffers that have active windows,
> those windows are closed instead of giving an error message. Don't give an
> error message when some, but not all, of the buffers do not exist.
> 
> Fixed an occasional core dump when using ^P or ^N in insert mode under certain
> conditions (Webb).
> 
> Fixed bug where inserting a new-line before a line starting with 'if' etc.
> would cause a smart-indent because of that 'if'.  This also fixes a small
> problem with comment formatting: consider the line "/""* text", and replace
> the space with a new-line.  It should insert the comment leader " *", but it
> did not before. (Webb)
> 
> Fixed bug where nowrap is set and doing 'j' or 'k' caused a sideways scroll
> with the cursor still in the middle of the screen.  Happened when moving from
> a line with few tabs to a line with many tabs. (Webb)
> 
> Accept an end-of-line in the same way a blank is accepted for the 'comments'
> option.
> 
> With ":file name" command, update status lines for new file name.
> 
> When file name changed, also change name of swapfile.
> 
> Fixed not checking for function arguments for gcc. Fixed three mistakes.
> 
> The Amiga trick for MSDOS compatible filesystems is now also done for UNIX.
> Fixes problems with wrong swap file name on MSDOS partition for FreeBSD and
> Linux.
> 
> Fixed bug: In message.c removed adding of K_OFF to K_MAXKEY.
> 
> Default options for backup file is now 'backup' off and 'writebackup' on.
> 
> Removed flush_buffers() from beep(), made beep_flush() that includes it.
> 
> An ESC in normal mode does not flush the map buffer, only beeps. Makes
> 	":map g axx^[^[ayy^[" work.
> 
> When a ".swp" file already exists, but the file name in it is different, don't
> give the "swap file exists" error message. Helpful when putting all swap files
> in one directory.
> 
> In an Ex address the '+' character is not required before a number, ".2d" is
> the same as ".+2d", "1copy 2 3 4" is the same as "1copy 2+3+4".
> 
> "O" in an empty buffer now inserts a new line as it should. ":0r file" in an
> empty file appends an empty line after the file, just like vi.
> 
> Fixed "more" for :global command.
> 
> Don't accept ":g", global command without any argument.
> 
> Separated history for command line and search strings.
> 
> Only typed command lines and search strings are put in the history.
> 
>  Vim 3.4 (finished 1995 March 9)
> 
> Improved the handling of empty lines for "[p" and the like.
> 
> After using ":set invlist" cursor would not stick to the column.
> 
> Removed #ifdef VIMINFO from around init_history(). Would not compile if
> VIMINFO is not defined.
> 
> Fixed problem of trailing 'q' with executing recorded buffer when 'sc' set.
> 
> Changed the displaying of message for many commands. Makes ":1p|2p" work.
> Avoids having to type some extra returns.
> 
> Added error message for using '!' in the command line where it is not allowed.
> 
> When recovering "Original file may have been changed" message was overwritten.
> Also changed it into an error message and don't wait for return after "using
> swap file" message.
> 
> Added wait_return() when filtering finds an error when executing the shell
> command.
> 
> Remove white space after comment leader when hitting ESC.
> 
> Added 'a' reply to substitute with confirmation, is like 'y' for all remaining
> replacements.
> 
> For xterm: Added cursor positioning by mouse control, added 'mouse' option,
> added visual selection with mouse, added window selection with mouse.
> 
> Fixed missing index to viminfo_hisidx in cmdline.c.
> 
> Recognize <C_UP> anywhere in the lhs of a mapping instead of #C_UP at the
> beginning (Webb).
> 
> Included some initializations for GCC (Webb).
> 
> Fixed CTRL-Z not working for Appolos (Webb).
> 
> Fixed ignoring CTRL-M at end of the line in viminfo file (Webb).
> 
> Fixed CTRP-P/CTRL-N on a non-comment line causing an extra newline to be
> inserted in when formatting is off (Webb).
> 
> Fixed moving marks with the ":move" command (Webb).
> 
> Fixed CTRL-P not working after CTRL-N hit end of the file (Webb).
> 
> Fixed BS in replace mode when deleting a NL where spaces have been deleted.
> 
> Removed 'delspaces' argument for Opencmd(), it was always TRUE.
> 
> Fixed overwriting "at top of tag stack" error message. Only show file message
> for a tag when it is in another file.
> 
> Fixed not sleeping after an error message that is removed by a redraw.
> 
> Implemented incremental search and 'incsearch' option (Kesteloo).
> 
> Added 'backupext' option, default is ".~" instead of ".bak". Avoids accidently
> overwriting ".bak" files that the user made by hand.
> 
> Fixed ":s///c", vgetc() was called twice and screen scrolled up.
> 
> Fixed problems with undo and empty buffer.
> 
> Fixed cursor not ending on right character when doing CTRL-T or CTRL-D in the
> indent in insert mode (Webb).
> 
> Removed #ifdefs for WEBB_COMPLETE and WEBB_KEYWORD_COMPL.
> 
> When ":set columns=0" was done, core dump or hang might happen. Fixed this by
> adding check_winsize() in doset().
> 
>  Vim 3.5 (finished 1995 April 2)
> 
> Added HOME and END keys to insert mode. HOME goes to column one, END goes to
> end of line. They now also behave this way in normal mode.
> 
> Changed implementation of builtin termcaps. Now it's more easy to make changes.
> 
> Special keys are now handled with two characters, or a value above 0x100. All
> 256 keyboard codes can be used without restriction.
> 
> Made incremental search in visual mode display the visual area instead of the
> matched string.
> 
> Fixed mouse not being used when using builtin_xterm.
> 
> Fixed message from :cn being deleted by screen redraw.
> 
> Fixed window resizing causing trouble while waiting for "-- more --" message.
> 
> ":center" and ":right" ignore trailing blanks.           
> 
> Increased default for 'undolevels' for unix to 1000.
> 
> Fixed using CTRL-N and CTRL-P in replace mode.
> 
> Added mouse positioning on the command line.
> 
> Don't wait for a return after abandoning the command line.
> 
> Added a few extra checks to GCC in makefile.unix. Changed a few parameter
> names to avoid unneccesary warning messages.
> 
> When splitting a window, the new window inherits the alternate file name.
> 
> With ":split [file]" and ":new [file]", the alternate file name in the current
> window is set to [file].
> 
> Added CTRL-W CTRL-^ command: split and edit alternate file.
> 
> In replace mode NL does not replace a character but is inserted.
> 
> For ":s///c" the complete match is highlighted (like with incsearch).
> 
> Updated messages displayed when ".swp" file is found and at end of recovery.
> 
> Fixed not updating the visual area correctly when using the mouse.
> 
> Added 'smartmatch' option, to be able to switch back to vi-compatible matching.
> Fixed matching braces inside quotes.
> 
> Autocommands now executed for each file, also when using "vim -o *.c".
> 
> Fixed docmdline() resetting RedrawingDisabled and other things when used
> recursively.
> 
> For Unix: If input or output is not from/to a terminal, just give a warning
> message, don't quit.
> 
> Replaced noremap list by noremapstr, much simpler.
> 
> Made ":map x<F1> foo" work.
> 
> Fixed "illegal line number" error when doing ":e!" after adding some lines at
> the end of the file.
> 
> Fixed problem with viminfo file when newlines embedded in strings.
> 
> Changed default for 'keywordprg' to "man", much more useful for most of us.
> 
> Fixed core dump when using commands like ":swap" in .vimrc file.
> 
> Fixed ":map #1 :help" not working.
> 
> Fixed abbreviations not working properly.
> 
> Added insert and delete keys in termcap. Delete key in normal mode now behaves
> like 'x'. Insert key in normal mode starts insert mode, in insert/replace mode
> toggles between insert and replace mode, in command line editing toggles
> insert/overstrike.
> 
> Made DEL in insert mode delete the character under the cursor. Join lines if
> cursor after end of line and 'bs' set.
> 
> Added ":open" command to cmdtab.tab (not supported), to make ":o" not to be
> recognized as ":only".
> 
> Fixed calling free() in buf_write() when smallbuf[] is used.
> 
> When writing the file fails and there is a backup file, try to put the backup
> in place of the new file. Avoids loosing the original file when trying to
> write again and overwriting the backup file.
> 
> Fixed problems with undo and redo in empty buffer.
> 
> Removed double redraw when returning from ":stop" command. (Webb)
> 
> Added 'indentchars' option: Characters that are included in indentifiers.
> (Webb)
> 
> Smart indent when entering '{' is not rounded to 'shiftwidth'. (Webb)
> 
> Included setting of window size for iris_ansi window. (Webb).
> 
> Included better checks for minimal window size and give error message when it
> is too small. (Webb).
> 
> Fixed mouse events being switched on again when exiting.
> 
> When opening a memfile, always write block 0 to disk, so findswapname() can
> compare the file name in it. Avoids extra "swap file exists" messages.
> 
> 
>  Vim 3.6 (finished 1995 April 28)
> 
> Made mouse click cursor movement inclusive.
> 
> Included catching of deadly signals in unix.c.
> 
> After recovering there was one extra empty line at the end.
> 
> Added ":recover [file]" command.
> 
> Fixed calling wait_return twice after message "ATTENTION: Found swap file .."
> 
> Fixed ":retab", it quitted if the first line had no changes. Save only the
> lines that are changed for undo, not the whole file.
> 
> Fixed initialization problem in getcmdline() (Demirel).
> 
> If VIMINIT is set, but it is empty, ignore it (Demirel).
> 
> Fixed core dump when reporting number of buffers deleted.
> Fixed core dump when deleting the current buffer.
> 
> Fixed ordering of codes in keymap.h (Webb).
> 
> Fixed mouse not turned off when doing CTRL-Z.
> 
> Changed 'identchar' to 'indentchars'.
> 
> If 'identchars' not set, use '_' instead of '"' as default.
> 
> Fixed autocommands not executed if file didn't exist.
> 
> Don't sleep after "ATTENTION" message.
> 
> Use enum for KS_ defines in keymap.h (Webb).
> 
> Fixed CTRL-C during shell command or ":make" to cause Vim to preserve the file
> and quit.
> 
> When mouse click is on the status line, only make that window the current
> window, don't move the cursor.
> 
> Fixed mouse positioning when 'number' is set.
> 
> Fixed cursor being moved when "]g" fails because buffer was changed.
> 
> Fixed cursor in wrong position after ":set invwrap" and cursor was below a
> long line.
> 
> Fixed ":split file" causing a "hit return" message.
> 
> Fixed term codes of one character causing a hang (e.g. DEL).
> 
> Fixed mappings not working after using a non-remappable mapping.
> 
> Fixed core dump when screen is made bigger while in --more-- mode.
> 
> Fixed "@:" executing last Ex command without prepending ":".
> 
> When setting the cursor with the mouse, set curswant, so it sticks to that
> column.
> 
> When going to another window in visual mode: When it is the same buffer,
> update visual area, when jumping to another buffer reset visual mode.
> 
> Made visual reselect work after "J" command.
> 
> Left mouse click does not exit visual mode, just moves the cursor. 'v', 'V'
> and CTRL-V set the visual mode, but don't exit visual mode. Use ESC instead.
> 
> Fixed problem that 'showcmd' would cause mappings to happen in the wrong mode.
> e.g. ":map g 1G^M:sleep 3^M:g" would show ":1G".
> 
> Added "*""/" to 'comments' option again, useful when doing "O" on it.
> 
> Removed setkeymap() stuff, it has never worked and probably never will.
> 
> Fixed hang on exit when 'viminfo' set and cmdline history is empty.
> 
> Removed -traditional from gcc, caused arguments to system functions not to be
> checked. Also removed "-Dconst=", because it caused warning for builtin
> functions.
> 
> Fixed problem with MS-DOS compatible file system under Unix: Did not recognize
> existing swap file. Now a proper check is done if the swap file is on an
> MS-DOS compatible filesystem and 'shortname' is set if required. This also
> causes the backup file name to be correct.
> 
> Added empty-buffer flag again. When an emtpy buffer is edited and written out,
> that file is also empty.
> 
> Added "No lines in buffer" message when last line in buffer is deleted.
> 
> Fixed problem when mapping ends in a character that start a key code, would
> wait for other characters for each character.
> 
> Added checks for creating too long lines on non-UNIX systems.
> 
> Added mouse positioning for MSDOS.
> 
> Changed commands for searching identifiers and defines in included files. It
> is more logical now. Lower case for search first match, upper case for list
> matches and Control for jump to first match. 'i' for identifier and 'd' for
> define.
> 
> Added ":isearch", ":ilist", ":ijump", ":isplit", ":dsearch, etc. Allows for an
> identifier to be found that is not in the text yet.
> 
> When file system is full, the error message for writing to the swap file was
> repeated over and over, making it difficult to continue editing. Now it is
> only given once for every key hit.
> 
> Added "gd", Go Declaration, search for identifier under cursor from the start
> of the current function. "gD" searches from start of the file. Included files
> are not used.
> 
> The number of lines reported when starting to edit a file was one too much.
> 
> Fixed problem that in some situations the screen would be scrolled up at every
> message.
> 
> Removed the screenclear() calls for MSDOS in fileio.c, some messages got lost
> by it. Just usr CTRL-L to redraw the screen in the rare case that you get the
> "insert disk b: in drive a:" message.
> 
> Fixed "--more--" message not always working for normal-mode commands like "[i".
> 
> Made "[i", "[ CTRL-I" and "CTRL-W g" and the like ignore comment lines.
> 
> When 'q' is typed at "--more--" message, don't display an extra line, don't
> wait for return to be hit.
> 
> Apply auto commands before reading the file, making modelines overrule auto
> commands.
> 
> Allow trailing bar for ":autocmd", so it can be used in EXINIT.
> 
> For ":s" don't accept digit as separator.
> 
> When doing ":/pat/p" on the last line without 'wrapscan' set, used to start in
> line 1 anyway. Now an error message is given and the command aborted.
> 
> When an error was detected in an Ex address (e.g. pattern not found) the
> command was executed anyway, now it is aborted.
> 
> When doing ":/pat/p" with 'wrapscan' set, the "continuing at top" message was
> displayed twice. Now it is overwritten.
> 
> Added "\?", "\/" and "\&" to ex address parsing, use previous search or
> substitute pattern.
> 
> When there is not previous search pattern, would get two error messages. The
> last one, "invalid search string" is now omitted.
> 
> When reading viminfo file for marks, accept file name with embedded spaces.
> 
> Set alternate file name for ":file fname" command.
> 
> When last file in argument list has been accessed, quit without asking.
> 
> When preserving file on a deadly signal, delete the swapfiles for buffers that
> have no modifications.
> 
> A single error message from .vimrc would be overwritten by file message.
> 
> When an error message is given while sourcing or starting up, the source of
> the error is mentioned.
> 
> Put character attributes in a separate byte in NextScreen, makes updating of
> highlighted parts more reliable.
> 
> Don't display "search hit bot" message twice for ":/pat/p" and overwrite it
> with any error message.
> 
> Fixed extra wait_return after error message on starting up.
> 
> Move '-' in 'identchars' to the end when using CTRL-N/P in insert mode. Avoids
> most common "Invalid range" errors. Other chars still need a backslash.
> 
>  Vim 3.7 (not finished yet)
> 
> Adjusted formatting of comments to keep spaces after comment leader.
> 
> A space in the 'comments' option stands for any non-empty amount of white
> space.
> 
> Changed T_LAST_KEY to t_mouse in term.c (Webb).
> 
> Also use 'id' option when searching for one-character id's, like with "w^N".
> 
> Fixed cursor in the wrong place after using DEL in insert mode at the end of
> the line when the next line is empty.
> 
> When using "D" in an empty line, give beep.
> 
> Remove trailing spaces for Ex commands that accept a "+command" argument, when
> it is not followed by another command. E.g. when using ":e file ".
> 
> Fixed problem that after using visual block mode any yank, delete and tilde
> command would still use the visual coordinates. Added "block_mode" variable.
> 
> Fixed CTRL-V's not being removed from argument to :map.
> 
> Fixed not always redrawing correctly with ":unhide" command.
> 
> Made "|" exclusive, this is Vi compatible.
> 
> Set alternate file name when using buffer commands like ":bmod", ":buf",
> ":bdel", etc.
> 
> Added "interrupted" message when ":retab" is interrupted (Webb).
> 
> Doing "%" on an empty line now beeps (Webb).
> 
> Made number of included files to be remembered unlimited instead of just 50
> (Webb).
> 
> For unix: Give error message when more than one file name given to Ex commands
> that accept only one.
> 
> Fixed: When "+command" argument given to Ex command, wildcards in file name
> after it were not correctly expanded.
> 
> Added two types to 'higlight' option: 'm' for -- more -- and 't' for titles
> (Webb).
> 
> Added 'd' to -- more -- responses: down half a page (Webb).
> 
> Changes to quickfix (Webb): :cl lists only recognized errors, use :cl! to list
> all. :cn and :cp don't go to an unrecognized error but give an error message
> when at the first/last error. When a column number is not found, put the
> cursor at the first non-blank. When deciding to redisplay the message or not,
> take TABS into account. When :cp or :cn fails for some reason, don't change
> the error index. use linetabsize() instead of strsize() to decide when to
> redisplay a message. Changed the format of the :cl listing. Don't show the
> column number if it is 0. Use msg_prt_line to print the error text, this takes
> care of TABS. Error number or count can also be before :cc, :cp and :cn.
> 
> Added file name argument to ":doautocmd" (Webb).
> 
> Added check for length of "[i", could run into ruler (Webb).
> 
> Sometimes a long message was redisplayed, causing -- more -- twice (Webb).
> 
> Improved smartindent: When entering '}' and the matching '{' is preceded with
> a '(', set indent to line containing the matching ')' (Webb).
> 
> Changed a few outstr() into msg_outstr(), makes screen output correct for some
> cases, e.g. when using "!!cp file" the message for reading the temporary file
> was messed up.
> 
> When filtering, use the 'shellredir' option to redirect the output. When
> possible 'shellredir' is initialized to include stderr.
> 
> Environment variables in options are now replaced at any position, not just at
> the start (Webb).
> 
> Incremental search no longer affects curswant and last used search pattern
> (Webb).
> 
> Implemented "Vim -r" to list swap files.
> 
> When out of memory because undo is impossible, and 'y' is typed in answer to
> the 'continue anyway' question, don't flush buffers (makes Maze macros work on
> MS-DOS).
> 
> When asked a yes/no question, ESC is the same as 'n'.
> 
> Removed a few large arrays from the stack, MSDOS was running out of stack
> space.
> 
> Fixed problem not being able to exit although all files from argument list
> were accessed, when using "vim -o file ..." or ":all".
> 
> Sometimes mappings would not be recognized, because the wrong flags in
> noremapstr[] were checked.
> 
> Fixed having to type return twice when starting to edit another file and the
> message is too long.
275c1038
< char		   *Version = "VIM 3.0";
---
> char		   *Version = "VIM 3.7";
277c1040
< char		   *longVersion = "Vi IMproved 3.0 by Bram Moolenaar (1994 Aug 12)";
---
> char		   *longVersion = "Vi IMproved 3.7 by Bram Moolenaar (1995 June 1)";
279c1042
< char		   *longVersion = "Vi IMproved 3.0 by Bram Moolenaar (1994 Aug 12, compiled " __DATE__ " " __TIME__ ")";
---
> char		   *longVersion = "Vi IMproved 3.7 by Bram Moolenaar (1995 June 1, compiled " __DATE__ " " __TIME__ ")";
Index: ./src/vim.h
diff -r ../vim3.0/src/vim.h ./src/vim.h
111a112,115
> #ifdef __sgi
> # define __ARGS(x)	x
> # define __PARMS(x) x
> #endif
119a124
> # include <time.h>
132c137
< #  if defined(SOLARIS) || defined(AIX) || defined(ARCHIE)
---
> #  if defined(SOLARIS) || defined(AIX) || defined(ARCHIE) || defined(__COHERENT__)
146a152,155
> /*
>  * Note: if MAXNAMLEN has the wrong value, you will get error messages
>  * 	     for not being able to open the swap file.
>  */
172a182,190
> #ifdef __COHERENT__
> #undef __ARGS
> #endif /* __COHERENT__ */
> 
> #ifdef __ARGS
> # ifndef __PARMS
> #  define __PARMS(x) x
> # endif
> #endif
223a242
> #define ASKMORE					0x90	/* Asking if you want --more-- */
228,229c247,249
< #define FORWARD 				 1
< #define BACKWARD				 -1
---
> #define FORWARD 				1
> #define BACKWARD				-1
> #define BOTH_DIRECTIONS			2
240,242d259
< #define VISUALLINE			MAXCOL	/* Visual is linewise */
< 
< #ifdef WEBB_COMPLETE
255c272,284
< #endif /* WEBB_COMPLETE */
---
> #define EXPAND_OLD_SETTING		7
> 
> /* Values for the find_pattern_in_path() function args 'type' and 'action': */
> #define FIND_ANY		1
> #define FIND_DEFINE		2
> #define CHECK_PATH		3
> 
> #define ACTION_SHOW		1
> #define ACTION_GOTO		2
> #define ACTION_SPLIT	3
> #define ACTION_SHOW_ALL	4
> #define ACTION_EXPAND	5
> 
262a292,308
> #define MAYBE	(2)			/* for beginline() and the 'sol' option */
> 
> /* May be returned by add_new_completion(): */
> #define RET_ERROR				-1
> 
> /* Returned by vim_fgets(): */
> #define VIM_EOF					1
> 
> /* Formatting options for the p_fo variable: */
> #define FO_WRAP			't'
> #define FO_WRAP_COMS	'c'
> #define FO_RET_COMS		'r'
> #define FO_OPEN_COMS	'o'
> #define FO_Q_COMS		'q'
> #define FO_COMS_PADDED	's'
> 
> #define FO_DFLT			"tcqs"
272,273c318,319
< #define MIN_COLUMNS		5
< #define MIN_ROWS		1
---
> #define MIN_COLUMNS		12		/* minimal columns for screen */
> #define MIN_ROWS		1		/* minimal rows for one window */
287a334
> #define MSG_BUF_LEN	80			/* lenght of buffer for small messages */
Index: ./src/window.c
diff -r ../vim3.0/src/window.c ./src/window.c
13a14
> static void reset_Visual __ARGS((void));
32a34,36
> 	int		len;
> 	int		type = -1;
> 	BUF		*old_curbuf = curbuf;
44c48
< 	case 's':	VIsual.lnum = 0;		/* stop Visual mode */
---
> 	case 's':	reset_Visual();					/* stop Visual mode */
47a52,60
> /* split current window and edit alternate file */
> 	case K_CCIRCM:
> 				reset_Visual();					/* stop Visual mode */
> 				stuffReadbuff(":split #");
> 				if (Prenum)
> 					stuffnumReadbuff(Prenum);	/* buffer number */
> 				stuffcharReadbuff('\n');
> 				break;
> 
50c63
< 	case 'n':	VIsual.lnum = 0;					/* stop Visual mode */
---
> 	case 'n':	reset_Visual();					/* stop Visual mode */
59c72
< 	case 'q':	VIsual.lnum = 0;		/* stop Visual mode */
---
> 	case 'q':	reset_Visual();					/* stop Visual mode */
65c78
< 	case 'c':	VIsual.lnum = 0;		/* stop Visual mode */
---
> 	case 'c':	reset_Visual();					/* stop Visual mode */
71c84
< 	case 'o':	VIsual.lnum = 0;		/* stop Visual mode */
---
> 	case 'o':	reset_Visual();					/* stop Visual mode */
79d91
< 				VIsual.lnum = 0;		/* stop Visual mode */
82a95
> new_win:
84a98,107
> 					/* When jumping to another buffer, stop visual mode */
> 				if (curbuf != old_curbuf && VIsual.lnum != 0)
> 				{
> 					VIsual.lnum = 0;
> 					for (wp = firstwin; wp; wp = wp->w_next)
> 						if (wp->w_buffer == old_curbuf &&
> 											wp->w_redr_type < NOT_VALID)
> 							wp->w_redr_type = NOT_VALID;
> 					updateScreen(NOT_VALID);
> 				}
90d112
< 				VIsual.lnum = 0;		/* stop Visual mode */
92c114
< 					beep();
---
> 					beep_flush();
111,112c133
< 					win_enter(wp, TRUE);
< 					cursupdate();
---
> 					goto new_win;
120d140
< 				VIsual.lnum = 0;		/* stop Visual mode */
124,126c144,156
< 				win_enter(wp, TRUE);
< 				cursupdate();
< 				break;
---
> 				goto new_win;
> 
> /* cursor to top window */
> 	case 't':
> 	case Ctrl('T'):
> 				wp = firstwin;
> 				goto new_win;
> 
> /* cursor to bottom window */
> 	case 'b':
> 	case Ctrl('B'):
> 				wp = lastwin;
> 				goto new_win;
131d160
< 				VIsual.lnum = 0;		/* stop Visual mode */
133c162
< 					beep();
---
> 					beep_flush();
136,137c165,166
< 					win_enter(prevwin, TRUE);
< 					cursupdate();
---
> 					wp = prevwin;
> 					goto new_win;
149c178
< 	case 'r':	VIsual.lnum = 0;					/* stop Visual mode */
---
> 	case 'r':	reset_Visual();					/* stop Visual mode */
154c183
< 	case 'R':	VIsual.lnum = 0;					/* stop Visual mode */
---
> 	case 'R':	reset_Visual();					/* stop Visual mode */
178c207
< 				VIsual.lnum = 0;		/* stop Visual mode */
---
> 				reset_Visual();					/* stop Visual mode */
186c215
< 				VIsual.lnum = 0;		/* stop Visual mode */
---
> 				reset_Visual();					/* stop Visual mode */
188,190c217
< 				if (ptr == NULL)
< 					beep();
< 				else
---
> 				if (ptr != NULL)
199c226,248
< 	default:	beep();
---
> /* Go to the first occurence of the identifier under cursor along path in a
>  * new window -- webb
>  */
> 	case 'i':						/* Go to any match */
> 	case Ctrl('I'):
> 	case 'I':
> 				type = FIND_ANY;
> 				/* FALLTHROUGH */
> 	case 'd':						/* Go to definition, using p_def */
> 	case Ctrl('D'):
> 	case 'D':
> 				if (type == -1)
> 					type = FIND_DEFINE;
> 
> 				if ((len = find_ident_under_cursor(&ptr, FALSE)) == 0)
> 					break;
> 				find_pattern_in_path(ptr, len, TRUE, type,
> 										Prenum1, ACTION_SPLIT,
> 										(linenr_t)1, (linenr_t)MAXLNUM);
> 				curwin->w_set_curswant = TRUE;
> 				break;
> 
> 	default:	beep_flush();
203a253,262
> 	static void
> reset_Visual()
> {
> 	if (VIsual.lnum != 0)
> 	{
> 		VIsual.lnum = 0;
> 		update_curbuf(NOT_VALID);		/* delete the inversion */
> 	}
> }
> 
310a370
> 	wp->w_alt_fnum = curwin->w_alt_fnum;
346a407,413
> 	if (need_status)
> 	{
> 		msg_pos((int)Rows - 1, sc_col);
> 		msg_clr_eos();		/* Old command/ruler may still be there -- webb */
> 		comp_col();
> 		msg_pos((int)Rows - 1, 0);	/* put position back at start of line */
> 	}
417c484
< 		beep();
---
> 		beep_flush();
479c546
< 		beep();
---
> 		beep_flush();
591a659,681
>  * close all windows for buffer 'buf'
>  */
> 	void
> close_windows(buf)
> 	BUF		*buf;
> {
> 	WIN 	*win;
> 
> 	++RedrawingDisabled;
> 	for (win = firstwin; win != NULL && lastwin != firstwin; )
> 	{
> 		if (win->w_buffer == buf)
> 		{
> 			close_window(win, FALSE);
> 			win = firstwin;			/* go back to the start */
> 		}
> 		else
> 			win = win->w_next;
> 	}
> 	--RedrawingDisabled;
> }
> 
> /*
598c688,689
< close_window(free_buf)
---
> close_window(win, free_buf)
> 	WIN		*win;
612c703
< 	close_buffer(curbuf, free_buf, FALSE);
---
> 	close_buffer(win->w_buffer, free_buf, FALSE);
617c708
< 	if (curwin->w_prev == NULL)		/* freed space goes to next window */
---
> 	if (win->w_prev == NULL)		/* freed space goes to next window */
619,620c710,711
< 		wp = curwin->w_next;
< 		wp->w_winpos = curwin->w_winpos;
---
> 		wp = win->w_next;
> 		wp->w_winpos = win->w_winpos;
623,624c714,715
< 		wp = curwin->w_prev;
< 	wp->w_height += curwin->w_height + curwin->w_status_height;
---
> 		wp = win->w_prev;
> 	wp->w_height += win->w_height + win->w_status_height;
626,627c717,719
< 	win_free(curwin);
< 	curwin = NULL;
---
> 	win_free(win);
> 	if (win == curwin)
> 		curwin = NULL;
630c722,723
< 	win_enter(wp, FALSE);
---
> 	if (curwin == NULL)
> 		win_enter(wp, FALSE);
640a734
> 		comp_col();
642c736
< 	win_comp_scroll(curwin);
---
> 	win_comp_scroll(wp);
769a864
> 		new->w_botline = 2;
1110a1206,1211
> 	return get_file_name_in_path(ml_get(curwin->w_cursor.lnum),
> 												curwin->w_cursor.col, TRUE);
> }
> 
> 	char_u *
> get_file_name_in_path(ptr, col, mess)
1111a1213,1215
> 	int		col;
> 	int		mess;						/* Do we give error messages? */
> {
1115c1219,1220
< 	int		col;
---
> 	char_u	*curr_path = NULL;
> 	int		curr_path_len;
1118,1131d1222
< 		/* characters in a file name besides alfa-num */
< #ifdef UNIX
< 	char_u	*file_chars = (char_u *)"/.-_+,~$";
< #endif
< #ifdef AMIGA
< 	char_u	*file_chars = (char_u *)"/.-_+,$:";
< #endif
< #ifdef MSDOS
< 	char_u	*file_chars = (char_u *)"/.-_+,$\\:";
< #endif
< 
< 	ptr = ml_get(curwin->w_cursor.lnum);
< 	col = curwin->w_cursor.col;
< 
1133c1224
< 	while (!isalnum((char) ptr[col]) && STRCHR(file_chars, ptr[col]) == NULL)
---
> 	while (!isfilechar(ptr[col]))
1135a1227,1229
> 	{
> 		if (mess)
> 			EMSG("No file name under cursor");
1136a1231
> 	}
1139,1140c1234
< 	while (col >= 0 &&
< 	  (isalnum((char) ptr[col]) || STRCHR(file_chars, ptr[col]) != NULL))
---
> 	while (col >= 0 && isfilechar(ptr[col]))
1146,1147c1240
< 	while (ptr[col] != NUL
< 	  && (isalnum((char) ptr[col]) || STRCHR(file_chars, ptr[col]) != NULL))
---
> 	while (isfilechar(ptr[col]))
1161a1255,1259
> 		if (mess)
> 		{
> 			sprintf((char *)IObuff, "Can't find file `%s'", NameBuff);
> 			emsg(IObuff);
> 		}
1165c1263,1272
< 		if ((file_name = alloc((int)(STRLEN(p_path) + STRLEN(NameBuff) + 2))) == NULL)
---
> 		if (curbuf->b_sfilename != NULL)
> 		{
> 			curr_path = curbuf->b_sfilename;
> 			ptr = gettail(curr_path);
> 			curr_path_len = ptr - curr_path;
> 		}
> 		else
> 			curr_path_len = 0;
> 		if ((file_name = alloc((int)(curr_path_len + STRLEN(p_path) +
> 											STRLEN(NameBuff) + 2))) == NULL)
1170c1277
< 			skipspace(&dir);
---
> 			skipwhite(&dir);
1187a1295,1312
> 			if (curr_path_len > 0)
> 			{
> 				/* Look for file relative to current file also -- webb */
> 				STRNCPY(file_name, curr_path, curr_path_len);
> 				if (len == 1 && dir[0] == '.')	/* current dir */
> 					STRCPY(file_name + curr_path_len, NameBuff);
> 				else
> 				{
> 					STRNCPY(file_name + curr_path_len, dir, len);
> #ifdef AMIGA
> 					if (file_name[curr_path_len + len - 1] != ':')
> #endif
> 						file_name[curr_path_len + len] = '/';
> 					STRCPY(file_name + curr_path_len + len + 1, NameBuff);
> 				}
> 				if (getperm(file_name) >= 0)
> 					return file_name;
> 			}
1189a1315,1319
> 		if (mess)
> 		{
> 			sprintf((char *)IObuff, "Can't find file `%s' in path", NameBuff);
> 			emsg(IObuff);
> 		}
1192a1323,1363
> }
> 
> /*
>  * Is the character 'c' a valid file-name character?
>  */
> 	int
> isfilechar(c)
> 	int	c;
> {
> 		/* characters in a file name besides alfa-num */
> #ifdef UNIX
> 	static char_u	*file_chars = (char_u *)"/.-_+,~$";
> #endif
> #ifdef AMIGA
> 	static char_u	*file_chars = (char_u *)"/.-_+,$:";
> #endif
> #ifdef MSDOS
> 	static char_u	*file_chars = (char_u *)"/.-_+,$\\:";
> #endif
> 	
> 	return isalnum((char) c) || (c != NUL &&
> 		STRCHR(file_chars, (char) c) != NULL);
> }
> 
> /*
>  * Return the minimal number of rows that is needed on the screen to display
>  * the current number of windows.
>  */
> 	int
> min_rows()
> {
> 	WIN		*wp;
> 	int		total;
> 
> 	if (firstwin == NULL)		/* not initialized yet */
> 		return MIN_ROWS + 1;	/* one window plus command line */
> 
> 	total = p_ch;		/* count the room for the status line */
> 	for (wp = firstwin; wp != NULL; wp = wp->w_next)
> 		total += MIN_ROWS + wp->w_status_height;
> 	return total;
Index: ./src/winnt.c
diff -r ../vim3.0/src/winnt.c ./src/winnt.c
391c391
<     outstr("new shell started\n");
---
>     msg_outstr("new shell started\n");
569c569
< 	ml_close_all(); 				/* remove all memfiles */
---
> 	ml_close_all(TRUE);				/* remove all memfiles */
778c778
<     outchar('\n');
---
>     msg_outchar('\n');
782d781
< #ifdef WEBB_COMPLETE
784,786d782
< #else
<     if (x)
< #endif
789c785
<         outchar('\n');
---
>         msg_outchar('\n');
959c955
<         *file = NULL;
---
>         *file = "";
Index: ./todo
diff -r ../vim3.0/todo ./todo
1c1
< Known problems:
---
> Known problems and priority improvements:
3,6c3,6
< If file system full and write to swap file failed, get error message for
< 	lnum > line_count?
< When editing same file in two xterms, in second type ":" at first wait-return
< 	for ".swp file exists", at exit cursor is left at top of window.
---
> "line numbers wrong" message in 3.6 (Webb message 47).
> Stack overflow on MSDOS when doing ":ta".
> 	- make command line buffers dynamic (docmdline(), DoOneCmd())
> 	- allocate buffers in findtag()
9,10d8
< MSDOS: When using smardrive a readonly floppy will cause problems. Test for
< 	writable directory first?
13,21c11,12
< ":s/\(.*\)/\1" on line with ^M should not replace ^M by linebreaks.
< Replace with 'r' should set last inserted text.
< BS in replace mode does not work correctly with et set and after inserting a TAB.
< In insert mode CTRL-O . does not repeat the last CTRL-O command but the insertion.
< Sometimes the time stamp in the memfile is old. May be caused by opening the 
< 	file r/w when testing for readonly.
< When doing a CTRL-Z and typing a command for the shell, while Vim is busy
< 	(e.g. writing a file), the command for the shell is sometimes eaten by Vim.
< Find out why screen size is changed in unexpected place for Bob Beresh.
---
> On Diamond Viper 132x43 mode crash on exit (John Lange)
> MSDOS: After writing on a network the 'w' bit for others is set.
24,32c15
< To be checked:
< Check '\n' at end of some : commands (that do not have TRLBAR).
< Check for '\\' at the start of search commands (undocumented vi feature).
< Environment name expansion for 'bdir' default value does not work?
< Usage of isspace() vi-compatible (compared to iswhite())?
< Terminal initializations compared to vi. "vs" used to make cursor very visible,
< 	or for scrollbars (Webb)?
< MSDOS: After writing on a network the 'w' bit for others is set.
< When can the 'p' and 'P' command not be redone??
---
> Documentation:
33a17,22
> Add a remark about the limitations of the check for editing the same file
> 	twice (e.g. when working on different machines) (Webb).
> Add more tags to windows.doc, difference.doc, machine.doc
> Add tags to index.doc
> Use vi.1 manpage to update vim.1 manpage.
> Clean up the list of changes. Move it from version.c to separate file?
34a24
> 
37c27
< Prolem with HPterm under X (cosentino/2).
---
> Problem with HPterm under X (Cosentino).
41,42c31,37
< Linux: A file with protection r--rw-rw- is seen readonly for others. The access()
< 	function in GNU libc is probably wrong.
---
> Linux: A file with protection r--rw-rw- is seen readonly for others. The
> 	access() function in GNU libc is probably wrong.
> MSDOS: When using smardrive with write-back buffering, writing to a readonly
> 	floppy will cause problems. How to test for writable floppy first?
> When doing a CTRL-Z and typing a command for the shell, while Vim is busy
> 	(e.g. writing a file), the command for the shell is sometimes eaten by
> 	Vim, because the terminal mode is changed from RAW to CBREAK.
46a42,108
> When switching to another file and screen scrolls because of the long message
> 	and return must be typed, don't scroll the screen back before
> 	redrawing.
> When using "gf" or "[f", ignore first part of hypertext link (Riehm)
> 	From "type://machine/path" just use "/path".
> When calling undo with a single line, check if line is already saved for undo.
> Add a way to change the meaning of a mouse click, e.g. with mapping.
> When incsearch used and hitting return, no need to search again in many cases,
> 	saves a lot of time in big files.
> Display the help for the -- more -- message only when an illegal key typed.
> Set '[ and '] for undo commands (first and last line that was undone).
> Besides remembering the last used line number of a file, also remember the
> 	column. Use it with CTRL-^ et. al.
> Add an option to switch on/off the setting of the last-used search pattern by
> 	the ":ta" command.
> For u_save() include the column number. This can be used to set '[ and ']. And
> 	in the future the undo can be made more efficient (Webb).
> ":split file1 file2" adds two more windows (Webb).
> Put strings from "*" and "#" searches in the search history (Webb). Also for
> 	other searches, like ":/pat", "vim +/pat file", etc. Don't do this if
> 	keep_old_search_pattern is TRUE.
> Use mouse-button-release code?
> When 'columns' or 'lines' is set try to set the window size.
> Use the middle mouse button to paste text that has been selected with visual
> 	mode (remember last selected visual area).
> Add the possibility to use more than one argument list: ":arglist 2".
> When unhiding a hidden buffer, put the same line at top of the window as the
> 	one before hiding it.
> Add mappings for visual mode; ":vmap" for visual mode, ":nmap" for normal mode
> 	and ":map" for both; use marks for start/end of selected text.
> Add command to show last search pattern and substitute string. Maybe make it
> 	accessible through a register ("/ for search string)?
> Also look for tag file in other directory for tag completion.
> When mouse click after 'r' command, get character that was pointed to.
> Add possibility to :set an option to the default value (for autocmd).
> Add ":which", like "[g" and ":whereis" like "[G".
> When setting 'formatoptions' check for illegal characters.
> Don't give message "Incomplete last line" when editing binary file.
> Be able to read input from a (named) pipe, just like vi can. Use the input
> 	from the pipe to put in the buffer, not as commands!
> Change 'directory' and 'backupdir' into a list of paths. '.' is the same
> 	directory as the file.
> Allow range for ":wq" (Webb).
> Make message "search hit xxx, continuin at..." invertable.
> Add a next/previous possibility to "[g".
> When quitting --more-- with CTRL-C or 'q', don't ask to hit return.
> Add other column number to CTRL-G, like in ruler.
> When in blockwise visual selection (CTRL-V), allow cursor to be placed
> 	right of the line.
> Add command to go to (esisting) buffer by name ":getbuf filename" (Webb).
> ^P/^N should be cyclic for the command line completion, although they should
> 	probably remain non-cyclic for moving through the history (Webb/Demirel)
> Allow for vi command "/foo/;/bar" (Webb/Bostic).
> Add number option to ":s//2": replace second occurance of string?
> Add ":a", ":i" for preloading of named buffers.
> In Replace mode, tab replaces as many characters as it takes on the screen,
> 	text remains at the same position. Requires replace-stack to work with
> 	strings instead of characters? Implement 'replacealign' in a different
> 	way from Webb.
> Put window title code in separate module, so it can be changed easily.
> possibility do operate on current word, line, paragraph with one letter, e.g.
> 	dr, dd, dp, Qp
> Sections in .vimrc that are done for specific file extensions (e.g. for
> 	setting makeprg and errorformat).
> Allow autowrite when doing ":e file" (with an option 'eaw').
> When sorting the file name arguments, only sort within one argument, don't
> 	sort the arguments.
65c127
< When line is too long to fit on screen, don't display it.
---
> When line is too long to fit on screen, display part where cursor is.
73a136
> :s///N substitutes N times.
76d138
< Add arguments to ":args", like ":next".
84,89c146,152
< 	"foo.new" to "foo". If dir is not writable or on write error copy "foo"
< 	to "backupdir/foo.bak" and overwrite "foo". Check for correct group/owner
< 	and try to set it if not. NO: this breaks with hard links.
< 	INSTEAD: make Amiga and MSDOS work like unix: first make copy of file, then
< 	truncate and overwrite original file. Use an option for this, default
< 	on for Unix, off for Amiga/MSDOS.
---
> 	"foo.new" to "foo". If dir is not writable or on write error copy
> 	"foo" to "backupdir/foo.bak" and overwrite "foo". Check for correct
> 	group/owner and try to set it if not. NO: this breaks with hard links.
> 	INSTEAD: make Amiga and MSDOS work like unix: first make copy of file,
> 	then truncate and overwrite original file. Use an option for this,
> 	default on for Unix, off for Amiga/MSDOS (Sayre has the algorithm
> 	worked out).
92,93c155
< Add t_del, code for delete key (termcap 'kD') and maybe some other keys:
< 	'kI' insert key, 'kL' delete line, t_bs 'bs', etc.
---
> Add special code for some keys: 'kL' delete line, t_bs 'bs', etc.
96a159
> CTRL-V :s should substitute only in the block.
103,105d165
< 8-bit codes between 0x80 and 0xa0 cannot be typed directly (mostly msdos
< 	problem). Need more codes for delete key and more function keys. Use
< 	2-byte code? (see xvim).
128c188,189
< 	overwriting; another user may have changed it.
---
> 	overwriting; another user may have changed it. Also check after
> 	executing a shell command?
142a204,205
> Make Vim work like vi when stdin is not a tty. Open /dev/tty if there is no
> 	controlling terminal? Vile does something like this.
154,155c217,218
< With wildcard expansion after '%' and '#', expand current/alternate file name, so
< 	it can be edited.
---
> With wildcard expansion after '%' and '#', expand current/alternate file name,
> 	so it can be edited.
164,165d226
< Add option 'comment', initally "/*,*,*/,#", giving the characters at start of
< 	a line that should be left alone by the internal formatting.
168c229,230
< Add 'scrolloff': scroll when cursor is less then 'scrolloff' lines from top/bottom.
---
> Add 'scrolloffset': scroll when cursor is less then 'scrolloff' lines from
> 	top/bottom. Remove scrolling with mouse click in first/last line.
177a240
> Add -z option: gzip/gunzip when writing/reading file.
186,188c249
< With :s///c highlight the pattern to be replaced and replace \&, ~, etc. when
< 	showing the replacement pattern.
< Add mappings for visual mode; use marks for start/end of selected text.
---
> With :s///c replace \&, ~, etc. when showing the replacement pattern.
192,193c253,254
< Command line: cursor up on empty line: go to previous command, on non-empty line:
< 	go to previous matching command.
---
> Command line: cursor up on empty line: go to previous command, on non-empty
> 	line: go to previous matching command.
201,203c262,263
< After ":read" set '[ and '] marks.
< In fileio.c replace filemess() by outputting strings after each other (only
< 	one wait_return().
---
> When screen has been scrolled (e.g. after CTRL-D), wait-return for every message, there
> 	should be only one wait-return at the end.
206,207d265
< Make program to transform termcap entries into something that fits in tcarr
< 	structure.
217c275,276
< Settings edit mode: make file with ":set opt=xx", edit it, parse it as ex commands.
---
> Settings edit mode: make file with ":set opt=xx", edit it, parse it as
> 	ex commands.
220,221d278
< tag-completion command: when tag found, replace it by the prototype, when not
< 	found, replace it by the longest match.
229d285
< Ex commands in a mapping should not be put in the command line history.
232,234d287
< Add ":retab". When "et" set, convert tabs to spaces, when "noet" vice versa.
< 	":retab 8" will replace tabs and spaces with the current "ts" setting
< 	to a "ts" of 8.
246c299
< Give message "No lines in buffer" when last line in buffer deleted.
---
>  in buffer" when last line in buffer deleted.
258c311,314
< Make options from modelines only used in the buffer where the file is read.
---
> Add command to ":read" a file at a certain column (blockwise read?).
> Add option to make settings from modelines valid only in the file where they
> 	were set. Reset options when starting to edit another file.
> Support the "abbreviate" command in modelines (Kearns).
266,267d321
< Add option to make settings from modelines valid only in the file where they
< 	were set. Reset options when starting to edit another file.
274a329,342
> Allow multiple arguments for ":read" and ":edit"; read/edit all files. Also
> 	allow ":r *" and ":e *".
> Add sort of replace mode where case is taken from the old text (Goldfarb).
> When doing ":bnext" and other go-to-other-buffer commands, set alternate file.
> Support for tabs in specific columns: ":set tabcol=8,20,34,56" (Demirel).
> Add 'searchdir' option: Directories to search for file name being
> 	edited (Demirel).
> Add other mode for smart indent: Brackets in same column as text (Goldfarb).
> Modifier for the put command: Change to linewise, charwise, blockwise, etc.
> Add commands for saving and restoring settings ":set save" "set restore", for
> 	use in macro's and the like.
> Add possibility to ":jumps" to show the text in the line (for loaded files).
> When using "Vim -r", the list of swap files found should include info about
> 	the swap file.
295,296d362
< Support mouse control (also weissman/1). With option to switch it off to
< 	enable copy/paste.
299a366
> Add :collapse, remove multiple blank lines (Demirel, Webb)?
308c375,383
< When horizontal scrolling, use '<' and '>' for lines continuing outside of window.
---
> When horizontal scrolling, use '<' and '>' for lines continuing outside of
> 	window.
> Support putting .swp files in /tmp. Command in rc.local to move .swp files
> 	from /tmp to some directory before deleting files.
> When static tag is ignored because filename is different, but no tag is found,
> 	retry with ignoring the filenames.
> Really read-only mode, impossible to change the text.
> Allow multiple arguments to ":stag", make one window for each.
> 
311a387,388
> Add Ex mode (some people like to use it).
> Add macro language with real functions (perl?).
319d395
< Add 'notwsuffixes' option: suffixes for files where 'tw' should be 0.
322c398,399
< Keyword completion: first look in the file for a match, then in a dictionary (Webb).
---
> Keyword completion: first look in the file for a match, then in a
> 	dictionary (Webb).
324c401
< 	input needed.
---
> 	input needed. Also possible to use Vim from a shell script.
339d415
< Add macro language with real functions.
346a423,432
> Make undo more memory-efficient: compare text before and after change, only
> 	remember the lines that really changed.
> Support for underlining (underscore-BS-char), bold (char-BS-char) and other
> 	standout modes switched on/off with , 'overstrike' option (Reiter).
> Add vertical mode (Paul Jury, Demirel): "5vdw" deletes a word in five lines,
> 	"3vitextESC" will insert "text" in three lines, etc..
> Highlighting of different kinds of text (e.g. for showing variables, keywords).
> Internationalization: wide characters and multibyte char support.
> Support to "freeze" the current editor state (buffers, windows, settings, etc.)
> 	so editing can be resumed at the same point at a later time.
