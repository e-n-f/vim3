*vim_ref.txt*


			    Vim reference manual

			     By Bram Moolenaar

				version 3.9


There is a contents listing at the end of this document.

The commands and options for multiple windows and buffers are explained in a
separate document: See |vim_win.txt|

You can use tags to jump to the explanation of a subject.  Position the
cursor on an item name between bars (e.g. |intro|) or an option name in
quotes (e.g.  'textwidth' ) and hit CTRL-]. Some special characters in the
names of the tags are not allowed, therefore they have been replaced by
letters: "bar for "|", "star" for "*".
	  mode 		    tag starts with	example
	Normal and Visual	nothing		|x|
	Visual			"v_"		|v_u|
	Command line		":"		|:quit|
	Insert mode		"i_"		|i_<ESC>|
	Command line editing	"e_"		|e_<DEL>|


	1. Introduction					*intro*

Vim stands for Vi IMproved. It used to be Vi IMitation, but that does not
really cover it anymore. Vim is a text editor which includes almost all the
commands from the Unix program "Vi" and a lot of new ones. It is very useful
for editing programs and other ASCII text. All commands are given with the
keyboard. There is only limited mouse support and there are no menus. This
gives the advantage that you can keep your fingers on the keyboard and your
eyes on the screen.

Throughout this manual the differences between Vi and Vim are mentioned in 
curly braces. See |vim_diff.txt| for a summary of the differences.

This manual refers to Vim on the Commodore Amiga computer. On other 
computers and on terminals there may be small differences. Besides the
remarks given in this document there is a separate document for each
supported system:
	system		    see
	Amiga		|vim_ami.txt|
	Archimedes	|vim_arch.txt|
	Macintosh	|vim_mac.txt|
	MS-DOS		|vim_dos.txt|
	Unix		|vim_unix.txt|
	Windows-NT	|vim_nt.txt|

This manual is a reference for all the Vim commands and options. This is not
an introduction to the use of Vim. There are books that contain an
introduction to Vi.

A summary of this manual can be found in the file "vim_help.txt"
|vim_help.txt|. It can be accessed from within Vim with the <HELP> key (in
MSDOS <F1>) and with the command ":help" |:help|. The 'helpfile' option can
be set to the name of the help file, so you can put it in any place you
like.


	2. Notation					*notation*

[]		Characters in square brackets are optional.

[count]		An optional number that may precede the command to multiply
		or iterate the command. If no number is given a count of one
		is used, unless otherwise noted. Note that in this manual
		the [count] is not mentioned in the description of the
		command, but only in the explanation. This was done to make
		the commands easier to lookup. If the "sc" option is on, the
		(partially) entered count is shown at the bottom of the
		window. You can use <DEL> to erase the last digit. (Note: if
		you like to use <BS> for this, add this mapping to your
		.vimrc:   :map! CTRL-V <BS>   CTRL-V <DEL>  )

["x]		An optional register designation where text can be stored.
		The x is a single character between <a> and <z> or <A> and
		<Z> or <">, and in some cases (with the put command) between
		<0> and <9>, <%>, <:> or <.>. The uppercase and lower case
		letter designate the same register, but the lower case letter
		is used to overwrite the previous register contents, while the
		uppercase letter is used to append to the previous register
		contents. Without the ""x" or with """" the stored text is
		put into the unnamed register. See also "Copying and moving
		text" |copy_move|.

{}		Curly braces denote parts of the command which must appear, 
		but can take a number of different values. The differences 
		between Vim and Vi are also given in curly braces (this will 
		be clear from the context).

{motion}	A command that moves the cursor. They are listed in chapter 
		6. This is used after an "operator" command to move over the 
		text that is to be operated upon. If the motion includes a 
		count and the operator also had a count, the two counts are 
		multiplied. For example: "2d3w" deletes six words. The
		motion can also be a mouse click. The mouse is currently
		only supported for MSDOS and xterm under UNIX.

{visual}	A piece of text that is started with the "v", "V" or CTRL-V
		command and ended by the cursor position. This is used
		before an "operator" to highlight the text that is to be
		operated upon. See the chapter on Visual mode |visual_mode|.

<character>	A special character from the table below or a single ASCII
		character.

<char1-char2>	A single character from the range <char1> to <char2>. For
		example: <a-z> is a lower case letter. Multiple ranges may be
		concatenated. For example: <a-zA-Z0-9> is any alphanumeric
		character.

CTRL-<char>	<char> typed as a control character, that is, typing <char>
		while holding the CTRL key down. The case of <char> does not
		matter, thus CTRL-A and CTRL-a are equivalent.

'option'	An option, or parameter, that can be set to a value is
		enclosed in single quotes. See chapter 19 |options|.

"command"	In examples the commands you can type are enclosed in double
		quotes.

								*key_notation*
notation	meaning		    equivalent  decimal value(s)
-----------------------------------------------------------------------
<NUL>		zero			CTRL_@    0 (stored as 10)
<BELL>		bell			CTRL-G	  7
<BS>		backspace		CTRL-H	  8
<TAB>		tab			CTRL-I	  9
<LF>		linefeed		CTRL-J	 10 (used for <NUL>)
<FF>		formfeed		CTRL-L	 12
<CR>		carriage return		CTRL-M	 13
<ESC>		escape			CTRL-[	 27
<SPACE>		space				 32
<DEL>		delete				127
<C_UP>		cursor-up			128  1
<C_DOWN>	cursor-down			128  2
<C_LEFT>	cursor-left			128  3
<C_RIGHT>	cursor-right			128  4
<SC_UP>		shift-cursor-up			128  5
<SC_DOWN>	shift-cursor-down		128  6
<SC_LEFT>	shift-cursor-left		128  7
<SC_RIGHT>	shift-cursor-right		128  8
<F1> - <F10>	function keys 1 to 10		128  9  to  128 18
<SF1> - <SF10>	shift-function keys 1 to 10	128 19  to  128 28
<HELP>		help key			128 29
<UNDO>		undo key			128 30
<INSERT>	insert key			128 31
<DELETE>	delete key			128 32
<HOME>		home				128 33
<END>		end				128 34
<PAGE_UP>	page-up				128 35
<PAGE_DOWN>	page-down			128 36
-----------------------------------------------------------------------
Note: The shifted cursor keys, the help key and the undo key are only
available on a few terminals. On some terminals the function keys 11 to 20
are used instead of the shifted function keys. On the Amiga shifted function
key 10 produces a code (CSI) that is also used by key sequences. It will be
recognized only after typing another key.

Note: There are two codes for the delete key. 127 is the ASCII value for the
delete key, which is always recognized. Some delete keys send another value,
in which case this value is obtained from the termcap entry "kD" and
translated into "128 32". Both codes have the same effect.


	3. Starting Vim					*starting*

3.1 Command line					*command_line*

Most often Vim is started to edit a single file with the command

	vim file					*cl_vim*

More generally Vim is started with:

	vim [options] [filelist]

If the filelist is missing, the editor will start with an empty buffer.
Otherwise exactly one out of the following three may be used to choose one
or more files to be edited.

							*cl_file*
file ..		A list of file names. The first one will be the current file 
		and read into the buffer. The cursor will be positioned on 
		the first line of the buffer.

							*cl_tag*
-t {tag}	A tag. "tag" is looked up in the tags file, the associated 
		file becomes the current file and the associated command is 
		executed. Mostly this is used for C programs. In that case 
		"tag" should be a function name. The effect is that the file 
		containing that function becomes the current file and the 
		cursor is positioned on the start of the function (see the 
		section on tags |tags|).

							*cl_qf*
-e [errorfile]	QuickFix mode. The file with the name [errorfile] is read
		and the first error is displayed. If [errorfile] is not
		given, the 'errorfile' option is used for the file name
		(default "AztecC.Err" for the Amiga, "errors" for other
		systems). See section 5.5: "using the QuickFix mode"
		|quickfix|.

The options, if present, must precede the filelist. The options may be given 
in any order.

							*cl_+*
+[num]		The cursor will be positioned on line "num" for the first
		file being edited. If "num" is missing, the cursor will be
		positioned on the last line.

							*cl_+/*
+/{pat}		The cursor will be positioned on the first line containing
		"pat" in the first file being edited (see the section
		"pattern searches" for the available search patterns
		|search_pattern|).

+{command}						*cl_+c*
-c {command}	"command" will be executed after the first file has been
		read. "command" is interpreted as an Ex command. If the
		"command" contains spaces it must be enclosed in double
		quotes (this depends on the shell that is used). Example:
		vim "+set si" main.c

							*cl_r*
-r		Recovery mode. Without a file name argument a list of
		existing swap files is given. With a file name a swap file
		is read to recover a crashed editing session. See the
		chapter "Recovery after a crash" |crash_recovery|.

							*cl_v*
-v		View mode. The 'readonly' option will be set for all the
		files being edited.  You can still edit the buffer, but will
		be prevented from accidentally overwriting a file. If you
		forgot that you are in View mode and did make some changes,
		you can overwrite a file by adding an exclamation mark to
		the Ex command, as in ":w!". The 'readonly' option can be
		reset with ":set noro" (see the options chapter |options|).
		Calling the executable "view" has the same effect as the -v
		option. If your system does not support links and you do not
		want to have the executable twice you could make an alias:
		"alias view vim -v". The 'updatecount' option will be set to
		10000, meaning that the swap file will not be updated
		automatically very often.

							*cl_b*
-b		Binary mode. The 'textauto', 'textmode' and 'expandtab'
		options will be reset. The 'textwidth' option is set to 0.
		'modelines' is set to 0. The 'binary' option is set. This is
		done after reading the .vimrc/.exrc files but before reading
		a file. See also 5.6: "Editing binary files" |edit_binary|.

							*cl_n*
-n		No swap file will be used. Recovery after a crash will be
		impossible. Handy if you want to view or edit a file on a
		very slow medium (e.g. floppy). Can also be done with ":set
		updatecount=0". You can switch it on again by setting the
		'updatecount' option to some value, e.g. ":set uc=100".

							*cl_o*
-o[N]		Open N windows. If [N] is not given, one window is opened
		for every file given as argument. If there is not enough
		room, only the first few files get a window. If there are
		more windows than arguments, the last few windows will be
		editing an empty file.

							*cl_T*
-T {terminal}	Set the terminal type to "terminal". This influences the 
		codes that Vim will send to your terminal. This is normally 
		not needed, because Vim will be able to find out what type 
		of terminal you are using (See chapter 20) |terminal_info|.

							*cl_d*
-d {device}	Amiga only: The "device" is opened to be used for editing.
		Normally you would use this to set the window position and
		size: "-d con:x/y/width/height", e.g.
		"-d con:30/10/600/150". But you can also use it to start
		editing on another device, e.g. AUX:.

							*cl_x*
-x		Amiga only: Do not restart Vim to open a new window. This
		option should be used when Vim is started by a program that
		will wait for the edit session to finish (e.g. mail or
		readnews). See section 3.3 |amiga_window|.

							*cl_u*
-u {vimrc}	The file "vimrc" is read for initializations. Other
		initializations are skipped, see |initialization|. This can
		be used to start Vim in a special mode, with special
		mappings and settings. A shell alias can be used to make
		this easy to use. For example:
			"alias vimc vim -u ~/.c_vimrc !*".
		Also consider using autocommands, see |autocommand|.

							*cl_s*
-s {scriptin}	The script file "scriptin" is read. The characters in the 
		file are interpreted as if you had typed them. The same can 
		be done with the command ":source! {scriptin}". If the end 
		of the file is reached before the editor exits, further 
		characters are read from the keyboard. See also the section 
		"complex repeats" |complex_repeat|.

							*cl_w*
-w {scriptout}	All the characters that you type are recorded in the file
		"scriptout", until you exit Vim. This is useful if you want 
		to create a script file to be used with "vim -s" or 
		":source!". See also the section "complex repeats"
		|complex_repeat|.

Example for using a script file to change a name in several files:
	Create a file "subs.vi" containing substitute commands and a :wq
	command:

		:%s/Jones/Smith/g
		:%s/Allen/Peter/g
		:wq

	Execute Vim on all files you want to change:

		foreach i ( *.let ) vim -s subs.vi $i

If the executable is called "view" Vim will start in Readonly mode. This is 
useful if you can make a hard or symbolic link from "view" to "vim".
Starting in Readonly mode can also be done with "vim -v". 


3.2 Workbench (Amiga only)				*workbench*

Vim can be started from the workbench by clicking on its icon twice. It will
then start with an empty buffer.

Vim can be started to edit one or more files by using a "Project" icon. The
"Default Tool" of the icon must be the full pathname of the Vim executable. 
The name of the ".info" file must be the same as the name of the text file. 
By clicking on this icon twice, Vim will be started with the filename as 
current filename, which will be read into the buffer (if it exists). You can 
edit multiple files by pressing the shift key while clicking on icons, and 
clicking twice on the last one. The "Default Tool" for all these icons must 
be the same.

It is not possible to give arguments to Vim, other than filenames, from the
workbench.


3.3 Vim window (Amiga only)				*amiga_window*

Vim will run in the CLI window where it was started. If Vim was started with 
the "run" or "runback" command, or if Vim was started from the workbench, it 
will open a window of its own.

Technical detail:
	To open the new window a little trick is used. As soon as Vim 
	recognizes that it does not run in a normal CLI window, it will 
	create a script file in t:. This script file contains the same 
	command as how Vim was started, and an "endcli" command. This script 
	file is then executed with a "newcli" command (the "c:run" and 
	"c:newcli" commands are required for this to work). The script file 
	will hang around until reboot, or until you delete it. This method 
	is required to get the ":sh" and ":!" commands to work correctly. 
	But when Vim was started with the -e option (Quickfix mode) or with 
	the -x option, this method is not used. The reason for this is that 
	when a compiler starts Vim with the -e option it will wait for a 
	return code. With the script trick the compiler cannot get the 
	return code. The -x option can be used when Vim is started by a mail 
	program which also waits for the edit session to finish. As a 
	consequence the ":sh" and ":!" commands are not available when the 
	-e or -x option is used.

Vim will automatically recognize the window size and react to window 
resizing. Under Amiga DOS 1.3 it is advised to use the fastfonts program 
"FF" to speed up display redrawing.


3.4 Initialization					*initialization*

When Vim starts running it does initializations in the following order. If
an environment variable is used, it is executed as a single Ex command line.
Multiple commands must be separated with <|> or <LF>. If a file is used,
each line is executed as an Ex command line.

1.  The environment variable SHELL, if it exists, is used to set the 
    'shell' option. With MSDOS the COMPSPEC variable is used if SHELL does
    not exist.

2.  The environment variable TERM, if it exists, is used to set the 'term'
    option.

3.  Five places are searched for initializations. The first that exists is 
    used, the others are ignored.
     1. The file given with the -u command-line option.
     2. The environment variable VIMINIT
     3. The file "s:.vimrc" (for Unix: "$HOME/.vimrc")
     4. The environment variable EXINIT
     5. The file "s:.exrc" (for Unix: "$HOME/.exrc")

4.  If the 'exrc' option is set (default is 'noexrc'), and the -u
    command-line option u is not used, the current directory is searched for
    two files.  The first that exists is used, the other is ignored.
     1. The file ".vimrc"
     2. The file ".exrc"

5.  The 'shellpipe' and 'shellredir' options are set according to
    the value of the 'shell' option, unless they have been set before.

6.  If the 'viminfo' option is set to non-zero by the previous
    initializations, the viminfo file is read. See |viminfo_file|.

The third can be used to set your default settings and mappings for all edit 
sessions. The fourth one for sessions in a certain directory (note that the
'exrc' option is default off). See |save_settings| for how to create a file
with commands to recreate the current settings.

If the VIMINIT environment variable or ".vimrc" exist the EXINIT and ".exrc" 
are skipped. This can be used to initialize Vim without interfering with 
another version of Vi.

On the Amiga two types of environment variables exist. The ones set with the
DOS 1.3 (or later) setenv command are recognized. See the AmigaDos 1.3 
manual. The environment variables set with the old Manx Set command (before 
version 5.0) are not recognized.

On MS-DOS systems Vim assumes that all the "_vimrc" and "_exrc" files have
<CR><LF> pairs as line separators. This will give problems if you have a
file with only <LF>s and have a line like ":map xx yy^M". The trailing ^M
will be ignored.

While reading the ".vimrc" or the ".exrc" file in the current directory some
commands can be disabled for security reasons by setting the 'secure'
option. Otherwise it would be possible to create a .exrc that contains nasty
commands, which another user may automatically execute when he starts Vim it
that directory. The disabled commands are the ones that start a shell,
the ones that write to a file and ":autocmd". The ":map" commands are
echoed, so you can see which keys are being mapped.

You can reset the 'secure' option in the EXINIT or VIMINIT environment
variable or in the global ".exrc" or ".vimrc" file. This is not possible in
".vimrc" or ".exrc" in the current directory, for obvious reasons.

On unix systems this only happens if you are not the owner of the ".vimrc" 
or ".exrc" file. Warning: If you unpack an archive that contains a .exrc 
file, it will be owned by you. You won't have the security protection. Check 
the .exrc file before you start Vim in that directory, or reset the 'exrc' 
option. 


3.5 Suspending						*suspend*

							*CTRL-Z*
CTRL-Z			On Unix systems: Suspend Vim. On other systems: 
			start a new shell (like ":sh"). Same as ":stop".


:sus[pend][!]	or				*:suspend* *:stop*
:st[op][!]		Suspend the editor. If the <!> is not given, the
			buffer was changed, autowrite is set and a filename
			is known, the buffer will be written.

On many UNIX systems it is possible to suspend Vim with CTRL-Z. This is only 
possible in Normal and Visual mode (see next chapter |edit_modes|). Vim will
continue if you make it the foreground job again. On other systems CTRL-Z
will start a new shell. This is the same as the ":sh" command. Vim will
continue if you exit from the shell.


3.6 The viminfo file					*viminfo_file*

The viminfo file is used to store:
- The command line history.
- The search string history.
- Contents of registers.
- Marks in several files.
- Last search/substitute pattern (for 'n' and '&').

When Vim is started and the 'viminfo' option is non-zero, the contents of
the viminfo file is read and the info can be used at the appropriate places.
The marks are not read in at startup. See |initialization| for how to set
the 'viminfo' option upon startup.

When Vim is exited and 'viminfo' is non-zero, the info is stored in the
viminfo file. The 'viminfo' option gives the number of files for which the
marks are remembered.

Marks are stored for each file separately. When a file is read and 'viminfo'
is set, the marks for that file are read from the viminfo file. NOTE: The
marks are only written when exiting Vim. If you want to save the marks for a
file that you are about to abandon, use ":wv".

The default name of the viminfo file is $HOME/.viminfo for Unix, s:.viminfo
for Amiga, $VIM\viminfo for MSDOS. For the commands below another file name
can be given.

Two commands can be used to read and write the viminfo file manually. This
can be used to exchange registers between two running Vim programs: First
type ":wv" in one and then ":rv" in the other.  Note that if the register
already contained something, then ":rv!" would be required.  Also note
however that this means everything will be overwritten with information from
the first vim, including the command line history etc.

The viminfo file itself can be edited by hand too, although we suggest you
start with an existing one to get the format right.  It is reasonably
self-explanatory once you're in there.  This can be useful in order to
create a second file, say "~/.my_viminfo" which could contain certain
settings that you always want when you first start vim.  For example, you
can preload registers with particular data, or put certain commands in the
command line history.  A line in your .vimrc file like
"rviminfo! ~/.my_viminfo" can be used to load this information.  You could
even have different vim-info for different types of files (eg C code) and
load them based on the file name using the ":autocmd" command (see
|:autocmd|).

                           *:rviminfo*
:rviminfo[!] [file]	Read from viminfo file [file] (default see above).
			If [!] is given, then any information that is
			already set (eg registers etc) will be overwritten.
			{not in Vi}

                           *:wviminfo*
:wviminfo[!] [file]	Write to viminfo file [file] (default see above).
			The information in the file is first read in to make
			a merge between old and new info. When [!] is used
			the information is not read first, only the internal
			info is written. If 'viminfo' is zero, marks for up
			to 100 files will be written. {not in Vi}


	4. Modes					*edit_modes*

4.1 Introduction

Vim has four basic modes:

Normal mode		In Normal mode you can enter all the editor
			commands. If you start the editor you are in this 
			mode (unless you have set the 'insertmode' option, 
			see below).

Visual mode		This is like Normal mode, but the movement commands
			extend a highlighted area. When a non-movement
			command is used it is executed for the highlighted
			area. See |visual_mode|.

Insert mode		In Insert mode the text you type is inserted into the
			buffer. If the 'showmode' option is set (which is
			default), the string "-- INSERT --" is shown at the
			bottom of the window.

Command_line mode	In Command_line mode you can enter one line of text
			at the bottom of the window. This is for the Ex
			commands <:>, the pattern search commands <?></> and
			the filter command <!>.

There is one additional mode:

Replace mode		Replace mode is a special case of Insert mode. You
			can do the same things as in Insert mode, but for 
			each character you enter (except some special 
			characters) one character of the existing text is 
			deleted. If the 'showmode' option is set (which is 
			default), the string "-- REPLACE --" is shown at the 
			bottom of the window.

More explanation on the Insert, Replace and Command_line mode is further on 
in this chapter.


4.2 Switching from mode to mode				*mode_switching*

If for any reason you do not know in which mode you are, you can always get
back to Normal mode by typing <ESC> twice. You will know you are back in
Normal mode when you see the screen flash or hear the bell after you type
<ESC>.

- go from Normal mode to Visual mode by giving one of the commands "vV^V"
- go from Normal mode to Insert mode by giving one of the commands
  "iIaAoOcCsS".
- go from Normal mode to Replace mode with the "R" command (not the "r"
  command!).
- go from Normal mode to Command_line mode with the one of the commands
  ":/?!".

							*i_esc*
- go from Insert or Replace mode to Normal mode with <ESC> (twice in some
  rare cases).
- go from Visual mode to Normal mode by giving a non-movement command, which
  causes the command to be executed, or by hitting <ESC> or 'v', which does
  nothing.
- go from Command_line mode to Normal mode by:
   - hitting <CR> or <LF>, which causes the entered command to be executed
   - deleting the complete line (e.g. with CTRL-U) and giving a final <BS>
   - hitting CTRL-C or <ESC>, which quits the command line without executing
     the command.
  In the last case <ESC> may be the character defined with the 'wildchar'
  option, and start command line completion. You can ignore that and type
  <ESC> again. {vi: when hitting <ESC> the command line is executed. This is
  unexpected for most people, therefore it was changed in Vim. But when the
  <ESC> is part of a mapping the command line is executed. If you want the
  vi behaviour also when typing <ESC> use ":cmap ^V<ESC> ^V^M"}

- go from Insert mode to Replace mode by hitting <INSERT>.
- go from Replace mode to Insert mode by hitting <INSERT>.
- go from Visual mode to Command_line mode by hitting ':'. The line numbers
  of the highlighted area will be inserted in the command line.

If the 'insertmode' option is set, editing a file will start in Insert mode.


4.3 Insert and Replace mode				*mode_ins_repl*

4.3.1 special keys					*ins_special_keys*

In insert and Replace mode the following characters have a special meaning,
other characters are inserted directly. To insert one of these special
characters into the buffer, precede it with CTRL-V. To insert a <NUL> 
character use "CTRL-V CTRL-@" or "CTRL-V 000". On some systems you have to
use "CTRL-V 003" to insert a CTRL-C.

char		action
-----------------------------------------------------------------------
						*i_CTRL-[* *i_<ESC>*
<ESC> or CTRL-[	End insert or Replace mode, back to Normal mode. Finish
		abbreviation.
						*i_CTRL-C*
CTRL-C		Quit insert mode, back to Normal mode. Do not check for
		abbreviations.

						*i_CTRL-@*
CTRL-@		Insert previously inserted text and stop insert. {Vi: only
		when typed as first char, only up to 128 chars}
						*i_CTRL-A*
CTRL-A		Insert previously inserted text. {not in Vi}

						*i_CTRL-H* *i_<BS>*
<BS> or CTRL-H	Delete the character before the cursor (see below). {Vi: 
		does not delete autoindents}
						*i_<DEL>*
<DEL>		Delete the character under the cursor. If the cursor is at
		the end of the line, and the 'backspace' option is non-zero,
		delete the newline. The next line is appended after the
		current one. {not in Vi}
						*i_CTRL-W*
CTRL-W		Delete the word before the cursor (see below). See the 
		section "word motions" |word_motions| for the definition of
		a word.
						*i_CTRL-U*
CTRL-U		Delete all entered characters in the current line (see 
		below).

						*i_CTRL-I* *i_<TAB>*
<TAB> or CTRL-I Insert a tab. If the 'expandtab' option is on, the
		equivalent number of spaces is inserted (use CTRL-V <TAB> to
		avoid the expansion). See also the 'smarttab' option and
		section 4.3.4 |ins_expandtab|.
						*i_CTRL-J* *i_<LF>*
<LF> or CTRL-J	Begin new line.
						*i_CTRL-M* *i_<CR>*
<CR> or CTRL-M	Begin new line.
						*i_CTRL-K*
CTRL-K {char1} {char2}
		Enter digraph (see 4.7 |digraphs|). {not in Vi}

CTRL-N		Find next keyword (see 4.3.7 |i_CTRL-N|). {not in Vi}
CTRL-P		Find previous keyword (see 4.3.7 |i_CTRL-P|). {not in Vi}

CTRL-R <0-9a-z"%:>				*i_CTRL-R*
		Insert the contents of a numbered or named register. The
		text is inserted as if you typed it, but mappings and
		abbreviations are not used. If you have options like
		'textwidht' or 'autoindent' set, this will influence what
		will be inserted. Use <"> for the unnamed register,
		containing the text of the last delete or yank. Use <%> for
		the current file name.  Use <:> for the last command line.
		See the chapter on copying |copy_move| and moving text about
		registers.  {<%>, <"> and <:> not in Vi}

						*i_CTRL-T*
CTRL-T		Insert one shiftwidth of indent at the start of the current 
		line. See also 'shiftround' option. {Vi: only when in 
		autoindent}
						*i_CTRL-D*
CTRL-D		Delete one shiftwidth of indent at the start of the current 
		line. See also 'shiftround' option. {Vi: CTRL-D works only
		when used after autoindent}
						*i_0_CTRL-D*
0 CTRL-D	Delete all indent in the current line.  {Vi: CTRL-D works
		only when used after autoindent}
						*i_^_CTRL-D*
^ CTRL-D	Delete all indent in the current line. The indent is
		restored in the next line. This is useful when inserting a
		label. {Vi: CTRL-D works only when used after autoindent}

						*i_CTRL-V*
CTRL-V		Insert next non-digit literally. Up to three digits form the 
		decimal value of a single byte (see below |i_CTRL-V_digit|.
		The non-digit and the three digits are not considered for
		mapping. {Vi: no decimal byte entry}
CTRL-X		Enter CTRL-X mode. This is a sub mode where a commands can
		be given to complete words or scroll the window. See below
		|i_CTRL-X| and in 4.3.7 |ins_completion|. {not in Vi}

						*i_CTRL-E**
CTRL-E		Insert the character which is below the cursor. {not in Vi}
						*i_CTRL-Y*
CTRL-Y		Insert the character which is above the cursor. {not in Vi}

						*i_CTRL-B*
CTRL-B		Toggle the 'revins' option (B for Backwards). {not in Vi}
						*i_<INSERT>*
<INSERT>	Toggle between insert and replace mode. {not in Vi}
-----------------------------------------------------------------------

The effect of the <BS>, CTRL-W and CTRL-U depends on the 'backspace' option
(unless 'revins' is set):

backspace	action
 option
   0	   delete stops in column 1 and start position of insert
   1	   delete stops at start position of insert
   2	   delete always, CTRL-W and CTRL-U stop once at start position of 
	   insert

If the 'backspace' option is non-zero and the cursor is in column 1 when one 
of the three keys is used, the current line is joined with the previous 
line. This effectively deletes the newline in front of the cursor. {Vi: does 
not cross lines, does not delete past start position of insert}

						*i_CTRL-V_digit*
With CTRL-V followed by one, two or three digits you can enter the decimal 
value of a byte, except 10. Normally CTRL-V is followed by three digits. The 
formed byte is inserted as soon as you type the third digit. If you type 
only one or two digits and then a non-digit, the decimal value of those one 
or two digits form the byte. After that the non-digit is dealt with in the 
normal way. If you enter a value of 10, it will end up in the file as a 0.
The 10 is a <LF>, which is used internally to represent the <NUL> character.
When writing the buffer to a file the <LF> character is translated into
<NUL>. The <LF> character is written at the end of each line. Thus if you
want to insert a <LF> character in a file you will have to make a line
break.

						*i_CTRL-X*
CTRL-X enters a sub-mode, where several commands can be used. Most of these
commands do keyword completion, see 4.3.7 |ins_completion|. Two commands can
be used to scroll the window up or down, without exiting insert mode:

						*i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		scroll window one line up.

						*i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		scroll window one line down.

The scrolling is not done if this makes the cursor scroll of the window or
end of file is reached. Further CTRL-E or CTRL-Y can be given to scroll more
or back. As soon as another key is hit, CTRL-X mode is exited and that key
is handled as in normal insert mode.


4.3.2 special special keys				*ins_special_special*

The following keys are special. They stop the current insert, do something 
and then restart insertion. This means you can do something without getting 
out of Insert mode. This is very handy if you prefer to use the Insert mode 
all the time, just like editors that don't have a separate Normal mode. You 
may also want to set the 'backspace' option to 2 and set the 'insertmode' 
option. You can use CTRL-O if you want to map a function key to a command.

The changes (inserted or deleted characters) before and after these keys can 
be undone separately. Only the last change can be redone and always behaves 
like an "i" command.

char		action
-----------------------------------------------------------------------
<C_UP>		cursor one line up			     *i_<C_UP>*
<C_DOWN>	cursor one line down			     *i_<C_DOWN>*
<C_LEFT>	cursor one character left		     *i_<C_LEFT>*
<C_RIGHT>	cursor one character right		     *i_<C_RIGHT>*
<SC_LEFT>	cursor one word back (like "b" command)	     *i_<SC_LEFT>*
<SC_RIGHT>	cursor one word forward (like "w" command)   *i_<SC_RIGHT>*
<HOME>		cursor to first char in the line	     *i_<HOME>*
<END>		cursor to after last char in the line	     *i_<END>*
mouse-click	cursor to position of mouse click.           *i_<MOUSE>*
<SC_UP>		move window one page up			     *i_<SC_UP>*
<PAGE_UP>	move window one page up			     *i_<PAGE_UP>*
<SC_DOWN>	move window one page down		     *i_<SC_DOWN>*
<PAGE_DOWN>	move window one page down		     *i_<PAGE_DOWN*
CTRL-O		execute one command and return to Insert mode*i_CTRL-O*
-----------------------------------------------------------------------

The CTRL-O command has one side effect: If the cursor was beyond the end of 
the line it will be put on the last character in the line.
The shifted cursor keys are not available on all terminals.

When the 'whichwrap' option is set appropriately, the <C_LEFT> and <C_RIGHT>
keys on the first/last character in the line make the cursor wrap to the
previous/next line.


4.3.3 'textwidth' and 'wrapmargin' option		*ins_textwidth*

The 'textwidth' option can be used to automatically break a line before it 
gets too long. Set the 'textwidth' option to the desired maximum line 
length. If you then type more characters (not spaces or tabs), the 
last word will be put on a new line (unless it is the only word on the 
line). If you set 'textwidth' to 0, this feature is disabled.

The 'wrapmargin' option does almost the same. The difference is that
'textwidth' has a fixed width while 'wrapmargin' depends on the width of the
screen. When using 'wrapmargin' this is equal to using 'textwidth' with a
value equal to (columns - 'wrapmargin'), where columns is the width of the
screen.

When 'textwidth' and 'wrapmargin' are both set, 'textwidth' is used.

The line is only broken automatically when using insert mode, or when
appending to a line. When in replace mode and the line length is not
changed, the line will not be broken.

If you want to format a block of text you can use the "Q" operator. Type "Q" 
and a movement command to move the cursor to the end of the block. In many 
cases the command "Q}" will do what you want (format until the end of 
paragraph). Or you can use visual mode: hit "v", move to the end of the
block and hit "Q". See also |Q|.


4.3.4 'expandtab' and 'smarttab' options		*ins_expandtab*

If the 'expandtab' option is set, spaces will be used to fill the amount of
whitespace of the tab. If you want to enter a real <TAB> type CTRL-V first.
The 'expandtab' option is default off. Note that in Replace mode a single
character is replaced by several spaces. The result of this is that the
number of characters in the line increases. Backspacing will delete one
space at a time. The original character will be put back for only one space
that you backspace over (the last one). {Vi does not have the 'expandtab'
option}

When the 'smarttab' option is set a TAB in front of a line inserts
'shiftwidth' positions, 'tabstop' in other places. This means that often
spaces instead of a TAB character is inserted. When not set a TAB always
inserts 'tabstop' positions, 'shiftwidth' is only used for ">>" and the like.
{not in Vi}


4.3.5 typing backwards					*ins_reverse*

If the 'revins' (reverse insert) option is set, inserting happens backwards.
This can be used to type Hebrew. When inserting characters the cursor is not
moved and the text moves rightwards. A <BS> deletes the character under the
cursor. CTRL-W and CTRL-U also work in the opposite direction. <BS>, CTRL-W
and CTRL-U do not stop at the start of insert or end of line, no matter how
the 'backspace' option is set.

In insert mode the 'revins' option can be toggled with CTRL-B.

There is no reverse replace mode.

If the 'showmode' option is set, "-- REVERSE INSERT --" will be shown in the
status line.


4.3.6 Replace mode					*replace_mode*

In Replace mode one character in the line is deleted for every character you 
type. If there is no character to delete (at the end of the line), the 
typed character is appended (as in Insert mode). Thus the number of
characters in a line stays the same until you get to the end of the line.
If a <LF> is typed, a line break is inserted and no character is deleted.

Be careful with <TAB> characters. If you type a normal printing character in 
its place, the number of characters is still the same, but the number of 
columns will become smaller.

If you delete characters in Replace mode (with <BS>, CTRL-W or CTRL-U), what
happens is that you delete the changes. The characters that were replaced
are restored. If you had typed past the existing text, the characters you
added are deleted. This is effectively a character-at-a-time undo.
    If the 'expandtab' option is set, a <TAB> will replace one character
with several spaces. The result of this is that the
number of characters in the line increases. Backspacing will delete one
space at a time. The original character will be put back for only one space
that you backspace over (the last one). {Vi does not have the 'expandtab'
option}


4.3.7 Insert mode completion				*ins_completion*

In insert and replace mode there are several commands to complete part of a
word or line that has been typed. This is useful if you are using
complicated words (e.g. function names with capitals and underscores).
Completion can be done for:

1. Whole lines						|compl_whole_line|
2. identifiers in the current file			|compl_current|
3. identifiers in the current and included files	|compl_ident|
4. tags							|compl_tag|
5. file names						|compl_filename|
6. definitions or macros				|compl_define|

All these, except 2., are done in CTRL-X mode. This is a sub-mode from
insert/replace mode. You enter CTRL-X mode by typing CTRL-X and one of the
CTRL-X commands. You exit CTRL-X mode by typing a key that is not a valid
CTRL-X mode command. Valid keys are the CTRL-X command itself, CTRL-N (next)
and CTRL-P (previous).

Also see the 'infercase' option if you wnat to adjust the case of the match.

Note: The keys that are valid in CTRL-X mode are not mapped. This allows for
":map CTRL-F CTRL-X CTRL-F" to work. The key that ends CTRL-X mode (a key
that is not a valid CTRL-X mode command) is mapped.

The following mappings are suggested to make typing the completion commands
a bit easier:
    :inoremap ^] ^X^]
    :inoremap ^F ^X^F
    :inoremap ^G ^X^G
    :inoremap ^L ^X^L


Completing whole lines:					*compl_whole_line*
							*i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		Search backwards for a line that starts with the
			same characters as in the current line before the
			cursor. Indent is ignored. The found line is
			inserted in front of the cursor.
	CTRL-L	or
	CTRL-P		Search backwards for next matching line. This line
			replaces the previous matching line.

	CTRL-N		Search forward for next matching line. This line
			replaces the previous matching line.

Completing identifiers in current file:			*compl_current*

							*i_CTRL-P*
							*i_CTRL-N*
The keys CTRL-N and CTRL-P can be used to complete the keyword that is in
front of the cursor. This is useful if you are writing a program that has
complicated variable names, and you want to copy a name from the text before
of after the cursor.

If there is an identifier in front of the cursor (a name made out of
alphanumeric characters and characters in 'identchars') it is used as the
search pattern, with "\<" prepended (meaning: start of a word). Otherwise
"\<[a-zA-Z%s][a-zA-Z0-9%s]" is used as search pattern: Start of any
identifier of at least two characters (%s is replaced with 'idenchars').

With CTRL-N (next) the search goes forward, with CTRL-P (previous) the
search goes backward. The first time the search starts where the cursor is.
The next times the search starts at the last found position. If you type any
other character than CTRL-P or CTRL-N the current text is accepted and the
search pattern is forgotten.

If the search found a match, it is inserted at the cursor position. Any
previous match is replaced. If no match was found, Vim will beep.

In replace mode the number of characters that is replaced depends on the
length of the matched string. This works like typing the characters of the
matched string in replace mode.

If there is not a valid identifier character before the cursor, any
identifier is matched.
	eg. to get:
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	just type:
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);

Multiple repeats of the same completion are skipped, thus a different match
will be inserted at each CTRL-N and CTRL-P (unless there is only one
matching identifier).

If there is only one completion found, then a second CTRL-P or CTRL-N will
give the message 'No other matches'.

If the only match in the file is an exact match, where no extra characters
would be typed, then the message 'Exact match only' is given (this is also
useful for checking that you typed the symbol correctly).

After CTRL-N and/or CTRL-P have been used to find all the matches in the
file, any files given in the 'dictionary' option will also be searched.
This could potentially be pretty slow, since all matches are found before
the user may cycle through them.  By default, there is no dictionary.

The mode (--INSERT--) is shown, unless there is another more important
message (eg Pattern not found).  This other message will stay until another
key is hit, and then the mode is shown again.

Only matches where something extra will be added are used.
	eg. to get:
	    printf("name = %s\n", name);
	just type:
	    printf("name = %s\n", n^P);
The 'n' in '\n' is skipped.


Completing identifiers in the current and included files:	*compl_ident*

The 'include' option is used to specify a line that contains an include file
name. The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		Search for the first identifier in the current and
			included files that starts with the same characters
			as before the cursor. The found identifier is
			inserted in front of the cursor.

	CTRL-N		Search forwards for next matching identifier. This
			This identifier replaces the previous matching
			identifier. Note: CTRL-I is the same as TAB, which
			is likely to be typed after a succesful completion,
			therefore CTRL-I is not used for searching for the
			next match.

	CTRL-P		Search backward for previous matching macro name.
			This identifier replaces the previous matching
			identifier.


Completing tags:					*compl_tag*
						*i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same
			characters as before the cursor. The found tag is
			inserted in front of the cursor.
	CTRL-]	or
	CTRL-N		Search forwards for next matching tag. This tag
			replaces the previous matching tag.

	CTRL-P		Search backward for previous matching tag. This tag
			replaces the previous matching tag.


Completing file names:					*compl_filename*
							*i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the
			same characters as before the cursor. The found file
			name is inserted in front of the cursor.
	CTRL-F	or
	CTRL-N		Search forwards for next matching file name. This
			file name replaces the previous matching file name.

	CTRL-P		Search backward for previous matching file name.
			This file name replaces the previous matching file
			name.


Completing definitions or macros:			*compl_define*

The 'define' option is used to specify a line that contains a definition.
The 'include' option is used to specify a line that contains an include file
name. The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		Search in the current and included files for the
			first definition (or macro) name that starts with
			the same characters as before the cursor. The found
			definition name is inserted in front of the cursor.
	CTRL-D	or
	CTRL-N		Search forwards for next matching macro name. This
			macro name replaces the previous matching macro
			name.

	CTRL-P		Search backward for previous matching macro name.
			This macro name replaces the previous matching macro
			name.


4.4 Command_line mode					*mode_cmdline*

Command_line mode is used to enter Ex commands <:>, search patterns </><?>
and filter commands <!>.


4.4.1 Command line editing			*cmdline_editing*

Normally characters are inserted in front of the cursor position. You can
move around in the command line with the left and right cursor keys. With
the <INSERT> key you can toggle between inserting and overstriking
characters. {Vi: can only alter the last character in the line}

The command lines that you enter are remembered in a history table. You can
recall them with the up and down cursor keys. There are actually two history
tables: One for ':' commands and one for search strings. These are
completely separate. The search strings history can only be accessed when
entering a search string, same for the ':' commands. Use the 'history'
option to set the number of lines that are remembered (default 20). Note
that when you enter a command line that is excactly the same as an older
one, the old one is removed (to avoid repeated commands moving older
commands out of the history). Only commands that are typed are remembered.
Ones that come from mappings are not put in the history (detail: the
descision is made from the last key that was typed for the line, normally
<CR>). {Vi: no history}

There is an automatic completion of names on the command line, see 4.4.2
|cmdline_completion|.

						*e_CTRL-V*
CTRL-V		Insert next non-digit literally. Up to three digits form the 
		decimal value of a single byte. The non-digit and the three
		digits are not considered for mapping. This works the same
		way as in Insert mode (see above |i_CTRL-V|).
						*e_<C_LEFT>*
<C_LEFT>	cursor left
						*e_<C_RIGHT*
<C_RIGHT>	cursor right
						*e_<SC_LEFT>*
<SC_LEFT>	cursor one word left
						*e_<SC_RIGHT*
<SC_RIGHT>	cursor one word right
CTRL-B or <HOME>				*e_CTRL-B* *e_<HOME>*
		cursor to begin of command line
CTRL-E or <END>					*e_CTRL-E* *e_<END>*
		cursor to end of command line

						*e_<MOUSE>*
mouse-click	cursor to position of mouse click.

						*e_<BS>*
<BS>		delete the character in front of the cursor
						*e_<DEL>*
<DEL>		delete the character under the cursor (at end of line:
		character in front of the cursor)
						*e_CTRL-W*
CTRL-W		delete the word in front of the cursor
						*e_CTRL-U*
CTRL-U		remove all characters

		Note: if the command line becomes empty with one of the
		delete commands, command line mode is quit.
						*e_<INSERT>*
<INSERT>	Toggle between insert and overstrike. {not in Vi}

{char1} <BS> {char2}	or			*e_digraph*
CTRL-K {char1} {char2}				*e_CTRL-K*
		enter digraph (see 4.7 |digraphs|). {not in Vi}

						*e_<LF>* *e_<CR>*
<CR> or <LF>	start entered command
						*e_<ESC>*
<ESC>		when typed: quit command line without executing
		in macros: start entered command
						*e_CTRL-C*
CTRL-C		quit command line without executing

						*e_<C_UP>*
<C_UP>		recall older command line from history
						*e_<C_DOWN>*
<C_DOWN>	recall more recent command line from history

						*e_<SC_UP>* *e_<PAGE_UP>*
<SC_UP> or <PAGE_UP>
		recall older command line from history, which begin matches 
		the current command line (see below).
						*e_<SC_DOWN>* *e_<PAGE_DOWN>*
<SC_DOWN> or <PAGE_DOWN>
		recall more recent command line from history, which begin 
		matches the current command line (see below).

CTRL-D		command line completion (see 4.4.2 |cmdline_completion|)
'wildchar' option
		command line completion (see 4.4.2 |cmdline_completion|)
CTRL-N		command line completion (see 4.4.2 |cmdline_completion|)
CTRL-P		command line completion (see 4.4.2 |cmdline_completion|)
CTRL-A		command line completion (see 4.4.2 |cmdline_completion|)
CTRL-L		command line completion (see 4.4.2 |cmdline_completion|)

The <SC_UP>, <PAGE_UP>, <SC_DOWN> and <PAGE_DOWN> keys take the current
command line as search string. The beginning of the next/previous command
lines are compared against this string. The fist line that matches is the
new command line. When typing these two keys repeatedly, the same string is
used again. For example this can be used to find the previous substitute
command: Type ":s" and then <SC_UP>. The same could be done by typing <C_UP>
a number of times until the desired command line is shown. (Note: the
shifted arrow keys do not work on all terminals) 


4.4.2 Command line completion				*cmdline_completion*

When editing the command line a few commands can be used to complete the
word before the cursor. This is available for:

- Command names, at the start of the command line. Works always.
- tags, only after the ":tag" command.
- file names, only after a command that accepts a file name or a setting for
  an option that can be set to a file name. This is called file name
  completion.
- options, only after the ":set" command.

These are the commands that can be used:

							*e_CTRL-D*
CTRL-D		List names that match the pattern in front of the cursor.
		When showing file names, directories are highlighted (see
		'highlight' option)
							*e_wildchar*
'wildchar' option
		A match is done on the pattern in front of the cursor. The
		match, or if there are several, the first match, is inserted
		in place of the pattern. (Note: does not work inside a
		macro, because TAB or ESC is mostly used as 'wildchar', and
		these have a special meaning in some macros)
		When typed again, and there were multiple matches, the next
		match is inserted. After the last match the first is used
		again (wrap around).
							*e_CTRL-N*
CTRL-N		After using 'wildchar' which got multiple matches: go to next
		match. Otherwise: Recall more recent command line from history.
							*e_CTRL-P*
CTRL-P		After using 'wildchar' which got multiple matches: go to
		previous match. Otherwise: Recall older command line from
		history.
							*e_CTRL-A*
CTRL-A		All names that match the pattern in front of the cursor are
		inserted.
							*e_CTRL-L*
CTRL-L		A match is done on the pattern in front of the cursor. If
		there is one match, it is inserted in place of the pattern.
		If there are multiple matches the longest common part is
		inserted in place of the pattern.

The 'wildchar' option defaults to <TAB> (CTRL-E when compiled with 
COMPATIBLE; in a previous version <ESC> was used). In the pattern standard
wildcards <*> and <?> are accepted. <*> matches any string, <?> matches
exactly one character.

For filename completion you can use the 'suffixes' option to set a priority 
between files with almost the same name. If there are multiple matches, 
those files with an extension that is in the 'suffixes' option are ignored.
The default is ".bak.~.o.h.info.swp", which means that files with the
extensions ".bak", ".~", ".o", ".h", ".info" and ".swp" are sometimes
ignored. It is impossible to ignore suffixes with two dots. Examples:

pattern:	files:				match:
test*		test.c test.h test.o		test.c
test*		test.h test.o			test.h and test.o
test*		test.i test.h test.c		test.i and test.c

If there is more than one matching file (after ignoring the ones matching
the 'suffixes' option) the first file name is inserted. You can see that
there is only one match when you type 'wildchar' twice and the completed
match stays the same. You can get to the other matches by entering
'wildchar', CTRL-N or CTRL-P. All files are included, also the ones with
extensions matching the 'suffixes' option.

The old value of an option can be obtained by hitting 'wildchar' just after
the '='. For example, typing 'wildchar' after ":set dir=" will insert the
current value of 'dir'. This overrules filename completion for the options
that take a file name.


4.4.3 Ex command lines					*cmdline_lines*

The Ex commands have a few specialties:

							*:"*
<"> at the start of a line causes the whole line to be ignored. <"> 
after a command causes the rest of the line to be ignored. This can be used 
to add comments. Example:
	:set ai		"set 'autoindent' option
It is not possible to add a comment to a shell command ":!cmd" or to the
":map" command and friends, because they see the <"> as part of their
argument.

							*:bar*
<|> can be used to separate commands, so you can give multiple commands in 
one line. The commands ":global", "vglobal", ":!" and "autocmd" see the <|>
as their argument, and can therefore not be followed by another command. If
you want <|> to be included in one of the other commands, precede it with
<\>. Note that this is confusing (inherited from vi). If you give a command
with ":!" you don't have to use a backslash, with ":r !" you have to. And
with ":g" the <|> is included in the command, with ":s" it is not. There is
one execption: With the ":map" and ":abbr" commands and friends CTRL-V needs
to be used instead of <\>.
Examples:
	:!ls | wc		view the output of two commands
	:r !ls \| wc		insert the same output in the text
	:%g/foo/p|>		moves all matching lines one shiftwidth
	:%s/foo/bar/|>		moves one line one shiftwidth
	:map q 10^V|		map "q" to "10|"
	:map q 10\|map \ l	map "q" to "10\" and map "\" to "l"
You can also use <LF> to separate commands in the same way as with <|>. But
using <|> is the preferred method.

When the character <%> or <#> is used where a filename is expected, they are 
expanded to the current and alternate filename (see the chapter "editing 
files" |:%| |:#|).

Embedded spaces in filenames are allowed if one filename is expected as
argument. Trailing spaces will be ignored, unless escaped with a backslash
or CTRL-V. Note that the ":next" command uses spaces to separate file names.
Escape the spaces to include them in a file name. Example:
	:next foo\ bar goes\ to school\ 
starts editing the three files "foo bar", "goes to" and "school ".

When you want to use the special characters <"> or  <|> in a command, or want
to use <%> or <#> in a filename, precede them with a backslash. The backslash
is not required in a range and in the ":substitute" command.


4.4.4 Ex command line ranges				*cmdline_ranges*

Some Ex commands accept a line range in front of them. This is noted as
[range]. It consists of one or more line specifiers, separated with <,> or 
<;>. When separated with <;> the cursor position will be set to that line 
before interpreting the next line specifier. The default line specifier for 
most commands is the cursor position, but the commands ":write" and 
":global" have the whole file (1,$) as default. If more line specifiers are 
given than required for the command, the first one(s) will be ignored.

Line numbers may be specified with:			*:range*
	{number}	an absolute line number
	.		the current line
	$		the last line in the file
	%		equal to 1,$ (the entire file)
	't		position of mark t (lower case)
	/{pattern}[/]	the next line where {pattern} matches
	?{pattern}[?]	the previous line where {pattern} matches
	\/		the next line where the previously used search
			pattern matches
	\?		the previous line where the previously used search
			pattern matches
	\&		the next line where the previously used substitute
			pattern matches

Each may be followed (several times) by <+> or <-> and an optional number. 
This number is added or subtracted from the preceding line number. If the 
number is omitted, 1 is used.

The "/" and "?" may be preceded with another address. The search starts from
there. The "/" and "?" after {pattern} are required to separate the pattern
from anything that follows.

The {number} must be between 0 and the number of lines in the file. A 0 is 
interpreted as a 1, except with the commands tag, pop and read.

Examples:
	.+3		three lines below the cursor
	/that/+1	the line below the next line containing "that"
	.,$		from current line until end of file
	0/that		the first line containing "that"

Some commands allow for a count after the command. This count is used as the
number of lines to be used, starting with the line given in the last line
specifier (the default is the cursor line). The commands that accept a count
are the ones that use a range but do not have a file name argument (because
a file name can also be a number).

Examples:
	:s/x/X/g 5	substitute <x> by <X> in the current line and four
			following lines
	:23d 4		delete lines 23, 24, 25 and 26

A range should have the lower line number first. If this is not the case, Vim
will ask you if it should swap the line numbers. This is not done within the
global command ":g".

							*N:*
When giving a count before entering ":", this is translated into:
		:.,.+(count - 1)
In words: The 'count' lines at and after the cursor. Example: To delete
three lines:
		3:d<CR>		is translated into: .,.+2d<CR>

							*v_:*
{visual}:	starts a command line with the visual selected lines as a
		range.


4.5 The window contents					*window_contents*

In command and Insert/Replace mode the screen window will show the current
contents of the buffer: What You See Is What You Get. {Vi: when changing 
text a <$> is placed on the last changed character; The window is not always 
updated on slow terminals} Lines longer than the window width will wrap,
unless the 'wrap' option is off (see below). The bottom lines in the window
may start with one of these two characters:

<@>	The next line is too long to fit in the window.
<~>	Below the last line in the buffer.

If the bottom line is completely filled with <@>, the line that is at the 
top of the window is too long to fit in the window. If the cursor is on this 
line you can't see what you are doing, because this part of the line is not 
shown. However, the part of the line before the <@>s can be edited normally. 
{Vi: gives an "internal error" on lines that do not fit in the window}

If the 'wrap' option is off, long lines will not wrap. Only the part that
fits on the screen is shown. If the cursor is moved to a part of the line
that is not shown, the screen is scrolled horizontally. The advantage of
this method is that columns are shown as they are and lines that cannot fit
on the screen can be edited. The disadvantage is that you cannot see all the
characters of a line at once. The 'sidescroll' option can be set to the
minimal number of columns to scroll. {Vi: has no 'wrap' option}

All normal ASCII characters are displayed directly on the screen. The <TAB> 
is replaced by the number of spaces that it represents. Other non-printing 
characters are replaced by "^<char>", where <char> is the non-printing 
character with 64 added. Thus character 7 (bell) will be shown as "^G". 
Characters between 127 and 160 are replaced by "~<char>", where <char> is 
the character with 64 subtracted. These characters occupy more than one 
position on the screen. The cursor can only be positioned on the first one.

If you set the 'number' option, all lines will be preceded with their 
number.

If you set the 'list' option, <TAB> characters will not be shown as several
spaces, but as "^I". A <$> will be placed at the end of the line, so you can
find trailing blanks.

In Command_line mode only the command line itself is shown correctly. The
display of the buffer contents is updated as soon as you go back to Command
mode.

Some commands hand over the window to external commands (e.g. ":shell" and
"="). After these commands are finished the window may be clobbered with 
output from the external command, so it needs to be redrawn. This is also 
the case if something is displayed on the status line that is longer than 
the width of the window. If you are expected to have a look at the screen 
before it is redrawn, you get this message:

		Press RETURN or enter command to continue

After you type a key the screen will be redrawn and Vim continues. If you 
type <CR>, <SP> or <LF> nothing else happens. If you type any other key, it 
will be interpreted as (the start of) a new command. {Vi: only <:> commands 
are interpreted}

The last line of the window is used for status and other messages. The 
status messages will only be used if an option is on:

status message			option		default	unix default
current mode			'showmode'	on	    on
command characters		'showcmd'	on	    off
cursor position			'ruler'		off	    off

The current mode is "-- INSERT --" or "-- REPLACE --". The command 
characters are those that you typed but were not used yet. {Vi: does not
show the characters you typed or the cursor position}

If you have a slow terminal you can switch off the status messages to speed 
up editing:
	:set nosc noru nosm

If there is an error, an error message will be shown for at least one second 
(in reverse video). {Vi: error messages may be overwritten with other 
messages before you have a chance to read them}

Some commands show how many lines were affected. Above which threshold this
happens can be controlled with the 'report' option (default 2).

On the Amiga Vim will run in a CLI window. The name Vim and the full name of
the current filename will be shown in the title bar. When the window is
resized, Vim will automatically redraw the window. You may make the window as
small as you like, but if it gets too small not a single line will fit in it.
Make it at least 40 characters wide to be able to read most messages on the
last line.

On most Unix systems window resize works ok.  {Vi: not ok}


4.6 Abbreviations					*abbreviations*

Abbreviations are used in insert mode, Replace mode and Command_line mode.
If you enter a word that is an abbreviation, it is replaced by the word it
stands for. This can be used to save typing for often used long words.

There are two types of abbreviations: The "full-id" type consists entirely
of id characters (letters, digits and <_> characters). This is the most
common abbreviation. The "non-id" type ends in an id character, but all the
other characters are not id characters. Examples of a "full-id" type are
"foo" and "c_1". Examples of a "non-id" type are "#i" and "$/7". Examples of
strings that will not be recognized as an abbreviation are "a.b", "a b" and
"_$ar".

The "full-id" abbreviation is recognized if:
- A character is typed that is not an id character. This can also be
  the <ESC> that ends insert mode or the <CR> that ends a command.
- The characters in front of the cursor match the abbreviation.
- In front of the match is a non-id character, or this is where the line or
  insertion starts. Exception: when the abbreviation is only one character,
  it is not recognized if there is a non-id character in front of it, other
  than a space or a TAB.

The "non-id" abbreviation is recognized if:
- A character is typed that is not an id character. This can also be
  the <ESC> that ends insert mode or the <CR> that ends a command.
- The characters in front of the cursor match the abbreviation.
- In front of the match is an id character, or a space or a TAB, or this is
  where the line or insertion starts.

Example: ":ab foo four old otters". Note that spaces in the <rhs> are
allowed and included in the replacement string. If you now insert the word
"foo" with a space before and after it, it will be replaced by "four old
otters". If you would type "foobar" or "barfoo" nothing happens.

To avoid the abbreviation in insert mode type part of the abbreviation, exit
insert mode with <ESC>, re-enter insert mode with "a" and type the rest. In
Command_line mode you can type CTRL-V twice somewhere in the abbreviation to
avoid it to be replaced. A CTRL-V in front of a normal character is mostly
ignored otherwise.

There are no default abbreviations.

Abbreviations are never recursive. You can use ":ab f f-o-o" without any
problem. But abbreviations can be mapped. {some versions of vi support
recursive abbreviations, for no apparent reason}

Abbreviations are disabled if the 'paste' option is set.

						*:abbreviate*
:ab[breviate]		list all abbreviations. The character in the first
			column indicates the mode where the abbreviation is
			used: 'i' for insert mode, 'c' for Command_line
			mode, '!' for both.

:ab[breviate] <lhs>	list the abbreviations that start with <lhs>

:ab[breviate] <lhs> <rhs>
			add abbreviation for <lhs> to <rhs>. If <lhs> already
			existed it is replaced with the new <rhs>. <rhs> may
			contain spaces.

						*:unabbreviate*
:una[bbreviate] <lhs>	remove abbreviation for <lhs> from the list

						*:noreabbrev*
:norea[bbrev] [lhs] [rhs]
			same as ":ab", but no remapping for this <rhs> {not
			in Vi}

						*:cabbrev*
:ca[bbrev] [lhs] [rhs]	same as ":ab", but for Command_line mode only. {not
			in Vi}

						*:cunabbrev*
:cuna[bbrev] <lhs>	same as ":una", but for Command_line mode only. {not
			in Vi}

						*:cnoreabbrev*
:cnorea[bbrev] [lhs] [rhs]
			same as ":ab", but for Command_line mode only and no
			remapping for this <rhs> {not in Vi}

						*:iabbrev*
:ia[bbrev] [lhs] [rhs]	same as ":ab", but for insert mode only. {not in Vi}

						*:iunabbrev*
:iuna[bbrev] <lhs>	same as ":una", but for insert mode only. {not in
			Vi}

						*:inoreabbrev*
:inorea[bbrev] [lhs] [rhs]
			same as ":ab", but for insert mode only and no
			remapping for this <rhs> {not in Vi}


4.7 Digraphs						*digraphs*

						*:digraphs*
:dig[raphs]		show currently defined digraphs. {not in Vi}

:dig[raphs] {char1}{char2} {number} ...
			Add digraph {char1}{char2} to the list. {number} is 
			the decimal representation of the character.

Digraphs are used to enter characters that normally cannot be entered by 
an ordinary keyboard. These are mostly accented characters which have the 
eighth bit set. The digraphs are easier to remember than the decimal number
that can be entered with CTRL-V (see above).

Vim must have been compiled with the 'digraphs' option enabled. If not, the 
":digraph" command will display an error message.

There are two methods to enter digraphs:			*i_digraph*
	CTRL-K {char1} {char2}		or
	{char1} <BS> {char2}
The first is always available. The second only when the 'digraph' option is 
set.

Once you have entered the digraph the character is treated like a normal 
character, taking up only one character in the file and on the screen. 
Example:
	<|> <BS> <|>	will enter the double <|> character (166)
	<a> <BS> <^>	will enter an <a> with a hat (226)
	CTRL-K <-> <->	will enter a minus sign (173)

The default digraphs are listed in the file "vim_digr.txt" |digraph_table|.
There are two sets: One that is used for MS-DOS and one for the
international standrard character set that is mostly used on Unix systems
and the Amiga. With the wrong character set they may be illogical.

For CTRL-K there is one general digraph: CTRL-K <SPACE> {char} will enter
{char} with the highest bit set. This can be used to enter meta-characters.

The <ESC> character cannot be part of a digraph. When hitting <ESC> entering
the digraph is aborted and insert mode too.

If you accidently typed an <a> that should be an <e>, you will type <a> <BS>
<e>. But that is a digraph, so you will not get what you want. To correct
this, you will have to type <BS> e again. To avoid this don't set the
'digraph' option and use CTRL-K to enter digraphs.


4.8 Using the mouse					*using_mouse*

Currently the mouse is supported under MSDOS and Unix in an xterm terminal.
Mouse clicks can be used to position the cursor and select the visual area.
There are no menus.

Clicking the left mouse button causes the cursor to be positioned. If the
click is in another window that window is made the active window. When
editing the command line the cursor can only be positioned on the command
line.

In Normal and Visual mode clicking the right mouse button causes the visual
area to be extended. When clicking in a window which is editing another
buffer, the Visual mode is stopped.

Mouse clicks can be mapped. The codes for mouse clicks are:
     code	  mouse click		  action
   <MOUSE>L	left button pressed	set cursor position
   <MOUSE>l	left button released
   <MOUSE>M	middle button pressed
   <MOUSE>m	middle button released
   <MOUSE>R	right button pressed	set end of visual area
   <MOUSE>r	right button released
   <MOUSE>P	-			set cursor position in current
					buffer

Note: Only one button press is recognized at a time, it is not possible to
use two buttons at the same time.

The <MOUSE>P code is not produced by the use of the mouse. It can be used in
a mapping to position the cursor at the coordinates of a mouse click,
without side effects. It differs from <MOUSE>L in that it does not exit
visual mode, there is no scrolling if the click is in the first or last line
of the window and clicks in other buffers are ignored.

The coordinates for the click are not available. Exactly one of the existing
mouse clicks must be used to get the coordinates. Failing to do so will
result in further mouse clicks not to be recognized, causing the
untranslated terminal codes from the mouse clicks to be interpreted as
commands. Use <MOUSE>P to just position the cursor at the click.

Examples:
	:map <MOUSE>l	<MOUSE>L
Use a left button release in the same way as a left button press.
	:map <MOUSE>M	mc<MOUSE>Px`c
The middle mouse button is used to delete a character, without moving the
cursor. Note that this only works correctly when clicking in the current
window.
	:noremap <MOUSE>L   ms<MOUSE>Lme`sv`e
The left mouse button is used to select a visual area, between the current
cursor position and the position of the click. Note the use of ":noremap"
instead of "map" to avoid a recursive mapping.


4.9 On-line help					*online_help*

<HELP>		or					*help* *:help*
:h[elp]			Split the window and display the help file in
			read-only mode.  {not in Vi}

:h[elp] {subject}	Like ":help", additionally jump to the tag
			"subject". {not in Vi}

The help file name can be set with the 'helpfile' option. The height of the
help window can be set with the 'helpheight' option (default 20). Jump to
specific subjects by using tags. This can be done in two ways:
- Use the CTRL-] command while standing on the name of a command or option.
  This only works when the tag is an identifier.
- use the ":ta {subject}" command. This works with all characters.

Use ":q" to close the help window.

							*doc_files*
All the help files should be in one directory. The files are:
	vim_help.txt	overview and quick reference	      |vim_help.txt|
	vim_idx.txt	alphabetical index of all commands    |vim_idx.txt|
	vim_ref.txt	reference manual (this file)	      |vim_ref.txt|
	vim_win.txt	reference manual for windows commands |vim_win.txt|
	vim_diff.txt	main differences between Vim and Vi   |vim_diff.txt|
	vim_digr.txt	list of available digraphs	      |vim_digr.txt|
	vim_tips.txt	tips on using Vim		      |vim_tips.txt|

	vim_unix.txt	unix specific remarks		      |vim_unix.txt|
	vim_ami.txt	Amiga specific remarks		      |vim_ami.txt|
	vim_dos.txt	MS-DOS specific remarks		      |vim_dos.txt|
	vim_nt.txt	Windows-NT specific remarks	      |vim_nt.txt|
	vim_arch.txt	Archimedes specific remarks	      |vim_arch.txt|
	vim_mac.txt	Macintosh specific remarks	      |vim_mac.txt|

	vim_tags	tags file for documentation


	5. Editing files				*edit_files*

5.1 Introduction					*edit_intro*

Editing a file with Vim means:

1. reading the file into the internal buffer
2. changing the buffer with editor commands
3. writing the buffer into a file

As long as you don't write the buffer, the original file remains unchanged. 
If you start editing a file (read a file into the buffer), the file name is 
remembered as the "current filename".

If there already was a current filename, then that one becomes the alternate
file name. All filenames are remembered in the file list. When you enter a
filename, for editing (e.g. with ":e filename") or writing (e.g. with (:w
filename"), the filename is added to the list. You can use this list to
remember which files you edited and to quickly switch from one file to
another with the CTRL-^ command (e.g. to copy text). First type the number
of the file and then hit CTRL-^. {Vi: only one alternate filename}

						*:%* *:#* *:%<*
In Ex commands (the ones that start with a colon) <%> is replaced by the
current filename and <#> is replaced by the alternate filename. The older
alternate filenames are "#1", "#2", etc. "#0" is the same as "#". If a
"<" is appended to <%>, <#> or "#n" the extension of the file name is
removed (everything after and including the last '.' in the file name).

	%		current file name
	%<		current file name without extension
	#		alternate file name for current window
	#<		idem, without extension
	#31		alternate file number 31
	#31<		idem, without extension

CTRL-G		or					*CTRL-G* *:file*
:f[ile]			Prints the current filename (as typed) and the
			cursor position (unless the 'ruler' option is set).
			See also 'shortmess' option. {vi does not include
			column number}

{count}CTRL-G		Prints the current filename with full path and the
			cursor position.

:f[ile] {name}		Sets the current filename to {name}.

:buffers						*:buffers*
:files							*:files* *:ls*
:ls			List all the currently known file names. See
			'vim_win.txt' |:files| |:buffers| |:ls|. {not in
			Vi}

Vim will remember the full path name of a file name that you enter. In most
cases when the file name is displayed only the name you typed is shown, but
the full path name is being used if you used the ":cd" command |:cd|.

If the environment variable 'HOME' is set, and the file name starts with
that string, it is often displayed with HOME replaced by "~". This was done
to keep file names short. When reading or writing files the full name is
still used, the "~" is only used when displaying file names.

When writing the buffer, the default is to use the current filename. Thus 
when you give the "ZZ" or ":wq" command, the original file will be 
overwritten. If you do not want this, the buffer can be written into another 
file by giving a filename argument to the ":write" command. For example:
	
	vim testfile
	[change the buffer with editor commands]
	:w newfile
	:q

This will create a file "newfile", that is a modified copy of "testfile". 
The file "testfile" will remain unchanged. Anyway, if the 'backup' option is 
set, Vim renames the original file before it will be overwritten. You can 
use this file if you discover that you need the original file. See also the
'patchmode' option. The name of the backup file is the same as the original
file with 'backupext' appended. The default ".~" is a bit strange to avoid
accidently overwriting existing files. If you prefer ".bak" change the
'backupext' option. Any <.> is replaced by <_> on MSDOS machines, when Vim
has detected that an MSDOS-like filesystem is being used (e.g. messydos or
crossdos) or when the 'shortname' option is set.

Technical: On the Amiga you can use 30 characters for a file name. But on an 
	   MSDOS-compatible filesystem only 8 plus 3 characters are 
	   available. Vim tries to detect the type of filesystem when it is 
	   creating the .swp file. If an MSDOS-like filesystem is suspected, 
	   a flag is set that has the same effect as setting the 'shortname' 
	   option. This flag will be reset as soon as you start editing a 
	   new file. The flag will be used when making the filename for the 
	   ".swp" and ".~" files for the current file. But when you are 
	   editing a file in a normal filesystem and write to an MSDOS-like 
	   filesystem the flag will not have been set. In that case the 
	   creation of the ".~" file may fail and you will get an error 
	   message. Use the 'shortname' option in this case.

When you started editing without giving a file name, "No File" is displayed in
messages. If a ":write file" or ":read file" command is used, the file name
for the current file is set to the file name in that command. This is useful
when starting Vim without an argument and then doing ":read file" to start
editing a file. Or when entering text in an empty buffer and then writing it
to a file. Because the file name was set without really starting to edit that
file, you are protected from overwriting that file. This is done by setting
the "notedited" flag. You can see if this flag is set with the CTRL-G or
":file" command. It will include "[Not edited]" when the "notedited" flag is
set. When writing the buffer to the current file name (with ":w!"), the
"notedited" flag is reset.

Vim remembers whether you have changed the buffer. You are protected from
losing the changes you made. If you try to quit without writing, or want to
start editing another file, this will be refused. In order to overrule this
protection add a <!> to the command. The changes will then be lost. For
example: ":q" will not work if the buffer was changed, but ":q!" will. To see
whether the buffer was changed use the "CTRL-G" command. The message includes
the string "[Modified]" if the buffer has been changed.


5.2 Editing a file					*edit_a_file*

							*:edit*
:e[dit] [+cmd]		Edit the current file, unless changes have been made.

							*:edit!*
:e[dit]! [+cmd]		Edit the current file always. Discard any changes to
			the buffer.

							*:edit_f*
:e[dit] [+cmd] {file}	Edit {file}, unless changes have been made.

							*:edit!_f*
:e[dit]! [+cmd] {file}	Edit {file} always. Discard any changes to the
			buffer.

:e[dit] #[count]        Edit the [count]th alternate filename (as shown by
                        :files). This command does the same as [count] CTRL-^.

							*:ex*
:ex [+cmd] [file]	Same as :edit. {Vi: go from visual to Ex mode}

							*:visual*
:vi[sual] [+cmd] [file]	Same as :edit. {Vi: go from Ex to Visual mode}

							*:view*
:vie[w] [+cmd] file	Same as :edit, but set 'readonly' option for this
			buffer. {not in Vi}

							*CTRL-^*
[count]CTRL-^		Edit [count]th alternate file (equivalent to ":e
			#[count]"). Without count this gets you to the
			previously edited file. This is a quick way to
			toggle between two (or more) files. If the
			'autowrite' option is set and the buffer was
			changed, write it.

]f							*]f*
[f							*[f* *gf*
gf			Edit the file whose name is under or after the
			cursor. Mnemonic: "goto file". Uses the 'path'
			variable as a list of directory names to look for
			the file. Also looks for the file relative to the
			current file. This command fails if the current file
			cannot be abandoned. If the name is a hypertext
			link, that looks like "type://machine/path", only
			"/path" is used.  {not in Vi}

							*:cd*
:cd			On non-Unix systems: Print the current directory
			name. On Unix systems: Change the current directory
			to the home directory.

:cd {path}		Change the current directory to {path}. Does not
			change the meaning of an already entered file name,
			because its full path name is remembered.

							*:chdir*
:chd[ir] [path]		Same as :cd.

							*:pwd*
:pwd			Print the current directory name. {Vi: no pwd}

These commands are used to start editing a single file. This means that the
file is read into the buffer and the current filename is set. You may use the
":cd" command to get to another directory, so you will not have to type that 
directory name in front of the filenames. One warning: After using ":cd" the
full path name will be used for reading and writing files. On some networked
file systems this may cause problems. The result of using the full path name
is that the file names currently in use will remain referring to the same
file. Example: If you have a file a:test and a directory a:vim the commands
":e test" ":cd vim" ":w" will overwrite the file a:test and not write
a:vim/test. But if you do ":w test" the file a:vim/test will be written,
because you gave a new file name and did not refer to a file name before the
":cd".

Note for systems other than Unix and MS-DOS: When using a command that
accepts a single file name (like ":edit file") spaces in the file name are
allowed, but trailing spaces are ignored.  This is useful on systems that
allow file names with embedded spaces (like the Amiga). Example: The command
":e   Long File Name " will edit the file "Long File Name". When using a
command that accepts more than one file name (like ":next file1 file2")
embedded spaces must be escaped with a backslash.

You can use the ":e!" command if you messed up the buffer and want to start 
all over again. The ":e" command is only useful if you have changed the 
current filename.

Note that ":e file" will fail if there are changes in the current buffer,
also when the 'autowrite' option is set. This is unlogical, because with
other commands (e.g. ":next") the current buffer would be written and
abandoned, but this behaviour is compatible with vi. If you encounter this
problem, you can use CTRL-^ to jump to the file, because the alternate file
name is set to the argument of the ":e" command.

The [+cmd] can be used to position the cursor in the newly opened file:
	+		Start at the last line.
	+{num}		Start at line {num}.
	+/{pat}		Start at first line containing {pat}. {pat} must not
			contain any spaces.
	+{command}	Execute {command} after opening the new file.
			{command} is an Ex command. It must not contain 
			spaces.

When reading a file when the 'textmode' option is off (default for
non-MSDOS) the <LF> character is interpreted as end-of-line. If 'textmode'
is on (default for MSDOS), <CR><LF> is also interpreted as end-of-line.

When writing a file when the 'textmode' option is off a <LF> character is
used to separate lines. When the 'textmode' option is on <CR><LF> is used.

You can read a file with 'textmode' set and write it with 'textmode' reset.
This will replace all <CR><LF> pairs by <LF>. If you read a file with
'textmode' reset and write with 'textmode' set, all <LF> characters will be
replaced by <CR><LF>.

If you start editing a new file and the 'textauto' option is set, Vim will
try to detect whether the lines in the file are separated by a single <LF>
(as used on Unix and Amiga) or by a <CR><LF> pair (MSDOS). It reads up to
the first <LF> and checks if there is a <CR> in front of it. If there is the
'textmode' option is set, otherwise it is reset. If the 'textmode' option is
set on non-MSDOS systems the message "[textmode]" is shown to remind you
that something unusual is happening. On MSDOS systems you get the message
"[notextmode]" if the 'textmode' option is not set.

Before editing binary, executable or Vim script files you should set the
'textmode' and 'textauto' options off. With 'textmode' on you risk that
single <LF> characters are unexpectedly replaced with <CR><LF>. A simple way
to do this is by starting Vim with the "-b" option.


5.3 The argument list					*argument_list*

If you give more than one filename when starting Vim, this list is
remembered as the argument list. Do not confuse this with the file list,
which you can see with the ":files" command |:files|. The argument list was
already present in vi, the file list is new in Vim. The file names in the
argument list will also be present in the file list (unless they were
deleted with ":bdel").

You can use the argument list with the following commands:

							*:args*
:ar[gs]			Print the argument list, with the current file in
			square brackets.

							*:argument*
:[count]argu[ment] [count] [+cmd]
			Edit file [count] in the argument list, unless
			changes have been made and the 'autowrite' option is
			off. {Vi: no such command}

:[count]argu[ment]! [count] [+cmd]
			Edit file [count] in the argument list, discard any
			changes to the current buffer. {Vi: no such command}

							*:next*
:[count]n[ext] [+cmd]	Edit [count] next file, unless changes have been 
			made and the 'autowrite' option is off {Vi: no 
			count}.

:[count]n[ext]! [+cmd]	Edit [count] next file, discard any changes to the 
			buffer {Vi: no count}.

:ar[gs] [+cmd] {filelist}
:n[ext] [+cmd] {filelist}
			Define {filelist} as the new argument list and edit
			the first one, unless changes have been made and the
			'autowrite' option is off.

:ar[gs]! [+cmd] {filelist}
:n[ext]! [+cmd] {filelist}				*:next_f*
			Define {filelist} as the new argument list and edit
			the first one. Discard any changes to the buffer.

:[count]N[ext] [count] [+cmd]				*:Next*
			Edit [count] previous file in argument list, unless 
			changes have been made and the 'autowrite' option is 
			off {Vi: no count}.

:[count]N[ext]! [count] [+cmd]
			Edit [count] previous file in argument list. Discard
			any changes to the buffer {Vi: no count}.

:[count]pre[vious] [count] [+cmd]			*:previous*
			Same as :Next {Vi: only in some versions}

							*:rewind*
:rew[ind] [+cmd]	Start editing the first file in the argument list,
			unless changes have been made and the 'autowrite'
			option is off.

:rew[ind]! [+cmd]	Start editing the first file in the argument list.
			Discard any changes to the buffer.

							*:last*
:la[st] [+cmd]		Start editing the last file in the argument list, unless
			changes have been made and the 'autowrite' option is
			off. {not in Vi}

:la[st]! [+cmd]		Start editing the last file in the argument list.
			Discard any changes to the buffer. {not in Vi}

							*:wnext*
:[count]wn[ext] [+cmd]	Write current file and start editing the [count] 
			next file. {not in Vi}

:[count]wn[ext] [+cmd] {file}
			Write current file to {file} and start editing the
			[count] next file, unless {file} already exists and
			the 'writeany' option is off. {not in Vi}

:[count]wn[ext]! [+cmd] {file}
			Write current file to {file} and start editing the
			[count] next file. {not in Vi}

:[count]wN[ext][!] [+cmd] [file]			*:wNext*
:[count]wp[revous][!] [+cmd] [file]			*:wprevious*
			Same as :wnext, but go to previous file instead of
			next. {not in Vi}

The [count] in the commands above defaults to one. For some commands it is
possible to use two counts. The last one (rightmost one) is used.

For [+cmd] see 5.2 |edit_a_file|.

The wildcards in the argument list are expanded and the filenames are sorted.
Thus you can use the command "vim *.c" to edit all the C files. From within 
Vim the command ":n *.c" does the same.

You are protected from leaving Vim if you have not been editing the last
file in the argument list. This prevents you from forgetting that you were
editing one out of several files. To exit anyway try to exit twice. If there
are changes in the current buffer this will fail. You can exit anyway, and
save any changes, with the ":wq!" command. To lose any changes use the ":q!"
command.


5.4 Writing and quitting				*write_quit*

							*:write*
:[range]w[rite][!]	Write the specified lines to the current file.

							*:write_f*
:[range]w[rite]	{file}	Write the specified lines to {file}, unless it
			already exists and the 'writeany' option is off.

:[range]w[rite]! {file}	Write the specified lines to {file}. Overwrite an
			existing file.

							*:write_a*
:[range]w[rite][!] >>	Append the specified lines to the current file.

:[range]w[rite][!] >> {file}
			Append the specified lines to {file}. <!> forces the
			write even if file does not exist.

							*:write_c*
:[range]w[rite] !{cmd}	Execute {cmd} with [range] lines as standard input
			(note the space in front of the <!>).

The default [range] for the ":w" command is the whole buffer (1,$).
If a file name is give with ":w" it becomes the alternate file. This can be
used when the write fails and you want to try again later with ":w #".


							*:quit*
:q[uit]			Quit, unless changes have been made or not editing 
			the last file in the argument list.

:q[uit]!		Quit always, without writing.

							*:cq*
:cq			Quit always, without writing, and return an error 
			code. Used for Manx's QuickFix mode (see 5.5
			|quickfix|).

							*:wq*
:wq			Write the current file. Exit if not editing the
			last file in the argument list.

:wq!			Write the current file and exit.

:wq {file}		Write to {file}. Exit if not editing the last
			file in the argument list.

:wq! {file}		Write to {file} and exit.

							*:xit*
:x[it][!] [file]	Like ":wq", but write only when changes have been
			made.

							*:exit*
:exi[t][!] [file]	Same as :xit.

							*ZZ*
ZZ			Write current file, if modified, and exit (same as
			":x").

If you write to an existing file (but do not append) while the 'backup' or 
'writebackup' option is on, a backup of the original file is made. On Unix 
systems the file is copied, on other systems the file is renamed. After the 
file has been successfully written and when the 'writebackup' option is on 
and the 'backup' option is off, the backup file is deleted.

						*backup_table*
'backup'	'writebackup'	action
   off		     off	no backup made
   off		     on		backup made, deleted afterwards (default)
   on		     off	backup made, not deleted
   on		     on		backup made, not deleted

On Unix systems:
When you write to an existing file, that file is truncated and then filled 
with the new text. This means that protection bits, owner and symbolic links 
are unmodified. The backup file however, is a new file, owned by the user 
who edited the file. If it is not possible to create the backup file in the 
same directory as the original file, the directory given with the 
'backupdir' option is used (default: home directory).

If the creation of a backup file fails, the write is not done. If you want 
to write anyway add a <!> to the command.

If the writing of the new file fails, you have to be careful not to loose
your changes AND the original file. If there is no backup file and writing
the new file failed, you have already lost the original file. Don't exit Vim
until you wrote out the file! If a backup was made, it is put back in place
of the original file (if possible). If you exit Vim, and loose the changes
you made, the original file will still be there. If putting back the
original file fails, there will be an error message telling you that you
lost the original file.

If the 'textmode' option is set <CR><LF> is used for end-of-line. This is
default for MSDOS. On other systems the message "[textmode]" is shown to
remind you that an usual end-of-line marker was used. If the 'textmode' is
not set LF is used for end-of-line. On MSDOS the message "[notextmode]" is
shown. See also the 'textmode' and 'textauto' options.


5.5 Using the QuickFix mode				*quickfix*

Vim has a special mode to speedup the edit-compile-edit cycle. This is
inspired by the quickfix option of the Manx's Aztec C compiler on the Amiga.
The idea is to save the error messages from the compiler in a file and use
Vim to jump to the errors one by one. You can then examine each problem and
fix it, without having to remember all the error messages.

If you are using Manx's Aztec C compiler on the Amiga you should do the
following:
- Set the CCEDIT environment variable with the command
	mset "CCEDIT=vim -e"
- Compile with the -qf option. If the compiler finds any errors, Vim is 
  started and the cursor is positioned on the first error. The error message
  will be displayed on the last line. You can go to other errors with the
  commands mentioned below. You can fix the errors and write the file(s).
- If you exit Vim normally the compiler will re-compile the same file. If you
  exit with the :cq command, the compiler will terminate. Do this if you
  cannot fix the error, or if another file needs to be compiled first.

If you are using another compiler you should save the error messages in a
file and start Vim with "vim -e filename". An easy way to do this is with
the ":make" command (see below). The 'errorformat' option should be set to
match the error messages from your compiler (see below).

The following commands can be used if you are in QuickFix mode:

							*:cc*
:cc [nr]		Display error [nr]. If [nr] is omitted, the same
			error is displayed again. {not in Vi}

							*:cnext*
:[count]cn[ext]		Display the [count] next error in the list that
			includes a file name. If there are no file names at
			all, go the the [count] next error. {not in Vi}

							*:cprevious*
:[count]cp[revious]	Display the [count] previous error in the list that
			includes a file name. If there are no file names at
			all, go the the [count] previous error. {not in Vi}

							*:cquit*
:cq[uit]		Quit Vim with an error code, so that the compiler
			will not compile the same file again. {not in Vi}

							*:cfile*
:cf[ile] [errorfile]	Read the error file and jump to the first error.
			This is done automatically when Vim is started with
			the -e option. You can use this command when you
			keep Vim running while compiling. If you give the
			name of the errorfile, the 'errorfile' option will
			be set to [errorfile] {not in Vi}

							*:clist*
:cl[ist]		List all errors that inlcude a file name. {not in Vi}

:cl[ist]!		List all errors. {not in Vi}

							*:make*
:make [arguments]	1. If the 'autowrite' option is set and the buffer
			   was changed, write it.
			2. Any existing 'errorfile' is deleted.
			3. The program given with the 'makeprg' option is
			   started (default "make") with the optional
			   [arguments] and the output is saved in
			   'errorfile' (for Unix it is also echoed on the
			   screen).
			4. The 'errorfile' is then read and the first error
			   is jumped to.
			5. The 'errorfile' is deleted.
			{not in Vi}

The name of the file can be set with the 'errorfile' option. The default is 
"AztecC.Err" for the Amiga and "errors" for other systems. The format of the
file from the Aztec compiler is:

	filename>linenumber:columnnumber:errortype:errornumber:errormessage

	filename	name of the file in which the error was detected
	linenumber	line number where the error was detected
	columnnumber	column number where the error was detected
	errortype	type of the error, normally a single <E> or <W>
	errornumber	number of the error (for lookup in the manual)
	errormessage	description of the error

Another compiler is likely to use a different format. You should set the
'errorformat' option to a scanf-like string that describes the format. First
you need to know how scanf works. Look in the documentation of your C
compiler. Vim will understand eight conversion characters. Others are invalid.
	%f		file name (finds a string)
	%l		line number (finds a number)
	%c		column number (finds a number)
	%t		error type (finds a single character)
	%n		error number (finds a number)
	%m		error message (finds a string)
	%*<conv>	any scanf non-assignable conversion
	%%		the single <%> character

Examples:
"%f>%l:%c:%t:%n:%m"			for the AztecC.Err file
"%f:%l:\ %t%*[^0123456789]%n:\ %m"	for Aztec C error messages
"%f\ %l\ %t%*[^0123456789]%n:\ %m"	for SAS C
"\"%f\",%*[^0123456789]%l:\ %m"		default for generic C compilers
"%f:%l:\ %m"				for GCC

Note the backslash in front of a space and double quote. It is required for
the :set command.

The "%f" and "%m" conversions have to detect the end of the string. They
should be followed by a character that cannot be in the string. Everything
up to that character is included in the string. Be careful: "%f%l" will
include everything up to the first <%> in the file name. If the "%f" or "%m"
is at the end, everything up to the end of the line is included.

If a line is detected that does not completely match the 'errorformat', the
whole line is put in the error message and the entry is marked "not valid"
These lines are skipped with the ":cn" and ":cp" commands (unless there is
no valid line at all). You can use ":cl" to display all the error messages.

If the error format does not contain a file name Vim cannot switch to the
correct file. You will have to do this by hand.

If you have a compiler that produces error messages that do not fit in the
format string, you could write a program that translates the error messages
into this format. You can use this program with the ":make" command by
changing the 'makeprg' option. For example:
	":set mp=make\ \\\|&\ error_filter".
The backslashes before the pipe character are required to avoid it to be
recognized as a command separator. The backslash before each space is
required for the set command.

						*:make_makeprg*
The ":make" command executes the command given with the 'makeprg' option.
This is done by passing the command to the shell given with the 'shell'
option. This works almost like typing

	":!{makeprg} [arguments] {shellpipe} {errorfile}".

{makeprg} is the string given with the 'makeprg' option. Any command can be
used, not just "make". Characters <%> and <#> are expanded as usual on a
command line. You can use "#<" to insert the current filename without
extension, for example ":set makeprg=make\ #<.o".

[arguments] is anything that is typed after ":make".
{shellpipe} is the 'shellpipe' option.
{errorfile} is the 'errorfile' option.

The 'shellpipe' option defaults to ">" for the Amiga and MSDOS. This means
that the output of the compiler is saved in a file and not shown on the
screen directly. For Unix "| tee" is used. The compiler output is shown on
the screen and saved in a file the same time. Depending on the shell used
"|& tee" or "2>&1| tee" is the default, so stderr output will be included.

There are some restrictions to the Quickfix mode on the Amiga. The
compiler only writes the first 25 errors to the errorfile (Manx's
documentation does not say how to get more). If you want to find the others,
you will have to fix a few errors and exit the editor. After recompiling,
up to 25 remaining errors will be found.

On the Amiga, if Vim was started from the compiler, the :sh and :! commands
will not work, because Vim is then running in the same process as the
compiler and these two commands may guru the machine then.

If you insert or delete lines, mostly the correct error location is still 
found because hidden marks are used (Manx's Z editor does not do this). 
Sometimes, when the mark has been deleted for some reason, the message "line 
changed" is shown to warn you that the error location may not be correct. If 
you quit Vim and start again the marks are lost and the error locations may
not be correct anymore.


5.6 Editing binary files				*edit_binary*

Although Vim was made to edit text files, it is possible to edit binary
files. The "-b" command line option (b for binary) sets some options for
editing binary files ('binary' on, 'textwidth' to 0, 'textmode' and
'textauto' off, 'modelines' to 0, 'expandtab' off). Setting the 'binary'
option has the same effect. Don't forget to do this before reading the file.

There are a few things to remember when editing binary files:
- When editing executable files the number of characters must not change.
  Use only the "R" or "r" command to change text. Do not delete characters
  with "x" or by backspacing.
- Set the 'textwidth' option to 0. Otherwise lines will unexpectedly be
  split in two.
- When there are not many end-of-line characters, the lines will become very
  long. If you want to edit a line that does not fit on the screen reset the
  'wrap' option. Horizontal scrolling is used then. If a line becomes too
  long (more than about 32767 characters on the Amiga, much more on 32-bit
  systems) you cannot edit that line. The line will be split when reading
  the file. It is also possible that you get an "out of memory" error when
  reading the file.
- Make sure the 'textmode' and 'textauto' options are off before loading the
  file. In 'textmode' both <CR><LF> and <LF> are considered to end a line
  and when the file is written the <LF> will be replaced by <CR><LF>. The
  'modelines' option should also be off, because there may be a string like
  ":vi:" in the file that would give unpredictable results.
- <NUL> characters are shown on the screen as ^@. You can enter them with
  "CTRL-V CTRL-@" or "CTRL-V 000" {vi cannot handle <NUL> characters in the
  file}
- To insert a <LF> character in the file split up a line. When writing the
  buffer to a file a <LF> will be written for the end of line.
- Vim normally appends an end-of-line character at the end of the file if
  there is none. Setting the 'binary' option prevents this. If you want to
  add the final end-of-line, set the 'endofline' option. You can also read the
  value of this option to see if there was an end-of-line character for the
  last line (you cannot see this in the text).


5.7 Automatic commands					*autocommand*

When starting to edit a file whose name matches a particular pattern,
certain commands can be executed.  For example, tw=0 can be set for
files matching *.c, and tw=76 can be set otherwise. These commands are
normally put in your .vimrc or .exrc file. {All this is not in Vi}

The auto-commands are executed just before reading the file. Any modelines
in the file overrule the auto-commands.

Note: This command cannot be followed by another command, since any '|' is
considered part of the command.

							*:autocmd*
:au[tocmd] {pat} {cmd}	Add {cmd} to the list of commands that will be
			automatically executed when editing a file
			matching {pat}.

:au[tocmd] {pat}	Show the auto-commands associated with {pat}.

:au[tocmd]		Show all auto-commands.

:au[tocmd]! {pat} {cmd} Remove all auto-commands associated with {pat}, and
			add the command {cmd}.

:au[tocmd]! {pat}   	Remove all auto-commands associated with {pat}.

:au[tocmd]!     	Remove ALL auto-commands.

							*:doautocmd*
:do[autocmd] [fname]	Apply the autocommands matching [fname] (default:
			current file name) to the current buffer. This can
			be used when the current file name does not match
			the right pattern, or after changing settings.

{pat} may be "default" for commands that should be used when no other
pattern matches.  Multiple patterns may be given separated by commas.  Here
are some examples:

  :autocmd *.c,*.h  set tw=0 smartindent noic
  :autocmd default  set tw=79 nosmartindent ic infercase

For makefiles (makefile, Makefile, imakefile, makefile.unix, etc):

  :autocmd *akefile*    set include=^s\=include
  :autocmd *.c,*.h  abbr FOR for(i = 0; i < 3; i++)^M{^M}^[O

To always start editing C files at the first function:

  :autocmd *.c,*.h  1;/^{

Without the "1;" above, the search would start from wherever the file was
entered, rather than from the start of the file.  When entering :autocmd on
the command line, completion of command names may be done (with tab etc)
where appropriate.


	6. Cursor motions				*cursor_motions*

These commands move the cursor position. If the new position is off of the
screen, the screen is scrolled to show the cursor (see also 'scrolljump' 
option).

The motion commands can be used after other commands, called operators, to
have the command operate on the text that was moved over. That is the text
between the cursor position before and after the motion. If the motion
includes a count and the operator also had a count, the two counts are
multiplied. For example: "2d3w" deletes six words.
	The operator either affects whole lines, or the characters between 
the start and end position. Generally, motions that move between lines
affect lines (are linewise), and motions that move within a line affect
characters. However, there are some exceptions.
	A character motion is either inclusive or exclusive. When inclusive,
the start and end position of the motion are included in the operation.
When exclusive, the last character towards the end of the buffer is not
included. Linewise motions always include the start and end position.
	Which motions are linewise, inclusive or exclusive is mentioned 
below. There are however, two general exceptions:
1. If the motion is exclusive and the end of the motion is in column 1, the 
   end of the motion is moved to the end of the previous line and the motion 
   becomes inclusive. Example: "}" ends at the first line after a paragraph, 
   but "V}" will not include that line.
2. If the motion is exclusive, the end of the motion is in column 1 and the 
   start of the motion was at or before the first non-blank in the line, the 
   motion becomes linewise. Example: If a paragraph begins with some blanks 
   and you do "d}" while standing on the first non-blank, all the lines of 
   the paragraph are deleted, including the blanks. If you do a put now, the 
   deleted lines will be inserted below the cursor position.

Instead of first giving the operator and then a motion you can use Visual
mode: mark the start of the text with <v>, move the cursor to the end of the
text that is to be affected and then hit the operator. The text between the
start and the cursor position is highlighted, so you can see what text will
be operated upon. This allows much more freedom, but requires more key
strokes and has limited redo functionality. See the chapter on Visual mode
|visual_mode|.

If you want to know where you are in the file use the "CTRL-G" command. If 
you set the 'ruler' option, the cursor position is continuously shown in the 
status line (which slows down Vim a little).

NOTE: Experienced users prefer the hjkl keys because they are always right
under their fingers. Beginners often prefer the arrow keys, because they
do not know what the hjkl keys do. The mnemonic value of hjkl is clear from
looking at the keyboard. Think of j as an arrow pointing downwards.


6.1 Left-right motions					*left_right_motions*

h		or					*h*
<C_LEFT>	or					*cur_left*
CTRL-H		or					*CTRL-H* *bs*
<BS>			[count] characters to the left (exclusive).
			Note: If you prefer <BS> and <DEL> to delete a
			character, use the mappings:
				:map CTRL-V<BS>		X
				:map CTRL-V<DEL>	x
			(to enter "CTRL-V<BS>" type the CTRL-V key, followed
			by the <BS> key)

l		or					*l*
<C_RIGHT>	or					*cur_right* *space*
<SPACE>			[count] characters to the right (exclusive).

							*0* *home*
0 or <HOME>		To the first character of the line (exclusive).

							*^*
^			To the first non-blank character of the line
			(exclusive).

							*$* *end*
$  or <END>		To the end of line [count] from the cursor
			(inclusive).

							*bar*
|			To column [count] (exclusive).

							*f*
f<char>			To [count]'th occurrence of <char> to the right. The
			cursor is placed on <char> (inclusive).

							*F*
F<char>			To the [count]'th occurrence of <char> to the left.
			The cursor is placed on <char> (inclusive).

							*t*
t<char>			Till before [count]'th occurrence of <char> to the
			right. The cursor is placed on the character left of 
			<char> (inclusive).

							*T*
T<char>			Till after [count]'th occurrence of <char> to the
			left. The cursor is placed on the character right of
			<char> (inclusive).

							*;*
;			Repeat latest f, t, F or T [count] times.

							*,*
,			Repeat latest f, t, F or T in opposite direction
			[count] times.

These commands move the cursor to the specified column in the current line.
They stop at the first column and at the end of the line, except "$", which 
may move to one of the next lines.


6.2 Up-down motions					*up_down_motions*

k		or					*k*
<C_UP>		or					*cur_up* *CTRL-P*
CTRL-P			[count] lines upward (linewise).

j		or					*j*
<C_DOWN>	or					*cur_down*
CTRL-J		or					*CTRL-J*
<LF>		or					*linefeed* *CTRL-N*
CTRL-N			[count] lines downward (linewise).

							*-*
-  <minus>		[count] lines upward, on the first non-blank
			character (linewise).

+		or					*+*
CTRL-M		or					*CTRL-M* *cr*
<CR>			[count] lines downward, on the first non-blank
			character (linewise).

							*_*
_  <underscore>		[count] - 1 lines downward, on the first non-blank
			character (linewise).

							*G*
G			Goto line [count], default last line, on the first
			non-blank character (linewise). If 'startofline' not
			set, keep the same column.

							*gg*
gg			Goto line [count], default first line, on the first
			non-blank character (linewise). If 'startofline' not
			set, keep the same column.

:[range]		Set the cursor on the (last) specified line number
			(cannot be used with an operator).

							*N%*
{count}%		Go to {count} percentage in the file, on the first
			non-blank in the line (linewise). To compute the new
			line number this formula is used: {count} *
			number-of-lines / 100. See also 'startofline'
			option. {not in Vi}

These commands move to the specified line. They stop when reaching the first 
or the last line. The first two commands put the cursor in the same column 
(if possible) as it was after the last command that changed the column, 
except after the "$" command, then the cursor will be put on the last 
character of the line.


6.3 Word motions					*word_motions*

<SC_RIGHT>	or					*scur_right* *w*
w			[count] words forward (exclusive).

							*W*
W			[count] WORDS forward (exclusive).

							*e*
e			Forward to the end of word [count] (inclusive).

							*E*
E			Forward to the end of WORD [count] (inclusive).

<SC_LEFT>	or					*scur_left* *b*
b			[count] words backward (exclusive).

							*B*
B			[count] WORDS backward (exclusive).

These commands move over words or WORDS. A word consists of a sequence of 
letters, digits and underscores, or a sequence of other non-blank 
characters, separated with white space (spaces, tabs, end of line). A WORD
consists of a sequence of non-blank characters, separated with white space.
An empty line is also considered to be a word and a WORD.

Special case: "cw" and "cW" are treated like "ce" and "cE" if the cursor is 
on a non-blank. This is because "cw" is interpreted as change-word, and a 
word does not include the following white space. {Vi: "cw" when on a blank 
followed by other blanks changes only the first blank; this is probably a 
bug, because "dw" deletes all the blanks}

Another special case: When using the "w" motion in combination with an 
operator and the last word moved over is at the end of a line, the end of 
that word becomes the end of the operated text, not the first word in the 
next line.

The original vi implementation of "e" is buggy. For example, the "e" command 
will stop on the first character of a line if the previous line was empty. 
But when you use "2e" this does not happen. In Vim "ee" and "2e" are the 
same, which is more logical. However, this causes a small incompatibility 
between vi and Vim.


6.4 Text object motions					*object_motions*

							*(*
(			[count] sentences backward (exclusive).

							*)*
)			[count] sentences forward (exclusive).

							*{*
{			[count] paragraphs backward (exclusive).

							*}*
}			[count] paragraphs forward (exclusive).

							*]]*
]]			[count] sections forward or to the next <{> in the
			first column. When used after an operator, then the
			<}> in the first column. (linewise).

							*][*
][			[count] sections forward or to the next <}> in the
			first column (linewise).

							*[[*
[[			[count] sections backward or to the previous <{> in
			the first column (linewise).

							*[]*
[]			[count] sections backward or to the previous <}> in
			the first column (linewise).

These commands move over three kinds of text objects.

A sentence is defined as ending at a <.>, <!> or <?> followed by either the 
end of a line, or by a space. {Vi: two spaces} Any number of closing <)>, 
<]>, <"> and <'> characters my appear after the <.>, <!> or <?> before the 
spaces or end of line. A paragraph and section boundary is also a sentence 
boundary.

A paragraph begins after each empty line, and also at each of a set of 
paragraph macros, specified by the pairs of characters in the 'paragraphs' 
option. The default is "IPLPPPQPP LIpplpipbp", which corresponds to the 
macros ".IP", ".LP", etc. (these are nroff macros, the dot must be in the 
first column). A section boundary is also a paragraph boundary. Note that
this does not include a <{> or <}> in the first column.

A section begins after a form-feed in the first column and at each of a set
of section macros, specified by the pairs of characters in the 'sections'
option. The default is "SHNHH HUnhsh".

The "]" and "[" commands stop at the <{> or <}" in the first column. This is
useful to find the start or end of a function in a C program. Note that the
first character of the command determines the search direction and the
second character the type of brace found.


6.5 Pattern searches					*pattern_searches*

							*/*
/{pattern}[/]<CR>	Search forward for the [count]'th occurrence of
			{pattern} (exclusive).

/{pattern}/{offset}<CR>	Search forward for the [count]'th occurrence of
			{pattern} and go {offset} lines up or down (see 
			below). (linewise).

							*/<CR>*
/<CR>			Search forward for the [count]'th latest used
			pattern with latest used {offset}.

//{offset}<CR>		Search forward for the [count]'th latest used
			pattern with new {offset}. If {offset} is empty no
			offset is used.

							*?*
?{pattern}[?]<CR>	Search backward for the [count]'th previous
			occurrence of {pattern} (exclusive).

?{pattern}?{offset}<CR>	Search backward for the [count]'th previous
			occurrence of {pattern} and go {offset} lines up or
			down (see below) (linewise).

							*?<CR>*
?<CR>			Search backward for the [count]'th latest used
			pattern with latest used {offset}.

??{offset}<CR>		Search backward for the [count]'th latest used
			pattern with new {offset}. If {offset} is empty no
			offset is used.

							*n*
n			Repeat the latest "/" or "?" [count] times. {Vi: no
			count}

							*N*
N			Repeat the latest "/" or "?" [count] times in
			opposite direction. {Vi: no count}

							*star*
*			Search forward for the [count]'th occurrence of the
			ident after or under the cursor (exclusive). Only
			whole words are search for, like with the command
			"/\<indent\>". If there is no identifier after or
			under the cursor, any non-blank word is used to
			search for. {not in Vi}

							*#*
#			Same as "*", but search backward. {not in Vi}

							*gd*
gd			Goto local Declaration. When the cursor is on a
			local variable, this command will jump to its
			declaration.  First a search is made for the end of
			the previous function, just like "[]". If it is not
			found the search stops in line 1. From this position
			a search is made for the identifier under the
			cursor, like with "*", but lines that look like a
			comment are ignored (see 'comments' option). Note
			that this is not guaranteed to work, Vim does not
			really check the syntax, it only searches for a
			match with the identifier. If included files also
			need to be searched use the commands listed in
			|include_search|. {not in Vi}

							*gD*
gD			Goto global Declaration. When the cursor is on a
			global variable that is defined in the file, this
			command will jump to its declaration. This works
			just like "gd", except that the search for the
			identifier always starts in line 1. {not in Vi}

							*CTRL-C*
CTRL-C			Interrupt current (search) command.

While typing the search pattern the current match will be shown if the
'incsearch' option is on.

These commands search for the specified pattern. With "/" and "?" an 
additional offset may be given. There are two types of offsets: line offsets 
and character offsets. {the character offsets are not in Vi}

The offset gives the cursor position relative to the found match:
    [num]	[num] lines downwards, in column 1
    +[num]	[num] lines downwards, in column 1
    -[num]	[num] lines upwards, in column 1
    e[+num]	[num] characters to the right of the end of the match
    e[-num]	[num] characters to the left of the end of the match
    s[+num]	[num] characters to the right of the start of the match
    s[-num]	[num] characters to the left of the start of the match
    b[+num]	[num] characters to the right of the start (begin) of the match
    b[-num]	[num] characters to the left of the start (begin) of the match

If a <-> or <+> is given but [num] is omitted, a count of one will be used.
When including an offset with 'e', the search becomes inclusive (the
character the cursor lands on is included in operations).

Examples:

pattern			cursor position
/test/+1		one line below "test", in column 1
/test/e			on the last t of "test"
/test/s+2		on the <s> of "test"
/test/b-3		three characters before "test"

If one of these commands is used after an operator, the characters between 
the cursor position before and after the search is affected. However, if a 
line offset is given, the whole lines between the two cursor positions are 
affected.

The last used <pattern> and <offset> are remembered. They can be used to
repeat the search, possibly in another direction or with another count. Note
that two patterns are remembered: one for 'normal' search commands and one
for the substitute command ":s". Each time an empty <pattern> is given, the
previously used <pattern> is used.

{In vi the :tag command sets a new search pattern when the tag is searched
for. In Vim this is not done, the previous search pattern is still
remembered}.

If the 'wrapscan' option is set (which is the default), searches wrap around 
the end of the buffer. If 'wrapscan' is not set, the backward search stops 
at the beginning and the forward search stops at the end of the buffer. If 
'wrapscan' is set and the pattern was not found the error message "pattern
not found" is given, and the cursor will not be moved. If 'wrapscan' is not
set the message becomes "search hit BOTTOM without match" when searching
forward, or "search hit TOP without match" when searching backward. If
wrapscan is set and the search wraps around the end of the file the message
"search hit TOP, continuing at BOTTOM" or "search hit BOTTOM, continuing at
TOP" is given when searching backwards or forwards respectively.

The "*" and "#" commands search for the identifier currently under the
cursor. If there is no identifier under the cursor, the first one to the
right is used. This identifier may only contain letters, digits and
characters in 'identchars'. Note that if you type with ten fingers, the
characters are easy to remember: the "#" is under your left hand middle
finger (search to the left and up) and the "*" is under your right hand
middle finger (search to the right and down). If there is no identifier
under or after the cursor, a search is done for any word under or after the
cursor. Blanks (<TAB>s and/or <SPACE>s) are recognized as delimiters for
this word.


The definition of a pattern:				*search_pattern*

Patterns may contain special characters, depending on the setting of the
'magic' option.

1.  A pattern is one or more branches, separated by '\|'. It matches anything
    that matches one of the branches. Example: "foo\|bar" matches "foo" and
    "bar.

2.  A branch is one or more pieces, concatenated. It matches a match for the
    first, followed by a match for the second, etc. Example: "foo[0-9]bar",
    first match "foo", then a digit and then "bar".

3.  A piece is an atom, possibly followed by:
      'magic'	'nomagic'
      option    option
	*	  \*		matches 0 or more of the preceding atom
	\+	  \+		matches 1 or more of the preceding atom {not
				in Vi}
	\=	  \=		matches 0 or 1 of the preceding atom {not in
				Vi}
    Examples:
       .*	  .\*		match anything, also empty string
       .\+	  .\+		match any non-empty string
       foo\=	  foo\=		match "fo" and "foo"


4.  An atom can be:
    - One of these five:
      magic	nomagic
	.	  \.		matches any single character
	\<	  \<		matches the beginning of a word
	\>	  \>		matches the end of a word
	^	  ^		at beginning of pattern, matches start of
				line
	$	  $		at end of pattern or in front of '\|',
				matches end of line
	~         \~		matches the last given substitute pattern
    - A pattern enclosed by escaped parentheses (e.g. "\(^a\)").
    - A single character, with no special meaning, matches itself
    - A backslash followed by a single character, with no special meaning,
      matches the single character.
    - A range. This is a sequence of characters enclosed in '[]' with the 
      'magic' option, or enclosed in '\[]' with the 'nomagic' option. It 
      normally matches any single character from the sequence. If the 
      sequence begins with <^>, it matches any single character NOT in the 
      sequence. If two characters in the sequence are separated by <->, this 
      is shorthand for the full list of ASCII characters between them (e.g. 
      '[0-9]' matches any decimal digit). To include a literal <]> in the 
      sequence, make it the first character (following a possible <^>). To 
      include a literal '\-', make it the first or last character.

If the 'ignorecase' option is set, the case of letters is ignored.

It is impossible to have a pattern that contains a line break.

Examples:
^beep(			Probably the start of the C function "beep".

[a-zA-Z]$		Any alphabetic character at the end of a line.

\(^\|[^a-zA-Z0-9_]\)[a-zA-Z_]\+[a-zA-Z0-9_]*
			A C identifier (will stop in front of it).

\(\.$\|\. \)		A period followed by end-of-line or a space.
			Note that "\(\. \|\.$\)" does not do the same,
			because '$' is not end-of-line in front of '\)'.
			This was done to remain vi-compatible.

[.!?][])"']*\($\|[ ]\)	A search pattern that finds the end of a sentence,
			with almost the same definition as the <)> command.

Technical detail:
<NUL> characters in the file are stored as <LF> in memory. In the display
they are shown as "^@". The translation is done when reading and writing
files. To match a <NUL> with a search pattern you can just enter CTRL-@ or
"CTRL-V 000". This is probably just what you expect. Internally the
character is replaced by a <LF> in the search pattern. What is unusual is
that typing CTRL_V CTRL_J also inserts a <LF>, thus also searches for a
<NUL> in the file. {vi cannot handle <NUL> characters in the file at all}


6.6 Various motions				*various_motions*

						*m*
m<a-zA-Z>		Set mark <a-zA-Z> at cursor position (does not move 
			the cursor, this is not a motion command).

						*:mark*
:[range]mar[k] <a-zA-Z>	Set mark <a-zA-Z> at last line number in [range], 
			column 0. Default is cursor line.

						*:k*
:[range]k<a-zA-Z>	Same as :mark, but the space before the mark name can
			be omitted.

						*'*
'<a-z>			To the first non-blank character on the line with
			mark <a-z> (linewise).

'<A-Z>			To the first non-blank character on the line with
			mark <A-Z> in the correct file (linewise when in 
			same file, not a motion command when in other file). 
			{not in Vi}

						*`*
`<a-z>			To the mark <a-z> (exclusive).

`<A-Z>			To the mark <A-Z> in the correct file (exclusive 
			when in same file, not a motion command when in 
			other file). {not in Vi}

						*:marks*
:marks			List all the current marks (not a motion command).
			{not in Vi}

:marks {arg}		List the marks that are mentioned in {arg} (not a
			motion command). For example:
				:marks aB
			to list marks 'a' and 'B'. {not in Vi}

A mark is not visible in any way. It is just a position in the file that is
remembered. Do not confuse marks with named registers, they are totally 
unrelated.

Lowercase marks are only remembered as long as the file remains loaded. If
you quit editing the file, change a character in a line or delete a line
that contains a mark, that mark is erased. Lowercase marks can be used
in combination with operators. For example: "d't" deletes the lines from the
cursor position to mark <t>. Hint: Use mark <t> for Top, <b> for Bottom,
etc..

Marks are restored when using undo and redo.

Marks are remembered as long as the file remains in the buffer list.

Uppercase marks include the file name. {Vi: no uppercase marks} You can use 
them to jump from file to file. You can only use an uppercase mark with 
an operator if the mark is in the current file. The line number of the mark
remains correct, even if you insert/delete lines or edit another file for a
moment.


						*'[*
'[			To the first non-blank character on the first line 
			of the previously operated text or start of the last 
			putted text. {not in Vi}

						*`[*
`[			To the first character of the previously operated 
			text or start of the last putted text. {not in Vi}

						*']*
']			To the first non-blank character on the last line of 
			the previously operated text or end of the last 
			putted text. {not in Vi}

						*`]*
`]			To the last character of the previously operated 
			text or end of the last putted text. {not in Vi}

After executing an operator the Cursor is put at the beginning of the text 
that was operated upon. After a put command ("p" or "P") the cursor is 
sometimes placed at the first inserted line and sometimes on the last 
inserted character. The four commands above put the cursor at either
end. Example: After yanking 10 lines you want to go to the last one of them: 
"10Y']". After inserting several lines with the "p" command you want to jump 
to the lowest inserted line: "p']".

Note: After deleting text, the start and end positions are the same, except 
when using blockwise Visual mode. These commands do not work when no
operator or put command has been used yet in the current file. The position
may be incorrect after inserting text and ".p.

						*'<*
'<			To the first non-blank character on the first line
			of the last selected visual area. {not in Vi}.

						*`<*
`<			To the first character of the last selected visual
			area. {not in Vi}.

						*''*
''			To the first non-blank character of the line where
			the cursor was before the latest jump (linewise).

						*``*
``			To the position before latest jump (exclusive).

A "jump" is one of the following commands: "'", "`", "G", "/", "?", "n", 
"N", "%", "(", ")", "[[", "]]", "{", "}", ":s", ":tag", "L", "M", "H" and
the commands that start editing a new file. If you make the cursor "jump"
with one of these commands, the position of the cursor before the jump is
remembered. You can return to that position with the "''" and "``" command,
unless the line containing that position was changed or deleted.

							*CTRL-O*
CTRL-O			Go to [count] Older cursor position in jump list
			(not a motion command). {not in Vi}

							*CTRL-I*
CTRL-I			Go to [count] newer cursor position in jump list
			(not a motion command). {not in Vi}

							*:jumps*
:jumps			Print the jump list (not a motion command). {not in 
			Vi} 

Jumps are remembered in a jump list. With the CTRL-O and CTRL-I command you 
can go to cursor positions before older jumps, and back again. Thus you can 
move up and down the list.

For example, after three jump commands you have this jump list:

 jump line  file
   1     1  -current-
   2    70  -current-
   3  1154  -current-
>

You are currently in line 1167. If you then use the CTRL-O command, the 
cursor is put in line 1154. This results in:

 jump line  file
   1     1  -current-
   2    70  -current-
>  3  1154  -current-
   4  1167  -current-

The pointer will be set at the last used jump position. The next CTRL-O 
command will use the entry above it, the next CTRL-I command will use the 
entry below it. If the pointer is below the last entry, this indicates that 
you did not use a CTRL-I or CTRL-O before. In this case the CTRL-O command 
will cause the cursor position to be added to the jump list, so you can get 
back to the position before the CTRL-O. In this case this is line 1167.

With more CTRL-O commands you will go to lines 70 and 1. If you use CTRL-I 
you can go back to 1154 and 1167 again.

If you use a jump command, the current line number is inserted at the end of 
the jump list. If you used CTRL-O or CTRL-I just before that, the same line 
may be in the list twice. This may be a bit strange. Just try it and look at 
the jump list with the :jumps command. Note that this behaviour is different 
from the tag stack.

After the CTRL-O command that got you into line 1154 you could give another 
jump command (e.g. "G"). The jump list would then become:

 jump line  file
   1     1  -current-
   2    70  -current-
   3  1154  -current-
   4  1167  -current-
   5  1154  -current-
>

As long as you stay in the same file, the line numbers will be adjusted for 
deleted and inserted lines. If you go to another file the line numbers may 
be wrong (keeping them correct would take too much time). If you want to 
avoid this use a :jumps command before changing files. This will update the 
line numbers in the current file.

							*%*
%			Find the next item in this line after or under the
			cursor and jump to its match (inclusive). Items can
			be:
			([{}])		parenthesis or (curly/square) brackets
			/* */		start or end of C-style comment
			#if, #ifdef, #else, #elif, #endif
					C preprocessor conditionals
			Parens and braces preceded with a backslash are
			ignored. When the 'smartmatch' option is set, Parens
			and braces inside quotes are ignored, unless the
			number of parens/braces in a line is uneven and this
			line and the previous one does not end in a
			backslash. No count is allowed ({count}% jumps to a
			line {count} percentage down the file).
			Using '%' on #if/#else/#endif makes the movement
			linewise.

						*[(*
[(			go to [count] previous unmatched <(>. {not in Vi}

						*[{*
[{			go to [count] previous unmatched <{>. {not in Vi}

						*])*
])			go to [count] next unmatched <)>. {not in Vi}

						*]}*
]}			go to [count] next unmatched <}>. {not in Vi}

The above four commands can be used to go to the start or end of the current
code block. It is like doing "%" on the <(>, <)>, <{> or <}> at the other
end of the code block, but you can do this from anywhere in the code block.
Very useful for C programs. Example: When standing on "case x:", "[{" will
bring you back to the switch statement.

						*H*
H 			To line [count] from top (Home) of screen (default:
			first line on the screen) on the first non-blank 
			character (linewise). See also 'startofline' option.

						*M*
M			To Middle line of screen, on the first non-blank
			character (linewise). See also 'startofline' option.

						*L*
L			To line [count] from bottom of screen (default: Last
			line on the screen) on the first non-blank character 
			(linewise). See also 'startofline' option.

left-mouse-click	Moves to the position on the screen where the mouse
			click is (inclusive). If the position is in the last
			line on the screen the text is scrolled up. If the
			position is in the first line on the screen the text
			is scrolled down. See also |visual_mode|. If the
			position is in a status line, that window is made
			the active window and the cursor is not moved. {not
			in Vi}


	7. Scrolling					*scrolling*

Move edit window downwards (this means that more lines downwards in the text
buffer are seen):

							*CTRL-E*
CTRL-E			Window [count] lines downwards in the buffer

							*CTRL-D*
CTRL-D			Window Downwards in the buffer. The number of lines
			comes from the 'scroll' option (default: half a
			screen). If [count] given, first set 'scroll' option
			to [count]. See also 'startofline' option.

<SC_DOWN>	or					*scur_down*
<PAGE_DOWN>	or					*page_down* *CTRL-F*
CTRL-F			Window [count] pages Forwards (downwards) in the
			buffer. See also 'startofline' option.

Move edit window upwards (this means that more lines upwards in the text
buffer are seen): 

							*CTRL-Y*
CTRL-Y			Window [count] lines upwards in the buffer.

							*CTRL-U*
CTRL-U			Window Upwards in the buffer. The number of lines
			comes from the 'scroll' option (default: half a
			screen). If [count] given, first set 'scroll' option
			to [count]. See also 'startofline' option.

<SC_UP>		or					*scur_up*
<PAGE_UP>	or					*page_up* *CTRL-B*
CTRL-B			Window [count] pages Backwards (upwards) in the
			buffer. See also 'startofline' option.

Window repositioning:

							*z*
z<CR>			Redraw, line [count] at top of window (default
			cursor line). Put cursor at first non-blank in the
			line.

							*zt*
zt			Like "z<CR>", but leave the cursor in the same
			column. {not in Vi}

							*z<CR>*
z{height}<CR>		Redraw, make window {height} lines tall. This is
			useful to make the number of lines small when screen
			updating is very slow. Cannot make the height more
			than the physical screen height.

							*z.*
z.			Redraw, line [count] at center of window (default 
			cursor line). Put cursor at first non-blank in the
			line.

							*zz*
zz			Like "z.", but leave the cursor in the same column.
			{not in Vi}

							*z-*
z-			Redraw, line [count] at bottom of window (default 
			cursor line). Put cursor at first non-blank in the
			line.

							*zb*
zb			Like "z-", but leave the cursor in the same column.
			{not in Vi}

These commands move the contents of the window. If the cursor position is 
moved off of the window, the cursor is moved onto the window. A page is the 
number of lines in the window minus two. The mnemonics for these commands 
may be a bit confusing. Remember that the commands refer to moving the 
window upwards or downwards in the buffer. But when the window moves upwards 
in the buffer, the text in the window moves downwards on your screen.


	8. Tags and special searches			*tags_and_searches*

8.1 Tags						*tag_commands*

							*:tag*
:ta[g][!] {ident}	Jump to the definition of {ident}, using the
			information in the tags file. Put {ident} in the tag
			stack. See below for [!].

							*CTRL-]*
CTRL-]			":ta" to the identifier under or after cursor. Put 
			the identifier in the tag stack. {Vi: identifier 
			after the cursor}

							*v_CTRL-]*
{visual}CTRL-]		":ta" to the text that is highlighted. {not in Vi}

							*CTRL-T*
CTRL-T			Jump to [count] older entry in the tag stack
			(default 1). {not in Vi}

							*:pop*
:[count]po[p][!]	Jump to [count] older entry in tag stack (default 1).
			See below for [!]. {not in Vi}

:[count]ta[g][!]	Jump to [count] newer entry in tag stack (default 1).
			See below for [!]. {not in Vi}

							*:tags*
:tags			Show the contents of the tag stack. The active
			entry is marked with a <>>. {not in Vi}

A tag is an identifier that appears in the "tags" file. It is a sort of label
that can be jumped to. For example: In C programs each function name can be 
used as a tag.

With the ":tag" command the cursor will be positioned on the tag. With the
CTRL-] command, the identifier on which the cursor is standing is used as the
tag. If the cursor is not on an identifier, the first identifier rightwards 
of the cursor is used.

The 'ignorecase' option can be used to make the tag search case insensitive.

{In Vi jumping to a tag sets the current search pattern.  This means that
hitting 'n' after jumping to a tag does not search for the same pattern that
it did before jumping to the tag.  Vim does not do this as we consider it to
be a bug.}

If the tag is in the current file this will always work. Otherwise the
performed actions depend on whether the current file was changed, whether a !
is added to the command and on the 'autowrite' option:

  tag in       file        autowrite
current file  changed   !   option	  action
-----------------------------------------------------------------------------
    yes		 x	x     x	  goto tag
    no		 no	x     x	  read other file, goto tag
    no		yes    yes    x   abandon current file, read other file, goto
				  tag
    no		yes	no    on  write current file, read other file, goto
				  tag
    no		yes	no   off  fail
-----------------------------------------------------------------------------

- If the tag is in the current file, the command will always work.
- If the tag is in another file and the current file was not changed, the 
  other file will be made the current file and read into the buffer.
- If the tag is in another file, the current file was changed and a ! is 
  added to the command, the changes to the current file are lost, the other 
  file will be made the current file and read into the buffer.
- If the tag is in another file, the current file was changed and the 
  'autowrite' option is set, the current file will be written, the other 
  file will be made the current file and read into the buffer.
- If the tag is in another file, the current file was changed and the 
  'autowrite' option is not set, the command will fail. If you want to save 
  the changes, use the ":w" command and then use ":tag" without an argument. 
  This works because the tag is put on the stack anyway. If you want to lose 
  the changes you can use the ":tag!" command.

The ":tag" command works very well for C programs. If you see a call to a
function and wonder what that function does, position the cursor inside of 
the function name and hit CTRL-]. This will bring you to the function 
definition. An easy way back is with the CTRL-T command. Also read about the 
tag stack below.

A tags file can be created with the external command 'ctags'. It will 
contain a tag for each function. Some versions of 'ctags' will also make a 
tag for each "#defined" macro.

The lines in the tags file should have this format:

	{tag}{separator}{filename}{separator}{command}

{tag}		the identifier
{separator}	one or more <TAB> or space characters
{filename}	the file that contains the definition of {tag}
{command}	the Ex command that positions the cursor on the tag.

The identifier normally is the name of a function, but it can be any
identifier. There is one special form for local (static) functions:
{filename}:{identifier}. Some ctags programs make use of this to separate
local (static) functions from global functions. If this construction is
present in the tags file, the following priority is used:
	1. The first matching static tag for the current file
	2. The first matching non-static tag
	3. The first matching static tag for another file
(Detail: Vim compares only the last part of the filename and ignores any
path before it).

The command can be any Ex command, but normally it is a search command like 
"/^main(argc, argv)". If it is a search command, and the search fails,
another try is done to search for "^main(" (the tag with <^> prepended and
<)> appended). When using function names, this will find the function name
when it is in column 0. This will help when the arguments to the function
have changed since the tags file was made. If this search also fails another
try is done with "^[#a-zA-Z_].*main(". This means: A line starting with <#>
or an identifier and containing the tag followed by <(>. This will find
macro names and function names with a type prepended. {the two extra
searches are not in vi}.

{In vi the :tag command sets a new search pattern when the tag is searched
for. In Vim this is not done, the previous search pattern is still
remembered. The search pattern for the tag is not remembered.}.


The 'tags' option is a list of file names separated by spaces. Each of these 
files is searched for the tag. This can be used to use a different file than 
the default file "tags". It can also be used to access a common tags file. 
For example:

:set tags=tags\ /home/user/commontags

The tag will first be searched for in the file "tags" in the current
directory. If it is not found there the file "/home/user/commontags" will be
searched for the tag. The backslash is required for the space to be included
in the string option.

When the tag could not been found in the tags file specified by the 'tags'
option, another try is done in the file "tags" in the same directory as the
current file.

If the 'tagrelative' option is set (which is the default) and using a tag file
in another directory, file names in that tag file are relative to the
directory where the tag file is.


The tags that you use are remembered in the tag stack. You can print this 
stack with the ":tags" command. The result looks like this:

  # TO tag      FROM line in file
  1 main               1  harddisk2:text/vim/test
> 2 FuncA             58  -current-
  3 FuncC            357  harddisk2:text/vim/src/amiga.c

This list shows the tags that you jumped to and the cursor position before that 
jump. The older tags are at the top, the newer at the bottom.

The <>> points to the active entry. This is the tag that will be used by the 
next ":tag" command. The CTRL-T and ":pop" command will use the position 
above the active entry.

The line number and file name are remembered to be able to get back to where 
you were before the tag command. The line number will be correct, also when
deleting/inserting lines, unless this was done by another program (e.g.
another instance of Vim).

You can jump to previously used tags with several commands. Some examples:

	":pop" or CTRL-T	to position before previous tag
	{count}CTRL_T		to position before {count} older tag
	":tag"			to newer tag
	":0tag"			to last used tag

The most obvious way to use this is while browsing through the call graph of 
a program. Consider the following call graph:

	main  --->  FuncA  --->  FuncC
	      --->  FuncB

(Explanation: main calls FuncA and FuncB; FuncA calls FuncC).
You can get from main to FuncA by using CTRL-] on the call to FuncA. Then 
you can CTRL-] to get to FuncC. If you now want to go back to main you can 
use CTRL-T twice. Then you can CTRL-] to FuncB.

If you issue a ":ta {ident}" or CTRL-] command, this tag is inserted at the
current position in the stack. If the stack was full (it can hold up to 20
entries), the oldest entry is deleted and the older entries shift one
position up (their index number is decremented by one). If the last used
entry was not at the bottom, the entries below the last used one are
deleted. This means that an old branch in the call graph is lost. After the
commands explained above the tag stack will look like this:

  # TO tag      FROM line in file
  1 main               1  harddisk2:text/vim/test
  2 FuncB             59  harddisk2:text/vim/src/main.c
>


8.2 Include file searches				*include_search*

These commands look for a string in the current file and in all encountered
included files (recursively). This can be used to find the definition of a
variable, function or macro. If you don't want to search in included files,
use the commands listed in |pattern_searches|.

When a line is encountered that includes another file, that file is searched
before continuing in the current file. Files included by included files are
also searched. When an include file could not be found it is silently
ignored. Use the ":checkpath" command to discover which files could not be
found.

The string can be any identifier or a defined macro. For the identifier any
match will be found. For defined macros only lines that match with the
'define' option will be found. The default is "\^#[ \t]*define", which is
for C programs.  Also, when a match is found for a defined macro, the
displaying of lines continues with the next line when a line ends in a
backslash.

The commands that start with "[" start searching from the start of the
current file. The commands that start with "]" start at the current cursor
position.

The 'include' option is used to define a line that includes another file.
The default is "\^#[ \t]*include", which is for C programs.  Note: Vim does
not recognize C syntax. If the 'include' option matches a line inside
"#ifdef/#endif" or inside a comment, it is searched anyway.

The 'path' option is used to find the directory for the include files that
do not have an absolute path.

The 'comments' option is used for the commands that display a single line or
jump to a line. It defines that patterns that start a comment. Those lines
are ignored for the search, unless [!] is used.

							*[i*
[i			Display the first line that contains the identifier
			under the cursor. The search starts at the beginning
			of the file. Lines that look like a comment are
			ignored (see 'comments' option). If a count is
			given, the count'th matching line is displayed. {not
			in Vi}

							*]i*
]i			like "[i", but start at the current cursor position.
			{not in Vi}

							*:isearch*
:[range]is[earch][!] [+] [count] pattern
			Like "[i"  and "]i", but search in [range] lines
			(default: whole file).  Without [!] lines that are
			recognized as comments are skipped. Without [+]
			only whole words are matched, using the pattern
			"\<pattern\>". {not in Vi}

							*[I*
[I			Display all lines that contain the identifier under
			the cursor. File names and line numbers are
			displayed for the found lines. The search starts at
			the beginning of the file. {not in Vi}

							*]I*
]I			like "[I", but start at the current cursor position.
			{not in Vi}

							*:ilist*
:[range]il[ist][!] [+] pattern
			Like "[I" and "]I", but search in [range] lines
			(default: whole file). Without [!] lines that are
			recognized as comments are skipped. Without [+]
			only whole words are matched, using the pattern
			"\<pattern\>". {not in Vi}

							*[_CTRL-I*
[ CTRL-I		Jump to the first line that contains the identifier
			under the cursor. The search starts at the beginning
			of the file. Lines that look like a comment are
			ignored (see 'comments' option). If a count is
			given, the count'th matching line is jumped to. {not
			in Vi}

							*]_CTRL-i*
] CTRL-I		like "[ CTRL-I", but start at the current cursor
			position.  {not in Vi}

							*:ijump*
:[range]ij[ump][!] [+] [count] pattern
			Like "[ CTRL-I"  and "] CTRL-I", but search in
			[range] lines (default: whole file).  Without [!]
			lines that are recognized as comments are skipped.
			Without [+] only whole words are matched, using the
			pattern "\<pattern\>". {not in Vi}

CTRL-W CTRL-I					*CTRL-W_CTRL-I* *CTRL-W_i*
CTRL-W i		Open a new window, with the cursor on the first line
			that contains the identifier under the cursor. The
			search starts at the beginning of the file. Lines
			that look like a comment line are ignored (see
			'comments' option). If a count is given, the
			count'th matching line is jumped to. {not in Vi}

							*:isplit*
:[range]isp[lit][!] [+] [count] pattern
			Like "CTRL-W i"  and "CTRL-W i", but search in
			[range] lines (default: whole file).  Without [!]
			lines that are recognized as comments are skipped.
			Without [+] only whole words are matched, using the
			pattern "\<pattern\>". {not in Vi}

							*[d*
[d			Display the first macro definition that contains the
			macro under the cursor. The search starts from the
			beginning of the file. If a count is given, the
			count'th matching line is displayed. {not in Vi}

							*]d*
]d			like "[d", but start at the current cursor position.
			{not in Vi}

							*:dsearch*
:[range]ds[earch][!] [+] [count] pattern
			Like "[d"  and "]d", but search in [range] lines
			(default: whole file).  Without [!] lines that are
			recognized as comments are skipped.  Without [+]
			only whole words are matched, using the pattern
			"\<pattern\>". {not in Vi}

							*[D*
[D			Display all macro definitions that contain the macro
			under the cursor. File names and line numbers are
			displayed for the found lines. The search starts
			from the beginning of the file. {not in Vi}

							*]D*
]D			like "[D", but start at the current cursor position.
			{not in Vi}

							*:dlist*
:[range]dl[ist][!] [+] pattern
			Like "[D"  and "]D", but search in [range] lines
			(default: whole file).  Without [!] lines that are
			recognized as comments are skipped.  Without [+]
			only whole words are matched, using the pattern
			"\<pattern\>". {not in Vi}

							*[_CTRL-D*
[ CTRL-D		Jump to the first macro definition that contains the
			identifier under the cursor. The search starts from
			the beginning of the file. If a count is given, the
			count'th matching line is jumped to. {not in Vi}

							*]_CTRL-D*
] CTRL-D		like "[ CTRL-D", but start at the current cursor
			position.  {not in Vi}

							*:djump*
:[range]dj[ump][!] [+] [count] pattern
			Like "[ CTRL-D"  and "] CTRL-D", but search  in
			[range] lines (default: whole file).  Without [!]
			lines that are recognized as comments are skipped.
			Without [+] only whole words are matched, using the
			pattern "\<pattern\>". {not in Vi}

							*CTRL-W_d*
CTRL-W d		Open a new window, with the cursor on the first
			macro definition line that contains the identifier
			under the cursor. The search starts from the
			beginning of the file. If a count is given, the
			count'th matching line is jumped to. {not in Vi}

							*:dsplit*
:[range]dsp[lit][!] [+] [count] pattern
			Like "CTRL-W d", but search in [range] lines
			(default: whole file).  Without [!] lines that are
			recognized as comments are skipped.  Without [+]
			only whole words are matched, using the pattern
			"\<pattern\>". {not in Vi}

							*:checkpath*
:che[ckpath]		List all the included files that could not be found.
			{not in Vi}


	9. Inserting text				*inserting*

The following commands can be used to insert new text into the buffer. They
can all be undone. The non-Ex commands can be repeated with the "." command.

							*a*
a			Append text after the cursor [count] times.

							*A*
A			Append text at the end of the line [count] times.

<INSERT>	or					*i* *insert*
i			Insert text before the cursor [count] times.

							*I*
I			Insert text before the first CHAR on the line
			[count] times.

							*o*
o			Begin a new line below the cursor and insert text,
			repeat [count] times. {Vi: blank [count] screen
			lines}

							*O*
O			Begin a new line above the cursor and insert text,
			repeat [count] times. {Vi: blank [count] screen
			lines}

These commands are used to start inserting text. They can be undone and
repeated. You can end Insert mode with <ESC>. See the section "Insert and
Replace mode" |mode_ins_repl| for the other special characters in Insert
mode. The effect of [count] takes place after Insert mode is exited.

							*:read*
:r[ead] [name]		Insert the file [name] (default: current file) below
			the cursor.

:{range}r[ead] [name]	Insert the file [name] (default: current file) below
			the specified line.

							*:read!*
:r[ead] !{cmd}		Execute {cmd} and insert its standard output below
			the cursor. A temporary file is used to store the
			output of the command which is then read into the
			buffer. 'shellredir' is used to save the output of
			the command, which can be set to include stderr or
			not.

These commands insert the contents of a file, or the output of a command, 
into the buffer. They can be undone. They cannot be repeated with the "." 
command. They work on a line basis, insertion starts below the line in which 
the cursor is, or below the specified line. To insert text above the first 
line use the command ":0r {name}".

The <LF> character is recognized as end-of-line marker. If the 'textmode'
option is set, a <CR> in front of an <LF> is ignored and a CTRL-Z at the end
of the file is ignored. The 'textmode' option is default on for MSDOS.

If the 'textauto' option is set Vim tries to recognize the type of
end-of-line marker (see 5.2 how this is done |edit_a_file|). However, the
'textmode' option will not be changed. Only while reading one file the text
mode is used or not.

On non-MSDOS systems the message "[textmode]" is shown if a file is read in
text mode, to remind you that something unusual is done. On MSDOS the
message "[notextmode]" is shown if a file is read without text mode.

An example on how to use ":r !":
	:r !uuencode binfile binfile
This command reads "binfile", uuencodes it and reads it into the current
buffer. Useful when you are editing e-mail and want to include a binary
file.


	10. Deleting text				*deleting*

["x]<DEL>	or					*<DEL>* *x*
["x]x			Delete [count] characters under and after the cursor
			[into register x] (not linewise).

							*X*
["x]X			Delete [count] characters before the cursor [into
			register x] (not linewise).

							*d*
["x]d{motion}		Delete text that is moved over [into register x]. 
			See below for exception.

							*dd*
["x]dd			Delete [count] lines [into register x] (linewise).

							*D*
["x]D			Delete the characters under the cursor until the end
			of the line and [count]-1 more lines [into register 
			x]; synonym for d$ (not linewise).

{visual}["x]x	or					*v_x* *v_d*
{visual}["x]d		Delete the highlighted text [into register x] (see
			the chapter on Visual mode |visual_mode|). {not in
			Vi}

{visual}["x]X	or					*v_X* *v_D*
{visual}["x]D		Delete the highlighted lines [into register x] (see
			the chapter on Visual mode |visual_mode|). {not in
			Vi}

							*:delete*
:[range]d[elete] [x]	Delete [range] lines (default: current line) [into
			register x].

:[range]d[elete] [x] {count}
			Delete {count} lines, starting with [range]
			(default: current line |cmdline_ranges|) [into
			register x].

These commands delete text. They can be repeated with the "." command
(except ":d") and undone. Use Visual mode to delete blocks of text. See
"Copying and moving text" |copy_move| for an explanation of registers.

An exception for the d{motion} command: If the motion is not linewise, the 
start and end of the motion are not in the same line and before the start 
and after the end are only blanks, the delete becomes linewise. This means 
that the blank line that would remain is also deleted.


							*J*
J			Join [count] lines, with a minimum of two lines.

							*v_J*
{visual}J		Join the highlighted lines, with a minimum of two
			lines. {not in Vi}

							*:join*
:[range]j[oin][!]	Join [range] lines. Same as "J", except when [!] is
			given, then no spaces will be inserted or deleted.
			When [range] is given and the start and end of the
			range are equal, nothing happens. Default is to join
			two lines.

:[range]j[oin][!] {count}
			Join {count} lines, starting with [range] (default:
			current line |cmdline_ranges|). Same as "J", except
			when [!] is given, then no spaces will be inserted
			or deleted.

These commands delete the newline between lines. This has the effect of 
joining them into one line. They can be repeated (except ":j") and undone. 

One space is inserted in place of the <LF>, unless the line ended with a 
space, <TAB> or the next line started with a <)>. If the next line has 
leading white space it is deleted first. If the 'joinspaces' option is set, 
two spaces are inserted after a period.


	11. Changing text				*changing*

The following commands can be used to change text, that is delete some text 
and insert something else, with one command. They can all be undone. The 
non-Ex commands can be repeated with the "." command.


11.1 Delete and insert					*delete_insert*

							*R*
R			Enter Replace mode: Each character you type replaces
			an existing character, starting with the character
			under the cursor. Repeat the entered text [count]-1
			times.

							*c*
["x]c{motion}		Delete {motion} text [into register x] and start
			insert.

							*cc*
["x]cc			Delete [count] lines [into register x] and start
			insert (linewise). If 'autoindent' is set, preserve
			the indent of the first line.

							*C*
["x]C			Delete from the cursor position to the end of the
			line and [count]-1 more lines [into register x], and 
			start insert. Synonym for c$ (not linewise).

							*s*
["x]s			Delete [count] characters [into register x] and start
			insert (s stands for Substitute). Synonym for "cl"
			(not linewise).

							*S*
["x]S			Delete [count] lines [into register x] and start 
			insert. Synonym for "cc" (not linewise).

{visual}["x]c	or					*v_c*
{visual}["x]r	or					*v_r* *v_s*
{visual}["x]s		Delete the highlighted text [into register x] and
			start insert (see the chapter on Visual mode
			|visual_mode|). {not in Vi}

{visual}["x]C	or					*v_C*
{visual}["x]R	or					*v_R* *v_S*
{visual}["x]S		Delete the highlighted lines [into register x] and
			start insert (see the chapter on Visual mode
			|visual_mode|). {not in Vi}

You can end Insert and Replace mode with <ESC>. See the section "Insert and
Replace mode" |mode_ins_repl| for the other special characters in these
modes. The effect of [count] takes place after Insert or Replace mode is
exited. {Vi: does not directly delete the text, but puts a <$> at the last
deleted character} See "Copying and moving text" |copy_move| for an
explanation of registers.

Replace mode is just like Insert mode, except that for every character you 
enter, one character is deleted. If the end of a line is reached, further 
characters are appended (just like Insert mode). In Replace mode the 
backspace key restores the original text (if there was any) (see section
"Insert and Replace mode" |mode_ins_repl|).

Special case: "cw" and "cW" are treated like "ce" and "cE" if the cursor is 
on a non-blank. This is because "cw" is interpreted as change-word, and a 
word does not include the following white space. {Vi: "cw" when on a blank 
followed by other blanks changes only the first blank; this is probably a 
bug, because "dw" deletes all the blanks}


11.2 Simple changes					*simple_change*

							*r*
r<char>			Replace the character under the cursor by <char>. If
			<char> is a <CR> or <LF> the character will be
			replaced by a line break. Replacing with a real <CR>
			can be done by using CTRL-V <CR>. CTRL-V <LF> will
			replace with a <NUL>. {in vi CTRL-V does not make a
			difference}
			If a [count] is given that many characters will be
			replaced by [count] <char>s or line breaks {Vi:
			"5r<CR>" replaces five characters with a single line
			break; CTRL-V <CR> still replaces with a line break,
			cannot replace something with a <CR>}

							*~*
~			'notildeop' option: switch case of the character
			under the cursor and move the cursor to the right.
			If a [count] is given do that many characters {Vi:
			no count}

~{motion}		'tildeop' option: switch case of {motion} text. {Vi: 
			tilde cannot be used as an operator}

							*g~*
g~{motion}		switch case of {motion} text. {Not in Vi}

							*v_~*
{visual}~		switch case of highlighted text (see the chapter on 
			Visual mode |visual_mode|). {not in Vi}

							*v_U*
{visual}U		Make highlighted text uppercase (see the chapter on 
			Visual mode |visual_mode|). {not in Vi}

							*gU*
gU{motion}		Make {motion} text uppercase. {not in Vi}

							*v_u*
{visual}u		Make highlighted text lowercase (see the chapter on 
			Visual mode |visual_mode|). {not in Vi}

							*gu*
gu{motion}		Make {motion} text lowercase. {not in Vi}

							*CTRL-A*
CTRL-A			Add [count] to the number at or after the cursor.
			{not in Vi}

							*CTRL-X*
CTRL-X			Subtract [count] from the number at or after the 
			cursor. {not in Vi}

The CTRL-A and CTRL-X commands work for (signed) decimal numbers and 
unsigned octal and hexadecimal numbers. Numbers starting with '0x' or '0X' 
are assumed to be hexadecimal. To decide whether the hexadecimal number 
should be printed uppercase or not, the case of the rightmost letter in the 
number is considered. If there is no letter in the current number, the 
previously detected case is used. Numbers starting with a <0> are considered 
to be octal. Other numbers are decimal and may be preceded with a minus 
sign. If the cursor is on a number, that one will be used. Otherwise the 
number right of the cursor will be used.

For octal and hexadecimal numbers with leading zeros, the number of
characters in the number remains equal (when possible). When doing CTRL-A on
"0077" it becomes "0100", CTRL-X on "0x0100" becomes "0x00ff". Note that
when there are no leading zeros this does not work, so CTRL-X on "0x100"
results in "0xff". Note that decimal numbers with leading zeros are
impossible, because they are recognized as octal numbers.

The CTRL-A command is very useful in a macro. Example: How to make a 
numbered list.

1. Create the first entry. The entry should start with a number.
2. qa        - start recording into buffer <a>
3. Y         - yank the entry
4. p         - put a copy of the entry below the first one
5. CTRL-A    - increment the number
6. q         - stop recording
7. <count>@a - repeat the yank, put and increment <count> times

							*<*
<{motion}		Shift the {motion} lines one shiftwidth leftwards.

							*<<*
<<			Shift [count] lines one shiftwidth leftwards.

							*v_<*
{visual}<		Shift the highlighted lines [count] shiftwidth
			leftwards (see the chapter on Visual mode
			|visual_mode|). {not in Vi} 

							*>*
>{motion}		Shift {motion} lines one shiftwidth rightwards.

							*>>*
>>			Shift [count] lines one shiftwidth rightwards.

							*v_>*
{visual}>		Shift the highlighted lines [count] shiftwidth
			rightwards (see the chapter on Visual mode
			|visual_mode|). {not in Vi}

							*:<*
:[range]<		Shift [range] lines left. Repeat '<' for multiple
			shifts.

:[range]< {count}	Shift {count} lines left, starting with [range]
			(default current line |cmdline_ranges|). Repeat '<'
			for multiple shifts.

:[range]le[ft] [indent]	left align lines in [range]. Sets the indent in the
			lines to [indent] (default 0). {not in Vi}

							*:>*
:[range]>		Shift {count} [range] lines right. Repeat '>' for
			multiple shifts.

:[range]> {count}	Shift {count} lines right, starting with [range]
			(default current line |cmdline_ranges|). Repeat '>'
			for multiple shifts.

The ">" and "<" commands are handy for changing the indent within programs. 
The size of the white space which is inserted or deleted can be set with the 
'shiftwidth' option. Normally the 'shiftwidth' option is set to 8, but you 
can set it to e.g. 3 to make smaller indents. The shift leftwards stops when 
there is no indent. The shift right does not do anything with empty lines. 

If the 'shiftround' option is set, the indent is rounded to a multiple of 
'shiftwidth'.

If the 'smartindent' option is set, lines starting with <#> will not be
shifted right.

When the 'expandtab' option if off (this is the default) <TAB>s are used as 
much as possible to make the indent. You can use ">><<" to replace an indent 
made out of spaces with the same indent made out of <TAB>s (and a few 
spaces if necessary). If the 'expandtab' option is on, only spaces are 
used. Then you can use ">><<" to replace <TAB>s in the indent by spaces.

To move a line several 'shiftwidth's use the visual mode or the ":"
commands. For example:
	Vjj4>		move three lines 4 indents to the right
	:<<<		move current line 3 indents to the left
	:>> 5		move 5 lines 2 indents to the right



11.3 Complex changes					*complex_change*

							*!*
!{motion}{filter}	Filter {motion} text through the external program
			{filter}.

							*!!*
!!{filter}		Filter [count] lines through the external program
			{filter}.

							*v_!*
{visual}!{filter}	Filter the highlighted lines through the external
			program {filter} (see the chapter on Visual mode
			|visual_mode|).  {not in Vi}

:{range}![!]{filter} [!][arg]				*:range!*
			Filter {range} lines through the external program
			{filter}. The optional bangs are replaced with the
			latest given command. The optional [arg] is
			appended. The output of the filter command is
			temporaryly saved in a file and then read into the
			buffer. The 'shellredir' option is used to write the
			output of the filter in the temporary file.

							*=*
={motion}		Filter {motion} lines through the external program 
			given with the 'equalprg' option (default: 
			"indent"). {Vi: when 'lisp' option is set, autoindent 
			{motion} lines}

							*==*
==			Filter [count] lines through the external program
			given with the 'equalprg' option (default: indent).
			{not in Vi}

							*v_=*
{visual}=		Filter the highlighted lines through the external
			program given with the 'equalprg' option (default:
			indent) (see the chapter on Visual mode
			|visual_mode|). {not in Vi}

A filter is a program that accepts text at standard input, changes it in some
way, and sends it to standard output. The commands above can be used to send
some text through a filter. An example of a filter is "sort", which sorts 
lines alphabetically. The "indent" program is used to pretty indent C 
programs (you need a version of indent that works like a filter, not all 
versions do that). The shell, given with the 'shell' option, is used to 
execute the command (See also the 'shelltype' option).
The filter commands can be redone with ".". There cannot be a comment (with
<">) after the ":!" command.


						*:substitute*
:[range]s[ubstitute]/{pattern}/{string}/[g][c][r] [count]
			For each line in [range] replace {pattern} by
			{string}. See below for the flags.

:[range]s[ubstitute] [g][c][r] [count]
:[range]&[g][c][r] [count]			*:&*
			Repeat last :substitute with same search pattern and
			substitute string. The flags may be different (see
			below).

:[range]~[g][c][r] [count]			*:~*
			Repeat last substitute with same substitute string
			but with last used search pattern. This is like
			"&r". See explanation for [r] below.

						*&*
&			Synonym for ":s//~/" (repeat last substitute).

The arguments that can be given to the substitute commands:
[g]	All occurrences in the line are replaced. Otherwise only the first
	occurrence in the line is replaced. If the 'edcompatible' option is
	set this flag is remembered and toggled each time it is used. It is
	reset when a new search pattern is given. If the 'gdefault' option
	is set, this flag is default on. Give the [g] to switch it on.
[c]	Each substitute has to be confirmed. The cursor is positioned on the
	matching string. You can type:
		<y> to substitute this match
		<n> to skip this match
		<a> to substitute this and all remaining matches {not in Vi}
		<q> to quit substituting {not in Vi}
		CTRL-E to scroll the screen up {not in Vi}
		CTRL-Y to scroll the screen down {not in Vi}.
	If the 'edcompatible' option is set the [c] flag is remembered and
	toggled each time it is used. It is reset when a new search pattern
	is given.
[r]	When the search pattern is empty use the previously used search
	pattern instead of the search pattern from the last substitute.
	If the last command that did a search was a substitute there is no
	effect. If the last command was another search command, like
	"/" or ":global", the pattern from that command is used.
[count] That many lines are are searched, starting with the last line number
	in [range] (default current line |cmdline_ranges|).

If the {pattern} for the substitute command is empty, the pattern from the
last substitute command is used. With the [r] flag the pattern from the last
substitute or search command ("/", ":global" and the like) is used.

For compatibility with vi these two execptions are allowed:
"\/{string}/" and "\?{string}?" do the same as "//{string}/r".
"\&{string}&" does the same as "//{string}/".

Instead of the </> which surrounds the pattern and replacement string, you
can use any other character, but not an alphanumeric character, <"> or <|>
or <#>. This is useful if you want to include a </> in the search pattern or
replacement string. Example: ":s+/+//+"

For the definition of a pattern see 6.5, "Pattern searches"
|search_pattern|.

Some characters in {string} have a special meaning:

magic	nomagic	  action
  &	  \&	  replaced by the whole matched pattern
 \&	   &	  replaced by &
      \0	  replaced by the whole matched pattern
      \1	  replaced by the matched pattern in the first pair of ()
      \2	  replaced by the matched pattern in the second pair of ()
      ..	  ..
      \9	  replaced by the matched pattern in the ninth pair of ()
  ~	  \~	  replaced by the {string} of the previous substitute
 \~	   ~	  replaced by ~
      \u	  next character made uppercase
      \U	  following characters made uppercase
      \l	  next character made lowercase
      \L	  following characters made lowercase
      \e	  end of /u, /U, /l and /L
      \E	  end of /u, /U, /l and /L
      <CR>	  split line in two at this point
  CTRL-V <CR>	  insert a carriage-return (CTRL-M)

Examples:
:s/a\|b/xxx\0xxx/g	      modifies "a b"	  in "xxxaxxx xxxbxxx"
:s/\([abc]\)\([efg]\)/\2\1/g  modifies "af fa bg" in "fa fa gb"
:s/abcde/abc^Mde/	      modifies "abcde"    in "abc", "de" (two lines)
:s/$/^V^M/		      modifies "abcde"	  in "abcde^M"

Note: To insert a ^M you have to type CTRL-V <CR>. To insert a ^V you have
to type CTRL-V CTRL-V. So to insert the ^V^M in the last example you have to
type CTRL-V CTRL-V CTRL-V <CR>.

Because CTRL-V <CR> inserts a <CR>, it is impossible to insert a CTRL-V just
in front of a line break. You will have to split it up in two parts:
	:s/foo/^Vxxxx/
	:s/xxxx/^M/

When using parentheses in combination with <|>, like in \([ab]\)\|\([cd]\), 
either the first or second pattern in parentheses did not match, so either 
\1 or \2 is empty. Example:
:s/\([ab]\)\|\([cd]\)/\1x/g   modifies "a b c d"  in "ax bx x x"

							*:retab*
:[range]ret[ab] [!] [new_tabstop]
			All sequences of white-space containing a tab are
			replaced by new strings of white-space using the new
			tabstop value given.  If no new tabstop size is
			given, the current value of 'tabstop' is used.  With
			!, strings of normal spaces will also be replace by
			tabs where appropriate.  With 'expandtab' set, all
			tabs will be replaced with the appropriate number of
			spaces.  This command sets 'tabstop' to the new
			value given, and if performed on the whole file,
			which is default, should not make any visible
			change. {not in Vi}


11.4 Formatting text						*formatting*

:[range]ce[nter] [width]				*:center*
			Center lines in [range] between [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).
			{not in Vi}

:[range]ri[ght] [width]					*:right*
			right align lines in [range] at [width] columns
			(default 'textwidth' or 80 when 'textwidth' is 0).
			{not in Vi}

							*:left*
:[range]le[ft] [indent]	left align lines in [range]. Sets the indent in the
			lines to [indent] (default 0). {not in Vi}

							*Q*
Q{motion}		Format the lines that were moved over. The length of 
			each line will be restricted to the width set with
			the 'textwidth' option. If the 'textwidth' option is
			0, all lines will be joined together. See below.
			{not in Vi}

							*v_Q*
{visual}Q		Format the highlighted text. (see the chapter on
			Visual mode |visual_mode|). {not in Vi}

Example: To format the current paragraph use "{Q}".

If the 'autoindent' option is set, the indent of the first line is used for
the following lines.

Empty lines are left unchanged (but lines with spaces are!).

The 'formatprg' option can be set to the name of an external program, which
will be used instead of the internal function. The 'textwidth' and other
options will not be used then.

Comments are formatted in a special way. Normally a comment starts with 
special characters, ends with special characters, and each line in between
can start with special characters.

The 'comments' option can be set to a comma separated list of patterns that
can start a comment line. A pattern can include spaces, but not at the start
of the pattern. If a pattern ends in a space, this means that the pattern
can be followed by the end-of-line or any non-zero amount of white space,
which is reproduced on the new line.  By default "* " is included, but "*"
is not. This means that "*" must be followed by some white space or
end-of-line for it to be accepted. This avoids a pointer dereference like
"*str" to be recognized as a comment. Also, "# " is included. This means
that a line that starts with "#include" is not recognized as a comment line.
But a line that starts with "# define" is recognized. In C code this is
good, because somewhere after this a "#endif" is needed.

The 'nestedcomments' option can be set to a comma separated list of patterns
that can start a comment line when they occur at least one time. For example
'>' is often used in e-mail reply to show a part that is included from the
original message. In a reply to a reply it becomes "> >".

The 'formatoptions' option can be set to influence the way how comments are
formatted. It is a string option, that may contain any of these letters. The
default is "tcq".

							*fo_table*
letter   meaning when present in 'formatoptions'

t	Do text autowrapping using textwidth
c	Do comment autowrapping using textwidth, inserting the current
	comment leader automatically.
r	Automatically insert the current comment leader after hitting
	<return> in insert mode.
o	Automatically insert the current comment leader after hitting 'o' or
	'O' in normal mode.
q	Allow formatting of comments with Q.  Note that blank lines, or
	lines containing only the comment leader will be left untouched.  A
	new paragraph starts after such a line, or when the comment leader
	changes.
2	When formatting text the indent of the second line of a paragraph is
	used for the rest of the paragraph. This allows for paragraphs with
	a different indent for the first line.

With 't' and 'c' you can decide when auto-wrapping is done:
value	action
""	no automatic formatting, "Q" can be used for manual formatting
"t"	automatic formatting of text, not for comments
"c"	automatic formatting for comments, not for text (good for C code)
"tc"	automatic formatting for text and comments

Note that when 'textwidth' is 0, no formatting is done anyway.
Note that now 'textwidth' can be non-zero even though auto-wrapping never
occurs.  This is good because it can be used for formatting only in this
case (with "Q").

If "/*", "*" and "*/" are in the 'comments' variable, then vim has some
built in stuff to treat these types of comments a bit more cleverly.
Opening a new line before or after "/*" or "*/" (with 'r' or 'o' present in
'formatoptions'), should work properly, as should formatting and
auto-wrapping.  Opening a line after a line starting with "/*" or "*" and
containing "*/", will cause no comment leader to be inserted, and the indent
of the new line is taken from the line containing the start of the comment.
Eg:
    /*
     * Your typical comment.
     */
    The indent on this line is the same as the start of the above
    comment.

All this should be really cool, especially in conjunction with the new
:autocmd command to prepare different settings for different types of file.

Some examples:
  for C code:       fo="croq"	(only format comments)
  for Mail/news:    fo="tcrq"	(format all, don't start comment with "o"
				  command)


	12. Copying and moving text			*copy_move*

							*"*
"<a-zA-Z0-9.%:-">	Use register <a-zA-Z0-9.%:-"> for next delete, yank
			or put (use uppercase character to append with
			delete and yank) (<.> only works with put).

							*:display*
:di[splay]		Display the contents of all numbered and named
			registers.  {not in Vi}

:di[splay] {arg}	Display the contents of the numbered and named
			registers that are mentioned in {arg}. For example:
				:dis 1a
			to display registers '1' and 'a'. {not in Vi}

							*y*
["x]y{motion}		Yank {motion} text [into register x].

							*yy*
["x]yy			Yank [count] lines [into register x] (linewise).

							*Y*
["x]Y			yank [count] lines [into register x] (synonym for
			yy, linewise). If you like "Y" to work from the
			cursor to the end of line (which is more logical,
			but not vi-compatible) use ":map Y y$".

							*v_y*
{visual}["x]y		Yank the highlighed text [into register x] (see the 
			chapter on Visual mode |visual_mode|). {not in Vi}

							*v_Y*
{visual}["x]Y		Yank the highlighted lines [into register x] (see the 
			chapter on Visual mode |visual_mode|). {not in Vi}

							*:yank*
:[range]y[ank] [x]	Yank [range] lines [into register x].

:[range]y[ank] [x] {count}
			Yank {count} lines, starting with last line number 
			in [range] (default: current line |cmdline_ranges|),
			[into register x].

							*p*
["x]p			Put the text [from register x] after the cursor
			[count] times. {Vi: no count}

							*P*
["x]P			Put the text [from register x] before the cursor
			[count] times. {Vi: no count}

							*:put*
:[line]pu[t] [x]	Put the text [from register x] after [line] (default
			current line).

:[line]pu[t]! [x]	Put the text [from register x] before [line] (default
			current line).

							*]p*
["x]]p			like "p", but adjust the indent to the current line.
			{not in Vi}

["x][P		or					*[P*
["x]]P		or					*]P* *[p*
["x][p			like "P", but adjust the indent to the current line.
			{not in Vi}

These commands can be used to copy text from one place to another. This is 
done by first getting the text into a register with a yank, delete or change 
command. The register can then be inserted with a put command. All registers 
are kept when changing files. Thus you can also use this to move text from 
one file to another (the CTRL-^ command is a quick way to toggle between two 
files).

The put commands can be repeated with "." (except for :put) and undone. If the
command that was used to get the text into the register was linewise, the 
text will be inserted below ("p") or above ("P") the line where the cursor
is. Otherwise the text will be inserted after ("p") or before ("P") the
cursor. With the ":put" command the text will always be inserted in the next
line. You can exchange two characters with the command sequence "xp". You
can exchange two lines with the command sequence "ddp". You can exchange
two words with the command sequence "deep" (start with the cursor in the
blank space before the first word). The "']" or "`]" command can be used
after the put command to move the cursor to the end of the inserted text,
"'[" or "`[" to move the cursor to the start.

If the command that was used to get the text into the register used 
blockwise Visual mode, the block of text will be inserted before ("P") or
after ("p") the cursor column, in the current and next lines. Vim will make
the whole block of text start in the same column. Thus the inserted text
looks the same as when it was yanked or deleted. Some <TAB> characters may
be replaced by spaces to make this happen. However, if the width of the
block is not a multiple of a <TAB> width and the text after the inserted
block contains <TAB>s, that text may be misaligned.

There are five types of registers:
- The unnamed register ""
- 10 numbered registers "0 to "9
- The small delete register "-
- 26 named registers "a to "z or "A to "Z
- three read-only registers ":, ". and "%

	The unnamed register is the register where all text deleted with     
the "d", "c", "s", "x" commands or copied with the yank "y" command is
placed, regardless of whether or not a specific register was used (e.g.
"xdd). The contents of this register are used by any put command (p or P)
which does not specify a register. Additionally it can be accessed by the
name <">. This means you have to type two double quotes. {Vi: register
contents lost when changing files, no <">}
	The numbered registers are filled with yank and delete commands. 
Numbered register <0> is filled with the last yank command, unless another 
register was specified with ["x]. Numbered register <1> is filled with the 
text that was deleted by each delete or change command, unless another 
register was specified or the text is less than one line (text deleted with
"x" or "dw" will be put in the small delete register). The contents of
register <1> are put in <2>, <2> in <3>, and so forth. The contents of
register <9> are lost. {Vi: numbered register contents are lost when
changing files; register 0 does not exist}
	The small delete register is filled with delete commands that delete
less than one line, except when a register was specified with ["x].
	The named registers are only filled when you say so. They are named 
<a> to <z> normally. If you use an uppercase letter, the same registers as 
with the lower case letter is used, but the text is appended to the previous 
register contents. With a lower case letter the previous contents are lost.
	The read-only registers are <%>, <:> and <.>. They can only be used
with the commands "p", "P" and ":put". <.> contains the last inserted
text (the same as what is inserted with the insert mode commands CTRL-A and
CTRL-@). <%> contains the name of the current file. <:> contains the last
command line, it can also be used with "@", "@:" repeats the last command
line.

If you use a put command without specifying a register, the register that 
was last written to is used (this is also the contents of the unnamed
register). If you are confused, use the ":dis" command to find out what will
be put (all named and numbered registers are displayed; the unnamed register
is labelled <">).

The next three commands always work on whole lines.

:[range]co[py] {address}				*:copy*
			Copy the lines given by [range] to below the line
			given by {address}.

							*:t*
:t			Synonym for copy.

:[range]m[ove] {address}				*:move*
			Move the lines given by [range] to below the line
			given by {address}.


	13. Visual mode					*visual_mode*

Visual mode is a flexible and easy way to select a piece of text for an 
operator. It is the only way to select a block of text. {Vi has no visual
mode}

							*v*
v			start Visual mode per character. {not in Vi}

							*V*
V			start Visual mode linewise. {not in Vi}

							*CTRL-V*
CTRL-V			start Visual mode blockwise. {not in Vi}

							*v_o*
o			go to Other end of highlighted text: The current
			cursor position becomes the start of the highlighted
			text and the cursor is moved to the Other end of the
			highlighted text. {not in Vi} 

							*left_mouse_click*
left-mouse-click	Set the current cursor position. If visual mode is
			active it is stopped. If the position is in the last
			line on the screen the text is scrolled up.  If the
			position is in the first line on the screen the text
			is scrolled down. {not in Vi}

							*right_mouse_click*
right-mouse-click	Start visual mode if it is not active. The text from
			the cursor position to the position of the click is
			highlighted. If visual mode was already active move
			the start or end of the highlighted text, which ever
			is closest, to the position of the click. If the
			position is in the last line on the screen the text
			is scrolled up. If the position is in the first line
			on the screen the text is scrolled down.

To apply an operator on a piece of text:
	1. mark the start of the text with "v", "V" or CTRL-V
		The character under the cursor will be used as the start.
	2. move to the end of the text
		The text from the start of the Visual mode up to and
		including the character under the cursor is highlighted.
	3. hit an operator
		The highlighted characters will be operated upon.

The 'highlight' option can be used to set the display mode to use for
highlighting in Visual mode.

The highlighted text includes the character under the cursor. On terminals
where it is possible to make the cursor invisible the cursor position is
also highlighted. On terminals where this is not possible the cursor is
displayed normally. If your cursor cannot be made invisible and you want Vim
to highlight the character under the cursor anyway, you could set the 't_cv'
and 't_ci' options to something harmless, for example:
        :set t_cv=^[^[ t_ci=^[^[

With "v" the text before the start position and after the end position will 
not be highlighted. However, All uppercase and non-alpha operators, except 
"~", will work on whole lines anyway. See the list of operators below.

With CTRL-V (blockwise Visual mode) the highlighted text will be a rectangle
between start position and the cursor. However, some operators work on whole
lines anyway (see the list below). The change and substitute operators will
delete the highlighted text and then start insertion at the top left
position. 

When the "$" command is used with blockwise Visual mode, the right end of the 
highlighted text will be determined by the longest highlighted line. This
stops when a motion command is used that does not move straight up or down.

							*v_v*
If you use ESC, 'v', click the left mouse button or use any command that
does a jump to another buffer while in Visual mode, the highlighting stops
and no text is affected.  If you hit CTRL-Z the highlighting stops and the
editor is suspended or a new shell is started |CTRL-Z|.

For moving the end of the block many commands can be used, but you cannot 
use Ex commands, commands that make changes or abandon the file. Commands 
(starting with) ".pPiIaAO&", CTRL_^, "ZZ", CTRL-], CTRL-T, CTRL-R, CTRL-I 
and CTRL-O cause a beep and Visual mode continues. 

If Visual mode is not active and the "v", "V" or CTRL-V is preceded with a
count, the previously highlighted area is used for a start. You can then
move the end of the highlighted area and give an operator. The type of the
old area is used (character, line or blockwise).
- Linewise Visual mode: The number of lines is multiplied with the count.
- Blockwise Visual mode: The number of lines and columns is multiplied with
  the count.
- Normal Visual mode within one line: The number of characters is multiplied
  with the count.
- Normal Visual mode with several lines: The number of lines is multiplied
  with the count, in the last line the same number of characters is used as
  in the last line in the previously highlighted area.
The start of the text is the Cursor position. If the "$" command was used as 
one of the last commands to extend the highlighted text, the area will be
extended to the rightmost column of the longest line.

The operators that can be used are:
	~	switch case					|v_tilde|
	d	delete						|v_d|
	c	change						|v_c|
	y	yank						|v_y|
	>	shift right (1)(*)				|v_>|
	<	shift left (1)(*)				|v_<|
	!	filter through external command (1)		|v_!|
	=	filter through 'equalprg' option command (1)	|v_=|
	Q	format lines to 'textwidth' length (1)		|v_Q|

Additionally the following commands can be used:
	v	stop visual mode
	V	switch between normal and linewise visual mode	*v_V*
	CTRL-V	switch between normal and blockwise visual mode	*v_CTRL-V*
	:	start ex command for highlighted lines (1)	|v_:|
	r	change						|v_r|
	s	change						|v_s|
	C	change (2)					|v_C|
	R	change (2)					|v_R|
	S	change (2)					|v_S|
	x	delete						|v_x|
	D	delete (2)					|v_D|
	X	delete (2)					|v_X|
	Y	yank (2)					|v_Y|
	J	join (1)					|v_J|
	U	make uppercase					|v_U|
	u	make lowercase					|v_u|
	^]	find tag

(1): always whole lines
(2): whole lines when not using CTRL-V
(*): in a future a blockwise shift will move the block only, not whole
     lines.

Note that the ":vmap" command can be used to specifically map keys in Visual
mode.

If you want to give a register name using the """ command, do this just before 
typing the operator character: "v{move around}"xd".

If you want to give a count to the command, do this just before typing the
operator character: "v{move around}3>" (move lines 3 indents to the right).

When repeating a Visual mode operator, the operator will be applied to the
same amount of text as the last time:
- Linewise Visual mode: The same number of lines.
- Blockwise Visual mode: The same number of lines and columns.
- Normal Visual mode within one line: The same number of characters.
- Normal Visual mode with several lines: The same number of lines, in the
  last line the same number of characters as in the last line the last time.
The start of the text is the Cursor position. If the "$" command was used as 
one of the last commands to extend the highlighted text, the repeating will
be applied up to the rightmost column of the longest line.


	14. Various commands				*various*

							*CTRL-L*
CTRL-L			Clear and redraw the screen.

							*del*
<DEL>			When entering a number: remove the last digit.
			Note: if you like to use <BS> for this, add this
			mapping to your .vimrc:
				:map! CTRL-V <BS>   CTRL-V <DEL>

:ascii		or					*ga* *:ascii*
ga			Print the ascii value of the character under the
			cursor in decimal, hexadecimal and octal. For
			example, when the cursor is on a 'R':
				<R>  82,  Hex 52,  Octal 122
			{not in vi}

							*:print*
:[range]p[rint]		Print [range] lines (default current line).

:[range]p[rint] {count}
			Print {count} lines, starting with [range] (default
			current line |cmdline_ranges|).

							*:list*
:[range]l[ist] [count]
			Same as :print, but display unprintable characters
			with <^>.

							*:number*
:[range]nu[mber] [count]
			Same as :print, but precede each line with its line
			number. (See also 'highlight' option).

							*:#*
:[range]# [count]	synonym for :number.

							*:=*
:=			Print the line number.

							*:shell*
:sh[ell]		Escape to a shell (name from 'shell' option).

							*:!*
:![!]{cmd} [!][arg]	Execute {cmd} with the shell. The optional bangs are
			replaced with the previously given command. The 
			optional [arg] is appended. See also the 'shell' and 
			'shelltype' option.

							*:version*
:ve[rsion]		Print the version number of the editor. If the
			compiler used understands "__DATE__" the compilation
			date is mentioned. Otherwise a fixed release-date is
			shown.

							*K*
K			Run a program to lookup the identifier under the 
			cursor. The name of the program is given with the 
			'keywordprg' (kp) option (default is "man"). The
			identifier is formed of letters, numbers and the
			characters in 'identchars'. The identifier under or
			right of the cursor is used. The same can be done
			with the command
				":!{program} {identifier}". 
			There is an example of a program to use in the tools
			directory of Vim. It is called 'ref' and does a
			simple spelling check. {not in Vi}

[N]gs							*gs*
							*:sleep*
:[N]sleep [N]		Do nothing for [N] seconds. Can be interrupted with
			CTRL-C (CTRL-break on MSDOS). "gs" stands for "goto
			sleep". {not in Vi}


	15. Repeating commands				*repeating*

15.1 Single repeats					*single_repeat*

							*.*
.			Repeat last change with count replaced by [count].

Simple changes can be repeated with the "." command. Without a count, the 
count of the last change is used. If you enter a count, it will replace the 
last one. If the last change included a specification of a numbered 
register, the register number will be incremented. See the section on undo 
and redo for an example how to use this |undo_redo|.


15.2 Multiple repeats					*multi_repeat*

							*:global*
:[range]g[lobal]/{pattern}/[cmd]
			Execute the Ex command [cmd] (default ":p") on the
			lines within [range] where {pattern} matches.

:[range]g[lobal]!/{pattern}/[cmd]
			Execute the Ex command [cmd] (default ":p") on the
			lines within [range] where {pattern} does NOT match.

:[range]v[global]/{pattern}/[cmd]
			Same as :g!.

The global commands work by first scanning through the [range] lines and
marking each line where a match occurs. In a second scan the [cmd] is 
executed for each marked line with its line number prepended. If a line is 
changed or deleted its mark disappears. The default for [range] is the whole 
buffer (1,$). Use "CTRL-C" to interrupt the command. If an error message is
given for a line global aborts.

To repeat a non-Ex command, you will have to put the command in a file and 
use "source!". For example:
	:g/pat/so! scriptfile
Make sure that the scriptfile ends with a whole command, otherwise Vim will 
wait for you to type the rest of the command for each match. The screen will 
not have been updated, so you don't know what you are doing.
	
The undo/redo command will undo/redo the whole global command at once.


15.3 Complex repeats					*complex_repeat*

							*q*
q<0-9a-zA-Z">		Record typed characters into register <0-9a-zA-Z">
			(uppercase to append). The 'q' that stops recording
			is also stored in the register. The 'q' command is
			disabled while executing a register. (Implementation
			note: This was done because the 'q' command can be
			the result of mapping). {Vi: no recording}

q			Stops recording. {Vi: no recording}

							*@*
@<0-9a-z">		Execute the contents of register <0-9a-z"> [count]
			times. {Vi: only named registers}

							*@:*
@:			Repeat last command line [count] times.

							*@@*
@@			Repeat the previous @<0-9a-z":> [count] times.

							*:@*
:[addr]@<0-9a-z">	Execute the contents of register <0-9a-z"> as
			an Ex command. First set cursor at line [addr]
			(default is current line). {Vi: only in some
			versions}

:[addr]@:		Repeat last command line [count] times. First set
			cursor at line [addr] (default is current line).
			{Vi: only in some versions}

							*:@@*
:[addr]@@		Repeat the previous :@<0-9a-z">. First set cursor at
			line [addr] (default is current line). {Vi: only in
			some versions}

							*:source*
:so[urce] {file}	Read Ex commands from {file}.

:so[urce]! {file}	Read Vim commands from {file}. {not in Vi}

All commands and command sequences can be repeated by putting them in a named
register and then executing it. There are two ways to get the commands in the
register:
- Use the record command "q". You type the commands once, and while they are
  being executed they are stored in a register. Easy, because you can see 
  what you are doing. If you make a mistake, 'put' the register into the 
  file, edit the command sequence, and then delete it into the register 
  again. You can continue recording by appending to the register (use an 
  uppercase letter).
- Delete or yank the command sequence into the register.

Often used command sequences can be put under a function key with the ':map'
command.

An alternative is to put the commands in a file, and execute them with the
':source!' command. Useful for long command sequences. Can be combined with 
the ':map' command to put complicated commands under a function key.

The ':source' command reads Ex commands from a file line by line. You will 
have to type any needed keyboard input. The ':source!' command reads from a 
script file character by character, interpreting each character as if you 
typed it.

Example: When you give the ":!ls" command you are asked to "hit return to
continue". If you ':source' a file with the line "!ls" in it, you will have 
to type the return yourself. But if you ':source!' a file with the line 
":!ls" in it, the next characters from that file are read until a <CR> is 
found. You will not have to type <CR> yourself, unless ":!ls" was the last 
line in the file.

It is possible to put ':source[!]' commands in the script file, so you can 
make a top-down hierarchy of script files. The ':source' command can be 
nested as deep as the number of files that can be opened at one time (about 
15). The ':source!' command can be nested up to 15 levels deep.

In script files terminal-dependent key codes are represented by 
terminal-independent two character codes. This means that they can be used
in the same way on different kinds of terminals. The first character of a
key code is 0x80 or 128, shown on the screen as "~@". The second one can be
found in the list |key_notation|.  Any of these codes can also be entered
with CTRL-V followed by the three digit decimal code.


	16. Undo and redo				*undo_redo*

<UNDO>		or					*undo* *u*
u			Undo [count] changes. {Vi: only one level}

							*:undo*
:u[ndo]			Undo one change. {Vi: only one level}

							*CTRL-R*
CTRL-R			Redo [count] changes which were undone. {Vi: redraw 
			screen}

							*:redo*
:red[o]			Redo one change which was undone. {Vi: no redo}

							*U*
U			Undo all latest changes on one line. {Vi: while not
			moved off of it}

The last changes are remembered. You can go back in time with the "u" 
command. You can then go forward again with the 'CTRL-R' command. If you 
make a new change after the "u" command, the 'CTRL-R' will not be possible 
anymore. The number of changes that are remembered is set with the 
'undolevels' option. If it is zero, the old fashioned Vi undo is present: 
one level of undo and undo undoes itself. If it is negative no undo is
possible. Use this if you are running out of memory.

The "U" command is treated by undo/redo just like any other command. Thus a 
"u" command undos a "U" command and a 'CTRL-R' command redoes it again. When 
mixing "U", "u" and 'CTRL-R' you will notice that the "U" command will 
restore the situation of a line to before the previous "U" command. This may 
be confusing. Try it out to get used to it.

When all changes have been undone the buffer is not considered to be changed.
Vim can then be exit with ":q" instead of ":q!". {this is not in Vi}

The numbered registers can also be used for undoing deletes. Each time you 
delete text, it is put into register "1. The contents of register "1 are 
shifted to "2, etc. The contents of register "9 are lost. You can now get
back the most recent deleted text with the put command: '"1P'. (also, if the
deleted text was the result of the last delete or copy operation, 'P' or 'p'
also works as this puts the contents of the unnamed register). You can get
back the text of three deletes ago with '"3P'.

If you want to get back more than one part of deleted text, you can use a
special feature of the repeat command ".". It will increase the number of the
register used. So if you first do ""1P", the following "." will result in a
'"2P'. Repeating this will result in all numbered registers being inserted.

Example:	If you deleted text with 'dd....' it can be restored with
		'"1P....'.

If you don't know in which register the deleted text is, you can use the
:display command. An alternative is to try the first register with '"1P', and
if it is not what you want do 'u.'. This will remove the contents of the
first put, and repeat the put command for the second register. Repeat the
'u.' until you got what you want.


	17. Key mapping					*key_mapping*

							*:map*
:map {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Normal and
			Visual mode.

							*:map!*
:map! {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Insert and
			Command_line mode.

							*:noremap*
:no[remap] {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Normal and
			Visual mode. Disallow remapping of {rhs}. {not in
			Vi}

:no[remap]! {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in insert and
			Command_line mode. Disallow remapping of {rhs}. {not 
			in Vi}

							*:unmap*
:unm[ap] {lhs}		Remove the mapping of {lhs} for Normal and Visual
			mode.

							*:unmap!*
:unm[ap]! {lhs}		Remove the mapping of {lhs} for Insert and
			Command_line mode.

:map			List all key mappings for Normal and Visual mode.

:map!			List all key mappings for Insert and Command_line
			mode.

							*:map_l*
:map {lhs}		List the key mappings for the key sequences starting
			with {lhs} in Normal and Visual mode. {not in Vi}

							*:map_l!*
:map! {lhs}		List the key mappings for the key sequences starting
			with {lhs} in insert and Command_line mode. {not in Vi}

							*:nmap*
:nm[ap]			Same as :map, but for Normal mode only. {not
			in Vi}

							*:nunmap*
:nun[map]		Same as :unmap, but for Normal mode only.
			{not in Vi}

							*:nnoremap*
:nn[oremap]		Same as :noremap, but for Normal mode only.
			{not in Vi}

							*:vmap*
:vm[ap]			Same as :map, but for Visual mode only. {not
			in Vi}

							*:vunmap*
:vu[nmap]		Same as :unmap, but for Visual mode only.
			{not in Vi}

							*:vnoremap*
:vn[oremap]		Same as :noremap, but for Visual mode only.
			{not in Vi}

							*:cmap*
:cm[ap]			Same as :map!, but for Command_line mode only. {not
			in Vi}

							*:cunmap*
:cu[nmap]		Same as :unmap!, but for Command_line mode only.
			{not in Vi}

							*:cnoremap*
:cno[remap]		Same as :noremap!, but for Command_line mode only.
			{not in Vi}

							*:imap*
:im[ap]			Same as :map!, but for Insert mode only. {not in Vi}

							*:iunmap*
:iu[nmap]		Same as :unmap!, but for Insert mode only. {not in
			Vi}

							*:inoremap*
:ino[remap]		Same as :noremap!, but for Insert mode only. {not in
			Vi}

These commands are used to map a key or key sequence to a string of 
characters. You can use this to put command sequences under function keys, 
translate one key into another, etc. See the "Options" chapter below for how 
to save and restore the current mapping |options|.

There are four sets of mappings
- For Insert mode. These are also used in Replace mode.
- For Command_line mode: When entering a ":" or "/" command.
- For Normal mode: When typing commands.
- For Visual mode: When typing commands while the visual area is highlighted.

The original vi did not have separate mappings for Normal/Visual mode and
Insert/Command_line mode. Therefore the ":map" and ":map!" commands enter
and display mappings for both. In Vim you can use the ":nmap", "vmap",
":cmap" and ":imap" commands to enter mappings for each mode separately.
When listing mappings the character in column 1 is

	char		mode
	<SPACE>		Normal and Visual
	 n		Normal
	 v		Visual
	 !		Insert and Command_line
	 i		Insert
	 c		Command_line

Note: When using mappings for Visual mode, you can use the '<' mark, which
is the start of the last selected visual area |'<|.

Everything from the first non-blank after {lhs} up to the end of the line
(or <|>) is considered to be part of {rhs}. This allows the {rhs} to end
with a space.

To include a space in {lhs} precede it with a CTRL-V (type two CTRL-Vs for 
each space). If you want a {rhs} that starts with a space, precede {rhs} 
with a single CTRL-V (You have to type CTRL-V two times). You can create an 
empty {rhs} by typing nothing after the two CTRL-Vs.

It is not possible to put a comment after this command, because the <"> 
character is considered to be part of the {rhs}. To put a <|> in {rhs} 
escape it with a backslash or a CTRL-V (to get one CTRL-V you have to type 
it twice).

To avoid mapping of the characters you type in insert or Command_line mode, 
type a CTRL-V first. The mapping in Insert mode is disabled if the 'paste'
option is set.

Note that the second character (argument) of the commands @zZtTfF[]rm'`"v
and CTRL-X is not mapped. This was done to be able to use all the named
registers and marks, even when the command with the same name has been
mapped.

Some examples (given as you type them; e.g. the "^V" is CTRL-V which you 
type, but will not show up on the screen):

	:map g /foo^V^Mcwbar^V^[	(replace next "foo" by "bar")
	:map! qq quadrillion questions

Vim will compare what you type with the start of a mapped sequence. If there
is an incomplete match, it will get more characters until there either is a
complete match or until there is no match at all. Example: If you map! "qq",
the first <q> will not appear on the screen until you type another
character. This is because Vim cannot know if the next character will be a
<q> or not. If you set the 'timeout' option (which is the default) Vim will
only wait for one second (or as long as specified with the 'timeoutlen'
option). After that it assumes that the <q> is to be interpreted as such. If
type slowly, or your system is slow, reset the 'timeout' option. Then you
might want to set the 'ttimeout' option. See the "Options" chapter |options|.

If you include the {lhs} in the {rhs} you have a recursive mapping. When
{lhs} is typed, it will be replaced by {rhs}. When the {lhs} which is
included in {rhs} is encountered it will be replaced by {rhs}, and so on.
This makes it possible to repeat a command an infinite number of times. The
only problem is that the only way to stop this is by causing an error. The
macros to solve a maze uses this, look there for an example. There is one
exception: If the {rhs} starts with {lhs}, that part is not mapped again.
For example:
	:map a ab
will execute the "a" command and insert a 'b' in the text. The 'a' in the
{rhs} will not be mapped again.

If you want to exchange the meaning of two keys you should use the :noremap 
command. For example:
	:noremap k j
	:noremap j k
This will exchange the cursor up and down commands.

With the normal :map command, when the 'remap' option is set, mapping takes
place until the text is found not to be a part of a {lhs}. For example, if
you use:
	:map x y
	:map y x
Vim will replace x by y, and then y by x, etc. When this has happened
'maxmapdepth' times (default 1000), Vim will give the error message
"recursive mapping".

See the file "index" for keys that are not used and thus can be mapped 
without losing any builtin function.

If you include an undo command inside a mapped sequence, this will bring the 
text back in the state before executing the macro. This is compatible with 
the original vi, as long as there is only one undo command in the mapped 
sequence (having two undo commands in a mapped sequence did not make sense 
in the original vi, you would get back the text before the first undo).

There are two ways to map a function key:
1. The vi-compatible method: Map the key code. Often this is a sequence that
   starts with <ESC>. To enter a mapping like this you type ":map " and then
   you have to type CTRL-V before hitting the function key. Note that when
   the key code for the key is in the termcap (the t_ options), it will
   automatically be translated into the internal code and become the second
   way of mapping.
2. The second method is to use the internal code for the function key. To
   enter such a mapping just hit the function key, without CTRL-V, or use
   the form "#1", "#2", .. "#9", "#0", "<C_UP>", "<SC_DOWN>", "<SF7>", etc.
   (see table of keys |key_notation|, all keys from <C_UP> can be used). The
   first ten function keys can be defined in two ways: Just the number, like
   "#2", and with "<F>", like "<F2>". Both stand for function key 2. "#0"
   refers to function key 10, defined with option 't_f10', which may be
   function key zero on some keyboards.
The advantage of the second method is that the mapping will work on
different terminals without modification (the function key will be
translated into the same internal code, no matter what terminal you are
using. The termcap must be correct for this to work, and you must use the
same mappings).

DETAIL: Vim first checks if a sequence from the keyboard is mapped. If it
isn't the terminal key codes are tried (see section 20.2
|terminal_options|). If a terminal code is found it is replaced by the
internal code. Then the check for a mapping is done again (so you can map an
internal code to something else).  What is written into the script file
depends on what is recognized. If the terminal key code was recognized as a
mapping the key code itself is written to the script file. If it was
recognized as a terminal code the internal code is written to the script
file.


	18. Recovery after a crash.			*crash_recovery*

You have spent several hours typing in that text that has to be finished
next morning, and then disaster strikes: Your computer crashes.

			DON'T PANIC!


18.1 The swap file					*swap_file*

Vim stores the things you changed in a swap file. Using the original file
you started from plus the swap file you can mostly recover your work.

You can see the name of the current swap file being used with the command:

	:sw[apname]					*:swapname*

The name of the swap file is normally the same as the file you are editing, 
with the extension ".swp". On MSDOS machines and when the 'shortname' option 
is set, any <.> in the original file name is replaced by <_>. If this file
already exists (e.g. when you are recovering from a crash) a warning is
given and another extension is used, ".swo", ".swn", etc. An existing file
will never be overwritten. The swap file is deleted as soon as Vim stops
editing the file.

Technical: The replacement of <.> by <_> is done to avoid problems with 
	   MSDOS compatible filesystems (e.g. crossdos, multidos). If Vim is 
	   able to detect that the file is on an MSDOS-like filesystem, a 
	   flag is set that has the same effect as the 'shortname' option. 
	   This flag is reset when you start editing another file.

	   If the ".swp" filename already exists, the last character is 
	   decremented until there is no file with that name or ".swa" is 
	   reached. In the last case, no swap file is created.

By setting the 'directory' option you can place the swap file in
another place than where the edited file is. The advantage is that you will
not pollute the directories with ".swp" files and, when the 'directory' is
on another partition, reduce the risk of damaging the file system where the
file is (in a crash). The tradeoff is that you can get name collisions from
files with the same name but in different directories. You can also use a
recoverable ram disk, but there is no 100% guarantee that this works.
Putting swap files in a normal ram disk (like RAM: on the Amiga) makes no
sense, you will loose them in a crash. If you want to put swap files in
another place, put a command resembling the following one in your .vimrc:
	:set dir=dh2:tmp
This is also very handy when editing files on floppy.

The swap file is updated after typing 200 characters or when you have 
not typed anything for four seconds. This only happens if the buffer was 
changed, not when you only moved around. The reason why it is not kept up to 
date all the time is that this would slow down normal work too much. You can 
change the 200 character count with the 'updatecount' option. You can set 
the time with the 'updatetime' option. The time is given in milliseconds.

If the writing to the swap file is not wanted, it can be switched off by
setting the 'updatecount' option to 0. The same is done when starting Vim 
with the "-n" option. Writing can be switched back on by setting the
'updatecount' option to non-zero. Swap files will be created for all buffers
when doing this. But when setting 'updatecount' to zero, the existing swap
files will not be removed, it will only affect files that will be opened
after this.

If you want to make sure that your changes are in the swap file use this
command:

							*:preserve*
:pres[erve]		Write all text for all buffers into swap file. The
			original file is no longer needed for recovery. {Vi:
			emergency exit}

A Vim swap file can be recognized by the first six characters: "b0VIM ".
After that comes the version number, e.g. "3.0".


18.2 Recovery						*recovery*

In most cases recovery is quite easy: Start Vim on the same file you were
editing when the crash happened, with the "-r" option added. Vim will read
the ".swp" file and may read bits and pieces of the original file.

Example:	vim -r vim_ref.txt

If you were editing without a file name, give an empty string as argument:
		vim -r ""

If there are several swap files that look they may be the one you want to
use, a list is given of these swap files and you are requested to enter the
number of the one you want to use. In case you don't know which one to use,
just try them one by one and check the resulting files if they are what you
expected.

If you know which swap file needs to be used, you can recover by giving the
swap file name. Vim will then find out the name of the original file from
the swap file.

Example:	Vim -r vim_ref.txt.swo

This is also handy when the swap file is in another directory than expected.
If this still does not work, see what file names Vim reports and rename the
files accordingly. Check the 'directory' option to see where Vim may have
put the swap file.

Another way to do recovery is to start Vim and use the ":recover" command.
This is easy when you start Vim to edit a file and you get the "ATTENTION:
Found a swap file ..." message. In this case the single command ":recover"
will do the work. You can also give the name of the file or the swap file to
the recover command:
							*:recover*
:recover [file]		Try to recover [file] from the swap file. If [file]
			is not given use the file name for the current
			buffer. The current contents of the buffer are lost.
			This command fails if the buffer was modified.

:recover! [file]	Like ":recover", but any changes in the current
			buffer are lost.

Vim has some intelligence about what to do if the swap file is corrupt in
some way. If Vim has doubt about what it found, it will give an error
message and insert lines with "???" in the text. If you see an error message
while recovering, search in the file for "???" to see what is wrong. You may
want to cut and paste to get the text you need.

Be sure that the recovery was successful before overwriting the original
file or deleting the swap file. It is good practice to write the recovered
file elsewhere and execute 'diff' to find out if the changes you want are in
the recovered file.

Once you are sure the recovery is ok delete the swap file. Otherwise, you
will continue to get warning messages that the ".swp" file already exists.

{Vi: recovers in another way and sends mail if there is something to recover}


	19. Options					*options*

Vi has a number of internal variables and switches which can be set to 
achieve special effects. These options come in three forms, those that are 
switches, which toggle from off to on and back, those that require a numeric 
value, and those that require an alphanumeric string value.

19.1 Setting options					*set_option*

							*:set*
:se[t]			Show all modified options. {Vi: non-default options}

:se[t] all		Show all but terminal options.

:se[t] termcap		Show all terminal options.

:se[t] {option}		Set toggle option on, show value of string or number
			option.

:se[t] no{option}	Set toggle option off.

:se[t] inv{option}	Invert toggle option. {not in Vi}

:se[t] {option}={value} Set string or number option to {value}. For numeric
			options the value can be given in decimal, hex
			(preceded with 0x) or octal (preceded with '0')
			(hex and octal are only available for machines which
			have the strtol() function). The old value can be
			inserted by typing TAB (or whatever the value of
			'wildchar' is). See 4.4.2 |cmdline_completion|.

:se[t] {option}?	Show value of {option}.

The {option} arguments to ":set" may be repeated. For example:
	":set ai nosi sw=3 ts=3".
If you make an error in one of the arguments an error message will be given
and the text up to the next space will be skipped. Thus following arguments
will be processed.

The listing from ":set" looks different from vi. Long string options are put
at the end of the list. The number of options is quite large. The output of
"set all" probably does not fit on the screen, causing Vim to give the
"--more--" message. See the 'more' option.

Environment variables in most string options will be expanded. This
happens only when the string starts with a <$> or has a <$> after a space.
If the environment variable exists the <$> and the following environment
variable name is replaced by its value. If it does not exist the <$> and the
name are not modified. Any non-id character (not a letter, digit or <_>) may
follow the environment variable name. That character and what follows is
appended to the value of the environment variable. Example:
	:set term=$TERM.new

Using "~/" is like using "$HOME".

Besides changing options with the ":set" command, there are seven 
alternatives to set options automatically for one or more files. The first 
four are used for all files. The fifth is used to set options for 
the files in one directory. The last two are used to set options for a
single file. The first five are done when you start Vim, in the given
order. The last two are done whenever you start editing a new file.

1. The environment variable VIMINIT is read for an Ex command. You can set
   VIMINIT to something like "set noai sw=3" to set options.
2. Only if there is no VIMINIT environment variable, the file 
   "s:.vimrc" is read for Ex commands. You can include set commands in this 
   file. (see below for how to automatically create a file with set commands).
3. If VIMINIT is not found and "s:.vimrc" does not exist, EXINIT is used, 
   in the same way as VIMINIT.
4. If VIMINIT is not found, "s:.vimrc" does not exist and EXINIT is not found, 
   the file "s:.exrc" is read for Ex commands.
5. If the 'exrc' option is set, the file ".vimrc" in the current directory is 
   read for Ex commands. You can include set commands in this file. If this 
   file is not found the file ".exrc" is tried.
6. If you start editing a new file, the automatic commands are executed.
   This can be used to set options for files matching a particular pattern.
   See the section "Automatic commands" |autocommand|.
							*modeline*
7. If you start editing a new file, and the 'modeline' option is set, a
   number of lines at the beginning and end of the file are checked for the
   string "vi:", "vim:" or "ex:". The text after it is considered to be the
   arguments for a ":set" command, separated with colons or spaces. For
   example:
		"vi:noai:sw=3 ts=6"
   The number of lines that are checked can be set with the 'modelines'
   option. If 'modeline' is not set or 'modelines' is 0 no lines are
   checked.
   The string "vi:", "vim:" or "ex:" must be preceded with a blank or begin 
   at the start of a line. This minimizes the chance that a normal word like 
   "lex:" is caught.
   Note that all of the rest of the line is used, thus a line like:
		"/* vi:ts=4: */"
   will give an error message for the trailing "*/".
   If an error is detected the rest of the line is skipped.
   One other form of modelines is recognized that has the "set" command
   after "vi:", "vim:" or "ex:" (this is compatible with some versions of
   vi). In this case the characters up to the first <:> are executed as an
   ex command. Anything following it is ignored. Thus a line like:
		"/* vi:set ts=4: */"
   is OK. If you want to include a <:> in a set command precede it with a
   <\>.


19.2 Saving settings					*save_settings*

							*:mkexrc*
:mk[exrc] [file]	Write current key mappings and changed options to 
			[file] (default ".exrc"), unless it already exists. 
			{not in Vi}

:mk[exrc]! [file]	Always write current key mappings and changed 
			options to [file] (default ".exrc"). {not in Vi}

							*:mkvimrc*
:mkv[imrc][!] [file]	Same as :mkexrc, but default is ".vimrc". {not in 
			Vi}

These commands will write ":map" and ":set" commands to a file, in such a 
way that when these commands are executed, the current key mappings and 
options will be set again. A common method is to use a default ".exrc" file 
by first reading one in with ":source s:.exrc.Cprogs", change the settings 
and then save them in the current directory with ":mkexrc!".


19.3 Options summary				*option_summary*

In the list below all the options are mentioned with their full name and some
with an abbreviation between parens. Both forms may be used. In this
document when an option that can be toggled is "set" that means that ":set
option" is entered.  When an option is "reset", ":set nooption" is used.

Most options are the same in all windows and buffers. There are a few that
are specific to how the text is presented in a window. These can be set to a
different value in each window. For example the 'list' option can be set in
one window and reset in another for the same text, giving both types of view
at the same time. There are a few options that are specific to a certain
file. These can have a different value for each file or buffer. For example
the 'textwith' option can be 78 for a normal text file and 0 for a C
program. When creating a new window or buffer the option values from the
currently active window or buffer are used as a default value.


This list was made by doing ""tY@t" on the following line.
Adjust the number 120 to the number of options.

:set tw=0jjjj0d/^$mt"aykOyt	O|'p0lea'|                   22|dwA():s/(/|'/g:s/)/'|/g$xxxx"Add/^[^ 	]0"qDdd/^[^ 	]120@q't"aP2dd:set tw=76

Alphabetical jump table for the options (because there are so many):

|'autoindent'|       |'ai'|
|'autowrite'|        |'aw'|
|'backspace'|        |'bs'|
|'backup'|           |'bk'|
|'backupdir'|        |'bdir'|
|'backupext'|        |'bex'|
|'binary'|           |'bin'|
|'bioskey'|          |'bk'|
|'cmdheight'|        |'ch'|
|'columns'|          |'co'|
|'comments'|         |'com'|
|'compatible'|       |'cp'|
|'define'|           |'def'|
|'dictionary'|       |'dict'|
|'digraph'|          |'dg'|
|'directory'|        |'dir'|
|'edcompatible'|     
|'endofline'|        |'eol'|
|'equalalways'|      |'ea'|
|'equalprg'|         |'ep'|
|'errorbells'|       |'eb'|
|'errorfile'|        |'ef'|
|'errorformat'|      |'efm'|
|'esckeys'|          |'ek'|
|'expandtab'|        |'et'|
|'exrc'|             
|'formatoptions'|    |'fo'|
|'formatprg'|        |'fp'|
|'gdefault'|         |'gd'|
|'graphic'|          |'gr'|
|'helpfile'|         |'hf'|
|'helpheight'|       |'hh'|
|'hidden'|           |'hid'|
|'highlight'|        |'hl'|
|'history'|          |'hi'|
|'icon'|             
|'identchars'|       |'id'|
|'ignorecase'|       |'ic'|
|'include'|          |'inc'|
|'incsearch'|        |'is'|
|'infercase'|        |'inf'|
|'insertmode'|       |'im'|
|'joinspaces'|       |'js'|
|'keywordprg'|       |'kp'|
|'laststatus'|       |'ls'|
|'lines'|            
|'list'|             
|'magic'|            
|'makeprg'|          |'mp'|
|'maxmapdepth'|      |'mmd'|
|'maxmem'|           |'mm'|
|'maxmemtot'|        |'mmt'|
|'modeline'|         |'ml'|
|'modelines'|        |'mls'|
|'more'|             
|'mouse'|            
|'nestedcomments'|   |'ncom'|
|'nobuf'|            |'nb'|
|'number'|           |'nu'|
|'paragraphs'|       |'para'|
|'paste'|            
|'patchmode'|        |'pm'|
|'path'|             |'pa'|
|'readonly'|         |'ro'|
|'remap'|            
|'report'|           
|'revins'|           |'ri'|
|'ruler'|            |'ru'|
|'scroll'|           
|'scrolljump'|       |'sj'|
|'sections'|         |'sect'|
|'secure'|           
|'shell'|            |'sh'|
|'shellpipe'|        |'sp'|
|'shellredir'|       |'srr'|
|'shelltype'|        |'st'|
|'shiftround'|       |'sr'|
|'shiftwidth'|       |'sw'|
|'shortmess'|        |'shm'|
|'shortname'|        |'sn'|
|'showcmd'|          |'sc'|
|'showmatch'|        |'sm'|
|'showmode'|         |'smd'|
|'sidescroll'|       |'ss'|
|'smartindent'|      |'si'|
|'smartmatch'|       |'sma'|
|'smarttab'|         |'sta'|
|'splitbelow'|       |'sb'|
|'startofline'|      |'sol'|
|'suffixes'|         |'su'|
|'tabstop'|          |'ts'|
|'taglength'|        |'tl'|
|'tagrelative'|      |'tr'|
|'tags'|             
|'term'|             
|'terse'|            
|'textauto'|         |'ta'|
|'textmode'|         |'tx'|
|'textwidth'|        |'tw'|
|'tildeop'|          |'to'|
|'timeout'|          
|'ttimeout'|         
|'timeoutlen'|       |'tm'|
|'title'|            
|'ttyfast'|          
|'undolevels'|       |'ul'|
|'updatecount'|      |'uc'|
|'updatetime'|       |'ut'|
|'viminfo'|          |'vi'|
|'visualbell'|       |'vb'|
|'warn'|             
|'weirdinvert'|      |'wi'|
|'whichwrap'|        |'ww'|
|'wildchar'|         |'wc'|
|'winheight'|        |'wh'|
|'wrap'|             
|'wrapmargin'|       |'wm'|
|'wrapscan'|         |'ws'|
|'writeany'|         |'wa'|
|'writebackup'|      |'wb'|

					*'autoindent'* *'ai'*
autoindent (ai)		toggle	(default off)
	Copy indent from current line when starting a new line (typing <CR> 
	in Insert mode or when using the "o" or "O" command). If you do not 
	type anything on the new line except <BS> and then type <ESC> or 
	<CR>, the indent is deleted again. When autoindent is set, 
	formatting (with the "Q" command or when you reach 'textwidth' in 
	Insert mode) uses the indentation of the first line. The 'autoindent'
	option is reset when the 'paste' option is set. {small difference
	from vi: After the indent is deleted when typing <ESC> or <CR>, the
	cursor position when moving up or down is after the deleted indent;
	vi puts the cursor somewhere in the deleted indent}. Each buffer has
	its own copy of this option.

						*'autowrite'* *'aw'*
autowrite (aw)		toggle	(default off)
	Write the contents of the file, if it has been modified, on each
	:next, :rewind, :previous, :stop, :suspend, :tag, :!, :make, CTRL-]
	and CTRL-^ command; and when a CTRL-O, CTRL-I, '<A-Z>, or `<A-Z>
	command takes one to another file.

					*'backspace'* *'bs'*
backspace (bs)		number	(default 0)
	Influences the working of <BS>, <DEL>, CTRL-W and CTRL-U in Insert 
	mode. If set to 0 Vi compatible backspacing is used. When 1 allow 
	backspacing over newlines. When larger than 1 allow backspacing over 
	the start of insert. In the last case CTRL-W and CTRL-U stop once at 
	the start of insert. {not in Vi}

						*'backup'* *'bk'*
backup (bk)		toggle	(default off)
	Make a backup before overwriting a file. Leave it around after the 
	file has been successfully written. If you do not want to keep the 
	backup file, but you do want a backup while the file is being
	written, reset this option and set the 'writebackup' option (this is
	the default). If you do not want a backup file at all reset both
	options (use this if your file system is almost full). See the table
	in section 5.4 for another explanation |backup_table|. {not in Vi}

						*'backupdir'* *'bdir'*
backupdir (bdir)	string	(default "$HOME")
	Directory name for the backup file. Empty means in same directory as
	the edited file. If the directory name starts with <>>, only the
	specified directory will be used. If there is a directory name but
	it does not start with <>>, the current directory is tried first.
	The specified directory is used only if that fails. The name may end
	in an <:> or </>. Environment variables are expanded. {not in Vi}

						*'backupext'* *'bex'*
backupext (bex)		string	(default ".~")
	String which is appended to a file name to make the name of the
	backup file. The default is quite unusual, because this avoids
	accidently overwriting existing files with a backup file. You might
	prefer using ".bak", but make sure that you don't have files with
	".bak" that you want to keep. {not in Vi}

						*'binary'* *'bin'*
binary (bin)		toggle	(default off)
	This option should be set before editing a binary file. You can also
	use the "-b" command line option. When this option is set the
	'textwidth' option will set to 0, the 'textmode' and 'textauto'
	options will be reset and 'modelines' will be set to 0. When writing
	a file the end-of-line for the last line is only written if there
	was one in the original file (normally Vim appends an end-of-line to
	the last line if there is none; this would make the file longer). See
	the 'endofline' option. Each buffer has its own copy of this option.
	{not in Vi}

						*'bioskey'* *'bk'*
bioskey (bk)		toggle	(default on)
	For MSDOS only: When set the bios is called to obtain a keyboard
	character. This works better to detect CTRL-C, but only works for
	the console. When using a terminal over a serial port reset this
	option. {not in Vi}

					*'cmdheight'* *'ch'*
cmdheight (ch)		number	(default 1)
	Number of lines to use for the command line. If you are annoyed by
	"hit return to continue" or "--more--" caused by long messages, set
	this option to a larger value. {not in Vi}

						*'columns'* *'co'*
columns (co)		number	(default 80 or terminal width)
	Number of columns in the display. Normally this is set by the 
	terminal initialization and does not have to be set by hand. {not in 
	Vi}

						*'comments'* *'com'*
comments (com)		string	(default "/* ,* ,*/,//,# ,%,XCOMM")
	Represents patterns that can start a comment line. See |formatting|.
	Each buffer has its own copy of this option. {not in Vi}

						*'compatible'* *'cp'*
compatible (cp)		toggle	(default off)
	At the moment this option is set, several other options will be set 
	or reset to make Vim vi-compatible. Switching this option off has no 
	effect. {not in Vi}

	option		new value	effect

	backspace	0		normal backspace
	backup		off		no backup file
	digraph		off		no digraphs
	esckeys		off		no <ESC>-keys in Insert mode
	expandtab	off		tabs not expanded to spaces
	history		0		no commandline history
	insertmode	off		do not start in Insert mode
	identchars	"_"		identifiers contain alphanumeric
						characters and '_'
	joinspaces	on		insert 2 spaces after period
	modelines	0		no modelines
	more		off		no pauses in listings
	revins		off		no reverse insert
	ruler		off		no ruler
	scrolljump	0		no jump scroll
	shiftround	off		indent not rounded to shiftwidth
	showcmd		off		command characters not shown
	showmode	off		current mode not shown
	smartindent	off		no smart indentation
	smartmatch	off		no smart paren matching
	startofline	on		goto startofline with some commands
	textauto	off		no automatic textmode detection
	textwidth	0		no automatic line wrap
	tildeop		off		tilde is not an operator
	ttimeout	off		no terminal timeout
	undolevels	0		no multilevel undo
	updatecount	0		no swap file
	writebackup	off		no backup file written

					*'define'* *'def'*
define (def)		string	(default "^#[ \t]*define")
	Pattern to be used to find a macro definition. It is a search
	pattern, just like for the "/" command. The default value is for C
	programs. This option is used for the commands like "[g"
	|include_search| and "[d" |include_search|. {not in Vi}

						*'dictionary'* *'dict'*
dictionary (dict)	string	(default "")
	List of file names, separated by spaces. Each file should contain a
	list of words, one per line. This option is used for keyword
	completion. {not in Vi}

						*'digraph'* *'dg'*
digraph (dg)		toggle	(default off)
	Enable the entering of digraphs in Insert mode with {char1} <BS> 
	{char2}. Only works if Vim was compiled with digraphs enabled. See
	|digraphs|. {not in Vi}

						*'directory'* *'dir'*
directory (dir)		string	(default for Amiga: "t:", for MSDOS:
				"c:\tmp", for unix: "/tmp")
	Directory name for the swap file. Empty means in same directory as the
	edited file. If the directory name starts with <>>, only the
	specified directory will be used. If there is a directory name but
	it does not start with <>>, the current directory is tried first.
	The specified directory is used only if that fails. The name may end
	in an <:> or </>. Environment variables are expanded. Careful with
	<\> characters, type two to get one in the option,
		":set dir=c:\\tmp".
	{Vi: directory to put temp file in, defaults to "/tmp"}

					*'edcompatible'*
edcompatible		toggle	(default off)
	Makes the 'g' and 'c' flags of the ":substitute" command to be
	toggled each time the flag is given. See 11.3 |complex_change|. See
	also 'gdefault' option.

						*'endofline'* *'eol'*
endofline (eol)		toggle	(default on)
	When writing a file and this option is off and the 'binary' option
	is set, no end of line (newline) character will be written for the
	last line in the file. This option is automatically set when
	starting to edit a new file, unless the 'binary' options is set and
	the file does not have an end of line (newline) for the last line in
	the file, in which case it is reset. Normally you don't have to set
	or reset this option. When 'binary' is not set the value is not
	used. When 'binary' is set it is used to remember the presence of a
	newline for the last line in the file, so that when you write the
	file the situation from the original file can be kept. But you can
	change it when you want to. Each buffer has its own copy of this
	option. {not in Vi}

						*'equalalways'* *'ea'*
equalalways (ea)	toggle	(default on)
	When set all the windows are automatically made the same size after
	splitting or closing a window. If you don't set this option, splitting
	a window will reduce the size of the current window and leave the
	other windows the same. When closing a window the extra lines are
	given the the window above it. {not in Vi}

						*'equalprg'* *'ep'*
equalprg (ep)		string	(default "indent")
	External program to use for "=" command. Environment variables are
	expanded. {not in Vi}

						*'errorbells'* *'eb'*
errorbells (eb)		toggle	(default off)
	Ring the bell for error messages. Does not work on the Amiga, you 
	always get a screen flash.

						*'errorfile'* *'ef'*
errorfile (ef)		string	(default "AztecC.Err" or "errors")
	Name of the error file for the QuickFix mode (see 5.5
	|:make_makeprg|). Environment variables are expanded. {not in Vi}

						*'errorformat'* *'efm'*
errorformat (efm)	string	(default "%f>%l:%c:%t:%n:%m" or
						""%f",%*[^0-9]%l %m")
	Scanf-like description of the format for the lines in the error file
	(see 5.5 |quickfix|). {not in Vi}

						*'esckeys'* *'ek'*
esckeys (ek)		toggle	(default on)
	Function keys that start with an <ESC> are recognized in Insert
	mode. When this option is off, the cursor and function keys cannot be
	used in Insert mode if they start with an <ESC>. The advantage of this
	is that the single <ESC> is recognized immediately, instead of after
	one second.

						*'expandtab'* *'et'*
expandtab (et)		toggle	(default off)
	In Insert mode: Use the appropriate number of spaces to insert a 
	<TAB>. Spaces are used in indents with the '>' and '<' commands and
	when 'autoindent' is set. To insert a real tab when expandtab is
	set, use CTRL-V<TAB>. See also ":retab" command in 11.3 |:retab|
	and section 4.3.4 |ins_expandtab|. Each buffer has its own copy of
	this option. {not in Vi}

						*'exrc'*
exrc			toggle (default off)
	Enables the reading of .vimrc and .exrc in the current directory. If
	you switch this option on you should also consider setting the
	'secure' option (see 3.4 |initialization|). {not in Vi}

					*'formatoptions'* *'fo'*
formatoptions (fo)	string (default "tcqs")
	This is a sequence of letters which describes how automatic
	formatting is to be done.  See |fo_table|. Each buffer has its own
	copy of this option. {not in Vi}

						*'formatprg'* *'fp'*
formatprg (fp)		string (default "")
	The name of an external program that will be used to format the
	lines selected with the "Q" command. The program must take the input
	on stdin and produce the output on stdout. The unix program 'fmt' is
	such a program. If this option is an empty string, the internal
	format function will be used. Environment variables are expanded.
	{not in Vi}

					*'gdefault'* *'gd'*
gdefault (gd)		toggle	(default off)
	When set, the ":substitute" flag 'g' is default on. This means that
	all matches in a line are substituted instead of one. See 11.3
	|complex_change|. {not in Vi} 

						*'graphic'* *'gr'*
graphic (gr)		toggle	(default off, MSDOS: on)
	When off characters between <~> and 0xa0 are displayed as "~?", 
	"~@", "~A", etc.. When on the characters are sent to the display 
	directly. This will allow for graphic characters to be shown on some 
	terminals (e.g. MSDOS console) and mess up the display on others 
	(e.g. Amiga).

					*'helpfile'* *'hf'*
helpfile (hf)		string	(default (Amiga) "vim:vim_help.txt"
					 (unix) "/usr/local/lib/vim_help.txt")
	Name of the help file. It may start with an environment variable.
	For example: "$VIM/doc/vim_help.txt". Environment variables are
	expanded.  {not in Vi}

						*'helpheight'* *'hh'*
helpheight (hh)		number	(default 20)
	Height of the help window when it is opened with the ":help"
	command. When it is zero the window will be half the height of the
	current window. {not in Vi}

						*'hidden'* *'hid'*
hidden (hid)		toggle	(default off)
	When off the current buffer is unloaded when it is abandoned. When
	on the current buffer becomes hidden when starting to edit another
	buffer. If the current buffer is also displayed in another window it
	does not become hidden. The commands that move through the buffer
	list make the current buffer hidden although the 'hidden' option is
	not set. See also |vim_win.txt|. {not in Vi} 

						*'highlight'* *'hl'*
highlight (hl)		string	(default "8b,db,es,hs,mb,nu,rs,si,tb,vi")
	This option can be used to set highlighting mode for various
	occasions. It is a comma separated list of character pairs. The first
	character in a pair gives the occasion, the second the mode to use for
	that occasion. The occasions are:
		8	Meta & special keys listed with ":map"
		d	directories in CTRL-D listing
		e	error messages
		h	help file headers
		m	"More?" message
		n	line number for ":number" and ":#" commands
		r	return to continue message and yes/no questions
		s	status lines
		t	Titles for output from ":set all" and ":autocmd" etc.
		v	visual mode
	The display modes are:
		i	invert		(termcap entry "mr")
		b	bold		(termcap entry "md")
		s	standout	(termcap entry "so")
		n	no highlighting
	The default is to use bold for directories, standout for error
	messages, help file headers and return, invert for visual mode and
	status lines.
	Invert is used for occasions that are not included. {not in Vi}

						*'history'* *'hi'*
history (hi)		number	(default 20)
	Number of command lines that are remembered. {not in Vi}

						*'icon'*
icon			toggle	(default off)
	When set the icon of the window will be set to the name of the file
	currently being edited. Only the last part of the name is used. Only
	works if the terminal supports setting window icons (currently only
	Unix xterm and iris-ansi). When Vim was compiled with USE_X11
	defined, the original icon will be restored if possible. {not in Vi}

						*'identchars'* *'id'*
identchars (id)		string	(default "_")
	The characters in this option are included in identifiers.
	Identifiers are used in searching and recognizing words with many
	commands: "*", "[g", etc. Some characters need a backslash before
	them: '"' and ']'. If you use '-' it will be moved to the end of the
	option automatically (to avoid problems with CTRL-N in insert mode).
	Each buffer has its own copy of this option. For C programs you
	could use "_.->". {not in Vi}

						*'ignorecase'* *'ic'*
ignorecase (ic)		toggle	(default off)
	Ignore case in search patterns. Also used when searching in the tags
	file.

						*'include'* *'inc'*
include (inc)		string	(default "^#[ \t]*include")
	Pattern to be used to find an include command. It is a search
	pattern, just like for the "/" command (See 6.5, "Pattern
	searches" |search_pattern|). The default value is for C programs.
	This option is used for the commands "[g", "]g", "[d", etc.  {not in
	Vi}

						*'incsearch'* *'is'*
incsearch (is)		toggle	(default off)
	While typing a search pattern, show immediately where the so far
	typed pattern matches. The matched string is highlighted. If the
	pattern is invalid or not found, nothing is shown. The screen will
	be updated often, this is only useful on fast terminals. {not in Vi}

						*'infercase'* *'inf'*
infercase (inf)		toggle	(default off)
	When doing keyword completion in insert mode |ins_completion|, and
	'ignorecase' is also set, the case of the match is adjusted. If the
	typed text contains a lowercase letter where the match has an upper
	case letter, the completed part is made lower case. If the typed
	text has no lower case letters and the match has a lower case letter
	where the typed text has an upper case letter, and there is a letter
	before it, the completed part is made uppercase.  {not in Vi}

						*'insertmode'* *'im'*
insertmode (im)		toggle	(default off)
	Start the edit of a file in Insert mode. {not in Vi}

					*'joinspaces'* *'js'*
joinspaces (js)		toggle	(default on)
	Insert two spaces after a period with a join command. {not in Vi}

					*'keywordprg'* *'kp'*
keywordprg (kp)		string	(default "man")
	Program to use for the "K" command. Environment variables are
	expanded. {not in Vi}

					*'laststatus'* *'ls'*
laststatus (ls)		number	(default 1)
	The value of this option influences when the last window will have a
	status line:
		0: never
		1: only if there are at least two windows
		2: always
	The screen looks nicer with a status line if you have several
	windows, but it takes another screen line. {not in Vi}

						*'lines'*
lines			number	(default 24 or terminal height)
	Number of lines in the display. Normally you don't need to set this. 
	That is done automatically by the terminal initialization code.

						*'list'*
list			toggle	(default off)
	List mode: Show tabs as CTRL-I, show end of line with $. Useful to 
	see the difference between tabs and spaces and for trailing blanks.
	Each window has its own copy of this option.

						*'magic'*
magic			toggle	(default on)
	Changes the special characters that can be used in search patterns. 
	See section "Pattern searches" |search_pattern|.

						*'makeprg'* *'mp'*
makeprg (mp)		string	(default "make")
	Program to use for the ":make" command. See |:make_makeprg|. This
	option may contain <%> and <#> characters, which are expanded like
	when used in a command line. Environment variables are expanded.
	{not in Vi}

						*'maxmapdepth'* *'mmd'*
maxmapdepth (mmd)		number	(default 1000)
	Maximum number of times a mapping is done without resulting in a
	character to be used. This normally catches endless mappings, like
	":map x y" with ":map y x". It still does not catch ":map g wg",
	because the 'w' is used before the next mapping is done. See also
	|key_mapping|  {not in Vi}

						*'maxmem'* *'mm'*
maxmem (mm)		number	(default 512)
	Maximum amount of memory (in Kbyte) to use for one buffer. When this
	limit is reached allocating extra memory for a buffer will cause
	other memory to be freed. See also 'maxmemtot'. {not in Vi}

						*'maxmemtot'* *'mmt'*
maxmemtot (mmt)		number	(default 512)
	Maximum amount of memory (in Kbyte) to use for all buffers together.
	Added 'maxmemtot' option ( 'mmt' ), maximal Kbyte to use for
	all buffers.

						*'modeline'* *'ml'*
modeline (ml)		toggle	(default on)
						*'modelines'* *'mls'*
modelines (mls)		number	(default 5)
	If 'modeline' is set 'modelines' gives the number of lines that is
	checked for set commands. If 'modeline' is not set or 'modelines' is
	0 no lines are checked. See 19.1 |modeline|. Each buffer has its
	own copy of the 'modeline' option. {not in Vi}

						*'more'*
more			toggle	(default on)
	Listings pause when the whole screen is filled.
	Type <CR> or <LF> for one more line.
	Type <SPACE> for the next page.
	Type 'd' for down half a page.
	Type 'q' or CTRL-C to stop the listing.
	Type ':' to stop the listing and enter a command line.
	Any other key causes the meaning of the keys to be displayed.
	When this option is off there are no pauses, the listing continues
	until finished. When Vim was compiled with COMPATIBLE defined this
	option is default off. When 'compatible' is set this option is off.
	Note: The key typed at the "more" prompt is not mapped {not in Vi}

						*'mouse'*
mouse			toggle	(default on)
	Enable the use of mouse clicks. Only works for certain terminals
	(MSDOS and xterm). Note: Normal copy/paste in an xterm can still be
	used by pressing the shift key when using the mouse. {not in Vi}

				*'nestedcomments'* *'ncom'*
nestedcomments (ncom)	string	(default ">")
	Contains patterns that start comments that can be nested. See
	|formatting|. Each buffer has its own copy of this option. {not in
	Vi}

						*'nobuf'* *'nb'*
nobuf (nb)		toggle	(default off)
	When set characters are send to the terminal one by one. For MSDOS
	pcterm this does not work. For debugging purposes. {not in Vi}

						*'number'* *'nu'*
number (nu)		toggle	(default off)
	Print the line number in front of each line. Each window has its own
	copy of this option.

			*'paragraphs'* *'para'*
paragraphs (para)	string	(default "IPLPPPQPP LIpplpipbp")
	Specifies the nroff macros that separate paragraphs. These are pairs 
	of two letters (see section 6.4 |object_motions|).

						*'paste'*
paste			toggle	(default off)
	Put Vim in Paste mode. This is useful if you want to cut or copy
	some text from one window and paste it in Vim. This will avoid
	unexpected effects. When the 'paste' option is set mapping in Insert
	mode is disabled, abbreviations are disabled and some options are
	reset ( 'textwidth', 'autoindent', 'smartindent', 'revins', 'ruler'
	and 'showmatch'). When the 'paste' option is reset the mentioned
	options are restored to the value before the moment 'paste' was
	set. Resetting 'paste' before ever setting it does not have any
	effect. If you use this often, you could map a function key to the
	command ":set invpaste^V^M". {not in Vi}

						*'patchmode'* *'pm'*
patchmode (pm)		string	(default "")
	Only for Unix: When set the oldest version of a file is kept. This can
	be used to keep the original version of a file if you are changing
	files in a source distribution. Only the first time that a file is
	edited a copy of the original file will be kept. The name of the copy
	is the name of the original file with the string in the 'patchmode'
	option appended. This option should start with a dot. Use a string
	like ".org". Only works properly if the 'backup' or the 'writebackup'
	option is set. If both are not set, an empty file is created with the
	'patchmode' option appended to the name of the original file. This
	means that you can only see which files where changed. {not in Vi}

						*'path'* *'pa'*
path (pa)		string  (default ". /usr/include" on unix, or ".")
	This is a list of directories which will be searched when using the
	gf, [f, ]f, ^Wf and other commands, provided that the file being
	searched for has a relative path (not absolute).  The directories
	may be relative or absolute.  When setting, \ must be used to escape
	spaces, eg:
		:set path=.\ /usr/local/include\ /usr/include
	Don't forget "." or files won't even be found in the current
	directory!  {not in Vi}

				*'readonly'* *'ro'*
readonly (ro)		toggle	(default off)
	If set, writes fail unless you use an !. Protects you from
	accidentally overwriting a file. Default on when vim is started
	in view mode ("vim -v") or when the executable is called "view". It
	is reset if you overwrite the current file (e.g. with ":w!"). Each
	buffer has its own copy of this option.

						*'remap'*
remap			toggle	(default on)
	Allows for :map command to work recursively. If you do not want this 
	for a single entry, use the :noremap[!] command.

						*'report'*
report			number	(default 2)
	Threshold for reporting number of lines changed.

						*'revins'*
revins (ri)		toggle	(default off)
	Inserting characters in Insert mode will work backwards. See "typing
	backwards" |ins_reverse|. Can be toggled with the CTRL-B command in
	Insert mode.  This option is reset when 'compatible' or 'paste' is
	set. {not in Vi}

						*'ruler'* *'ru'*
ruler (ru)		toggle	(default off)
	Show the line and column number of the cursor position in the status
	line, separated by a comma. If there are characters in the line that
	take two positions on the screen, both the "real" column and the
	screen column are shown, separated with a dash. This option is reset
	when the 'paste' option is set. {not in Vi}

						*'scroll'*
scroll			number	(default 'lines' / 2)
	Number of lines to scroll with CTRL-U and CTRL-D commands. Will be
	set to half the number of lines in the window when the window size
	changes. If you give a count to the CTRL-U or CTRL-D command it will
	be used as the new value for 'scroll'. Reset to 'lines' / 2 with
	":set scroll=0". Each window has its own copy of this option.

						*'scrolljump'* *'sj'*
scrolljump (sj)		number	(default 1)
	Minimal number of lines to scroll when the cursor gets off the 
	screen (e.g. with "j"). Not used for scroll commands (e.g. CTRL-E, 
	CTRL-D). Useful if your terminal scrolls very slowly. {not in Vi}

						*'sections'* *'sect'*
sections (sect)		string	(default "SHNHH HUnhsh")
	Specifies the nroff macros that separate sections. These are pairs of
	two letters (See section 6.4 |object_motions|).

						*'secure'*
secure			toggle	(default off)
	When on, ":autocmd", shell and write commands are not allowed in
	".vimrc" and ".exrc" in the current directory and map commands are
	displayed.  Switch it off only if you know that you will not run
	into problems, or when the 'exrc' option is off. On unix this option
	is only used if the ".vimrc" or ".exrc" is not owned by you.

						*'shell'* *'sh'*
shell (sh)		string	(default $SHELL or "sh", MSDOS: "command")
	Name of the shell to use for ! and :! commands. See also the
	'shelltype' option. It is allowed to give an argument to the 
	command, e.g. "csh -f". If you type this in the command line you 
	will have to put a backslash in front of the space. Environment
	variables are expanded.

						*'shellpipe'* *'sp'*
shellpipe (sp)		string	(default ">", "| tee", "|& tee" or "2>&1| tee")
	String to be used to put the output of the ":make" command in the
	error file. See also |:make_makeprg|. For the Amiga and MSDOS the
	default is ">". The output is directly saved in a file and not
	echoed to the screen. For Unix the default it "| tee". The stdout of
	the compiler is saved in a file and echoed to the screen. If the
	'shell' option is "csh", "tcsh" or "zsh" after initializations, the
	default becomes "|& tee". If the 'shell' option is "sh", "ksh" or
	"bash" the default becomes "2>&1| tee". This means that stderr is
	also included.  The initialization of this option is done after
	reading the ".vimrc" and the other initializations, so when the
	'shell' option is set there it automatically changes the 'shellpipe'
	option, unless it was set before. {not in Vi}

						*'shellredir'* *'srr'*
shellredir (srr)	string	(default ">", ">&" or "2>&1 1>")
	String to be used to put the output of a filter in a temporary file.
	See also |:!|. The default is ">".  For Unix, if the 'shell'
	option is "csh", "tcsh" or "zsh" during initializations, the default
	becomes ">&". If the 'shell' option is "sh", "ksh" or "bash" the
	default becomes "2>&1 1>". This means that stderr is also included.
	The initialization of this option is done after reading the ".vimrc"
	and the other initializations, so when the 'shell' option is set
	there it automatically changes the 'shellredir' option, unless it
	was set before. {not in Vi}

						*'shelltype'* *'st'*
shelltype (st)		number	(default 0)
	On the Amiga this option influences the way how the commands work 
	which use a shell.
	0 and 1: always use the shell
	2 and 3: use the shell only to filter lines
	4 and 5: use shell only for ':sh' command
	When not using the shell, the command is executed directly.

	0 and 2: use 'shell -c cmd' to start external commands
	1 and 3: use 'shell cmd' to start external commands

						*'shiftround'* *'sr'*
shiftround (sr)		toggle	(default off)
	Round indent to multiple of shiftwidth. Applies to > and < commands 
	and to CTRL-T and CTRL-D in Insert mode. {not in Vi}

						*'shiftwidth'* *'sw'*
shiftwidth (sw)		number	(default 8)
	Number of spaces to use for (auto)indent. Each buffer has its own
	copy of this option.

						*'shortmess'* *'shm'*
shortmess (shm)		number	(default 0)
	This option helps to avoid all the "Hit return" messages caused by
	file messages, eg with ^G.  If shm=2 and the message will be too
	long then the start is truncated and "<" will appear in the left
	most column.  Also when shortmess is 1 or 2, [Modified] will be
	written as [+], [readonly] will be written as [RO], and "(file 3 of
	5)" will be written as "(3 of 5)".  All this hopefully means that
	changing between buffers rarely requires hitting return, but still
	gives as useful a message as possible for the space available.  When
	shm=2, to get the whole message that you would have got with shm=1,
	use :file!
	    shm=0       -- No abbreviation of message.
	    shm=1       -- Abbreviation, but no loss of information.
	    shm=2       -- Abbreviation, and truncate message when necessary.
	{not in Vi}

						*'shortname'* *'sn'*
shortname (sn)		toggle	(default off)
	Filenames can be 8 characters plus one extension of 3 characters. 
	Multiple dots in file names are not allowed. When this option is on, 
	dots in filenames are replaced by underscores when adding an 
	extension (".~" or ".swp"). This option is not available for 
	MSDOS, because then it would always be on. This option is useful 
	when editing files on an MSDOS compatible filesystem, e.g. messydos 
	or crossdos. Each buffer has its own copy of this option. {not in
	Vi}

						*'showcmd'* *'sc'*
showcmd (sc)		toggle	(default on, off for unix)
	show command in status line. Set this option off if your terminal 
	is slow. {not in Vi}

						*'showmatch'* *'sm'*
showmatch (sm)		toggle	(default off)
	When a bracket is inserted, briefly jump to the matching one. This
	option is reset when the 'paste' option is set.

						*'showmode'* *'smd'*
showmode (smd)		toggle	(default on)
	If in Insert or Replace mode, put a message on the last line.

						*'sidescroll'* *'ss'*
sidescroll (ss)		number	(default 0)
	The minimal number of columns to scroll horizontally. Used only when
	the 'wrap' option is on and the cursor is moved off of the screen.
	When set to zero the cursor will be put in the middle of the screen.
	When using a slow terminal set it to a large number or 0. When using
	a fast terminal use a small number or 1. {not in Vi}

						*'smartindent'* *'si'*
smartindent (si)	toggle	(default off)
	Do smart autoindenting for C programs in Insert mode and with the
	"o" and "O" commands. An indent is automatically inserted:
	- After a line ending in <{>.
	- After a line starting with "if", "for", "while", "else" or "do".
	  If you type a <{> as the first character in the new line, the
	  indent is deleted. 
	- Before a line starting with <}> (only with the "O" command).
	When typing <}> as the first character in a new line, that line is
	given the same indent as the matching <{>.
	When typing <#> as the first character in a new line, the indent for
	that line is removed, the <#> is put in the first column. The indent
	is restored for the next line.
	When using the ">>" command, lines starting with <#> are not shifted
	right.
	'smartindent' is reset when the 'paste' option is set. Each buffer
	has its own copy of this option. {not in Vi}

						*'smartmatch'* *'sma'*
smartmatch (sma)	toggle	(default on)
	When this option is off vi-compatible matching is done for the "%"
	command. Parens inside single and double quotes are also counted,
	causing a string that contains a paren to disturb the matching. For
	example, in a line like "if (strcmp("foo(", s))" the first paren
	does not match the last one.
	When this option is off, parens inside single and double quotes are
	treated specially. When matching a paren outside of quotes,
	everyting inside quotes is ignored. When matching a paren inside
	quotes, it will find the matching one (if there is one). This works
	very well for C programs.
	This option is reset when the 'compatible' option is set. {not in
	Vi}

						*'smarttab'* *'sta'*
smarttab (sta)		toggle	(default off)
	When set a TAB in front of a line inserts 'shiftwidth' positions,
	'tabstop' in other places. When not set a TAB always inserts 'tabstop'
	positions, 'shiftwidth' is only used for ">>" and the like. See also
	section 4.3.4 |ins_expandtab|. {not in Vi}

						*'splitbelow'* *'sb'*
splitbelow (sb)		toggle	(default off)
	When set new window from split is below the current one. {not in Vi}

						*'startofline'* *'sol'*
startofline (sol)	toggle	(default on)
	When set the commands listed below move the cursor to the first
	blank of the line. If not set the cursor is kept in the same column
	(if possible). This applies to the commands: CTRL-D, CTRL-U, CTRL-B,
	CTRL-F, "G", "H", "M", "L", , and to the commands "d", "<<" and ">>"
	with a linewise operator and with "%" with a count. This option is
	set when the 'compatible' option is set. {not in Vi}

						*'suffixes'* *'su'*
suffixes (su)		string	(default ".bak.~.o.h.info.swp")
	Files with these suffixes are ignored when multiple files match a
	wildcard. {not in Vi}

					*'tabstop'* *'ts'*
tabstop (ts)		number	(default 8)
	Number of spaces that a <TAB> in the file counts for. (See also
	":retab" command in 11.3 |:retab|). Each buffer has its own copy of
	this option.

						*'taglength'* *'tl'*
taglength (tl)		number	(default 0)
	If non-zero, tags are significant up to this number of characters.

						*'tagrelative'* *'tr'*
tagrelative (tr)	toggle	(default on)
	If set and using a tag file in another directory, file names in that
	tag file are relative to the directory where the tag file is. If Vim
	was compiled with COMPATIBLE defined, or when the 'compatible' option
	is set, this option is reset. {not in Vi}

						*'tags'*
tags			string	(default "tags")
	Filenames for the tag command, separated by spaces. Environment
	variables are expanded for the first name. {Vi: default is "tags
	/usr/lib/tags"}

						*'term'*
term			string	(default $TERM or "amiga" on Amiga, "pcterm"
					on MSDOS)
	Name of the terminal. Used for choosing the terminal control 
	characters. Environment variables are expanded.

						*'terse'*
terse			toggle	(default off)
	Shorten some of the messages. {Vi shortens a lot more messages}

						*'textauto'* *'ta'*
textauto (ta)		toggle	(default on)
	When a new file is edited the first line is checked for the line
	separator. If it is a single <LF> 'textmode' is reset. If it is a
	<CR><LF> pair 'textmode' is set. {not in Vi}

						*'textmode'* *'tx'*
textmode (tx)		toggle	(MSDOS: default on, others: default off)
	When off, <LF> separates lines. When on, <CR><LF> separates lines
	and CTRL-Z at end of file is ignored. Only used when reading and
	writing files. Set automatically when reading a file and 'textauto'
	is on. Each buffer has its own copy of this option. {not in Vi}

						*'textwidth'* *'tw'*
textwidth (tw)		number	(default 0)
	Maximum width of text that is being inserted. A longer line will be
	broken after white space to get this width. A zero value disables
	this. 'textwidth' is set to 0 when the 'paste' option is set. When
	'textwidth' is zero, 'wrapmargin' may be used. See |ins_textwidth|.
	Each buffer has its own copy of this option. {not in Vi} 

						*'tildeop'* *'to'*
tildeop (to)		toggle	(default off)
	The tilde command <~> behaves like an operator. {not in Vi}

						*'timeout'*
timeout			toggle (default on)
						*'ttimeout'*
ttimeout		toggle (default off)
	These two options together determine the behaviour when part of a 
	mapped key sequence or keyboard code has been received:

	timeout		ttimeout	action
	off		off		no time out
	on		on or off	time out on :mappings and key codes
	off		on		time out on key codes

	If there is no time out, Vim will wait until either the complete 
	mapping or key sequence has been received, or it is clear that there 
	is no mapping or key sequence for the received characters. For 
	example: if you have mapped "vl" and Vim has received <v>, the next 
	character is needed to see if the <v> is followed by an <l>. With a 
	time out Vim will wait for about 1 second for the next character to 
	arrive. After that the already received characters are interpreted
	as single characters. The time can be set with the 'timeoutlen'
	option.
	On slow terminals or very busy systems time out may cause 
	malfunctioning cursor keys. If both options are off, Vim waits 
	forever after an entered <ESC> if there are key codes that start 
	with <ESC>. You will have to type <ESC> twice. If you do not have 
	problems with key codes, but would like to have :mapped key 
	sequences not time out in 1 second, set the ttimeout option and 
	reset the timeout option. {the ttimeout option is not in Vi}

						*'timeoutlen'* *'tm'*
timeoutlen (tm)		number	(default 1000)
	The time in milliseconds that is waited for a key code or mapped key
	sequence to complete. {only in some versions of Vi}

						*'title'*
title			toggle	(default on)
	When set the title of the window will be set to "VIM - filename",
	where filename is the name of the file currently being edited. Only
	works if the terminal supports setting window titles (currently Amiga
	console, Unix xterm and iris-ansi). When Vim was compiled with NOTITLE
	defined the default is off. When Vim was compiled with USE_X11
	defined, the original title will be restored if possible. {not in Vi}

						*'ttyfast'* *'tf'*
ttyfast	(tf)		toggle (default off)
	Indicates a fast terminal connection. More characters will be send
	to the screen for redrawing, instead of using insert/delete line
	commands. Improves smoothness of redrawing when there are multiple
	windows and the terminal does not support a scrolling region. {not
	in Vi} 

					*'undolevels'* *'ul'*
undolevels (ul)		number	(default 100, for unix 1000)
	Maximum number of changes that can be undone. Set to 0 for Vi 
	compatibility: one level of undo and 'u' undoes itself. Set to a
	negative number for no undo at all (saves memory). {not in Vi}

						*'updatecount'* *'uc'*
updatecount (uc)	number	(default 200)
	After typing this many characters the swap file will be written to
	disk. When zero no swap file will be created at all (see chapter on
	recovery |crash_recovery|). Can be set to zero by starting Vim with
	the "-n" option, see |starting|. When editing in readonly mode this
	option will be initialized to 10000. {not in Vi}

						*'updatetime'* *'ut'*
updatetime (ut)		number	(default 4000)
	If this many milliseconds nothing is typed the swap file will be
	written to disk (see chapter on recovery |crash_recovery|). {not in
	Vi}

					*'viminfo'* *'vi'*
viminfo (vi)		number	(default 0)
	When non-zero, the viminfo file is read upon startup and written
	when exiting Vim. The value is the maximum number of files for which
	the marks are remembered. See |viminfo_file|. {not in Vi}

						*'visualbell'* *'vb'*
visualbell (vb)		toggle	(default off)
	Use visual bell instead of beeping. The terminal code to display the
	visual bell is given with 't_vb'. When no beep of flash is wanted,
	use ":set vb t_vb=". {not in Vi}

						*'warn'*
warn			toggle	(default on)
	Give a warning message when a shell command is used while the buffer
	has been changed.

						*'weirdinvert'* *'wi'*
weirdinvert (wi)	toggle	(default off)
	Set this option for terminals that have a weird inversion method.
	Makes the start/end invert code outputted before every character.
	Slows down terminal I/O a lot, but it makes Visual mode work.
	{not in Vi}

						*'whichwrap'* *'ww'*
whichwrap (ww)		number	(default 3)
	Allow specified keys that move the cursor left/right to wrap to the
	previous/next line when the cursor is on the first/last character in
	the line. Add numbers to allow this for these keys:
		 1 for backspace	 in Normal and Visual mode
		 2 for space		 in Normal and Visual mode
		 4 for 'h' and 'l'	 in Normal and Visual mode
		 8 for cursor left/right in Normal and Visual mode
		16 for cursor left/right in Insert and Replace mode
	For example: ":set ww=24" allows wrap only when cursor keys are used.
	When compiled with COMPATIBLE defined or when 'compatible' option set,
	'whichwrap' is set to 0.
	{not in Vi}

						*'wildchar'* *'wc'*
wildchar (wc)		number	(default <TAB> or CTRL-E)
	Character you have to type to start wildcard expansion in the 
	command line. CTRL-E is used when Vim was compiled with COMPATIBLE 
	or when the 'compatible' option is set. The character is not
	recognized when used inside a macro. {not in Vi}

						*'winheight'* *'wh'*
winheight (wh)		number	(default 0)
	Minimal number of lines for the current window. If the current
	window is smaller, its size is increased, at the cost of the height
	of other windows. Set it to 999 to make the current window always
	fill the screen. Set it to a small number for normal editing. The
	height is not adjusted after one of the commands to change the
	height of the current window. {not in Vi} 

						*'wrap'*
wrap			toggle	(default on)
	When on, long lines will wrap and continue on the next line. When
	off long lines will not wrap and only part of them will be shown.
	When the cursor is moved to a part that is not shown, the screen
	will scroll horizontally (also see 'sidescroll' option. Each window
	has its own copy of this option. {not in Vi}

						*'wrapmargin'* *'wm'*
wrapmargin (wm)		number	(default 0)
	Number of characters from the right window border where wrapping
	starts. When 'textwidth' is set, this option is not used. See
	|ins_textwidth|. Each buffer has its own copy of this option. {Vi:
	works differently and less useful}

						*'wrapscan'* *'ws'*
wrapscan (ws)		toggle	(default on)
	Searches wrap around the end of the file.

						*'writeany'* *'wa'*
writeany (wa)		toggle	(default off)
	Allows writing to any file with no need for "!" override.

						*'writebackup'* *'wb'*
writebackup (wb)	toggle	(default on)
	Make a backup before overwriting a file. The backup is removed after 
	the file was successfully written, unless the 'backup' option is
	also on. Reset this option if your file system is almost full. See
	the table in section 5.4 for another explanation |backup_table|.
	{not in Vi}


	20. Terminal information			*terminal_info*

Vim uses information about the terminal you are using to fill the screen and 
recognize what keys you hit. If this information is not correct the screen 
may be messed up or keys may not be recognized. The actions which have to be 
performed on the screen are accomplished by outputting a string of
characters. Special keys produce a string of characters. These strings are 
stored in the terminal options, see section 20.2 |terminal_options|.


20.1 startup						*startup*

When Vim is started a default terminal type is assumed. For the Amiga this 
is a standard CLI window, for MSDOS the pc terminal, for Unix an ansi 
terminal. A few other terminal types are always available. Use the command 
"set term=xxx" to find out which ones are builtin.

You can give the terminal name with the '-T' command line option. If it is 
not given Vim will try to get the name from the TERM environment variable.

On Unix the termcap file is used. On Amiga and MSDOS this is only available 
if Vim was compiled with TERMCAP defined. If the termcap code is included 
Vim will try to get the strings for the terminal you are using from the 
termcap file.

For normal editing the terminal will be put into "raw" mode. The strings 
defined with 't_ts' and 't_ks' will be sent to the terminal. Normally this 
puts the terminal in a state where the termcap codes are valid and activates 
the cursor and function keys. When Vim exits the terminal will be put back 
into the mode it was before Vim started. The strings defined with 't_te' and 
't_ke' will be sent to the terminal. On the Amiga with commands that execute
an external command (e.g. "!!") the terminal will be put into normal mode
for a moment. This means that you can stop the output to the screen by
hitting a printing key. Output resumes when you hit <BS>.

Some termcap entries are wrong in the sense that after sending 't_ks' the 
cursor keys send codes different from the codes defined in the termcap. To 
avoid this you can set 't_ks' (and 't_ke') to empty strings. This must be
done during initialization (see 3.4 |initialization|), otherwise its too
late.

Some termcap entries assume that the highest bit is always reset. For 
example: The cursor-up entry for the amiga could be ":ku=\EA:". But the 
Amiga really sends "\233A". This works fine if the highest bit is reset, 
e.g. when using an Amiga over a serial line. If the cursor keys don't work, 
try the entry ":ku=\233A:".

Some termcap entries have the entry ":ku=\E[A:". But the Amiga really sends 
"\233A". On output "\E[" and "\233" are often equivalent, on input they 
aren't. You will have to change the termcap entry, or change the key code 
with the :set command to fix this.

Many cursor key codes start with an <ESC>. Vim must find out if this a 
single hit of the <ESC> key or the start of a cursor key sequence. It waits 
for a next character to arrive. If it does not arrive within one second a 
single <ESC> is assumed. On very slow systems this may fail, causing cursor 
keys not to work sometimes. If you discover this problem reset the 'timeout' 
option. Vim will wait for the next character to arrive after an <ESC>. If 
you want to enter a single <ESC> you must type it twice. Resetting the
'esckeys' option avoids this problems in Insert mode, but you lose the
possibility to use cursor and function keys in Insert mode.

On the Amiga the recognition of window resizing is activated only when the 
terminal name is "amiga" or "builtin_amiga".

Some terminals have confusing codes for the cursor keys. The televideo 925
is such a terminal. It sends a CTRL-H for cursor-left. This would make it
impossible to distinguish a backspace and cursor-left. To avoid this problem
CTRL-H is never recognized as cursor-left.

The default termcap entry for xterm on sun and other platforms does not
contain the entry for scroll regions. Add ":cs=\E[%i%d;%dr:" to the
xterm entry in /etc/termcap and everything should work.


20.2 terminal options					*terminal_options*

The terminal options can be set just like normal options. But they are not
shown with the ":set all" command. Instead use ":set termcap".

It is always possible to change individual strings by setting the 
appropriate option. For example:

	:set t_el=^V^[[K	(CTRL-V, ESC, [, K)

{Vi: no terminal options. You have to exit vi, edit the termcap entry and
try again}

The options are listed below along with the associated termcap code. Two of
them are required: Cursor positioning and clear screen. The others are used
to minimize the screen updating overhead and to recognize special keys.


	option	termcap		meaning

OUTPUT CODES
	t_name	(name)	name of current terminal entry *t_name*
	t_el	ce	clear to end of line *t_el*
	t_il	al	add new blank line *t_il*
	t_cil	AL	add number of blank lines *t_cil*
	t_dl	dl	delete line *t_dl*
	t_cdl	DL	delete number of lines *t_cdl*
	t_cs	cs	define scrolling region *t_cs*
	t_ed	cl	clear screen (required!) *t_ed*
	t_ci	vi	cursor invisible *t_ci*
	t_cv	ve	cursor visible *t_cv*
	t_cvv	cvv	cursor very visible *t_cvv*
	t_tp	me	normal mode (undoes t_ti and t_tb) *t_tp*
	t_ti	mr	reverse (invert) mode *t_ti*
	t_tb	md	bold mode *t_tb*
	t_se	se	standout end *t_se*
	t_so	so	standout mode *t_so*
	t_ue	ue	underline end *t_ue*
	t_us	us	underline mode *t_us*
							*t_ms*
	t_ms	ms	if set, cursor can be moved in standout/inverse mode
	t_cm	cm	cursor motion (required!) *t_cm*
	t_sr	sr	scroll reverse (backward) *t_sr*
	t_cri	RI	cursor number of chars right *t_cri*
	t_vb	vb	visual bell *t_vb*
	t_ks	ks	put terminal in "keypad transmit" mode *t_ks*
	t_ke	ke	out of "keypad transmit" mode *t_ke*
	t_ts	ti	put terminal in "termcap" mode *t_ts*
	t_te	te	out of "termcap" mode *t_te*

KEY CODES
	t_ku	ku	arrow up *t_ku*
	t_kd	kd	arrow down *t_kd*
	t_kr	kr	arrow right *t_kr*
	t_kl	kl	arrow left *t_kl*
	t_sku	(none)	shift arrow up *t_sku*
	t_skd	(none)	shift arrow down *t_skd*
	t_skr	%i	shift arrow right *t_skr*
	t_skl	#4	shift arrow left *t_skl*
	t_f1	k1	function key 1 *t_f1*
	t_f2	k2	function key 2 *t_f2*
	t_f3	k3	function key 3 *t_f3*
	t_f4	k4	function key 4 *t_f4*
	t_f5	k5	function key 5 *t_f5*
	t_f6	k6	function key 6 *t_f6*
	t_f7	k7	function key 7 *t_f7*
	t_f8	k8	function key 8 *t_f8*
	t_f9	k9	function key 9 *t_f9*
	t_f10	k;	function key 10 *t_f10*
	t_sf1	F1	function key 11 or shifted function key 1 *t_sf1*
	t_sf2	F2	function key 12 or shifted function key 2 *t_sf2*
	t_sf3	F3	function key 13 or shifted function key 3 *t_sf3*
	t_sf4	F4	function key 14 or shifted function key 4 *t_sf4*
	t_sf5	F5	function key 15 or shifted function key 5 *t_sf5*
	t_sf6	F6	function key 16 or shifted function key 6 *t_sf6*
	t_sf7	F7	function key 17 or shifted function key 7 *t_sf7*
	t_sf8	F8	function key 18 or shifted function key 8 *t_sf8*
	t_sf9	F9	function key 19 or shifted function key 9 *t_sf9*
	t_sf10	FA	function key 20 or shifted function key 10 *t_sf10*
	t_help	%1	help key *t_help*
	t_undo	&8	undo key *t_undo*
	t_ins	kI	insert key *t_ins*
	t_del	kD	delete key *t_del*
	t_home	kh	home key *t_home*
	t_end	@7	end key *t_end*
	t_pu	kP	page-up key *t_pu*
	t_pd	kN	page-down key *t_pd*

Note about t_so and t_ti: When the termcap entry "so" is not present the
entry for "mr" is used. And visa versa. The same is done for "se" and "me".
If your terminal supports both inversion and standout mode, you can see two
different modes. If you terminal supports only one of the modes, both will
look the same.

If inversion or other highlighting does not work correctly, try setting the
'weirdinvert' option. This makes the start-highlight or end-highlight termcap
code to be outputted before every character. This slows down terminal I/O a
lot, but it makes inversion work on some terminals.

Some termcaps do not include an entry for 'cs' (scroll region), although the
terminal does support it. For example: xterm on a sun. You can use the
builtin_xterm or define t_cs yourself. For example:

	:set t_cs=^V^[[%i%d;%dr

Where ^V is CTRL-V and ^[ is <ESC>.

Unfortunately it is not possible to deduct from the termcap how cursor
positioning should be done when using a scrolling region: Relative to the
beginning of the screen or relative to the beginning of the scrolling region.
Most terminals use the first method. A know exception is the MSDOS console
(pcterm). The 't_csc' option should be set to any string when cursor
positioning is relative to the start of the scrolling region. It should be set
to an empty string otherwise. It is default "yes" when 'term' is "pcterm".

Note for xterm users: The shifted cursor keys normally don't work. You can
	make them work with the xmodmap command and some mappings in Vim.

	Give these commands in the xterm:
		xmodmap -e "keysym Up = Up F13"
		xmodmap -e "keysym Down = Down F16"
		xmodmap -e "keysym Left = Left F18"
		xmodmap -e "keysym Right = Right F19"

	And use these mappings in Vim:
		:map <SF3> <SC_UP>
		:map! <SF3> <SC_UP>
		:map <SF6> <SC_DOWN>
		:map! <SF6> <SC_DOWN>
		:map <SF8> <SC_LEFT>
		:map! <SF8> <SC_LEFT>
		:map <SF9> <SC_RIGHT>
		:map! <SF9> <SC_RIGHT>

Instead of, say, <SC_UP> you can use any other command that you want to use
the shift-cursor-up key for. (Note: F14 is not used because it is confused
witht the undo key; F15 is not used, because it does a window-to-front; F17
is not used, because it closes the window)


20.3 Window size					*window_size*

[This is about the size of the whole window Vim is using, not a window that is
created with the :split command]

If you are running Vim on an Amiga and the terminal name is "amiga" or 
"builtin_amiga", the amiga-specific window resizing will be enabled. On Unix 
systems three methods are tried to get the window size:

- an ioctl call (TIOCGSIZE or TIOCGWINSZ, depends on your system)
- the environment variables "LINES" and "COLUMNS"
- from the termcap entries "li" and "co"

If everything fails a default size of 24 lines and 80 columns is assumed. If 
a window-resize signal is received the size will be set again. If the window 
size is wrong you can use the 'lines' and 'columns' options to set the 
correct values.

One command can be used to set the screen size:

							*:mode*
:mode [mode]

Without argument this only detects the screen size. With MSDOS it is possible
to switch screen mode. [mode] can be one of these values:
	"bw40"		40 columns black&white
	"c40"		40 columns color
	"bw80"		80 columns black&white
	"c80"		80 columns black&white (most people use this)
	"mono"		80 columns monochrome
	"c4350"		43 or 50 lines EGA/VGA mode
	number		mode number to use, depends on your video card


20.4 slow and fast terminals			*slow_fast_terminal*

If you have a fast terminal you may like to set the 'ruler' option. The 
cursor position is shown in the status line. If you are using horizontal
scrolling ('wrap' option off) consider setting 'sidescroll' to a small
number. 

If you have a slow terminal you may want to reset the 'showcmd' option. 
The command characters will not be shown in the status line. If the terminal 
scrolls very slowly, set the 'scrolljump' to 5 or so. If the cursor is moved
off the screen (e.g. with "j") Vim will scroll 5 lines at a time. Another
possibility is to reduce the number of lines that Vim uses with the command
"z<height><CR>".

If the characters from the terminal are arriving with more than 1 second 
between them you might want to set the 'timeout' and/or 'ttimeout' option. 
See the "Options" chapter |options|.

If your terminal does not support a scrolling region, but it does support
insert/delete line commands, scrolling with multiple windows may make the
lines jump up and down. If you don't want this set the 'ttyfast' option.
This will redraw the window instead of scroll it.

If you are testing termcap options, but you cannot see what is happening,
you might want to set the 'nobuf' option ( 'nb' ). When set one character is
send to the terminal at a time (does not work for MSDOS). This makes the
screen updating a lot slower, making it possible to see what is happening.


	21. Differences from Vi and Ex			*vi_differences*

Throughout this document differences between Vim and Vi/Ex are given in
curly braces. This chapter only lists what has not been mentioned in
previous chapters. Also see |vim_diff.txt| for an overview.


21.1 Missing commands					*missing_commands*

A large number of the "Ex" commands (the commands that start with a colon) 
are included. However, there is no Ex mode. 

These commands are in Vi, but not in Vim.

Q			{Vi: go to Ex mode}

:a[ppend]		{Vi: append text}
:c[hange]		{Vi: replace lines}
:i[nsert]		{Vi: insert text}
:o[pen]			{Vi: start editing in open mode}
:z			{Vi: print some lines}


21.2 Missing options					*missing_options*

These options are in the unix Vi, but not in Vim. If you try to set one of
them you won't get an error message, but the value is not used and cannot be
printed.

autoprint (ap)		toggle	(default on)
beautify (bf)		toggle	(default off)
flash (fl)		toggle  (default ??)
hardtabs (ht)		number	(default 8)
	number of spaces that a <TAB> moves on the display
lisp			toggle	(default off)
mesg			toggle	(default on)
novice			toggle	(default ??)
open			toggle	(default on)
optimize (op)		toggle	(default on)
prompt			toggle	(default on)
redraw			toggle	(default off)
slowopen (slow)		toggle	(default off)
sourceany		toggle	(default not documented)
ttytype			string
window			number	(default 24)
w300			number	(default 24)
w1200			number	(default 24)
w9600			number	(default 24)



CONTENTS			*reference_contents* *ref* *reference*

[Note: The commands for multiple windows and buffers are explained in
a different file, see |vim_win.txt|]

 1. Introduction				|intro|
 2. Notation					|notation|
 3. Starting Vim				|starting|
	3.1 Command line			|command_line|
	3.2 Workbench (Amiga only)		|workbench|
	3.3 Vim window (Amiga only)		|amiga_window|
	3.4 Initialization			|initialization|
	3.5 Suspending				|suspend|
	3.6 The viminfo file			|viminfo_file|
 4. Modes					|edit_modes|
	4.1 Introduction
	4.2 Switching from mode to mode		|mode_switching|
	4.3 Insert and Replace mode		|mode_ins_repl|
		4.3.1 special keys		|ins_special_keys|
		4.3.2 special special keys	|ins_special_special|
		4.3.3 'textwidth' option	|ins_textwidth|
		4.3.4 'expandtab' option	|ins_expandtab|
		4.3.5 typing backwards		|ins_reverse|
		4.3.6 Replace mode		|replace_mode|
		4.3.7 Insert mode completion	|ins_completion|
	4.4 Command_line mode			|mode_cmdline|
		4.4.1 Command line editing	|cmdline_editing|
		4.4.2 Command line completion	|cmdline_completion|
		4.4.3 Ex command lines		|cmdline_lines|
		4.4.4 Ex command line ranges	|cmdline_ranges|
	4.5 The window contents			|window_contents|
	4.6 Abbreviations			|abbreviations|
	4.7 Digraphs				|digraphs|
	4.8 Using the mouse			|using_mouse|
	4.9 On-line help			|online_help|
 5. Editing files				|edit_files|
	5.1 Introduction			|edit_intro|
	5.2 Editing a file			|edit_a_file|
	5.3 The argument list			|argument_list|
	5.4 Writing and quitting		|write_quit|
	5.5 Using the QuickFix mode		|quickfix|
	5.6 Editing binary files		|edit_binary|
	5.7 Automatic commands			|autocommand|
 6. Cursor motions				|cursor_motions|
	6.1 Left-right motions			|left_right_motions|
	6.2 Up-down motions			|up_down_motions|
	6.3 Word motions			|word_motions|
	6.4 Text object motions			|object_motions|
	6.5 Pattern searches			|pattern_searches|
	6.6 Various motions			|various_motions|
 7. Scrolling					|scrolling|
 8. Tags and special searches			|tags_and_searches|
	8.1 Tags				|tag_commands|
	8.2 Identifier searches			|include_search|
 9. Inserting text				|inserting|
10. Deleting text				|deleting|
11. Changing text				|changing|
	11.1 Delete and insert			|delete_insert|
	11.2 Simple changes			|simple_change|
	11.3 Complex changes			|complex_change|
	11.4 Formatting text			|formatting|
12. Copying and moving text			|copy_move|
13. Visual mode					|visual_mode|
14. Various commands				|various|
15. Repeating commands				|repeating|
	15.1 Single repeats			|single_repeat|
	15.2 Multiple repeats			|multi_repeat|
	15.3 Complex repeats			|complex_repeat|
16. Undo and redo				|undo_redo|
17. Key mapping					|key_mapping|
18. Recovery after a crash			|crash_recovery|
	18.1 The swap file			|swap_file|
	18.2 Recovery				|recovery|
19. Options					|options|
	19.1 Setting options			|set_option|
	19.2 Saving settings			|save_settings|
	19.3 Options summary			|option_summary|
20. Terminal information			|terminal_info|
	20.1 startup				|startup|
	20.2 terminal options			|terminal_options|
	20.3 Window size			|window_size|
	20.4 slow and fast terminals		|slow_fast_terminal|
21. Differences from Vi and Ex			|vi_differences|
	21.1 Missing commands			|missing_commands|
	21.2 Missing options			|missing_options|

vim:tw=76:ts=8:sw=8
