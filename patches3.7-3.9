Index: ./doc/Makefile
diff -r ../vim.orig/doc/Makefile ./doc/Makefile
0a1,7
> DOCS = vim_ami.txt vim_arch.txt vim_diff.txt vim_digr.txt vim_dos.txt \
> 	vim_help.txt vim_idx.txt vim_mac.txt vim_nt.txt vim_ref.txt \
> 	vim_tips.txt vim_unix.txt vim_win.txt
> 
> vim_tags: doctags $(DOCS)
> 	./doctags $(DOCS) | sort >vim_tags
> 
4,7c11,12
< DOCS = reference.doc windows.doc
< 
< tags: $(DOCS)
< 	./doctags $(DOCS) | sort >tags
---
> clean:
> 	-rm doctags
Index: ./doc/doctags.c
diff -r ../vim.orig/doc/doctags.c ./doc/doctags.c
16,17c16,17
<     int     argc;
<     char    **argv;
---
> 	int		argc;
> 	char	**argv;
19,22c19,22
<     char    line[LINELEN];
<     char    *p1, *p2;
<     char    *p;
<     FILE    *fd;
---
> 	char	line[LINELEN];
> 	char	*p1, *p2;
> 	char	*p;
> 	FILE	*fd;
24,62c24,61
<     if (argc <= 1)
<     {
<         fprintf(stderr, "Usage: doctags docfile ... >tags\n");
<         exit(1);
<     }
<     while (--argc > 0)
<     {
<         ++argv;
<         fd = fopen(argv[0], "r");
<         if (fd == NULL)
<         {
<             fprintf(stderr, "Unable to open %s for reading\n", argv[0]);
<             continue;
<         }
<         while (fgets(line, LINELEN, fd) != NULL)
<         {
<             p1 = strchr(line, '*');             /* find first '*' */
<             while (p1 != NULL)
<             {
<                 p2 = strchr(p1 + 1, '*');       /* find second '*' */
<                 if (p2 != NULL)
<                 {
<                     for (p = p1 + 1; p < p2; ++p)
<                         if (!isalnum(*p) && *p != '_')
<                             break;
<                     if (p == p2)                /* if it is all id-characters
< */
<                     {
<                         *p2 = '\0';
<                         printf("%s\t%s\t/\\*%s\\*\n", p1 + 1, argv[0], p1 +
< 1);
<                     }
<                     p2 = strchr(p2 + 1, '*');
<                 }
<                 p1 = p2;
<             }
<         }
<         fclose(fd);
<     }
---
> 	if (argc <= 1)
> 	{
> 		fprintf(stderr, "Usage: doctags docfile ... >tags\n");
> 		exit(1);
> 	}
> 	while (--argc > 0)
> 	{
> 		++argv;
> 		fd = fopen(argv[0], "r");
> 		if (fd == NULL)
> 		{
> 			fprintf(stderr, "Unable to open %s for reading\n", argv[0]);
> 			continue;
> 		}
> 		while (fgets(line, LINELEN, fd) != NULL)
> 		{
> 			p1 = strchr(line, '*');				/* find first '*' */
> 			while (p1 != NULL)
> 			{
> 				p2 = strchr(p1 + 1, '*');		/* find second '*' */
> 				if (p2 != NULL)
> 				{
> 					for (p = p1 + 1; p < p2; ++p)
> 						if (*p == ' ' || *p == '\t' || *p == '|')
> 							break;
> 					if (p == p2)				/* if it is all valid
> 													characters */
> 					{
> 						*p2 = '\0';
> 						printf("%s\t%s\t/\\*%s\\*\n", p1 + 1, argv[0], p1 + 1);
> 					}
> 					p2 = strchr(p2 + 1, '*');
> 				}
> 				p1 = p2;
> 			}
> 		}
> 		fclose(fd);
> 	}
Index: ./doc/vim.1
diff -r ../vim.orig/doc/vim.1 ./doc/vim.1
135a136,139
> .TP
> -u {vimrc}
> Use the commands in the file "vimrc" for initializations. All the other
> initializations are skipped. Use this to edit a special kind of files.
154c158
< vim.hlp:
---
> vim_help.txt:
Index: ./doc/vim.man
diff -r ../vim.orig/doc/vim.man ./doc/vim.man
189c189
<        vim.hlp:    File used by the on-line help (short)
---
>        vim.help:   File used by the on-line help (short)
Index: ./doc/vim_ami.txt
diff -r ../vim.orig/doc/vim_ami.txt ./doc/vim_ami.txt
0a1,2
> *vim_ami.txt*
> 
4c6
< - Assign "vim:" to the directory where the vim.hlp file is (for the help 
---
> - Assign "vim:" to the directory where the vim_help.txt file is (for the help
Index: ./doc/vim_arch.txt
diff -r ../vim.orig/doc/vim_arch.txt ./doc/vim_arch.txt
0a1,2
> *vim_arch.txt*
> 
8c10
< vim.hlp needs to be saved as Lib:vimhlp (you should set Lib$Path to be a
---
> vim_hlp.txt needs to be saved as Lib:vimhlp (you should set Lib$Path to be a
Index: ./doc/vim_diff.txt
diff -r ../vim.orig/doc/vim_diff.txt ./doc/vim_diff.txt
0a1
> *vim_diff.txt*
2d2
< 
4c4
< see also reference.doc and look for comments in {}.
---
> see also reference.doc, look for comments in {}.
412,415c412,414
< Missing options: autoprint (ap), beautify (bf), edcompatible, hardtabs (ht), 
< lisp, mesg, open, optimize (op), prompt, redraw, slowopen (slow), terse,
< window, w300, w1200 and w9600. These options can be set but are otherwise
< ignored.
---
> Missing options: autoprint (ap), beautify (bf), hardtabs (ht), lisp, mesg,
> open, optimize (op), prompt, redraw, slowopen (slow), window, w300, w1200 and
> w9600. These options can be set but are otherwise ignored.
501a501,503
> 
> The "No lines in buffer" message is a normal message instead of an error
> message, since that may cause a mapping to be aborted.
Index: ./doc/vim_digr.txt
diff -r ../vim.orig/doc/vim_digr.txt ./doc/vim_digr.txt
0a1,2
> *vim_digr.txt*
> 
15c17,18
< Default digraphs on the Amiga:
---
> 							*digraph_table*
> Default digraphs on non-MSDOS machines:
17,29c20,33
< "" ¨ 168   cO © 169   a- ª 170   << « 171   -- ­ 173   rO ® 174   -= ¯ 175
< ~o ° 176   +- ± 177   22 ² 178   33 ³ 179   '' ´ 180   ju µ 181   pp ¶ 182
< ~. · 183   ,, ¸ 184   11 ¹ 185   o- º 186   >> » 187   14 ¼ 188   12 ½ 189
< 34 ¾ 190   ~? ¿ 191   A` À 192   A' Á 193   A^ Â 194   A~ Ã 195   A" Ä 196
< A@ Å 197   AE Æ 198   C, Ç 199   E` È 200   E' É 201   E^ Ê 202   E" Ë 203
< I` Ì 204   I' Í 205   I^ Î 206   I" Ï 207   -D Ð 208   N~ Ñ 209   O` Ò 210
< O' Ó 211   O^ Ô 212   O~ Õ 213   O" Ö 214   /\ × 215   O/ Ø 216   U` Ù 217
< U' Ú 218   U^ Û 219   U" Ü 220   Y' Ý 221   Ip Þ 222   ss ß 223   a` à 224
< a' á 225   a^ â 226   a~ ã 227   a" ä 228   a@ å 229   ae æ 230   c, ç 231
< e` è 232   e' é 233   e^ ê 234   e" ë 235   i` ì 236   i' í 237   i^ î 238
< i" ï 239   -d ð 240   n~ ñ 241   o` ò 242   o' ó 243   o^ ô 244   o~ õ 245
< o" ö 246   :- ÷ 247   o/ ø 248   u` ù 249   u' ú 250   u^ û 251   u" ü 252
< y' ý 253   ip þ 254   y" ÿ 255
---
> "" ¨ 168   cO © 169   a- ª 170   << « 171   -, ¬ 172   -- ­ 173   rO ® 174
> -= ¯ 175   ~o ° 176   +- ± 177   22 ² 178   33 ³ 179   '' ´ 180   ju µ 181
> pp ¶ 182   ~. · 183   ,, ¸ 184   11 ¹ 185   o- º 186   >> » 187   14 ¼ 188
> 12 ½ 189   34 ¾ 190   ~? ¿ 191   A` À 192   A' Á 193   A^ Â 194   A~ Ã 195
> A" Ä 196   A@ Å 197   AE Æ 198   C, Ç 199   E` È 200   E' É 201   E^ Ê 202
> E" Ë 203   I` Ì 204   I' Í 205   I^ Î 206   I" Ï 207   D- Ð 208   N~ Ñ 209
> O` Ò 210   O' Ó 211   O^ Ô 212   O~ Õ 213   O" Ö 214   /\ × 215   O/ Ø 216
> U` Ù 217   U' Ú 218   U^ Û 219   U" Ü 220   Y' Ý 221   Ip Þ 222   ss ß 223
> a` à 224   a' á 225   a^ â 226   a~ ã 227   a" ä 228   a@ å 229   ae æ 230
> c, ç 231   e` è 232   e' é 233   e^ ê 234   e" ë 235   i` ì 236   i' í 237
> i^ î 238   i" ï 239   d- ð 240   n~ ñ 241   o` ò 242   o' ó 243   o^ ô 244
> o~ õ 245   o" ö 246   :- ÷ 247   o/ ø 248   u` ù 249   u' ú 250   u^ û 251
> u" ü 252   y' ý 253   ip þ 254   y" ÿ 255
> 
Index: ./doc/vim_dos.txt
diff -r ../vim.orig/doc/vim_dos.txt ./doc/vim_dos.txt
0a1,2
> *vim_dos.txt*
> 
98,102c100,104
< The default help filename is "$VIM\vim.hlp". If the environment variable $VIM 
< is not defined or the file is not found, the DOS search path is used to 
< search for the file "vim.hlp". If you do not want to put "vim.hlp" in your 
< search path, use the command ":set helpfile=pathname" to tell Vim where the 
< help file is.
---
> The default help filename is "$VIM\vim_help.txt". If the environment variable
> $VIM is not defined or the file is not found, the DOS search path is used to
> search for the file "vim_help.txt". If you do not want to put "vim_help.txt"
> in your search path, use the command ":set helpfile=pathname" to tell Vim
> where the help file is.
Index: ./doc/vim_help.txt
diff -r ../vim.orig/doc/vim_help.txt ./doc/vim_help.txt
1c1
<                      VIM help file index
---
> *vim_help.txt*		 VIM help file
3,573c3
< RETURN quit help                VIM stands for Vi IMproved.
<  SPACE  one page forward        Most of VIM was made by Bram Moolenaar.
<      a  go to this index
<      b  one page backward
< 
< c   left-right and up-down motions   q   options i-n
< d   word and text object motions     r   options p-s
< e   pattern searches                 s   options s-t
< f   various motions; using tags      t   options t-y
< g   scrolling                        u   undo; shell; quickfix; various
< h   inserting text; digraphs         v   command line editing
< i   insert mode                      w   Ex ranges; Ex special characters
< j   changing text                    x   editing files
< k   complex changes                  y   using the file list
< l   deleting, copying, moving text   z   writing and quitting
< m   repeating commands               A   starting VIM
< n   key mapping; abbreviations       B   multi window functions
< o   option commands, options a-c     C   buffer list functions
< p   options d-h
< 
< Read "reference.doc" for a more complete explanation.
< Left-right motions
< N  h            left (same as CTRL-H, BS and cursor-left key)
< N  l            right (same as SPACE and cursor-right key)
<    0            to first character in the line
<    ^            to first non-blank character in the line
< N  $            to the last character in the line (N-1 lines lower)
< N  |            to column N
< N  f<char>      to the Nth occurrence of <char> to the right
< N  F<char>      to the Nth occurrence of <char> to the left
< N  t<char>      till before the Nth occurrence of <char> to the right
< N  T<char>      till before the Nth occurrence of <char> to the left
< N  ;            repeat the last f, F, t or T N times
< N  ,            repeat the last f, F, t or T N times in opposite direction
< 
< Up-down motions
< N  k            up (same as CTRL-P and cursor-up key)
< N  j            down (same as CTRL-J, CTRL-N, LF and cursor-down key)
< N  -            up, on the first non-blank character
< N  +            down, on the first non-blank char. (same as CTRL-M and CR)
< N  _            N - 1 lines down, on the first non-blank character
< N  G            goto line N (default last line), on the first non-blank char.
< N  %            goto line N percentage down in the file.
< Word motions
< N  w            N words forward
< N  W            N blank-separated words forward
< N  e            forward to the end of the Nth word
< N  E            forward to the end of the Nth blank-separated word
< N  b            N words backward
< N  B            N blank-separated words backward
< 
< Text object motions
< N  )            N sentences forward
< N  (            N sentences backward
< N  }            N paragraphs forward
< N  {            N paragraphs backward
< N  ]]           N sections forward
< N  [[           N sections backward
< N  ][           N sections (starting with a <}>) forward
< N  []           N sections (starting with a <}>) backward
< N  [(  [{       N times back to unclosed <(> or <{>
< N  ])  ]}       N times forward to unclosed <(> or <{>
< Pattern searches
< N  /{pattern}[/]        search forward for the Nth occurrence of {pattern}
< N  ?{pattern}[?]        search backward for the Nth occurrence of {pattern}
< N  /                    repeat last search, in the forward direction
< N  ?                    repeat last search, in the backward direction
< N  n                    repeat last search
< N  N                    repeat last search, in opposite direction
< N  *                    search forward for the ident under the cursor
< N  #                    search backward for the ident under the cursor
< 
< special characters in search patterns      magic      nomagic
<            matches any single character      .            \.
<                   matches start of line      ^            ^
<                     matches end of line      $            $
<                   matches start of word      \<           \<
<                     matches end of word      \>           \>
<    matches a single char from the range      [a-z]        \[a-z]
<  matches a single char not in the range      [^a-z]       \[^a-z]
< matches 0 or more of the preceding atom      *            \*
< matches 1 or more of the preceding atom      \+           \+
<    matches 0 or 1 of the preceding atom      \=           \=
<                  separates two branches      \|           \|
<            group a pattern into an atom      \(\)         \(\)
< Various motions
<    m<a-zA-Z>    mark current position with mark <a-zA-Z>
<    `<a-zA-Z>    go to mark <a-zA-Z>
<    ``           go to the position before the last jump
<    `[ or `]     go to the start or end of the previously operated or put text
<    '<a-zA-Z[]'> same as `, but on the first non-blank in the line
< :marks          print the active marks
< N  CTRL-O       go to N older position in jump list
< N  CTRL-I       go to N newer position in jump list
< :jumps          print the jump list
<    %            find the next brace, bracket, comment or #if/#else/#endif in
<                 this line and go to its match
< N  H            go to the Nth line in the window, on the first non-blank
<    M            go to the middle line in the window, on the first non-blank
< N  L            go to the Nth line from the bottom, on the first non-blank
< 
< Using tags
< :ta[g][!] {tag}         Jump to tag {tag}, unless changes have been made
<    CTRL-]               Jump to the tag under cursor, unless changes made
< N  CTRL-T               Jump to N older tag in tag list
< :[count]po[p][!]        Jump to [count] older tag in tag list
< :[count]ta[g][!]        Jump to [count] newer tag in tag list
< :tags                   Print tag list
< Scrolling
< N  CTRL-E       window N lines downwards (N lines Extra)
< N  CTRL-D       window N lines Downwards (default half a window)
< N  CTRL-F       window N pages Forwards (downwards)
< N  CTRL-Y       window N lines upwards
< N  CTRL-U       window N lines Upwards (default half a window)
< N  CTRL-B       window N pages Backwards (upwards)
<    z<CR> or zt  redraw, current line at top of window
<    z.    or zz  redraw, current line at center of window
<    z-    or zb  redraw, current line at bottom of window
< Inserting text
< N  a            append text after the cursor (N times)
< N  A            append text at the end of the line (N times)
< N  i            insert text before the cursor (N times)
< N  I            insert text before the first non-blank in the line (N times)
< N  o            open a new line below the current line, append text (N times)
< N  O            open a new line above the current line, append text (N times)
< 
< Special inserts
< :r [file]       insert the contents of [file] below the cursor
< :r!{command}    insert the standard output of {command} below the cursor
< 
< Digraphs
< :dig[raphs]     show current list of digraphs
< :dig[raphs] {char1}{char2} {number} ...
<                 add digraph(s) to the list
< char              action in insert mode
< CTRL-[ or <ESC>   end insert or replace mode, back to command mode
< CTRL-A            insert previously inserted text
< CTRL-@            insert previously inserted text and stop insert
< CTRL-R <0-9a-z%:> insert contents of register <0-9a-z%:>
< CTRL-J or <LF> or CTRL-M or <CR>   begin new line
< CTRL-K {char1} {char2}  enter digraph
< CTRL-E / CTRL-Y   insert the character which is below/above the cursor
< CTRL-V            insert character literally, or enter decimal byte value
< CTRL-N / CTRL-P   insert next/previous match of identifier before the cursor
< CTRL-H or <BS> or <DEL> delete the character before the cursor
< CTRL-W            delete word before the cursor
< CTRL-U            delete all entered characters in the current line
< CTRL-T            insert one shiftwidth of indent in the current line
< CTRL-D            delete one shiftwidth of indent in the current line
< 0 CTRL-D or ^ CTRL-D    delete all indent in the current line
< {char1} <BS> {char2}    enter digraph if 'dg' option set
< CTRL-B            toggle 'revins' (reverse insert) option
<         keys that stop insert, do something and get back to insert:
< cursor keys       move cursor left/right/up/down
< shift-up/down     one screenfull backward/forward
< shift-left/right  one word left/right
< CTRL-O {command}  execute {command}
< Changing text
< N  R            enter replace mode (repeat the entered text N times)
< N  c{motion}    change the text that is moved over with {motion}
< {visual}c       change the highlighted text
< N  cc           change N lines
< N  C            change to end of line (and N-1 more lines)
< N  s            change N characters
< N  S            change N lines
< N  r<char>      replace N characters by <char>
< N  ~            switch case for N characters and advance cursor
< {visual}~       switch case for highlighted text
< {visual}u       make highlighted text lowercase
< {visual}U       make highlighted text uppercase
< N  CTRL-A       add N to the number at or after the cursor
< N  CTRL-X       subtract N from the number at or after the cursor
< N  <{motion}    move the lines that are moved over one shiftwidth left
< N  <<           move N lines one shiftwidth left
< N  >{motion}    move the lines that are moved over one shiftwidth right
< N  >>           move N lines one shiftwidth right
< N  Q{motion}    format the lines that are moved over to 'textwidth' length
< :[range]ce[nter] [width]   center the lines in [range]
< :[range]le[ft] [indent]    left align the lines in [range] [with indent]
< :[range]ri[ght] [width]    right align the lines in [range]
< Complex changes
<    v            start highlighting characters  } move cursor and use
<    V            start highlighting linewise    } operator to affect
<    CTRL-V       start highlighting blockwise   } highlighted text
<    o            exchange cursor position with start of highlighting
< 
< N  !{motion}{command}
<                 filter the lines that are moved over through {command}
< N  !!{command}
<                 filter N lines through {command}
< :[range]!{command}
<                 filter [range] lines through {command}
< N  ={motion}{command}
<                 filter the lines that are moved over through "indent"
< N  =={command}
<                 filter N lines through "indent"
< :[range]s[ubstitute]/{pattern}/{string}/[g][c]
<                 substitute {pattern} by {string} in [range] lines; with [g]
<                 replace all occurrences of {pattern}; with [c] ask first
< :[range]s[ubstitute] [g][c]
<                 repeat previous :s with new range and options
<    &            Repeat previous :s on current line without options
< :[range]ret[ab][!] [tabstop]
<                 set 'tabstop' to new value and adjust white space accordingly
< Deleting text
< N  x            delete N characters under and after the cursor
< N  X            delete N characters before the cursor
< N  d{motion}    delete the text that is moved over with {motion}
< {visual}d       delete the highlighted text
< N  dd           delete N lines
< N  D            delete to end of line (and N-1 more lines)
< N  J            join N-1 lines (delete newlines)
< {visual}J       join the highlighted lines
< :[range]d [x]   delete [range] lines [into register x]
< 
< Copying and moving text
<    "<char>      use register <char> for the next delete, yank or put
< :dis            show the current register contents
< N  y{motion}    yank the text, moved over with {motion}, into a register
< {visual}y       yank the highlighted text into a register
< N  yy           yank N lines into a register
< N  Y            yank N lines into a register
< N  p            put a register after the cursor position (N times)
< N  P            put a register before the cursor position (N times)
< N  ]p           like p, but adjust indent to current line
< N  [p           like P, but adjust indent to current line
< Repeating commands
< N  .            repeat last change (with count replaced by N)
<    q<a-z>       record typed characters into register <a-z>
<    q            stop recording
< N  @<a-z>       execute the contents of register <a-z> (N times)
< N  @@           repeat previous @<a-z> (N times)
< :@<a-z>         execute the contents of register <a-z> as an Ex command
< :@@             repeat previous :@<a-z>
< :[range]g[lobal]/{pattern}/[cmd]
<                 Execute Ex command [cmd] (default :p) on the lines within
<                 [range] where {pattern} matches.
< :[range]g[lobal]!/{pattern}/[cmd]
<                 Execute Ex command [cmd] (default :p) on the lines within
<                 [range] where {pattern} does NOT match.
< :so[urce] {file}
<                 Read Ex commands from {file}.
< :so[urce]! {file}
<                 Read VIM commands from {file}.
< :sl[eep] [N[    don't do anything for N seconds
< N  gs           goto sleep for N seconds
< Key mapping
< :ma[p] {lhs} {rhs}      Map {lhs} to {rhs} in normal mode.
< :ma[p]! {lhs} {rhs}     Map {lhs} to {rhs} in insert and command line mode.
< :no[remap][!] {lhs} {rhs}
<                         Same as :map, no remapping for this {rhs}
< :unm[ap] {lhs}          Remove the mapping of {lhs} for normal mode.
< :unm[ap]! {lhs}         Remove the mapping of {lhs} for insert and command
<                         line mode.
< :ma[p] [lhs]            List mappings (starting with [lhs]) for normal mode.
< :ma[p]! [lhs]           List mappings (starting with [lhs]) for insert and
<                         command line mode.
< :cmap/:cunmap/:cnoremap like map/unmap/noremap but for command line mode only
< :imap/:iunmap/:inoremap like map/unmap/noremap but for insert mode only
< :mk[exrc][!] [file]     write current mappings, abbreviations and settings
<                         to [file] (default ".exrc"; use ! to overwrite)
< :mkv[imrc][!] [file]    same as :mkexrc, but with default ".vimrc"
< 
< Abbreviations
< :ab[breviate] {lhs} {rhs}    add abbreviation for {lhs} to {rhs}
< :ab[breviate] {lhs}          show abbreviations that start with {lhs}
< :ab[breviate]                show all abbreviations
< :una[bbreviate] {lhs}        remove abbreviation for {lhs}
< :iab/:cab/:iunab/:cunab/:noreab/:cnoreab/:inoreab    also available!
< Options
< :se[t]                  Show all modified options.
< :se[t] all              Show all options.
< :se[t] {option}         Set toggle option on, show string or number option.
< :se[t] no{option}       Set toggle option off.
< :se[t] inv{option}      invert toggle option.
< :se[t] {option}={value} Set string or number option to {value}.
< :se[t] {option}?        Show value of {option}.
< 
< option (shorthand)   type  default        effect
< autoindent (ai)     toggle    off   insert mode: copy indent from prev line
< autowrite (aw)      toggle    off   write the file when starting a new edit
< backspace (bs)      number    0     0 standard Vi, 1 delete NL, 2 delete all
< backup (bk)         toggle    on    backup a file before overwriting it
< backupdir (bdir)    string    "~/"  Unix only: Directory for backup files
< binary (bin)        toggle    off   binary file mode
< bioskey (bk)        toggle    on    MSDOS: use bios to get characters
< cmdheight (ch)      number     1    number of lines for the command line
< columns (co)        number    80    number of columns in the display
< compatible (cp)     toggle    off   set options for maximum vi-compatibility
< option (shorthand)   type  default        effect
< digraph (dg)        toggle    off   enable <BS> digraphs in insert mode
< directory (dir)     string    ""    directory to put swap file
< edcompatible        toggle    off   flags for :substitute toggle
< endofline (eol)     toggle    on    last line has a newline character
< equalalways (ea)    toggle    on    windows made equal height after open/close
< equalprg (ep)       string    "indent"  program used for '=' command
< errorbells (eb)     toggle    off   ring the bell for error messages
< errorfile (ef)      string    "AztecC.Err" file for QuickFix option
< errorformat (efm)   string          format of error messages from compiler
< esckeys (ek)        toggle    on    func. keys with <ESC> work in insert mode
< expandtab (et)      toggle    off   insert mode: use spaces to enter a tab
< exrc                toggle    off   read .exrc/.vimrc from current directory
< formatprg (fp)      string    ""    external program for 'Q' command
< gdefault (gd)       toggle    off   the 'g' flag is default on for :substitute
< graphic (gr)        toggle    off   display chars 0x80-0x9f directly
< helpfile (hf)       string    "vim:vim.hlp"     name of help file
< hidden (hid)        toggle    off   buffers become hidden when abandoned
< highlight (hl)      string    "db,es,hs,rs,vi,si"   when to use higlighting
< history (hi)        number    20    number of remembered command lines
< option (shorthand)   type  default        effect
< icon                toggle    off   set icon title to file name
< ignorecase (ic)     toggle    off   ignore case in search patterns
< insertmode (im)     toggle    off   start editing in insert mode
< joinspaces (js)     toggle    on    insert two spaces after a '.' with join
< keywordprg (kp)     string    "man" name of program for 'K' command
< laststatus (ls)     number    1     when 0 last window has no status line, when
<                                     1 only with multiple windows, when 2 always
< lines               number    25    number of lines in the display
< list                toggle    off   display lines in list mode
< magic               toggle    on    different pattern matching characters
< makeprg (mp)        string    "make" name of program for ':make' command
< maxmem (mm)         number    512   How may Kbyte to use for one buffer
< maxmemtot (mmt)     number    512   How may Kbyte to use for all buffers
< modeline (ml)       toggle    on    lines are checked for set commands
< modelines (mls)     number    5     number of lines checked for set commands
< more                toggle    on    pause with long listings
< number (nu)         toggle    off   display line numbers
< option (shorthand)   type  default        effect
< paragraphs (para)   string    "IPLPPPQPP LIpplpipbp"
<                                     nroff macros that separate paragraphs
< paste               toggle    off   paste mode: insert literally
< patchmode (pm)      string    ""    extension to use when patching files
< readonly (ro)       toggle    off   overwriting the file not allowed
< remap               toggle    on    :map command works recursively
< report              number    2     minimal number of lines for reporting
< revins (ri)         toggle    off   insert characters right to left
< ruler (ru)          toggle    off   show cursor position in status line
< scroll              number    12    scroll size for CTRL-U and CTRL-D
< scrolljump (sj)     number    1     minimal number of lines for scrolling
< sections (sect)     string    "SHNHH HUnhsh"      macros separating sections
< secure              toggle    off   security checks for .vimrc and .exrc
< shell (sh)          string    "sh"  shell to use for ! and :! commands
< shellpipe (sh)      string          pipe command to be used for :make
< shelltype (st)      number    0     how to use the shell (Amiga only)
< shiftround (sr)     toggle    off   round indent to shiftwidth with > and <
< shiftwidth (sw)     number    8     number of spaces to use for (auto)indent
< shortmess (shm)     number    0     short file message when 1, truncate when 2
< shortname (sn)      toggle    off   MSDOS-like filesystem being used
< showcmd (sc)        toggle    on    show command in status line
< showmatch (sm)      toggle    off   show matching bracket if one is inserted
< option (shorthand)   type  default        effect
< showmode (smd)      toggle    on    show insert/replace mode message
< sidescroll (ss)     number    0     minimal nr of columns for horiz. scroll
< smartindent (si)    toggle    off   do smart autoindenting
< smartmatch (sma)    toggle    on    with % command recognize parens in quotes
< smarttab (sta)      toggle    off   tab size depends on position
< splitbelow (sb)     toggle    off   create new windows below current one
< startofline (sol)   toggle    on    cursor to startofline for some commands
< suffixes (su)       string    ".bak.o.h.info.swp" suffixes that are ignored
<                                     when multiple files match a wildcard
< tabstop (ts)        number    8     number of spaces that a TAB counts for
< taglength (tl)      number    0     if non-zero, tags are significant upto
<                                         this number of characters
< tagrelative (tr)    toggle    on    file names in tags file are relative
< tags                string    "tags"   names of tag files
< term                string    "amiga"   name of terminal
< terse               toggle    off   make some messages shorter
< textauto (ta)       toggle    on    detect line separator, (re)set 'textmode'
< textmode (tx)       toggle    off   use <CR><LF> for line separator
< textwidth (tw)      number    0     maximum width of a line in insert mode
< tildeop (to)        toggle    off   tilde behaves like an operator
< timeout             toggle    on    wait only 'tm' msec for mappings&key codes
< option (shorthand)   type  default        effect
< ttimeout            toggle    off   wait only 'tm' msec for key codes
< timeoutlen (tm)     number    1000  milliseconds to wait for mappings&key codes
< title               toggle    on    set window title to file name
< ttyfast (tf)        toggle    off   don't use scroll commands for terminal
< undolevels (ul)     number    100   number of changes that can be undone
<                                         (0 for Vi compatibility)
< updatecount (uc)    number    200   after this many key hits swap file updated
< updatetime (ut)     number    4000  after this many mil.sec. swap file updated
< visualbell (vb)     toggle    off   use visual instead of audible beep
< warn                toggle    on    warn when changes and shell command used
< weirdinvert (wi)    toggle    off   terminal has a weird invert behaviour
< whichwrap (ww)      number    3     which left/right move commands wrap
< wildchar (wc)       number    TAB   char used to start filename completion
< winheight (wh)      number    0     minimal number of lines for current window
< wrap                toggle    on    when off: horizontal scrolling
< wrapmargin (wm)     number    0     wrap text when at (columns - wrapmargin)
< wrapscan (ws)       toggle    on    searches wrap around the end of the file
< writeany (wa)       toggle    off   always write file without asking
< writebackup (wb)    toggle    on    backup a file WHILE overwriting it
< Undo/Redo commands
< N  u            undo N last changes
< N  CTRL-R       redo N last undone changes
<    U            restore last changed line
< External commands
< :sh             start a shell
< :!{command}     execute {command} with a shell
<    K            lookup keyword under the cursor with 'keywordprg' program
< Quickfix commands
< :cc [nr]        display error [nr] (default is the same again)
< :cn             display the next error
< :cp             display the previous error
< :cl             list all errors
< :cf             read errors from the file 'errorfile'
< :cq             quit without writing and return error code (to the compiler)
< :make [args]    start make, read errors and jump to first error
< Various commands
<    CTRL-L       Clear and redraw the screen.
<    CTRL-G       show current file name (with path) and cursor position
<    CTRL-C       during searches: interrupt the search
<    <DEL>        while entering a count: delete last character
< :vers           show exact version number of this VIM
< :mode N         MSDOS: set screen mode to N (number, C80, C4350, etc.)
< Command line editing
< <ESC>              abandon command line (if 'wildchar' is <ESC> type it twice)
< CTRL-V {char}      insert {char} literally
< CTRL-V {number}    enter decimal byte value (up to three digits)
< <C_LEFT>/<C_RIGHT> cursor left/right
< <SC_LEFT>/<SC_RIGHT>  cursor one word left/right
< CTRL-B/CTRL-E      cursor to begin/end of command line
< <BS>               delete the character in front of the cursor
< <DEL>              delete the character under the cursor
< CTRL-W             delete the word in front of the cursor
< CTRL-U             remove all characters
< <C_UP>/<C_DOWN>    recall older/newer command line from history
< <SC_UP>/<SC_DOWN>  recall older/newer command that starts with current command
< 
< Context sensitive completion
< 'wildchar'  (def. <TAB>)  do completion on the pattern in front of the cursor
< CTRL-D             list all names that match the pattern in front of the cursor
< CTRL-A             insert all names that match pattern in front of cursor
< CTRL-L             insert longest common part of names that match pattern
< CTRL-N             after 'wildchar' with multiple matches: go to next match
< CTRL-P             after 'wildchar' with multiple matches: go to previous match
< Ex ranges
< ,               separates two line numbers
< ;               idem, set cursor to the first line number
< 
< {number}        an absolute line number
< .               the current line
< $               the last line in the file
< %               equal to 1,$ (the entire file)
< 't              position of mark t
< /{pattern}      the next line where {pattern} matches
< ?{pattern}      the previous line where {pattern} matches
< 
< +[num]          add [num] to the preceding line number (default 1)
< -[num]          subtract [num] from the preceding line number (default 1)
< 
< Special Ex characters
<     |           separates two commands (not for ":global" and ":!")
<     "           begins comment
<     #[number]   alternate filename [number] (only where filename is expected)
<     %           current filename (only where filename is expected)
<     %<  or #<   idem, but without extension
< Editing a file
< :e                      Edit the current file, unless changes have been made.
< :e!                     Edit the current file always. Discard any changes.
< :e[dit] {file}          Edit {file}, unless changes have been made.
< :e[dit]! {file}         Edit {file} always. Discard any changes.
< N   CTRL-^              Edit alternate file N (equivalent to ":e #N").
< gf  or ]f               Edit the file whose name is under the cursor
< :pwd                    Print the current directory name.
< :cd [path]              Change the current directory to [path].
< :f[ile]                 Print the current filename and the cursor position.
< :f[ile] {name}          Set the current filename to {name}.
< :files                  Show alternate file names.
< 
< Using the file list
< :ar[gs]                 Print the file list, with the current file in "[]".
< :all  or :sall          Open a window for every file.
< :wn[ext][!]             Write file and edit next file.
< :wn[ext][!] {file}      Write to {file} and edit next file, unless {file}
<                         exists. With ! overwrite existing files.
< :wN[ext][!] [file]      Write file and edit previous file.
< 
< in current window    in new window
< :argu[ment] N        :sar[gument] N        Edit file N
< :n[ext]              :sn[ext]              Edit next file
< :n[ext] {filelist}   :sn[ext] {filelist}   define new list of files and edit
<                                                 the first one
< :N[ext]              :sN[ext]              Edit previous file
< :rew[ind][!]         :srew[ind]            Edit first file
< :last                :slast                Edit last file
< 
< Writing and quitting
< :[range]w[rite][!]      Write to the current file.
< :[range]w[rite] {file}  Write to {file}, unless it already exists.
< :[range]w[rite]! {file} Write to {file}. Overwrite an existing file.
< :[range]w[rite][!] >>   Append to the current file.
< :[range]w[rite][!] >> {file}
<                         Append to {file}.
< :[range]w[rite] !{cmd}  Execute {cmd} with [range] lines as standard input.
< :wall[!]                write all changed buffers
< 
< :q[uit]                 Quit, unless changes have been made.
< :q[uit]!                Quit always, discard any changes.
< :qall[!]                exit, also when buffers and windows open
< :cq                     Quit without writing and return error code
< :wq[!]                  Write the current file and exit.
< :wq[!] {file}           Write to {file} and exit.
< :x[it][!] [file]        Like ":wq" but write only when changes have been made
<    ZZ                   Same as ":x".
< :xall[!]  or :wqall[!]  write all changed buffers and exit
< 
< :st[op][!]              suspend VIM or start new shell. If 'aw' option is set
<                         and [!] not given write the buffer.
< CTRL-Z                  same as ":stop!"
< Starting VIM
< vim [options]           start editing with an empty buffer
< vim [options] {file ..} start editing one or more files
< vim [options] -t {tag}  edit the file associated with {tag}
< vim [options] -e [fname] start editing in QuickFix mode, display the first error
< Options
< +[num]                  put the cursor at line [num] (default last line)
< +/{pat} {file ..}       put the cursor at the first occurrence of {pat}
< -v                      read-only mode (View), implies -n
< -b                      binary mode
< -r                      recover aborted edit, using ".swp" file
< -n                      do not create ".swp" file
< -o [N]                  open N windows (default: one for each file)
< -x                      do not restart VIM to open a window (for e.g. mail)
< -s {scriptin}           first read the commands in the file {scriptin}
< -w {scriptout}          write all typed characters to the file {scriptout}
< -T {terminal}           set terminal type
< -d {device}             open {device} to be used as a console
< 
< Automatic option setting when editing a file
< vim:{set-arg}: ..       In the first and last lines of the file (see 'ml'
<                         option), {set-arg} is given as an argument to :set
< Multi window functions
< CTRL-W s  or :split     Split window in two parts
< :split <file>           Split window and edit <file> in one of them
< CTRL-W ]                Split window and jump to tag under cursor
< CTRL-W f                Split window and edit file name under the cursor
< CTRL-W n  or :new       Create new empty window
< CTRL-W q  or :q[uit]    Quit editing and close window
< CTRL-W c  or :cl[ose]   Make buffer hidden and close window
< CTRL-W o  or :o[nly]    Make current window only one on the screen
< 
< CTRL-W j                Move cursor to window below
< CTRL-W k                Move cursor to window above
< CTRL-W CTRL-W           Move cursor to next window (wrap around)
< CTRL-W t                Move cursor to top window
< CTRL-W b                Move cursor to bottom window
< CTRL-W p                Move cursor to previous active window
< 
< CTRL-W r                Rotate windows downwards
< CTRL-W R                Rotate windows upwards
< CTRL-W x                Exchange current window with next one
< 
< CTRL-W =                Make all windows equal height
< CTRL-W -                decrease current window height
< CTRL-W +                increase current window height
< CTRL-W _                Set current window height (default: very high)
< Buffer list functions
< :buffers  or :files     list all known buffer and file names
< 
< :ball     or :sball     edit all args/buffers
< :unhide   or :sunhide   edit all loaded buffers
< 
< in current window     in new window
< :[N]buffer [N]       :[N]sbuffer [N]       to arg/buf N
< :[N]bnext [N]        :[N]sbnext [N]        to Nth next arg/buf
< :[N]bNext [N]        :[N]sbNext [N]        to Nth previous arg/buf
< :[N]bprevious [N]    :[N]sbprevious [N]    to Nth previous arg/buf
< :brewind             :sbrewind             to first arg/buf
< :blast               :sblast               to last arg/buf
< :[N]bmod [N]         :[N]sbmod [N]         to Nth modified buf
---
> VIM stands for Vi IMproved.  Most of VIM was made by Bram Moolenaar.
575,576c5,795
< :bunload[!] [N]          unload buffer [N] from memory
< :bdelete[!] [N]          unload buffer [N] and delete it from the buffer list
---
> To jump to a subject position the cursor on the tag and hit CTRL-]. The tag is
> between bars at the start of the line. Use CTRL-T to go back.
> 
>  tag	  subject		      tag      subject
> 
> |t_lr|    Left-right motions         |t_cm|    Copying and moving text
> |t_ud|    Up-down motions            |t_re|    Repeating commands
> |t_wo|    Word motions               |t_km|    Key mapping
> |t_to|    Text object motions        |t_ab|    Abbreviations
> |t_pa|    Pattern searches           |t_op|    Options
> |t_ma|    Marks and motions          |t_ur|    Undo/Redo commands
> |t_vm|    Various motions            |t_et|    External commands
> |t_ta|    Using tags                 |t_qf|    Quickfix commands
> |t_sc|    Scrolling                  |t_vc|    Various commands
> |t_in|    Inserting text             |t_cl|    Command line editing
> |t_ai|    Keys in insert mode        |t_ra|    Ex ranges
> |t_ss|    Special keys in insert mode|t_ex|    Special Ex characters
> |t_di|    Digraphs                   |t_ed|    Editing a file
> |t_si|    Special inserts            |t_fl|    Using the file list
> |t_ch|    Changing text              |t_wq|    Writing and quitting
> |t_vi|    Visual mode                |t_st|    Starting VIM
> |t_co|    Complex changes            |t_wi|    Multi window functions
> |t_de|    Deleting text              |t_bu|    Buffer list functions
> 
> list of documentation files:		      remarks about specific systems:
> 
> |vim_help.txt|	quick reference (this file)         |vim_unix.txt|  Unix
> |vim_idx.txt|	alphabetical index                  |vim_ami.txt|   Amiga
> |vim_ref.txt|	reference manual                    |vim_dos.txt|   MS-DOS
> |vim_win.txt|	reference for windows commands      |vim_nt.txt|    Windows-NT
> |vim_diff.txt|	differences between Vim and Vi      |vim_arch.txt|  Archimedes
> |vim_digr.txt|	list of available digraphs          |vim_mac.txt|   Macintosh
> |vim_tips.txt|	tips on using Vim
> 
> 
> *t_lr*		Left-right motions
> 
> |h|	N  h		left (also: CTRL-H, BS or cursor-left key)
> |l|	N  l		right (also: SPACE or cursor-right key)
> |0|	   0		to first character in the line (also: HOME key)
> |^|	   ^		to first non-blank character in the line
> |$|	N  $		to the last character in the line (N-1 lines lower)
> 				(also: END key)
> |bar|	N  |		to column N (default: 0)
> |f|	N  f<char>	to the Nth occurrence of <char> to the right
> |F|	N  F<char>	to the Nth occurrence of <char> to the left
> |t|	N  t<char>	till before the Nth occurrence of <char> to the right
> |T|	N  T<char>	till before the Nth occurrence of <char> to the left
> |;|	N  ;		repeat the last f, F, t or T N times
> |,|	N  ,		repeat the last f, F, t or T N times in opposite
> 			direction
> *t_ud*		Up-down motions
> 
> |k|	N  k		up (also: CTRL-P and cursor-up key)
> |j|	N  j		down (also: CTRL-J, CTRL-N, LF and cursor-down key)
> |-|	N  -		up, on the first non-blank character
> |+|	N  +		down, on the first non-blank character (also: CTRL-M
> 				and CR)
> |_|	N  _		N - 1 lines down, on the first non-blank character
> |G|	N  G		goto line N (default last line), on the first
> 				non-blank character
> |gg|	N  gg		goto line N (default first line), on the first
> 				non-blank character
> |N%|	N  %		goto line N percentage down in the file. N must be
> 				given, otherwise it is |%|.
> 
> *t_wo*		Word motions
> 
> |w|	N  w		N words forward
> |W|	N  W		N blank-separated words forward
> |e|	N  e		forward to the end of the Nth word
> |E|	N  E		forward to the end of the Nth blank-separated word
> |b|	N  b		N words backward
> |B|	N  B		N blank-separated words backward
> 
> *t_to*		Text object motions
> 
> |)|	N  )		N sentences forward
> |(|	N  (		N sentences backward
> |}|	N  }		N paragraphs forward
> |{|	N  {		N paragraphs backward
> |]]|	N  ]]		N sections forward, at start of section
> |[[|	N  [[		N sections backward, at start of section
> |][|	N  ][		N sections forward, at end of section
> |[]|	N  []		N sections backward, at end of section
> |[(|	N  [(		N times back to unclosed <(>
> |[(|	N  [{		N times back to unclosed <{>
> |])|	N  ])		N times forward to unclosed <(>
> |])|	N  ]}		N times forward to unclosed <{>
> 
> *t_pa*		Pattern searches
> 
> |/|	N  /{pattern}[/]<CR>
> 			search forward for the Nth occurrence of {pattern}
> |?|	N  ?{pattern}[?]<CR>
> 			search backward for the Nth occurrence of {pattern}
> |/<CR>|	N  /<CR>	repeat last search, in the forward direction
> |?<CR>|	N  ?<CR>	repeat last search, in the backward direction
> |n|	N  n		repeat last search
> |N|	N  N		repeat last search, in opposite direction
> |star|	N  *		search forward for the ident under the cursor
> |#|	N  #		search backward for the ident under the cursor
> |gd|	   gd		goto local declaration of ident under the cursor
> |gD|	   gD		goto global declaration of ident under the cursor
> 
> |search_pattern|	Special characters in search patterns
> 
> 			meaning		   magic       nomagic
> 	   matches any single character      .		  \.
> 		  matches start of line      ^		  ^
> 		    matches end of line      $		  $
> 		  matches start of word      \<		  \<
> 		    matches end of word      \>		  \>
>    matches a single char from the range      [a-z]	  \[a-z]
>  matches a single char not in the range      [^a-z]	  \[^a-z]
> matches 0 or more of the preceding atom      *		  \*
> matches 1 or more of the preceding atom      \+		  \+
>    matches 0 or 1 of the preceding atom      \=		  \=
> 		 separates two branches      \|		  \|
> 	   group a pattern into an atom      \(\)	  \(\)
> 
> *t_ma*		Marks and motions
> 
> |m|	     m<a-zA-Z>	mark current position with mark <a-zA-Z>
> |`|	     `<a-zA-Z>	go to mark <a-zA-Z>
> |``|	     ``		go to the position before the last jump
> |`[|	     `[		go to the start of the previously operated or put text
> |`]|	     `]		go to the end of the previously operated or put text
> |'|	     '<a-zA-Z[]'>
> 			same as `, but on the first non-blank in the line
> |:marks|  :marks	print the active marks
> |CTRL-O|  N  CTRL-O	go to N older position in jump list
> |CTRL-I|  N  CTRL-I	go to N newer position in jump list
> |:jumps|  :ju[mps]	print the jump list
> 
> *t_vm*		Various motions
> 
> |%|	   %		find the next brace, bracket, comment or #if/
> 				#else/#endif in this line and go to its match
> |H|	N  H		go to the Nth line in the window, on the first
> 				non-blank
> |M|	   M		go to the middle line in the window, on the first
> 				non-blank
> |L|	N  L		go to the Nth line from the bottom, on the first
> 				non-blank
> 
> *t_ta*		Using tags
> 
> |:tag|	   :ta[g][!] {tag}	Jump to tag {tag}
> |CTRL-]|      CTRL-]		Jump to the tag under cursor, unless changes
> 					have been made
> |CTRL-T|   N  CTRL-T		Jump back from N older tag in tag list
> |:pop|	   :[count]po[p][!]	Jump back from [count] older tag in tag list
> |:tag|	   :[count]ta[g][!]	Jump to [count] newer tag in tag list
> |:tags|	   :tags		Print tag list
> 
> *t_sc*		Scrolling
> 
> |CTRL-E|	N  CTRL-E	window N lines downwards (default 1)
> |CTRL-D|	N  CTRL-D	window N lines Downwards (default 1/2 window)
> |CTRL-F|	N  CTRL-F	window N pages Forwards (downwards)
> |CTRL-Y|	N  CTRL-Y	window N lines upwards (default 1)
> |CTRL-U|	N  CTRL-U	window N lines Upwards (default 1/2 window)
> |CTRL-B|	N  CTRL-B	window N pages Backwards (upwards)
> |z<CR>|		   z<CR> or zt	redraw, current line at top of window
> |z.|		   z.	 or zz	redraw, current line at center of window
> |z-|		   z-	 or zb	redraw, current line at bottom of window
> 
> *t_in*		Inserting text
> 
> |a|	N  a	append text after the cursor (N times)
> |A|	N  A	append text at the end of the line (N times)
> |i|	N  i	insert text before the cursor (N times) (also: INSERT key)
> |I|	N  I	insert text before the first non-blank in the line (N times)
> |o|	N  o	open a new line below the current line, append text (N times)
> |O|	N  O	open a new line above the current line, append text (N times)
> 
> *t_ai*		Keys in insert mode
> 
> 		char			action in insert mode
> |i_<ESC>|	<ESC>   	  end insert mode, back to command mode
> |i_CTRL-C|	CTRL-C		  like <ESC>, but do not do an abbreviation
> |i_CTRL-A|	CTRL-A		  insert previously inserted text
> |i_CTRL-@|	CTRL-@		  insert previously inserted text and stop
> 					  insert
> |i_CTRL-R|	CTRL-R <0-9a-z%:> insert contents of register <0-9a-z%:>
> |i_<LF>|	<LF> or <CR> or CTRL-M or CTRL-J
> 				  begin new line
> |i_CTRL-E|	CTRL-E		  insert the character from below the cursor
> |i_CTRL-Y|	CTRL-Y		  insert the character from above the cursor
> |i_CTRL-V|	CTRL-V		  insert character literally, or enter decimal
> 					  byte value
> |i_CTRL-N|	CTRL-N		  insert next match of identifier before the
> 					  cursor
> |i_CTRL-P|	CTRL-P		  insert previous match of identifier before
> 					  the cursor
> |i_<BS>|	<BS> or CTRL-H    delete the character before the cursor
> |i_<DEL>|	<DEL>		  delete the character under the cursor
> |i_CTRL-W|	CTRL-W		  delete word before the cursor
> |i_CTRL-U|	CTRL-U		  delete all entered characters in the current
> 					  line
> |i_CTRL-T|	CTRL-T		  insert one shiftwidth of indent in front of
> 					  the current line
> |i_CTRL-D|	CTRL-D		  delete one shiftwidth of indent in front of
> 					  the current line
> |i_0_CTRL-D|	0 CTRL-D	  delete all indent in the current line
> |i_^_CTRL-D|	^ CTRL-D	  delete all indent in the current line,
> 					restore indent in next line
> |i_CTRL-K|	CTRL-K {char1} {char2}
> 				  enter digraph (See |t_di|)
> |i_digraph|	{char1} <BS> {char2}
> 				  enter digraph if 'digraph' option set
> |i_CTRL-B|	CTRL-B		  toggle 'revins' (reverse insert) option
> 
> *t_ss*		Special keys in insert mode
> 
> |i_<C_UP>|	cursor keys	  move cursor left/right/up/down
> |i_<SC_LEFT>|	shift-left/right  one word left/right
> |i_<SC_UP>|	shift-up/down	  one screenfull backward/forward
> |i_CTRL-O|	CTRL-O {command}  execute {command}
> |i_<END>|	end key		  cursor after last character in the line
> |i_<HOME>|	home key	  cursor to first character in the line
> 
> *t_di*		Digraphs
> 
> |:digraphs|	:dig[raphs]	  show current list of digraphs
> |:digraphs|	:dig[raphs] {char1}{char2} {number} ...
> 				  add digraph(s) to the list
> 
> *t_si*		Special inserts
> 
> |:read|	   :r [file]	   insert the contents of [file] below the cursor
> |:read!|   :r! {command}   insert the standard output of {command} below the
> 				   cursor
> 
> *t_ch*		Changing text
> 
> |R|	  N  R		enter replace mode (repeat the entered text N times)
> |c|	  N  c{motion}	change the text that is moved over with {motion}
> |v_c|	     {visual}c	change the highlighted text
> |cc|	  N  cc		change N lines
> |S|	  N  S		change N lines
> |C|	  N  C		change to end of line (and N-1 more lines)
> |s|	  N  s		change N characters
> |r|	  N  r<char>	replace N characters by <char>
> 
> |~|	  N  ~		switch case for N characters and advance cursor
> |v_~|	     {visual}~	switch case for highlighted text
> |v_u|	     {visual}u	make highlighted text lowercase
> |v_U|	     {visual}U	make highlighted text uppercase
> |g~|	     g~{motion} switch case for the text that is moved over with
> 				{motion}
> |gu|	     gu{motion} make the text that is moved over with {motion}
> 				lowercase
> |gU|	     gU{motion} make the text that is moved over with {motion}
> 				uppercase
> 
> |CTRL-A|  N  CTRL-A	add N to the number at or after the cursor
> |CTRL-X|  N  CTRL-X	subtract N from the number at or after the cursor
> 
> |<|	  N  <{motion}	move the lines that are moved over one shiftwidth left
> |<<|	  N  <<		move N lines one shiftwidth left
> |>|	  N  >{motion}	move the lines that are moved over one shiftwidth
> 				right
> |>>|	  N  >>		move N lines one shiftwidth right
> |Q|	  N  Q{motion}	format the lines that are moved over to 'textwidth'
> 				length
> |:center| :[range]ce[nter] [width]
> 			center the lines in [range]
> |:left|	  :[range]le[ft] [indent]
> 			left align the lines in [range] [with indent]
> |:right|  :[range]ri[ght] [width]
> 			right align the lines in [range]
> 
> *t_vi*		Visual mode
> 
> |v|	   v		start highlighting characters  } move cursor and use
> |V|	   V		start highlighting linewise    } operator to affect
> |CTRL-V|   CTRL-V	start highlighting blockwise   } highlighted text
> |v_o|	   o		exchange cursor position with start of highlighting
> |v_v|	   v		stop highlighging
> |v_V|	   V		switch between highlighting characters and linewise
> |v_CTRL-V| CTRL-V	switch between highlighting characters and blockwise
> 
> *t_co*		Complex changes
> 
> |!|		N  !{motion}{command}<CR>
> 			filter the lines that are moved over through {command}
> |!!|		N  !!{command}<CR>
> 			filter N lines through {command}
> |v_!|		   {visual}!{command}<CR>
> 			filter the highlighted lines through {command}
> |:range!|	:[range]! {command}<CR>
> 			filter [range] lines through {command}
> |=|		N  ={motion}
> 			filter the lines that are moved over through "indent"
> |==|		N  ==	filter N lines through "indent"
> |v_=|		   {visual}=
> 			filter the highlighted lines through "indent"
> |:substitute|	:[range]s[ubstitute]/{pattern}/{string}/[g][c]
> 			substitute {pattern} by {string} in [range] lines;
> 				with [g] replace all occurrences of {pattern};
> 				with [c] ask first
> |:substitute|	:[range]s[ubstitute] [g][c]
> 			repeat previous :s with new range and options
> |&|		   &	Repeat previous :s on current line without options
> |:retab|	:[range]ret[ab][!] [tabstop]
> 			set 'tabstop' to new value and adjust white space
> 			accordingly
> 
> *t_de*		Deleting text
> 
> |x|	N  x		delete N characters under and after the cursor
> |<DEL>| N  del key	delete N characters under and after the cursor
> |X|	N  X		delete N characters before the cursor
> |d|	N  d{motion}	delete the text that is moved over with {motion}
> |v_d|	{visual}d	delete the highlighted text
> |dd|	N  dd		delete N lines
> |D|	N  D		delete to end of line (and N-1 more lines)
> |J|	N  J		join N-1 lines (delete newlines)
> |v_J|	{visual}J	join the highlighted lines
> |:delete|
> 	:[range]d [x]	delete [range] lines [into register x]
> 
> *t_cm*		Copying and moving text
> 
> |"|	     "<char>	use register <char> for the next delete, yank or put
> |:display|   :dis	show the current register contents
> |y|	  N  y{motion}	yank the text moved over with {motion} into a register
> |v_y|	  {visual}y	yank the highlighted text into a register
> |yy|	  N  yy		yank N lines into a register
> |Y|	  N  Y		yank N lines into a register
> |p|	  N  p		put a register after the cursor position (N times)
> |P|	  N  P		put a register before the cursor position (N times)
> |]p|	  N  ]p		like p, but adjust indent to current line
> |[p|	  N  [p		like P, but adjust indent to current line
> 
> *t_re*		Repeating commands
> 
> |.|	   N  .		repeat last change (with count replaced by N)
> |q|	      q<a-z>	record typed characters into register <a-z>
> |q|	      q		stop recording
> |@|	   N  @<a-z>	execute the contents of register <a-z> (N times)
> |@@|	   N  @@		repeat previous @<a-z> (N times)
> |:@|	   :@<a-z>	execute the contents of register <a-z> as an Ex
> 				command
> |:@@|	   :@@		repeat previous :@<a-z>
> |:global|  :[range]g[lobal]/{pattern}/[cmd]
> 			Execute Ex command [cmd] (default :p) on the lines
> 				within [range] where {pattern} matches.
> |:global|  :[range]g[lobal]!/{pattern}/[cmd]
> 			Execute Ex command [cmd] (default :p) on the lines
> 				within [range] where {pattern} does NOT match.
> |:source|  :so[urce] {file}
> 			Read Ex commands from {file}.
> |:source|  :so[urce]! {file}
> 			Read Vim commands from {file}.
> |:sleep|  :sl[eep] [N]	don't do anything for N seconds
> |gs|	  N  gs		goto sleep for N seconds
> 
> *t_km*		Key mapping
> 
> |:map|	     :ma[p] {lhs} {rhs}	  Map {lhs} to {rhs} in normal and visual
> 					mode.
> |:map!|	     :ma[p]! {lhs} {rhs}  Map {lhs} to {rhs} in insert and command
> 					line mode.
> |:noremap|   :no[remap][!] {lhs} {rhs}
> 				  Same as :map, no remapping for this {rhs}
> |:unmap|     :unm[ap] {lhs}	  Remove the mapping of {lhs} for normal and
> 					visual mode.
> |:unmap!|    :unm[ap]! {lhs}	  Remove the mapping of {lhs} for insert and
> 					command line mode.
> |:map_l|     :ma[p] [lhs]	  List mappings (starting with [lhs]) for
> 					normal and visual mode.
> |:map_l!     :ma[p]! [lhs]	  List mappings (starting with [lhs]) for
> 					insert and command line mode.
> |:cmap|	     :cmap/:cunmap/:cnoremap
> 				  like map!/unmap!/noremap! but for command
> 					  line mode only
> |:imap|	     :imap/:iunmap/:inoremap
> 				  like map!/unmap!/noremap! but for insert
> 					  mode only
> |:nmap|	     :nmap/:nunmap/:nnoremap
> 				  like map/unmap/noremap but for normal mode
> 					  only
> |:vmap|	     :vmap/:vunmap/:vnoremap
> 				  like map/unmap/noremap but for visual mode
> 					  only
> |:mkexrc|    :mk[exrc][!] [file]  write current mappings, abbreviations and
> 					settings to [file] (default ".exrc";
> 					use ! to overwrite)
> |:mkvimrc|   :mkv[imrc][!] [file]
> 				  same as :mkexrc, but with default ".vimrc"
> 
> *t_ab*		Abbreviations
> 
> |:abbreviate|	:ab[breviate] {lhs} {rhs}  add abbreviation for {lhs} to {rhs}
> |:abbreviate|	:ab[breviate] {lhs}	   show abbr's that start with {lhs}
> |:abbreviate|	:ab[breviate]		   show all abbreviations
> |:unabbreviate|	:una[bbreviate] {lhs}	   remove abbreviation for {lhs}
> |:noreabbrev|	:norea[bbrev] [lhs] [rhs]  like :ab, but don't remap [rhs]
> |:iabbrev|	:iab/:iunab/:inoreab       like :ab, but only for insert mode
> |:cabbrev|	:cab/:cunab/:cnoreab       like :ab, but only for command line
> 
> *t_op*		Options
> 
> |:set|	:se[t]			Show all modified options.
> |:set|	:se[t] all		Show all options.
> |:set|	:se[t] {option}		Set toggle option on, show string or number
> 					option.
> |:set|	:se[t] no{option}	Set toggle option off.
> |:set|	:se[t] inv{option}	invert toggle option.
> |:set|	:se[t] {option}={value} Set string or number option to {value}.
> |:set|	:se[t] {option}?	Show value of {option}.
> 
> Use the tags below to jump to the explanation of each option.
> |'autoindent'|     |'ai'|
> |'autowrite'|      |'aw'|
> |'backspace'|      |'bs'|
> |'backup'|         |'bk'|
> |'backupdir'|      |'bdir'|
> |'backupext'|      |'bex'|
> |'binary'|         |'bin'|
> |'bioskey'|        |'bk'|
> |'cmdheight'|      |'ch'|
> |'columns'|        |'co'|
> |'comments'|       |'com'|
> |'compatible'|     |'cp'|
> |'define'|         |'def'|
> |'dictionary'|     |'dict'|
> |'digraph'|        |'dg'|
> |'directory'|      |'dir'|
> |'edcompatible'|   
> |'endofline'|      |'eol'|
> |'equalalways'|    |'ea'|
> |'equalprg'|       |'ep'|
> |'errorbells'|     |'eb'|
> |'errorfile'|      |'ef'|
> |'errorformat'|    |'efm'|
> |'esckeys'|        |'ek'|
> |'expandtab'|      |'et'|
> |'exrc'|           
> |'formatoptions'|  |'fo'|
> |'formatprg'|      |'fp'|
> |'gdefault'|       |'gd'|
> |'graphic'|        |'gr'|
> |'helpfile'|       |'hf'|
> |'helpheight'|     |'hh'|
> |'hidden'|         |'hid'|
> |'highlight'|      |'hl'|
> |'history'|        |'hi'|
> |'icon'|           
> |'identchars'|     |'id'|
> |'ignorecase'|     |'ic'|
> |'include'|        |'inc'|
> |'incsearch'|      |'is'|
> |'infercase'|      |'inf'|
> |'insertmode'|     |'im'|
> |'joinspaces'|     |'js'|
> |'keywordprg'|     |'kp'|
> |'laststatus'|     |'ls'|
> |'lines'|          
> |'list'|           
> |'magic'|          
> |'makeprg'|        |'mp'|
> |'maxmapdepth'|    |'mmd'|
> |'maxmem'|         |'mm'|
> |'maxmemtot'|      |'mmt'|
> |'modeline'|       |'ml'|
> |'modelines'|      |'mls'|
> |'more'|           
> |'mouse'|          
> |'nestedcomments'| |'ncom'|
> |'nobuf'|          |'nb'|
> |'number'|         |'nu'|
> |'paragraphs'|     |'para'|
> |'paste'|          
> |'patchmode'|      |'pm'|
> |'path'|           |'pa'|
> |'readonly'|       |'ro'|
> |'remap'|          
> |'report'|         
> |'revins'|         
> |'ruler'|          |'ru'|
> |'scroll'|         
> |'scrolljump'|     |'sj'|
> |'sections'|       |'sect'|
> |'secure'|         
> |'shell'|          |'sh'|
> |'shellpipe'|      |'sp'|
> |'shellredir'|     |'srr'|
> |'shelltype'|      |'st'|
> |'shiftround'|     |'sr'|
> |'shiftwidth'|     |'sw'|
> |'shortmess'|      |'shm'|
> |'shortname'|      |'sn'|
> |'showcmd'|        |'sc'|
> |'showmatch'|      |'sm'|
> |'showmode'|       |'smd'|
> |'sidescroll'|     |'ss'|
> |'smartindent'|    |'si'|
> |'smartmatch'|     |'sma'|
> |'smarttab'|       |'sta'|
> |'splitbelow'|     |'sb'|
> |'startofline'|    |'sol'|
> |'suffixes'|       |'su'|
> |'tabstop'|        |'ts'|
> |'taglength'|      |'tl'|
> |'tagrelative'|    |'tr'|
> |'tags'|           
> |'term'|           
> |'terse'|          
> |'textauto'|       |'ta'|
> |'textmode'|       |'tx'|
> |'textwidth'|      |'tw'|
> |'tildeop'|        |'to'|
> |'timeout'|        
> |'ttimeout'|       
> |'timeoutlen'|     |'tm'|
> |'title'|          
> |'ttyfast'|        
> |'undolevels'|     |'ul'|
> |'updatecount'|    |'uc'|
> |'updatetime'|     |'ut'|
> |'viminfo'|        |'vi'|
> |'visualbell'|     |'vb'|
> |'warn'|           
> |'weirdinvert'|    |'wi'|
> |'whichwrap'|      |'ww'|
> |'wildchar'|       |'wc'|
> |'winheight'|      |'wh'|
> |'wrap'|           
> |'wrapmargin'|     |'wm'|
> |'wrapscan'|       |'ws'|
> |'writeany'|       |'wa'|
> |'writebackup'|    |'wb'|
> 
> *t_ur*		Undo/Redo commands
> 
> |u|	  N  u		undo N last changes
> |CTRL-R|  N  CTRL-R	redo N last undone changes
> |U|	     U		restore last changed line
> 
> *t_et*		External commands
> 
> |:shell|	:sh[ell]	start a shell
> |:!|		:!{command}	execute {command} with a shell
> |K|		   K		lookup keyword under the cursor with
> 					'keywordprg' program (default; man)
> 
> *t_qf*		Quickfix commands
> 
> |:cc|		:cc [nr]	display error [nr] (default is the same again)
> |:cnext|	:cn		display the next error
> |:cprevious|	:cp		display the previous error
> |:clist|	:cl		list all errors
> |:cfile|	:cf		read errors from the file 'errorfile'
> |:cquit|	:cq		quit without writing and return error code (to
> 					the compiler)
> |:make|		:make [args]	start make, read errors and jump to first
> 					error
> 
> *t_vc*		Various commands
> 
> |CTRL-L|	   CTRL-L	Clear and redraw the screen.
> |CTRL-G|	   CTRL-G	show current file name (with path) and cursor
> 					position
> |CTRL-C|	   CTRL-C	during searches: interrupt the search
> |<DEL>|	   	   <DEL>	while entering a count: delete last character
> |:version|	:ve[rsion]	show exact version number of this VIM
> |:mode|		:mode N		MSDOS: set screen mode to N (number, C80,
> 					C4350, etc.)
> 
> *t_cl*		Command line editing
> 
> |e_<ESC>|	<ESC>		   abandon command line (if 'wildchar' is
> 					<ESC> type it twice)
> |e_CTRL-V|	CTRL-V {char}	   insert {char} literally
> |e_CTRL-V|	CTRL-V {number}    enter decimal value of character (up to
> 					three digits)
> |e_<C_LEFT>|	<C_LEFT>/<C_RIGHT> cursor left/right
> |e_<SC_LEFT>|	<SC_LEFT>/<SC_RIGHT>  cursor one word left/right
> |e_CTRL-B|	CTRL-B/CTRL-E	   cursor to begin/end of command line
> |e_<BS>|	<BS>		   delete the character in front of the cursor
> |e_<DEL>|	<DEL>		   delete the character under the cursor
> |e_CTRL-W|	CTRL-W		   delete the word in front of the cursor
> |e_CTRL-U|	CTRL-U		   remove all characters
> |e_<C_UP>|	<C_UP>/<C_DOWN>    recall older/newer cmd line from history
> |e_<SC_UP>|	<SC_UP>/<SC_DOWN>  recall older/newer cmd line that starts
> 					with current command
> 
> 	Context sensitive completion on the command line:
> 
> |e_wildchar|	'wildchar'  (default <TAB>)
> 				do completion on the pattern in front of the
> 					cursor; If there are multiple
> 					matches, beep and show the first
> 					one, further 'wildchar' will show
> 					the next ones.
> |e_CTRL-D|	CTRL-D		list all names that match the pattern in
> 					front of the cursor
> |e_CTRL-A|	CTRL-A		insert all names that match pattern in front
> 					of cursor
> |e_CTRL-L|	CTRL-L		insert longest common part of names that
> 					match pattern
> |e_CTRL-N|	CTRL-N		after 'wildchar' with multiple matches: go
> 					to next match
> |e_CTRL-P|	CTRL-P		after 'wildchar' with multiple matches: go
> 					to previous match
> 
> *t_ra*		Ex ranges
> 
> |:range|	,		separates two line numbers
> |:range|	;		idem, set cursor to the first line number
> 
> |:range|	{number}	an absolute line number
> |:range|	.		the current line
> |:range|	$		the last line in the file
> |:range|	%		equal to 1,$ (the entire file)
> |:range|	't		position of mark t
> |:range|	/{pattern}	the next line where {pattern} matches
> |:range|	?{pattern}	the previous line where {pattern} matches
> 
> |:range|	+[num]		add [num] to the preceding line number
> 					(default 1)
> |:range|	-[num]		subtract [num] from the preceding line
> 					number (default 1)
> 
> *t_ex*		Special Ex characters
> 
> |:bar|	    |		separates two commands (not for ":global" and ":!")
> |:"|	    "		begins comment
> |:#|	    #[number]	alternate filename [number] (only where filename is
> 				expected)
> |:%|	    %		current filename (only where filename is expected)
> |:%<|	    %<	or #<	idem, but without extension
> 
> *t_ed*		Editing a file
> 
> |:edit|	   :e[dit]		Edit the current file, unless changes have
> 					been made.
> |:edit!|   :e[dit]!		Edit the current file always. Discard any
> 					changes.
> |:edit_f|  :e[dit] {file}	Edit {file}, unless changes have been made.
> |:edit!_f| :e[dit]! {file}	Edit {file} always. Discard any changes.
> |CTRL-^|   N   CTRL-^		Edit alternate file N (equivalent to ":e #N").
> |gf|	       gf  or ]f	Edit the file whose name is under the cursor
> |:pwd|	   :pwd			Print the current directory name.
> |:cd|	   :cd [path]		Change the current directory to [path].
> |:file|	   :f[ile]		Print the current filename and the cursor
> 					position.
> |:file|	   :f[ile] {name}	Set the current filename to {name}.
> |:files|   :files		Show alternate file names.
> 
> *t_fl*		Using the file list
> 
> |:args|	   :ar[gs]		Print the file list, with the current file in
> 					"[]".
> |:all|	   :all  or :sall	Open a window for every file.
> |:wnext|   :wn[ext][!]		Write file and edit next file.
> |:wnext|   :wn[ext][!] {file}	Write to {file} and edit next file, unless
> 					{file} exists. With ! overwrite
> 					existing files.
> |:wNext|   :wN[ext][!] [file]	Write file and edit previous file.
> 
> 	     in current window    in new window
> |:argument|  :argu[ment] N	  :sar[gument] N	Edit file N
> |:next|	     :n[ext]		  :sn[ext]		Edit next file
> |:next_f|    :n[ext] {filelist}   :sn[ext] {filelist}   define new list of
> 							   files and edit the
> 							   first one
> |:Next|	     :N[ext]		  :sN[ext]		Edit previous file
> |:rewind|    :rew[ind][!]	  :srew[ind]		Edit first file
> |:last|	     :last		  :slast		Edit last file
> 
> *t_wq*		Writing and quitting
> 
> |:write|    :[range]w[rite][!]		Write to the current file.
> |:write_f|  :[range]w[rite] {file}	Write to {file}, unless it already
> 					   exists.
> |:write_f|  :[range]w[rite]! {file}	Write to {file}. Overwrite an existing
> 					   file.
> |:write_a|  :[range]w[rite][!] >>	Append to the current file.
> |:write_a|  :[range]w[rite][!] >> {file}
> 					Append to {file}.
> |:write_c|  :[range]w[rite] !{cmd}	Execute {cmd} with [range] lines as
> 					   standard input.
> |:wall|	    :wall[!]			write all changed buffers
> 
> |:quit|	  :q[uit]		Quit, unless changes have been made.
> |:quit|	  :q[uit]!		Quit always, discard any changes.
> |:qall|	  :qall[!]		exit, also when buffers and windows open
> |:cq|	  :cq			Quit without writing and return error code
> |:wq|	  :wq[!]		Write the current file and exit.
> |:wq|	  :wq[!] {file}		Write to {file} and exit.
> |:xit|	  :x[it][!] [file]	Like ":wq" but write only when changes have
> 				   been made
> |ZZ|	     ZZ			Same as ":x".
> |:xall|	  :xall[!]  or :wqall[!]
> 				Write all changed buffers and exit
> 
> |:stop|	  :st[op][!]		Suspend VIM or start new shell. If 'aw' option
> 				   is set and [!] not given write the buffer.
> |CTRL-Z|     CTRL-Z		Same as ":stop!"
> 
> *t_st*		Starting VIM
> 
> |cl_vim|    vim [options]		start editing with an empty buffer
> |cl_file|   vim [options] {file ..}	start editing one or more files
> |cl_tag|    vim [options] -t {tag}	edit the file associated with {tag}
> |cl_qf|	    vim [options] -e [fname]	start editing in QuickFix mode,
> 					   display the first error
> 
> 	options:
> 
> |cl_+|	+[num]		    put the cursor at line [num] (default last line)
> |cl_+c| +{command}	    execute {command} after loading the file
> |cl_+/|	+/{pat} {file ..}   put the cursor at the first occurrence of {pat}
> |cl_v|	-v		    read-only mode (View), implies -n
> |cl_b|	-b		    binary mode
> |cl_r|	-r		    without file name: give list of swap files
> |cl_r|	-r		    with file name: Recover aborted edit
> |cl_n|	-n		    do not create ".swp" file
> |cl_o|	-o [N]		    open N windows (default: one for each file)
> |cl_x|	-x		    do not restart VIM to open a window (for e.g.
> 				mail)
> |cl_s|	-s {scriptin}	    first read the commands in the file {scriptin}
> |cl_w|	-w {scriptout}	    write all typed characters to the file {scriptout}
> |cl_T|	-T {terminal}	    set terminal type
> |cl_d|	-d {device}	    open {device} to be used as a console
> |cl_u|	-u {vimrc}	    read inits from {vimrc} instead of other inits
> 
> Automatic option setting when editing a file
> 
> |modeline|	vim:{set-arg}: ..	In the first and last lines of the
> 					file (see 'ml' option), {set-arg} is
> 					given as an argument to :set
> 
> *t_wi*		Multi window functions
> 
> |CTRL-W_s|	CTRL-W s  or :split	Split window in two parts
> |:split_f|	:split {file}		Split window and edit {file} in one of
> 					   them
> |CTRL-W_]|	CTRL-W ]		Split window and jump to tag under
> 					   cursor
> |CTRL-W_f|	CTRL-W f		Split window and edit file name under
> 					   the cursor
> |CTRL-W_n|	CTRL-W n  or :new	Create new empty window
> |CTRL-W_q|	CTRL-W q  or :q[uit]	Quit editing and close window
> |CTRL-W_c|	CTRL-W c  or :cl[ose]	Make buffer hidden and close window
> |CTRL-W_o|	CTRL-W o  or :o[nly]	Make current window only one on the
> 					   screen
> 
> |CTRL-W_j|	CTRL-W j		Move cursor to window below
> |CTRL-W_k|	CTRL-W k		Move cursor to window above
> |CTRL-W_CTRL-W|	CTRL-W CTRL-W		Move cursor to next window (wrap)
> |CTRL-W_t|	CTRL-W t		Move cursor to top window
> |CTRL-W_b|	CTRL-W b		Move cursor to bottom window
> |CTRL-W_p|	CTRL-W p		Move cursor to previous active window
> 
> |CTRL-W_r|	CTRL-W r		Rotate windows downwards
> |CTRL-W_R|	CTRL-W R		Rotate windows upwards
> |CTRL-W_x|	CTRL-W x		Exchange current window with next one
> 
> |CTRL-W_=|	CTRL-W =		Make all windows equal height
> |CTRL-W_-|	CTRL-W -		decrease current window height
> |CTRL-W_+|	CTRL-W +		increase current window height
> |CTRL-W__|	CTRL-W _		Set current window height (default:
> 					   very high)
> 
> *t_bu*		Buffer list functions
> 
> |:buffers|	:buffers  or :files	list all known buffer and file names
> 
> |:ball|		:ball	  or :sball	edit all args/buffers
> |:unhide|	:unhide   or :sunhide	edit all loaded buffers
> 
> |:bunload|	:bunload[!] [N]		unload buffer [N] from memory
> |:bdelete|	:bdelete[!] [N]		unload buffer [N] and delete it from
> 					   the buffer list
> 
> 	      in current window   in new window
> |:buffer|     :[N]buffer [N]	  :[N]sbuffer [N]     to arg/buf N
> |:bnext|      :[N]bnext [N]	  :[N]sbnext [N]      to Nth next arg/buf
> |:bNext|      :[N]bNext [N]	  :[N]sbNext [N]      to Nth previous arg/buf
> |:bprevious|  :[N]bprevious [N]   :[N]sbprevious [N]  to Nth previous arg/buf
> |:brewind|    :brewind	     	  :sbrewind	      to first arg/buf
> |:blast|      :blast		  :sblast	      to last arg/buf
> |:bmodified|  :[N]bmod [N]	  :[N]sbmod [N]	      to Nth modified buf
> 
> vim:ts=8:
Index: ./doc/vim_idx.txt
diff -r ../vim.orig/doc/vim_idx.txt ./doc/vim_idx.txt
0a1,2
> *vim_idx.txt*
> 
193c195
< [p		2	like "p", but adjust indent to current line
---
> [p		2	like "P", but adjust indent to current line
200c202
< ]p		2	like "P", but adjust indent to current line
---
> ]p		2	like "p", but adjust indent to current line
216a219,222
> ga			print ascii value of character under the cursor (vi:
> 			not)
> gf			edit file name under the cursor (vi: not)
> gg		1	cursor to line N, default first line (vi: not)
218d223
< gf			edit file name under the cursor
260c265,266
< <HELP>			show the file vim:vim.hlp page by page (vi: no help)
---
> <HELP>			open a new window on the file vim:vim_help.txt (vi: no
> 				help)
275a282,283
> "Completion" below refers to context-sensitive completion.  It will complete
> filenames, tags, commands etc as appropriate.
278,279c286,287
< ^A		do filename completion on the pattern in front of the cursor
< 		and insert all matches
---
> ^A		do completion on the pattern in front of the cursor and
> 		insert all matches
281c289
< ^D		list filenames that match the pattern in front of the cursor
---
> ^D		list completions that match the pattern in front of the cursor
284,286c292,294
< ^L		do filename completion on the pattern in front of the cursor
< 		and insert the longest common part
< ^N		after an <ESC> with multiple matches: go to next match
---
> ^L		do completion on the pattern in front of the cursor and
> 		insert the longest common part
> ^N		after using 'wildchar' with multiple matches: go to next match
288,289c296,297
< ^P		after an <ESC> with multiple matches: go to previous match
< 		otherwise: same as <C_UP>
---
> ^P		after using 'wildchar' with multiple matches: go to previous
> 		match otherwise: same as <C_UP>
295c303
< 		do filename completion on the pattern in front of the cursor
---
> 		do completion on the pattern in front of the cursor
Index: ./doc/vim_mac.txt
diff -r ../vim.orig/doc/vim_mac.txt ./doc/vim_mac.txt
0a1,409
> *vim_mac.txt*
> 
> VIM Release Notes
> Initial Macintosh release, VIM version 3.0
> 19 October 1994
> 
> Eric Fischer
> enf1@midway.uchicago.edu, eric@jcp.uchicago.edu, etaoin@uchicago.edu
> 5759 N. Guilford Ave
> Indianapolis IN 46220 USA
> 
> 
> 
> I've tried to test Vim under as many conditions as possible, but
> there are certainly bugs and incompatibilities which still exist.
> If it doesn't work on your machine, sorry...  but if you'll let
> me know what's wrong with it, I'll try to fix it.
> 
> Vim has been verified to perform at least its most basic of functions
> on Quadras 650 and 660AV, PowerMac 6100, and Macintosh IIci, all under
> System 7.5.  It also definitely works on my Quadra 605 (System 7.1,
> virtual memory enabled).
> 
> It has been verified NOT to perform its most basic of functions on
> my roommate's Mac Plus (System 6, no hard disk).  The editor actually
> worked -- it was just saving and loading files that broke (see below).
> 
> See the file uganda.txt for Bram Moolenaar's requests with regard to
> redistributing Vim.  Since Think C was used to compile the Mac version,
> Symantec copyright applies to the standard libraries included as part
> of this distribution.
> 
> I hope that if you give copies to other people you'll include this
> file so that people will know why the Mac version works the way it
> does and so they can get bug reports and such back to me.
> 
> Thanks to Alain Roy and Corey Liss for beta testing.
> 
> 
> Vim Doesn't Run Right Under System 6
> --- ------- --- ----- ----- ------ -
> 
> I don't know why, though.  You can edit text, but you can't load or
> save it.  It does, however, feature the most informative system bomb
> dialog I've ever seen in all my days of Macintosh use: when you do
> a command that would open a Standard File dialog box, it bombs and
> tells you that the trap is missing, which it is in System 6.  Quite
> a refreshing change from the usual meaningless "The application
> ``unknown'' has unexpectedly quit with an error of type 1"...
> 
> Feel free to try it with System 5 or System 4 and tell me how it goes,
> though I have no great hopes...  Pre-HFS Systems I think are definitely
> a lost cause.
> 
> 
> 
> Since Vim was originally written to operate on computers very different
> from Macintoshes, there are some changes from the "traditional" behavior
> that you should be aware of.
> 
> File System Support
> ---- ------ -------
> 
> One really majorly different thing about the Macintosh and Unix systems
> is the way the file systems work.  Both are nominally hierarchical systems,
> but while Unix does everything by directory names, the Mac system software
> prefers to refer to disks and directories by reference number.
> 
> Since Vim needs to be able to use ordinary text strings to refer to files,
> instead of the Macintosh FSSpec data structure, a compromise is made:
> whenever a file is selected in a Macintosh-style way (with the OpenI,
> InsertI, or Save AsI menu items), the FSSpec returned to the program is
> converted into a text string, and when a file is written or read, the text
> string that Vim uses for the name is turned back into an FSSpec.
> 
> In the earliest versions (about a week ago) this was done by searching the
> directory tree for each parent folder of the one you're interested in and
> returning a stream of folder names, for instance
> 
>    disk:Desktop Folder:vim D:doc:mac documentation
> 
> or whatever.  For short paths, this works great.  For long paths, it's
> a real problem, because several of the Mac file system routines are
> limited to strings 63 characters long.  Back to the drawing board...
> 
> What Vim does now is to take the numerical fields that are part of the
> FSSpec structure and convert them into ASCII format so that they can be
> passed to the Unixy parts of Vim, then convert them directly back to
> FSSpecs when saving Macintosh files, without going through the entire
> directory structure.  So the file mentioned above would be referred to
> (on my Mac) as
> 
>    -1:6193:mac documentation
> 
> where -1 is the volume number (it's drive number one) and 6193 is the
> folder number (I guess this means the 6193rd folder on my hard drive).
> It's kinda ugly, but it *works*, which is more important, in my
> humble opinion.
> 
> Special directories
> ------- -----------
> 
> There are also a few special-purpose directories defined for the sake
> of easy access to special files.  "s:" is defined as meaning the
> Preferences folder on your startup disk (s stands for System), and
> "t:" the Temporary Items folder, where Vim's swap files are stored
> when memory gets low.  You can use these if you want, though there's
> not really much reason to except for quick access to your _exrc
> file (s:_exrc).
> 
> If you chance to specify a filename without a path, the ordinary Mac
> file system search path takes effect.  This essentially means that
> for *reading* files it will find them in the directory from which you
> launched Vim or in your System Folder, while for *writing* them they'll
> turn up in the folder you launched Vim from.
> 
> File conversion
> ---- ----------
> 
> There's one other substantial difference between the way Unix handles
> files and the way the Macintosh does: on Unix, control-J is the newline
> character, while on the Mac, the character is control-M.  In Vim, this
> conversion is handled transparently whenever you save a file: any ^M
> characters in your file are turned into ^Js, and the newlines end up
> as Mac carriage returns.  The same thing happens, in reverse, when
> you open a file: all the ^Ms in the file become newlines in the editor,
> and all the ^Js in the file show up as ^Ms which will be turned back
> into ^Js when you save.  Ordinary text, including Mac special characters,
> passes through unscathed.
> 
> The only time this makes much of a difference in practice is in files
> of Vim macros.  If there are any references to ^M in the macro (for
> instance to end a : command or search, or to remap the action of the
> Return key) this will be saved in the file as ^J.  If you then copy
> the file in "text mode" by FTP to another variety of computer, you
> stand a good chance of both ^J *and* ^M ending up as whatever the
> destination computer's newline character is, screwing up the 
> functioning of your macro.  It's not something you need to worry
> about much, but something you should be aware of.
> 
> 
> Macintosh Menus
> --------- -----
> 
> In order to make this a usable Macintosh program, Vim has to support
> the basic menus that Mac programs are supposed to have.  I'll describe
> them in order:
> 
>     Apple menu
>         About VimI
>             This puts up a dialog box telling Bram Moolenaar's and my
>             e-mail addresses.
> 
>         HelpI
>             This executes the Vim command, :help.  See below for the
>             help file information.
> 
>     File menu
>         New Subwindow
>             This opens a new window inside the Vim window, in which
>             you can edit text or do whatever you'd do in a full-screen
>             vi.  See windows.doc for more information about how Vim
>             does windows; this command does Control-W n.
> 
>         OpenI
>             Puts up a Macintosh file selector dialog.  If you don't
>             cancel, types :new <filename> to edit your file.
> 
>         Open in the Same SubwindowI
>             Does the same as OpenI, but types :vi <filename> instead.
> 
>         InsertI
>             Yet another file-opening dialog; this one does :r.
> 
>         Close
>             Types :q, which closes the current window, leaving the
>             others intact.
> 
>         Save
>             Types :w.
> 
>         Save A Copy AsI
>             Puts up a Macintosh dialog for saving files, then, if it's
>             not cancelled, types :w! <filename>
> 
>         Quit
>             Types :qall.
> 
>     Edit menu
>         Undo
>             Types u
> 
>         Redo
>             Types Control-R
> 
>         Previous Subwindow
>             Types Control-W k
> 
>         Next Subwindow
>             Types Control-W j
> 
>     Font and Size menus
>         do what you'd expect them to do.
> 
> Most of these commands also type Escape before doing their job, to ensure
> that you're not inserting text or typing a search or : command on the
> bottom of the screen when they execute.  Until you press a key, beeps
> (either real or visual) are disabled so that you don't get the speaker
> beeping or the window flashing every time you use a menu item.
> 
> Vim responds to Open Apple Events with :vi <filename> for the first file,
> :new <filename> for the rest.  It responds to a Quit Apple Event with :qall.
> 
> Mouse use
> ----- ---
> 
> The mouse gets to be used for a bit more than just selecting from menus,
> too.  One job it has is resizing the Vim window, which happens when you
> drag on the lower-right corner of the window.  It works just like a
> regular Macintosh grow box, but it's not visible.  A gross violation of
> Human Interface Guidelines, of course, but so is the general way vi
> works...
> 
> The mouse can also be used to move the cursor inside the window.  This
> doesn't work quite as well as I'd like, because the up arrow and down
> arrow move by *file* line instead of by *screen* line, but it does a
> pretty good job.  And (as suggested by Alain Roy), if you click where
> the cursor already is and start dragging, the Vim visual select mode
> (the v command) is turned on and the region you drag through is selected
> for use by any of the visual mode commands.  Clicking again removes the
> selection and moves the cursor toward where you clicked.
> 
> The cursor movement, by the way, is not instantaneous -- you need to hold
> down the button for a small fraction of a second until the cursor gets
> there.  This has the useful side effect that you can click the mouse
> button and then move above or below the edge of the window and have a
> scrolling selection just like any other Mac program.  Not as fast as
> using the paging keys, but nice for quickly looking through a file.
> 
> Macintosh Keys
> --------- ----
> 
> Currently the Mac arrow keys *are* supported in Vim but the other movement
> keys (Help, Forward Delete, Home, End, Page Up, Page Down) and the
> function keys on the top row are *not*.  A future release should remedy
> this, I hope.  There isn't really any support for old Macs that don't
> have Escape and Control keys, either, though the Control-C that the
> Enter key sends can usually be used in place of Escape.
> 
> The usual Option-key combinations can be used to type Macintosh special
> high-ASCII characters.  If you want all of them to appear normally on
> the screen, make sure to :set graphic, because otherwise Vim will assume
> some of them to be control characters instead of actual real ones and
> display them as ~@, ~A, ..., ~Z instead of what they really should be.
> 
> Fonts and Sizes
> ----- --- -----
> 
> Vim has fairly minimal support for changing fonts and sizes.  The default
> is Monaco-9, but you can select your favorite font and size from the menus.
> Monospaced fonts all work fine, but proportional ones will probably look
> a bit bizarre, since almost all your letters, numbers, and symbols will
> certainly be either wider or narrower than the space they have been
> allotted.  Proportional text is also considerably slower than monospaced,
> since Vim must move to *each* character position and draw a single character
> rather than spewing out a full line in one fell swoop as it can do with
> monospaced type.  But if you want to edit in Zapf Chancery 36, you can do
> it...
> 
> If you don't like Monaco-9 (who does?), you can set a font and size that
> you do like in your _exrc file (see below).  You can also do it from
> the : command line if you really want to.  Mac Vim, since it only supports
> the computer console, uses the term variable to set the font and size,
> so, for instance you could set the font and size to Helvetica 17 with
> 
>    :set term=helvetica
>    :set term=17
> 
> The font and size menus aren't done very carefully and don't have the check
> marks and outlining a proper Mac program should put on them.  Also, if you
> have a font named "17" (or any other number) it'll be misinterpreted as a
> size instead.
> 
> The window size can also be set from the keyboard, for instance if you
> want a different default than the standard 80x25 one.  You could set
> it to 90x10 with
> 
>   :set lines=10
>   :set rows=90
> 
> or whatever other numbers you enjoy.
> 
> 
> System Files
> ------ -----
> 
> Vim is pretty much self-contained.  There are only two instances where
> it absolutely needs an external support file: to get configuration 
> information at startup, and to get the help file.  It also uses files
> for virtual memory and backups while editing files.
> 
> The search path for startup files goes as follows:
> 
>    s:_vimrc
>    s:_exrc
>    _vimrc  (if :set exrc)
>    _exrc   (if :set exrc)
> 
> This means that first it looks in the Preferences folder for first _vimrc
> and then _exrc, then in the Vim startup folder for the same.  The reason
> there are both _vimrc and _exrc files is because on a Unix system you
> might want different configuration settings for Vim and Ex, and Ex will
> ignore the .vimrc, and Vim the .exrc (if there's a .vimrc).  There's no
> Ex on the Macintosh, but you can still use its name if you want.  I've
> enclosed a sample _exrc that sets Vim to work the way I want it to,
> but feel free not to use it.
> 
> The other file Vim needs is called vim_help.txt, and is just referred to as
> vim_help.txt, with no pathname at all.  This means that you can keep it
> either in your Vim startup folder or in your System Folder.  It
> won't be found in the Prefences folder, though.  The vim_help.txt file is
> used by the :help command and the HelpI menu item.
> 
> While you're editing files, Vim creates swap files called <filename>_swp
> in your Temporary Items directory.  These are used to allow you to make
> more changes to files than would reasonably fit in memory and still allow
> lots of undos.  If you prefer your swap files to go somewhere else, you
> can :set directory= the directory where you want them to go (make sure
> to include a '>' at the start of the name to force it there) or set
> it to null to make the swap files go in the same directory as the file
> you're editing.
> 
> Vim also creates backup files for files you save, by default.  If you
> don't like this, :set nobackup and it'll stop cluttering up your
> directories with backup files.  Probably a future version should make
> the word "bak" (or whatever) go at the start of the name instead of
> the end, because none of the Finder views are especially useful for
> selecting all the files that *end* with a particular string.
> 
> 
> What Vim Doesn't Do
> ---- --- ------- --
> 
> The Mac port doesn't support printing, pipes to external filters, filename
> globbing, filename completion in : commands, or external shells.  It also
> doesn't support proper Mac-style Copy and Paste.  All of these go on the
> Maybe Someday list.
> 
> There's no mapping of another key to Control to support those old Macs
> without Control keys.  The Enter key sends a Control-C and can usually
> be used in place of Escape, though.
> 
> Vim's digraph feature isn't supported.  You'll have to use the usual
> Mac option-keys to type extended ASCII characters.  :set graphic
> if you want them to all show up properly.
> 
> A major problem is that the Mac interface doesn't really have a clue
> about any of the internal data structures, mostly because #I# don't
> have much of a clue about the internal data structures.  Almost everything
> that the Mac interface does is by faking keystrokes to the parts of
> Vim that do the real work.  This is functional, but probably the wrong
> way to go about things in the long run.
> 
> A more pressing problem is that Vim is, at its heart, not a Macintosh
> program.  It allocates all its memory with malloc(), not NewHandle(),
> so when memory gets low, there's not much it can do.  Fortunately, the
> swapping is smart enough that memory doesn't get too badly fragmented,
> but if you do really large deletes and pastes, it's possible that Vim
> will fill up its partition and be unable to continue.
> 
> As the MS-DOS documentation puts it,
> > A swap file is used to store most of the text. You should be able to edit
> > very large files. However, memory is used for undo and other things. If you
> > delete a lot of text you can still run out of memory.
> > 
> > If Vim gives an "Out of memory" warning you should stop editing. Result of
> > further editing actions is unpredictable. Setting 'undolevels' to 0 saves
> > some memory. Running the maze macros on a big maze is guaranteed to run out
> > of memory, because each change is remembered for undo. In this case set
> > 'undolevels' to a negative number. This will switch off undo completely. In
> > a future release extended memory will be used to avoid these problems.
> 
> Things to Do, Someday
> ------ -- --- -------
> 
> Clipboard conversion, Vim <-> Mac
> Printing
> New malloc() and free() that can use MultiFinder temporary memory when the real
>     stuff gets low
> Filename completion and globbing, support for :set path
> Better Font and Size menus
> Add an option to put the backup files in the Trash instead of in the
>     folder which they're backing up
> 
> Things to Do, probably not for a very long time
> ------ -- --- -------- --- --- - ---- ---- ----
> 
> Shell escapes and filters
> Either much more Mac-like or much more Unix-like file system model
> 
> 
> What's the Icon Supposed To Be?
> ------ --- ---- -------- -- ---
> 
> It's supposed to look like an ADDS Viewpoint, the kind of terminals they
> had for the Prime minicomputer at my high school.  On second thought,
> though, the keyboard bears a remarkable resemblance to the old Timex-
> Sinclair 1000 (I think it's the lack of a space bar in the picture that
> does it), so maybe that had some sublimnal influence.
Index: ./doc/vim_nt.txt
diff -r ../vim.orig/doc/vim_nt.txt ./doc/vim_nt.txt
0a1,2
> *vim_nt.txt*
> 
Index: ./doc/vim_ref.txt
diff -r ../vim.orig/doc/vim_ref.txt ./doc/vim_ref.txt
0a1
> *vim_ref.txt*
3d3
< 
8c8
< 				version 3.6
---
> 				version 3.9
14c14
< separate document: windows.doc
---
> separate document: See |vim_win.txt|
17,20c17,20
< cursor on an item name between bars (e.g. |intro|) or quotes (e.g.
< `textwidth`) and hit CTRL-]. Special characters in the names of the tags are
< not allowed, therefore they have been replaced by letters, e.g. "ctrl_e" for
< CTRL-E, "star" for "*".
---
> cursor on an item name between bars (e.g. |intro|) or an option name in
> quotes (e.g.  'textwidth' ) and hit CTRL-]. Some special characters in the
> names of the tags are not allowed, therefore they have been replaced by
> letters: "bar for "|", "star" for "*".
22,25c22,26
< 	Normal			nothing		"x"
< 	Command line		"c_"		"c_quit"
< 	Insert mode		"i_"		"i_esc"
< 	Command line editing	"e_"		"e_del"
---
> 	Normal and Visual	nothing		|x|
> 	Visual			"v_"		|v_u|
> 	Command line		":"		|:quit|
> 	Insert mode		"i_"		|i_<ESC>|
> 	Command line editing	"e_"		|e_<DEL>|
39,40c40
< curly braces. Read the file "difference.doc" for a summary of the 
< differences.
---
> curly braces. See |vim_diff.txt| for a summary of the differences.
43,50c43,62
< computers and on terminals there may be small differences. For MSDOS this 
< is documented in msdos.doc. For UNIX this is in unix.doc.
< 
< This manual is a reference for all the Vim commands and options. A basic
< knowledge of "Vi" is assumed. A summary of this manual can be found in the 
< file vim.hlp. It can be accessed from within Vim with the <HELP> key (in 
< MSDOS <F1>) and with the command ":help". The 'helpfile' option can be 
< set to the name of the help file, so you can put it in any place you like.
---
> computers and on terminals there may be small differences. Besides the
> remarks given in this document there is a separate document for each
> supported system:
> 	system		    see
> 	Amiga		|vim_ami.txt|
> 	Archimedes	|vim_arch.txt|
> 	Macintosh	|vim_mac.txt|
> 	MS-DOS		|vim_dos.txt|
> 	Unix		|vim_unix.txt|
> 	Windows-NT	|vim_nt.txt|
> 
> This manual is a reference for all the Vim commands and options. This is not
> an introduction to the use of Vim. There are books that contain an
> introduction to Vi.
> 
> A summary of this manual can be found in the file "vim_help.txt"
> |vim_help.txt|. It can be accessed from within Vim with the <HELP> key (in
> MSDOS <F1>) and with the command ":help" |:help|. The 'helpfile' option can
> be set to the name of the help file, so you can put it in any place you
> like.
165c177
< 	vim file
---
> 	vim file					*cl_vim*
174a187
> 							*cl_file*
178a192
> 							*cl_tag*
186a201
> 							*cl_qf*
196a212
> 							*cl_+*
200a217
> 							*cl_+/*
206c223
< +{command}
---
> +{command}						*cl_+c*
212a230
> 							*cl_r*
218,229c236,249
< -v		View mode. The 'readonly' option will be set and no 
< 		swap file will be written (see -n below). You can 
< 		still edit the buffer, but will be prevented from 
< 		accidentally overwriting a file. If you forgot that you are 
< 		in View mode and did make some changes, you can overwrite 
< 		a file by adding an exclamation mark to the Ex command, as in 
< 		":w!". The 'readonly' option can be reset with ":set noro" 
< 		(see the options chapter |options|). Calling the executable
< 		"view" has the same effect as the -v option. If your system
< 		does not support links and you do not want to have the
< 		executable twice you could make an alias: "alias view vim
< 		-v".
---
> 							*cl_v*
> -v		View mode. The 'readonly' option will be set for all the
> 		files being edited.  You can still edit the buffer, but will
> 		be prevented from accidentally overwriting a file. If you
> 		forgot that you are in View mode and did make some changes,
> 		you can overwrite a file by adding an exclamation mark to
> 		the Ex command, as in ":w!". The 'readonly' option can be
> 		reset with ":set noro" (see the options chapter |options|).
> 		Calling the executable "view" has the same effect as the -v
> 		option. If your system does not support links and you do not
> 		want to have the executable twice you could make an alias:
> 		"alias view vim -v". The 'updatecount' option will be set to
> 		10000, meaning that the swap file will not be updated
> 		automatically very often.
230a251
> 							*cl_b*
236a258
> 							*cl_n*
240,242c262,263
< 		uc=0". You can switch it on again by setting the 'uc' option
< 		to some value, e.g. ":set uc=100". Any files already being
< 		edited will not be affected by this.
---
> 		updatecount=0". You can switch it on again by setting the
> 		'updatecount' option to some value, e.g. ":set uc=100".
243a265
> 							*cl_o*
249a272
> 							*cl_T*
254a278
> 							*cl_d*
260a285
> 							*cl_x*
265a291,300
> 							*cl_u*
> -u {vimrc}	The file "vimrc" is read for initializations. Other
> 		initializations are skipped, see |initialization|. This can
> 		be used to start Vim in a special mode, with special
> 		mappings and settings. A shell alias can be used to make
> 		this easy to use. For example:
> 			"alias vimc vim -u ~/.c_vimrc !*".
> 		Also consider using autocommands, see |autocommand|.
> 
> 							*cl_s*
272a308
> 							*cl_w*
352,353c388
<     not exist. The 'shellpipe' and 'shellredir' options are set according to
<     the name of the shell.
---
>     not exist.
358c393
< 3.  Four places are searched for initializations. The first that exists is 
---
> 3.  Five places are searched for initializations. The first that exists is 
360,367c395,403
<      1. The environment variable VIMINIT
<      2. The file "s:.vimrc" (for Unix: "$HOME/.vimrc")
<      3. The environment variable EXINIT
<      4. The file "s:.exrc" (for Unix: "$HOME/.exrc")
< 
< 4.  If the 'exrc' option is set (default is 'noexrc'), the current directory
<     is searched for two files. The first that exists is used, the other is
<     ignored.
---
>      1. The file given with the -u command-line option.
>      2. The environment variable VIMINIT
>      3. The file "s:.vimrc" (for Unix: "$HOME/.vimrc")
>      4. The environment variable EXINIT
>      5. The file "s:.exrc" (for Unix: "$HOME/.exrc")
> 
> 4.  If the 'exrc' option is set (default is 'noexrc'), and the -u
>     command-line option u is not used, the current directory is searched for
>     two files.  The first that exists is used, the other is ignored.
371c407,410
< 5.  If the 'viminfo' option is set to non-zero by the previous
---
> 5.  The 'shellpipe' and 'shellredir' options are set according to
>     the value of the 'shell' option, unless they have been set before.
> 
> 6.  If the 'viminfo' option is set to non-zero by the previous
397,399c436,438
< that directory. The disabled commands are the ones that start a shell and
< the ones that write to a file. The ":map" commands are echoed, so you can
< see which keys are being mapped.
---
> that directory. The disabled commands are the ones that start a shell,
> the ones that write to a file and ":autocmd". The ":map" commands are
> echoed, so you can see which keys are being mapped.
414c453
< 							*ctrl_z*
---
> 							*CTRL-Z*
419c458
< :sus[pend][!]	or				*c_suspend* *c_stop*
---
> :sus[pend][!]	or				*:suspend* *:stop*
425,428c464,467
< possible in Command mode (see next chapter |edit_modes|). Vim will continue
< if you make it the foreground job again. On other systems CTRL-Z will start
< a new shell.   This is the same as the ":sh" command. Vim will continue if
< you exit from the shell.
---
> possible in Normal and Visual mode (see next chapter |edit_modes|). Vim will
> continue if you make it the foreground job again. On other systems CTRL-Z
> will start a new shell. This is the same as the ":sh" command. Vim will
> continue if you exit from the shell.
437a477
> - Last search/substitute pattern (for 'n' and '&').
459c499,514
< type ":wv" in one and then ":rv" in the other.
---
> type ":wv" in one and then ":rv" in the other.  Note that if the register
> already contained something, then ":rv!" would be required.  Also note
> however that this means everything will be overwritten with information from
> the first vim, including the command line history etc.
> 
> The viminfo file itself can be edited by hand too, although we suggest you
> start with an existing one to get the format right.  It is reasonably
> self-explanatory once you're in there.  This can be useful in order to
> create a second file, say "~/.my_viminfo" which could contain certain
> settings that you always want when you first start vim.  For example, you
> can preload registers with particular data, or put certain commands in the
> command line history.  A line in your .vimrc file like
> "rviminfo! ~/.my_viminfo" can be used to load this information.  You could
> even have different vim-info for different types of files (eg C code) and
> load them based on the file name using the ":autocmd" command (see
> |:autocmd|).
460a516
>                            *:rviminfo*
462,463c518,520
< 			If [!] is given, registers that are already in use
< 			are overwritten. {not in Vi}
---
> 			If [!] is given, then any information that is
> 			already set (eg registers etc) will be overwritten.
> 			{not in Vi}
464a522
>                            *:wviminfo*
479c537
< Command mode		In Command mode you can enter all the editor
---
> Normal mode		In Normal mode you can enter all the editor
483a542,546
> Visual mode		This is like Normal mode, but the movement commands
> 			extend a highlighted area. When a non-movement
> 			command is used it is executed for the highlighted
> 			area. See |visual_mode|.
> 
488a552,558
> Command_line mode	In Command_line mode you can enter one line of text
> 			at the bottom of the window. This is for the Ex
> 			commands <:>, the pattern search commands <?></> and
> 			the filter command <!>.
> 
> There is one additional mode:
> 
497,502c567
< Command_line mode	In Command_line mode you can enter one line of text
< 			at the bottom of the window. This is for the Ex
< 			commands <:>, the pattern search commands <?></> and
< 			the filter command <!>.
< 
< More explanation on the insert, replace and Command_line mode is further on 
---
> More explanation on the Insert, Replace and Command_line mode is further on 
509,510c574,575
< back to Command mode by typing <ESC> twice. You will know you are back in
< Command mode when you see the screen flash or hear the bell after you type
---
> back to Normal mode by typing <ESC> twice. You will know you are back in
> Normal mode when you see the screen flash or hear the bell after you type
513c578,579
< - go from Command mode to Insert mode by giving one of the commands
---
> - go from Normal mode to Visual mode by giving one of the commands "vV^V"
> - go from Normal mode to Insert mode by giving one of the commands
515c581
< - go from Command mode to Replace mode with the "R" command (not the "r"
---
> - go from Normal mode to Replace mode with the "R" command (not the "r"
517c583
< - go from Command mode to Command_line mode with the one of the commands
---
> - go from Normal mode to Command_line mode with the one of the commands
521c587
< - go from insert or Replace mode to Command mode with <ESC> (twice in some
---
> - go from Insert or Replace mode to Normal mode with <ESC> (twice in some
523c589,592
< - go from Command_line mode to Command mode by:
---
> - go from Visual mode to Normal mode by giving a non-movement command, which
>   causes the command to be executed, or by hitting <ESC> or 'v', which does
>   nothing.
> - go from Command_line mode to Normal mode by:
534a604,608
> - go from Insert mode to Replace mode by hitting <INSERT>.
> - go from Replace mode to Insert mode by hitting <INSERT>.
> - go from Visual mode to Command_line mode by hitting ':'. The line numbers
>   of the highlighted area will be inserted in the command line.
> 
550c624,631
< 						*i_ctrl_at*
---
> 						*i_CTRL-[* *i_<ESC>*
> <ESC> or CTRL-[	End insert or Replace mode, back to Normal mode. Finish
> 		abbreviation.
> 						*i_CTRL-C*
> CTRL-C		Quit insert mode, back to Normal mode. Do not check for
> 		abbreviations.
> 
> 						*i_CTRL-@*
553c634
< 						*i_ctrl_a*
---
> 						*i_CTRL-A*
555,570c636,638
< 						*i_ctrl_b*
< CTRL-B		Toggle the 'revins' option (B for Backwards). {not in Vi}
< 						*i_ctrl_c*
< CTRL-C		Quit insert mode, back to command mode. Do not check for
< 		abbreviations.
< 						*i_ctrl_d*
< CTRL-D		Delete one shiftwidth of indent at the start of the current 
< 		line. See also 'shiftround' option. When preceded with <^>
< 		or <0> delete all indent in the current line. With <^> the
< 		indent is restored in the next line. This is useful when
< 		inserting a label. {Vi: CTRL-D works only when used after
< 		autoindent}
< 						*i_ctrl_e*
< CTRL-E		Insert the character which is below the cursor. {not in Vi}
< 						*i_ctrl_h* *i_bs*
< CTRL-H <BS>	Delete the character before the cursor (see below). {Vi: 
---
> 
> 						*i_CTRL-H* *i_<BS>*
> <BS> or CTRL-H	Delete the character before the cursor (see below). {Vi: 
572,573c640,654
< 						*i_ctrl_i* *i_tab*
< CTRL-I <TAB>    Insert a tab. If the 'expandtab' option is on, the
---
> 						*i_<DEL>*
> <DEL>		Delete the character under the cursor. If the cursor is at
> 		the end of the line, and the 'backspace' option is non-zero,
> 		delete the newline. The next line is appended after the
> 		current one. {not in Vi}
> 						*i_CTRL-W*
> CTRL-W		Delete the word before the cursor (see below). See the 
> 		section "word motions" |word_motions| for the definition of
> 		a word.
> 						*i_CTRL-U*
> CTRL-U		Delete all entered characters in the current line (see 
> 		below).
> 
> 						*i_CTRL-I* *i_<TAB>*
> <TAB> or CTRL-I Insert a tab. If the 'expandtab' option is on, the
577,579c658,662
< 						*i_ctrl_j* *i_lf*
< CTRL-J <LF>	Begin new line.
< 						*i_ctrl_k*
---
> 						*i_CTRL-J* *i_<LF>*
> <LF> or CTRL-J	Begin new line.
> 						*i_CTRL-M* *i_<CR>*
> <CR> or CTRL-M	Begin new line.
> 						*i_CTRL-K*
582,589c665,669
< 						*i_ctrl_m* *i_cr*
< CTRL-M <CR>	Begin new line.
< CTRL-N		Find next keyword (see 4.3.7 |i_ctrl_n|). {not in Vi}
< CTRL-O		Execute one Command mode command. See below |i_ctrl_o|. {not
< 		in Vi}
< CTRL-P		Find previous keyword (see 4.3.7 |i_ctrl_p|). {not in
< 		Vi}
< CTRL-R <0-9a-z"%:>				*i_ctrl_r*
---
> 
> CTRL-N		Find next keyword (see 4.3.7 |i_CTRL-N|). {not in Vi}
> CTRL-P		Find previous keyword (see 4.3.7 |i_CTRL-P|). {not in Vi}
> 
> CTRL-R <0-9a-z"%:>				*i_CTRL-R*
599c679,680
< 						*i_ctrl_t*
---
> 
> 						*i_CTRL-T*
603,606c684,696
< 						*i_ctrl_u*
< CTRL-U		Delete all entered characters in the current line (see 
< 		below).
< 						*i_ctrl_v*
---
> 						*i_CTRL-D*
> CTRL-D		Delete one shiftwidth of indent at the start of the current 
> 		line. See also 'shiftround' option. {Vi: CTRL-D works only
> 		when used after autoindent}
> 						*i_0_CTRL-D*
> 0 CTRL-D	Delete all indent in the current line.  {Vi: CTRL-D works
> 		only when used after autoindent}
> 						*i_^_CTRL-D*
> ^ CTRL-D	Delete all indent in the current line. The indent is
> 		restored in the next line. This is useful when inserting a
> 		label. {Vi: CTRL-D works only when used after autoindent}
> 
> 						*i_CTRL-V*
608c698
< 		decimal value of a single byte (see below |i_ctrl_v_digit|.
---
> 		decimal value of a single byte (see below |i_CTRL-V_digit|.
611,614d700
< 						*i_ctrl_w*
< CTRL-W		Delete the word before the cursor (see below). See the 
< 		section "word motions" |word_motions| for the definition of
< 		a word.
617,618c703,707
< 		|i_ctrl_x| and in 4.3.7 |ins_completion|. {not in Vi}
< 						*i_ctrl_y*
---
> 		|i_CTRL-X| and in 4.3.7 |ins_completion|. {not in Vi}
> 
> 						*i_CTRL-E**
> CTRL-E		Insert the character which is below the cursor. {not in Vi}
> 						*i_CTRL-Y*
620,627c709,712
< 						*i_ctrl_l_sbracket* *i_esc*
< CTRL-[ or <ESC>	End insert or Replace mode, back to Command mode.
< 						*i_del*
< <DEL>		Delete the character under the cursor. If the cursor is at
< 		the end of the line, and the 'backspace' option is non-zero,
< 		delete the newline. The next line is appended after the
< 		current one. {not in Vi}
< 						*i_insert*
---
> 
> 						*i_CTRL-B*
> CTRL-B		Toggle the 'revins' option (B for Backwards). {not in Vi}
> 						*i_<INSERT>*
646c731
< 						*i_ctrl_v_digit*
---
> 						*i_CTRL-V_digit*
659c744
< 						*i_ctrl_x*
---
> 						*i_CTRL-X*
664c749
< 						*i_ctrl_x_ctrl_e*
---
> 						*i_CTRL-X_CTRL-E*
667c752
< 						*i_ctrl_x_ctrl_y*
---
> 						*i_CTRL-X_CTRL-Y*
681c766
< all the time, just like editors that don't have a separate Command mode. You 
---
> all the time, just like editors that don't have a separate Normal mode. You 
691,704c776,789
< <C_UP>		cursor one line up			     *i_cur_up*
< <C_DOWN>	cursor one line down			     *i_cur_down*
< <C_LEFT>	cursor one character left		     *i_cur_left*
< <C_RIGHT>	cursor one character right		     *i_cur_right*
< <SC_LEFT>	cursor one word back (like "b" command)	     *i_scur_left*
< <SC_RIGHT>	cursor one word forward (like "w" command)   *i_scur_right*
< <HOME>		cursor to first char in the line	     *i_home*
< <END>		cursor to after last char in the line	     *i_end*
< mouse-click	cursor to position of mouse click.           *i_mouse_click*
< <SC_UP>		move window one page up			     *i_scur_up*
< <PAGE_UP>	move window one page up			     *i_page_up*
< <SC_DOWN>	move window one page down		     *i_scur_down*
< <PAGE_DOWN>	move window one page down		     *i_page_down*
< CTRL-O		execute one command and return to Insert mode*i_ctrl_o*
---
> <C_UP>		cursor one line up			     *i_<C_UP>*
> <C_DOWN>	cursor one line down			     *i_<C_DOWN>*
> <C_LEFT>	cursor one character left		     *i_<C_LEFT>*
> <C_RIGHT>	cursor one character right		     *i_<C_RIGHT>*
> <SC_LEFT>	cursor one word back (like "b" command)	     *i_<SC_LEFT>*
> <SC_RIGHT>	cursor one word forward (like "w" command)   *i_<SC_RIGHT>*
> <HOME>		cursor to first char in the line	     *i_<HOME>*
> <END>		cursor to after last char in the line	     *i_<END>*
> mouse-click	cursor to position of mouse click.           *i_<MOUSE>*
> <SC_UP>		move window one page up			     *i_<SC_UP>*
> <PAGE_UP>	move window one page up			     *i_<PAGE_UP>*
> <SC_DOWN>	move window one page down		     *i_<SC_DOWN>*
> <PAGE_DOWN>	move window one page down		     *i_<PAGE_DOWN*
> CTRL-O		execute one command and return to Insert mode*i_CTRL-O*
837c922
< 							*i_ctrl_x_ctrl_l*
---
> 							*i_CTRL-X_CTRL-L*
851,852c936,937
< 							*i_ctrl_p*
< 							*i_ctrl_n*
---
> 							*i_CTRL-P*
> 							*i_CTRL-N*
917,918c1002,1003
< 							*i_ctrl_x_ctrl_g*
< CTRL-X CTRL-G		Search for the first identifier in the current and
---
> 							*i_CTRL-X_CTRL-I*
> CTRL-X CTRL-I		Search for the first identifier in the current and
922c1007
< 	CTRL-G	or
---
> 
925c1010,1013
< 			identifier.
---
> 			identifier. Note: CTRL-I is the same as TAB, which
> 			is likely to be typed after a succesful completion,
> 			therefore CTRL-I is not used for searching for the
> 			next match.
933c1021
< 						*i_ctrl_x_ctrl_r_sbracket*
---
> 						*i_CTRL-X_CTRL-]*
946c1034
< 							*i_ctrl_x_ctrl_f*
---
> 							*i_CTRL-X_CTRL-F*
965c1053
< 							*i_ctrl_x_ctrl_d*
---
> 							*i_CTRL-X_CTRL-D*
1009c1097
< 						*e_ctrl_v*
---
> 						*e_CTRL-V*
1013,1014c1101,1102
< 		way as in Insert mode (see above |i_ctrl_v|).
< 						*e_cur_left*
---
> 		way as in Insert mode (see above |i_CTRL-V|).
> 						*e_<C_LEFT>*
1016c1104
< 						*e_cur_right*
---
> 						*e_<C_RIGHT*
1018c1106
< 						*e_scur_left*
---
> 						*e_<SC_LEFT>*
1020c1108
< 						*e_scur_right*
---
> 						*e_<SC_RIGHT*
1022c1110
< CTRL-B or <HOME>				*e_ctrl_b* *e_home*
---
> CTRL-B or <HOME>				*e_CTRL-B* *e_<HOME>*
1024c1112
< CTRL-E or <END>					*e_ctrl_e* *e_end*
---
> CTRL-E or <END>					*e_CTRL-E* *e_<END>*
1027c1115
< 						*e_mouse_click*
---
> 						*e_<MOUSE>*
1030c1118
< 						*e_bs*
---
> 						*e_<BS>*
1032c1120
< 						*e_del*
---
> 						*e_<DEL>*
1035c1123
< 						*e_ctrl_w*
---
> 						*e_CTRL-W*
1037c1125
< 						*e_ctrl_u*
---
> 						*e_CTRL-U*
1042c1130
< 						*e_insert*
---
> 						*e_<INSERT>*
1046c1134
< CTRL-K {char1} {char2}				*e_ctrl_k*
---
> CTRL-K {char1} {char2}				*e_CTRL-K*
1049c1137
< 						*e_lf* *e_cr*
---
> 						*e_<LF>* *e_<CR>*
1051c1139
< 						*e_esc*
---
> 						*e_<ESC>*
1054c1142
< 						*e_ctrl_c*
---
> 						*e_CTRL-C*
1057c1145
< 						*e_cur_up*
---
> 						*e_<C_UP>*
1059c1147
< 						*e_cur_down*
---
> 						*e_<C_DOWN>*
1062c1150
< 						*e_scur_up* *e_page_up*
---
> 						*e_<SC_UP>* *e_<PAGE_UP>*
1066c1154
< 						*e_scur_down* *e_page_down*
---
> 						*e_<SC_DOWN>* *e_<PAGE_DOWN>*
1103c1191
< 							*e_ctrl_d*
---
> 							*e_CTRL-D*
1117c1205
< 							*e_ctrl_n*
---
> 							*e_CTRL-N*
1120c1208
< 							*e_ctrl_p*
---
> 							*e_CTRL-P*
1124c1212
< 							*e_ctrl_a*
---
> 							*e_CTRL-A*
1127c1215
< 							*e_ctrl_l*
---
> 							*e_CTRL-L*
1167c1255
< 							*c_quotes*
---
> 							*:"*
1176c1264
< 							*c_bar*
---
> 							*:bar*
1178,1183c1266,1274
< one line. The commands ":global", "vglobal" and  ":!" see the <|> as their
< argument, and can therefore not be followed by another command. If you want
< <|> to be included in a command, precede it with <\>. Note that this is
< confusing (inherited from vi). If you give a command with ":!" you don't
< have to use a backslash, with ":r !" you have to. And with ":g" the <|> is
< included in the command, with ":s" it is not. Examples:
---
> one line. The commands ":global", "vglobal", ":!" and "autocmd" see the <|>
> as their argument, and can therefore not be followed by another command. If
> you want <|> to be included in one of the other commands, precede it with
> <\>. Note that this is confusing (inherited from vi). If you give a command
> with ":!" you don't have to use a backslash, with ":r !" you have to. And
> with ":g" the <|> is included in the command, with ":s" it is not. There is
> one execption: With the ":map" and ":abbr" commands and friends CTRL-V needs
> to be used instead of <\>.
> Examples:
1187a1279,1280
> 	:map q 10^V|		map "q" to "10|"
> 	:map q 10\|map \ l	map "q" to "10\" and map "\" to "l"
1193c1286
< files" |c_percent| |c_pound|).
---
> files" |:%| |:#|).
1217c1310
< Line numbers may be specified with:
---
> Line numbers may be specified with:			*:range*
1263a1357
> 							*N:*
1269a1364,1367
> 							*v_:*
> {visual}:	starts a command line with the visual selected lines as a
> 		range.
> 
1412c1510
< 						*c_abbreviate*
---
> 						*:abbreviate*
1425c1523
< 						*c_unabbreviate*
---
> 						*:unabbreviate*
1428c1526
< 						*c_noreabbrev*
---
> 						*:noreabbrev*
1433c1531
< 						*c_cabbrev*
---
> 						*:cabbrev*
1437c1535
< 						*c_cunabbrev*
---
> 						*:cunabbrev*
1441c1539
< 						*c_cnoreabbrev*
---
> 						*:cnoreabbrev*
1446c1544
< 						*c_iabbrev*
---
> 						*:iabbrev*
1449c1547
< 						*c_iunabbrev*
---
> 						*:iunabbrev*
1453c1551
< 						*c_inoreabbrev*
---
> 						*:inoreabbrev*
1461c1559
< 						*c_digraphs*
---
> 						*:digraphs*
1476c1574
< There are two methods to enter digraphs:
---
> There are two methods to enter digraphs:			*i_digraph*
1489,1491c1587,1590
< The default digraphs are listed in the file digraph.doc. They are meant for 
< the Amiga character set, which is some international standard. With another 
< character set they may be illogical.
---
> The default digraphs are listed in the file "vim_digr.txt" |digraph_table|.
> There are two sets: One that is used for MS-DOS and one for the
> international standrard character set that is mostly used on Unix systems
> and the Amiga. With the wrong character set they may be illogical.
1504a1604,1695
> 4.8 Using the mouse					*using_mouse*
> 
> Currently the mouse is supported under MSDOS and Unix in an xterm terminal.
> Mouse clicks can be used to position the cursor and select the visual area.
> There are no menus.
> 
> Clicking the left mouse button causes the cursor to be positioned. If the
> click is in another window that window is made the active window. When
> editing the command line the cursor can only be positioned on the command
> line.
> 
> In Normal and Visual mode clicking the right mouse button causes the visual
> area to be extended. When clicking in a window which is editing another
> buffer, the Visual mode is stopped.
> 
> Mouse clicks can be mapped. The codes for mouse clicks are:
>      code	  mouse click		  action
>    <MOUSE>L	left button pressed	set cursor position
>    <MOUSE>l	left button released
>    <MOUSE>M	middle button pressed
>    <MOUSE>m	middle button released
>    <MOUSE>R	right button pressed	set end of visual area
>    <MOUSE>r	right button released
>    <MOUSE>P	-			set cursor position in current
> 					buffer
> 
> Note: Only one button press is recognized at a time, it is not possible to
> use two buttons at the same time.
> 
> The <MOUSE>P code is not produced by the use of the mouse. It can be used in
> a mapping to position the cursor at the coordinates of a mouse click,
> without side effects. It differs from <MOUSE>L in that it does not exit
> visual mode, there is no scrolling if the click is in the first or last line
> of the window and clicks in other buffers are ignored.
> 
> The coordinates for the click are not available. Exactly one of the existing
> mouse clicks must be used to get the coordinates. Failing to do so will
> result in further mouse clicks not to be recognized, causing the
> untranslated terminal codes from the mouse clicks to be interpreted as
> commands. Use <MOUSE>P to just position the cursor at the click.
> 
> Examples:
> 	:map <MOUSE>l	<MOUSE>L
> Use a left button release in the same way as a left button press.
> 	:map <MOUSE>M	mc<MOUSE>Px`c
> The middle mouse button is used to delete a character, without moving the
> cursor. Note that this only works correctly when clicking in the current
> window.
> 	:noremap <MOUSE>L   ms<MOUSE>Lme`sv`e
> The left mouse button is used to select a visual area, between the current
> cursor position and the position of the click. Note the use of ":noremap"
> instead of "map" to avoid a recursive mapping.
> 
> 
> 4.9 On-line help					*online_help*
> 
> <HELP>		or					*help* *:help*
> :h[elp]			Split the window and display the help file in
> 			read-only mode.  {not in Vi}
> 
> :h[elp] {subject}	Like ":help", additionally jump to the tag
> 			"subject". {not in Vi}
> 
> The help file name can be set with the 'helpfile' option. The height of the
> help window can be set with the 'helpheight' option (default 20). Jump to
> specific subjects by using tags. This can be done in two ways:
> - Use the CTRL-] command while standing on the name of a command or option.
>   This only works when the tag is an identifier.
> - use the ":ta {subject}" command. This works with all characters.
> 
> Use ":q" to close the help window.
> 
> 							*doc_files*
> All the help files should be in one directory. The files are:
> 	vim_help.txt	overview and quick reference	      |vim_help.txt|
> 	vim_idx.txt	alphabetical index of all commands    |vim_idx.txt|
> 	vim_ref.txt	reference manual (this file)	      |vim_ref.txt|
> 	vim_win.txt	reference manual for windows commands |vim_win.txt|
> 	vim_diff.txt	main differences between Vim and Vi   |vim_diff.txt|
> 	vim_digr.txt	list of available digraphs	      |vim_digr.txt|
> 	vim_tips.txt	tips on using Vim		      |vim_tips.txt|
> 
> 	vim_unix.txt	unix specific remarks		      |vim_unix.txt|
> 	vim_ami.txt	Amiga specific remarks		      |vim_ami.txt|
> 	vim_dos.txt	MS-DOS specific remarks		      |vim_dos.txt|
> 	vim_nt.txt	Windows-NT specific remarks	      |vim_nt.txt|
> 	vim_arch.txt	Archimedes specific remarks	      |vim_arch.txt|
> 	vim_mac.txt	Macintosh specific remarks	      |vim_mac.txt|
> 
> 	vim_tags	tags file for documentation
> 
> 
1527c1718
< 						*c_percent* *c_pound*
---
> 						*:%* *:#* *:%<*
1541c1732
< CTRL-G		or					*ctrl_g* *c_file*
---
> CTRL-G		or					*CTRL-G* *:file*
1552,1553c1743,1744
< :buffers
< :files
---
> :buffers						*:buffers*
> :files							*:files* *:ls*
1555c1746
< 			'windows.doc' |c_files| |c_buffers| |c_ls|. {not in
---
> 			'vim_win.txt' |:files| |:buffers| |:ls|. {not in
1560c1751
< the full path name is being used if you used the ":cd" command |c_cd|.
---
> the full path name is being used if you used the ":cd" command |:cd|.
1624c1815
< 							*c_edit*
---
> 							*:edit*
1626a1818
> 							*:edit!*
1629a1822
> 							*:edit_f*
1631a1825
> 							*:edit!_f*
1638c1832
< 							*c_ex*
---
> 							*:ex*
1641c1835
< 							*c_visual*
---
> 							*:visual*
1644c1838,1842
< 							*ctrl_hat*
---
> 							*:view*
> :vie[w] [+cmd] file	Same as :edit, but set 'readonly' option for this
> 			buffer. {not in Vi}
> 
> 							*CTRL-^*
1652,1653c1850,1851
< ]f							*r_sbracket_f*
< [f							*l_sbracket_f* *gf*
---
> ]f							*]f*
> [f							*[f* *gf*
1659c1857,1859
< 			cannot be abandoned. {not in Vi}
---
> 			cannot be abandoned. If the name is a hypertext
> 			link, that looks like "type://machine/path", only
> 			"/path" is used.  {not in Vi}
1661c1861
< 							*c_cd*
---
> 							*:cd*
1670c1870
< 							*c_chdir*
---
> 							*:chdir*
1673c1873
< 							*c_pwd*
---
> 							*:pwd*
1748c1948
< which you can see with the ":files" command |c_files|. The argument list was
---
> which you can see with the ":files" command |:files|. The argument list was
1755c1955
< 							*c_args*
---
> 							*:args*
1759c1959
< 							*c_argument*
---
> 							*:argument*
1769c1969
< 							*c_next*
---
> 							*:next*
1784c1984
< :n[ext]! [+cmd] {filelist}
---
> :n[ext]! [+cmd] {filelist}				*:next_f*
1788c1988
< :[count]N[ext] [count] [+cmd]				*c_Next*
---
> :[count]N[ext] [count] [+cmd]				*:Next*
1797c1997
< :[count]pre[vious] [count] [+cmd]			*c_previous*
---
> :[count]pre[vious] [count] [+cmd]			*:previous*
1800c2000
< 							*c_rewind*
---
> 							*:rewind*
1808c2008
< 							*c_last*
---
> 							*:last*
1816c2016
< 							*c_wnext*
---
> 							*:wnext*
1829,1830c2029,2030
< :[count]wN[ext][!] [+cmd] [file]			*c_wNext*
< :[count]wp[revous][!] [+cmd] [file]			*c_wprevious*
---
> :[count]wN[ext][!] [+cmd] [file]			*:wNext*
> :[count]wp[revous][!] [+cmd] [file]			*:wprevious*
1853c2053
< 							*c_write*
---
> 							*:write*
1855a2056
> 							*:write_f*
1861a2063
> 							*:write_a*
1867a2070
> 							*:write_c*
1876c2079
< 							*c_quit*
---
> 							*:quit*
1882c2085
< 							*c_cq*
---
> 							*:cq*
1887c2090
< 							*c_wq*
---
> 							*:wq*
1898c2101
< 							*c_xit*
---
> 							*:xit*
1902c2105
< 							*c_exit*
---
> 							*:exit*
1976c2179
< 							*c_cc*
---
> 							*:cc*
1980c2183
< 							*c_cnext*
---
> 							*:cnext*
1985c2188
< 							*c_cprevious*
---
> 							*:cprevious*
1990c2193
< 							*c_cquit*
---
> 							*:cquit*
1994c2197
< 							*c_cfile*
---
> 							*:cfile*
2002c2205
< 							*c_clist*
---
> 							*:clist*
2007c2210
< 							*c_make*
---
> 							*:make*
2080c2283
< 						*c_make_makeprg*
---
> 						*:make_makeprg*
2168,2169c2371,2372
< Note: Any <|> and <LF> in this command must be escaped by a backslash,
< otherwise it will be seen as the start of another command (see |c_bar|).
---
> Note: This command cannot be followed by another command, since any '|' is
> considered part of the command.
2171c2374
< 							*c_autocmd*
---
> 							*:autocmd*
2187c2390
< 							*c_doautocmd*
---
> 							*:doautocmd*
2269c2472
< CTRL-H		or					*ctrl_h* *bs*
---
> CTRL-H		or					*CTRL-H* *bs*
2282c2485
< 							*zero* *home*
---
> 							*0* *home*
2285c2488
< 							*hat*
---
> 							*^*
2289c2492
< 							*dollar* *end*
---
> 							*$* *end*
2314c2517
< 							*semicolon*
---
> 							*;*
2317c2520
< 							*comma*
---
> 							*,*
2329c2532
< <C_UP>		or					*cur_up* *ctrl_p*
---
> <C_UP>		or					*cur_up* *CTRL-P*
2334,2335c2537,2538
< CTRL-J		or					*ctrl_j*
< <LF>		or					*linefeed* *ctrl_n*
---
> CTRL-J		or					*CTRL-J*
> <LF>		or					*linefeed* *CTRL-N*
2338c2541
< 							*minus*
---
> 							*-*
2342,2343c2545,2546
< +		or					*plus*
< CTRL-M		or					*ctrl_m* *cr*
---
> +		or					*+*
> CTRL-M		or					*CTRL-M* *cr*
2347c2550
< 							*underscore*
---
> 							*_*
2355a2559,2563
> 							*gg*
> gg			Goto line [count], default first line, on the first
> 			non-blank character (linewise). If 'startofline' not
> 			set, keep the same column.
> 
2359c2567
< 							*count_percent*
---
> 							*N%*
2419c2627
< 							*l_paren*
---
> 							*(*
2422c2630
< 							*r_paren*
---
> 							*)*
2425c2633
< 							*l_bracket*
---
> 							*{*
2428c2636
< 							*r_bracket*
---
> 							*}*
2431c2639
< 						*r_sbracket_r_sbracket*
---
> 							*]]*
2436c2644
< 						*r_sbracket_l_sbracket*
---
> 							*][*
2440c2648
< 						*l_sbracket_l_sbracket*
---
> 							*[[*
2444c2652
< 						*l_sbracket_r_sbracket*
---
> 							*[]*
2475,2476c2683,2684
< 							*slash*
< /{pattern}[/]		Search forward for the [count]'th occurrence of
---
> 							*/*
> /{pattern}[/]<CR>	Search forward for the [count]'th occurrence of
2479c2687
< /{pattern}/{offset}	Search forward for the [count]'th occurrence of
---
> /{pattern}/{offset}<CR>	Search forward for the [count]'th occurrence of
2483c2691,2708
< /			Search forward for the [count]'th latest used
---
> 							*/<CR>*
> /<CR>			Search forward for the [count]'th latest used
> 			pattern with latest used {offset}.
> 
> //{offset}<CR>		Search forward for the [count]'th latest used
> 			pattern with new {offset}. If {offset} is empty no
> 			offset is used.
> 
> 							*?*
> ?{pattern}[?]<CR>	Search backward for the [count]'th previous
> 			occurrence of {pattern} (exclusive).
> 
> ?{pattern}?{offset}<CR>	Search backward for the [count]'th previous
> 			occurrence of {pattern} and go {offset} lines up or
> 			down (see below) (linewise).
> 
> 							*?<CR>*
> ?<CR>			Search backward for the [count]'th latest used
2486c2711
< //{offset}		Search forward for the [count]'th latest used
---
> ??{offset}<CR>		Search backward for the [count]'th latest used
2489a2715,2722
> 							*n*
> n			Repeat the latest "/" or "?" [count] times. {Vi: no
> 			count}
> 
> 							*N*
> N			Repeat the latest "/" or "?" [count] times in
> 			opposite direction. {Vi: no count}
> 
2498c2731
< 							*hatch*
---
> 							*#*
2523,2546c2756
< 							*question*
< ?{pattern}[?]		Search backward for the [count]'th previous
< 			occurrence of {pattern} (exclusive).
< 
< ?{pattern}?{offset}	Search backward for the [count]'th previous
< 			occurrence of {pattern} and go {offset} lines up or
< 			down (see below) (linewise).
< 
< ?			Search backward for the [count]'th latest used
< 			pattern with latest used {offset}.
< 
< ??{offset}		Search backward for the [count]'th latest used
< 			pattern with new {offset}. If {offset} is empty no
< 			offset is used.
< 
< 							*n*
< n			Repeat the latest "/" or "?" [count] times. {Vi: no
< 			count}
< 
< 							*N*
< N			Repeat the latest "/" or "?" [count] times in
< 			opposite direction. {Vi: no count}
< 
< 							*ctrl_c*
---
> 							*CTRL-C*
2653a2864
> 	~         \~		matches the last given substitute pattern
2704c2915
< 						*c_mark*
---
> 						*:mark*
2708c2919
< 						*c_k*
---
> 						*:k*
2712c2923
< 						*quote*
---
> 						*'*
2721c2932
< 						*backquote*
---
> 						*`*
2728,2730c2939,2946
< 						*c_marks*
< :marks			List the current marks (not a motion command). {not 
< 			in Vi}
---
> 						*:marks*
> :marks			List all the current marks (not a motion command).
> 			{not in Vi}
> 
> :marks {arg}		List the marks that are mentioned in {arg} (not a
> 			motion command). For example:
> 				:marks aB
> 			to list marks 'a' and 'B'. {not in Vi}
2754c2970
< 						*quote_l_sbracket*
---
> 						*'[*
2759c2975
< 						*backquote_l_sbracket*
---
> 						*`[*
2763c2979
< 						*quote_r_sbracket*
---
> 						*']*
2768c2984
< 						*backquote_r_sbracket*
---
> 						*`]*
2784a3001,3007
> 						*'<*
> '<			To the first non-blank character on the first line
> 			of the last selected visual area. {not in Vi}.
> 
> 						*`<*
> `<			To the first character of the last selected visual
> 			area. {not in Vi}.
2786c3009
< 						*quote_quote*
---
> 						*''*
2790c3013
< 						*backquote_backquote*
---
> 						*``*
2800c3023
< 							*ctrl_o*
---
> 							*CTRL-O*
2804c3027
< 							*ctrl_i*
---
> 							*CTRL-I*
2808c3031
< 							*c_jumps*
---
> 							*:jumps*
2866c3089
< 							*percent*
---
> 							*%*
2884c3107
< 						*l_sbracket_l_paren*
---
> 						*[(*
2887c3110
< 						*l_sbracket_l_bracket*
---
> 						*[{*
2890c3113
< 						*r_sbracket_r_paren*
---
> 						*])*
2893c3116
< 						*r_sbracket_r_bracket*
---
> 						*]}*
2931c3154
< 							*ctrl_e*
---
> 							*CTRL-E*
2934c3157
< 							*ctrl_d*
---
> 							*CTRL-D*
2941c3164
< <PAGE_DOWN>	or					*page_down* *ctrl_f*
---
> <PAGE_DOWN>	or					*page_down* *CTRL-F*
2948c3171
< 							*ctrl_y*
---
> 							*CTRL-Y*
2951c3174
< 							*ctrl_u*
---
> 							*CTRL-U*
2958c3181
< <PAGE_UP>	or					*page_up* *ctrl_b*
---
> <PAGE_UP>	or					*page_up* *CTRL-B*
2972a3196
> 							*z<CR>*
2978c3202
< 							*z_dot*
---
> 							*z.*
2987c3211
< 							*z_min*
---
> 							*z-*
3008c3232
< 							*c_tag*
---
> 							*:tag*
3013c3237
< 							*ctrl_r_sbracket*
---
> 							*CTRL-]*
3018c3242,3245
< 							*ctrl_t*
---
> 							*v_CTRL-]*
> {visual}CTRL-]		":ta" to the text that is highlighted. {not in Vi}
> 
> 							*CTRL-T*
3022c3249
< 							*c_pop*
---
> 							*:pop*
3029c3256
< 							*c_tags*
---
> 							*:tags*
3101,3105c3328,3335
< {filename}:{identifier}. In this case the identifier is only valid if the
< name of the current file matches the filename before the colon. In other
< files this identifier will be ignored. Some ctags programs make use of this
< to separate local (static) functions from global functions. (Detail: Vim
< compares only the last part of the filename and ignores any path before it).
---
> {filename}:{identifier}. Some ctags programs make use of this to separate
> local (static) functions from global functions. If this construction is
> present in the tags file, the following priority is used:
> 	1. The first matching static tag for the current file
> 	2. The first matching non-static tag
> 	3. The first matching static tag for another file
> (Detail: Vim compares only the last part of the filename and ignores any
> path before it).
3204c3434
< before continuing in the current file. Files included in included files are
---
> before continuing in the current file. Files included by included files are
3211,3213c3441,3444
< 'define' optionwill be found. The default is "\^#[ \t]*define", which is for
< C programs.  Also, when a match is found for a defined macro, the displaying
< of lines continues with the next line when a line ends in a backslash.
---
> 'define' option will be found. The default is "\^#[ \t]*define", which is
> for C programs.  Also, when a match is found for a defined macro, the
> displaying of lines continues with the next line when a line ends in a
> backslash.
3229c3460
< are ignored for the search.
---
> are ignored for the search, unless [!] is used.
3231c3462
< 							*l_sbracket_i*
---
> 							*[i*
3239c3470
< 							*r_sbracket_i*
---
> 							*]i*
3243,3244c3474,3475
< 							*c_isearch*
< :[range]is[earch][!] ident
---
> 							*:isearch*
> :[range]is[earch][!] [+] [count] pattern
3246,3247c3477,3480
< 			(default: whole file).  Without [!] only whole words
< 			are matched. {not in Vi}
---
> 			(default: whole file).  Without [!] lines that are
> 			recognized as comments are skipped. Without [+]
> 			only whole words are matched, using the pattern
> 			"\<pattern\>". {not in Vi}
3249c3482
< 							*l_sbracket_I*
---
> 							*[I*
3255c3488
< 							*r_sbracket_I*
---
> 							*]I*
3259,3260c3492,3493
< 							*c_ilist*
< :[range]il[ist][!] ident
---
> 							*:ilist*
> :[range]il[ist][!] [+] pattern
3262,3263c3495,3498
< 			(default: whole file). Without [!] only whole words
< 			are matched. {not in Vi}
---
> 			(default: whole file). Without [!] lines that are
> 			recognized as comments are skipped. Without [+]
> 			only whole words are matched, using the pattern
> 			"\<pattern\>". {not in Vi}
3265c3500
< 							*l_sbracket_ctrl_i*
---
> 							*[_CTRL-I*
3273c3508
< 							*r_sbracket_ctrl_i*
---
> 							*]_CTRL-i*
3277,3278c3512,3513
< 							*c_ijump*
< :[range]ij[ump][!] ident
---
> 							*:ijump*
> :[range]ij[ump][!] [+] [count] pattern
3281c3516,3518
< 			only whole words are matched. {not in Vi}
---
> 			lines that are recognized as comments are skipped.
> 			Without [+] only whole words are matched, using the
> 			pattern "\<pattern\>". {not in Vi}
3283,3284c3520,3521
< 							*ctrl_w_g*
< CTRL-W g		Open a new window, with the cursor on the first line
---
> CTRL-W CTRL-I					*CTRL-W_CTRL-I* *CTRL-W_i*
> CTRL-W i		Open a new window, with the cursor on the first line
3291,3292c3528,3529
< 							*c_isplit*
< :[range]isp[lit][!] ident
---
> 							*:isplit*
> :[range]isp[lit][!] [+] [count] pattern
3295c3532,3534
< 			only whole words are matched. {not in Vi}
---
> 			lines that are recognized as comments are skipped.
> 			Without [+] only whole words are matched, using the
> 			pattern "\<pattern\>". {not in Vi}
3297c3536
< 							*l_sbracket_d*
---
> 							*[d*
3300c3539,3540
< 			beginning of the file. {not in Vi}
---
> 			beginning of the file. If a count is given, the
> 			count'th matching line is displayed. {not in Vi}
3302c3542
< 							*r_sbracket_d*
---
> 							*]d*
3306,3307c3546,3547
< 							*c_dsearch*
< :[range]ds[earch][!] ident
---
> 							*:dsearch*
> :[range]ds[earch][!] [+] [count] pattern
3309,3310c3549,3552
< 			(default: whole file).  Without [!] only whole words
< 			are matched. {not in Vi}
---
> 			(default: whole file).  Without [!] lines that are
> 			recognized as comments are skipped.  Without [+]
> 			only whole words are matched, using the pattern
> 			"\<pattern\>". {not in Vi}
3312c3554
< 							*l_sbracket_D*
---
> 							*[D*
3318c3560
< 							*r_sbracket_D*
---
> 							*]D*
3322,3323c3564,3565
< 							*c_dlist*
< :[range]dl[ist][!] ident
---
> 							*:dlist*
> :[range]dl[ist][!] [+] pattern
3325,3326c3567,3570
< 			(default: whole file).  Without [!] only whole words
< 			are matched. {not in Vi}
---
> 			(default: whole file).  Without [!] lines that are
> 			recognized as comments are skipped.  Without [+]
> 			only whole words are matched, using the pattern
> 			"\<pattern\>". {not in Vi}
3328c3572
< 							*l_sbracket_ctrl-d*
---
> 							*[_CTRL-D*
3331c3575,3576
< 			the beginning of the file. {not in Vi}
---
> 			the beginning of the file. If a count is given, the
> 			count'th matching line is jumped to. {not in Vi}
3333c3578
< 							*r_sbracket_ctrl_d*
---
> 							*]_CTRL-D*
3337,3338c3582,3583
< 							*c_djump*
< :[range]dj[ump][!] ident
---
> 							*:djump*
> :[range]dj[ump][!] [+] [count] pattern
3341c3586,3588
< 			only whole words are matched. {not in Vi}
---
> 			lines that are recognized as comments are skipped.
> 			Without [+] only whole words are matched, using the
> 			pattern "\<pattern\>". {not in Vi}
3343c3590
< 							*ctrl_w_d*
---
> 							*CTRL-W_d*
3347c3594,3595
< 			beginning of the file. {not in Vi}
---
> 			beginning of the file. If a count is given, the
> 			count'th matching line is jumped to. {not in Vi}
3349,3350c3597,3598
< 							*c_dsplit*
< :[range]dsp[lit][!] ident
---
> 							*:dsplit*
> :[range]dsp[lit][!] [+] [count] pattern
3352,3353c3600,3603
< 			(default: whole file).  Without [!] only whole words
< 			are matched. {not in Vi}
---
> 			(default: whole file).  Without [!] lines that are
> 			recognized as comments are skipped.  Without [+]
> 			only whole words are matched, using the pattern
> 			"\<pattern\>". {not in Vi}
3355c3605
< 							*c_checkpath*
---
> 							*:checkpath*
3393c3643
< 							*c_read*
---
> 							*:read*
3399a3650
> 							*:read!*
3425a3677,3682
> An example on how to use ":r !":
> 	:r !uuencode binfile binfile
> This command reads "binfile", uuencodes it and reads it into the current
> buffer. Useful when you are editing e-mail and want to include a binary
> file.
> 
3429c3686
< ["x]<DEL>	or					*del* *x*
---
> ["x]<DEL>	or					*<DEL>* *x*
3459c3716
< 							*c_delete*
---
> 							*:delete*
3485c3742
< 							*c_join*
---
> 							*:join*
3584c3841,3842
< 			replace with a <NUL>.
---
> 			replace with a <NUL>. {in vi CTRL-V does not make a
> 			difference}
3591c3849
< 							*tilde*
---
> 							*~*
3600c3858,3861
< 							*v_tilde*
---
> 							*g~*
> g~{motion}		switch case of {motion} text. {Not in Vi}
> 
> 							*v_~*
3607a3869,3871
> 							*gU*
> gU{motion}		Make {motion} text uppercase. {not in Vi}
> 
3612c3876,3879
< 							*ctrl_a*
---
> 							*gu*
> gu{motion}		Make {motion} text lowercase. {not in Vi}
> 
> 							*CTRL-A*
3616c3883
< 							*ctrl_x*
---
> 							*CTRL-X*
3629a3897,3903
> For octal and hexadecimal numbers with leading zeros, the number of
> characters in the number remains equal (when possible). When doing CTRL-A on
> "0077" it becomes "0100", CTRL-X on "0x0100" becomes "0x00ff". Note that
> when there are no leading zeros this does not work, so CTRL-X on "0x100"
> results in "0xff". Note that decimal numbers with leading zeros are
> impossible, because they are recognized as octal numbers.
> 
3641,3642c3915
< 
< 							*smaller*
---
> 							*<*
3645c3918
< 							*smaller_smaller*
---
> 							*<<*
3648c3921
< 							*v_smaller*
---
> 							*v_<*
3653c3926
< 							*greater*
---
> 							*>*
3656c3929
< 							*greater_greater*
---
> 							*>>*
3659c3932
< 							*v_greater*
---
> 							*v_>*
3664c3937
< 							*c_smaller*
---
> 							*:<*
3675c3948
< 							*c_greater*
---
> 							*:>*
3711c3984
< 							*bang*
---
> 							*!*
3715c3988
< 							*bang_bang*
---
> 							*!!*
3719c3992
< 							*v_bang*
---
> 							*v_!*
3724c3997
< :{range}![!]{filter} [!][arg]				*c_bang*
---
> :{range}![!]{filter} [!][arg]				*:range!*
3733c4006
< 							*equal*
---
> 							*=*
3739c4012
< 							*equal_equal*
---
> 							*==*
3744c4017
< 							*v_equal*
---
> 							*v_=*
3761c4034
< 						*c_substitute*
---
> 						*:substitute*
3767c4040
< :[range]&[g][c][r] [count]			*c_and*
---
> :[range]&[g][c][r] [count]			*:&*
3772c4045
< :[range]~[g][c][r] [count]			*c_tilde*
---
> :[range]~[g][c][r] [count]			*:~*
3777c4050
< 						*and*
---
> 						*&*
3862c4135
< 							*c_retab*
---
> 							*:retab*
3879c4152
< :[range]ce[nter] [width]				*c_center*
---
> :[range]ce[nter] [width]				*:center*
3884c4157
< :[range]ri[ght] [width]					*c_right*
---
> :[range]ri[ght] [width]					*:right*
3889c4162
< 							*c_left*
---
> 							*:left*
3939a4213
> 							*fo_table*
3952a4227,4229
> 2	When formatting text the indent of the second line of a paragraph is
> 	used for the rest of the paragraph. This allows for paragraphs with
> 	a different indent for the first line.
3991c4268
< 							*double_quote*
---
> 							*"*
3996,3998c4273,4280
< 							*c_display*
< :di[splay]		Display the contents of numbered and named registers.
< 			{Vi: no such command}
---
> 							*:display*
> :di[splay]		Display the contents of all numbered and named
> 			registers.  {not in Vi}
> 
> :di[splay] {arg}	Display the contents of the numbered and named
> 			registers that are mentioned in {arg}. For example:
> 				:dis 1a
> 			to display registers '1' and 'a'. {not in Vi}
4020c4302
< 							*c_yank*
---
> 							*:yank*
4036c4318
< 							*c_put*
---
> 							*:put*
4043c4325
< 							*r_sbracket_p*
---
> 							*]p*
4047,4048c4329,4330
< ["x][P		or					*l_sbracket_P*
< ["x]]P		or			*r_sbracket_P* *l_sbracket_p*
---
> ["x][P		or					*[P*
> ["x]]P		or					*]P* *[p*
4124c4406
< :[range]co[py] {address}				*c_copy*
---
> :[range]co[py] {address}				*:copy*
4128c4410
< 							*c_t*
---
> 							*:t*
4131c4413
< :[range]m[ove] {address}				*c_move*
---
> :[range]m[ove] {address}				*:move*
4148c4430
< 							*ctrl_v*
---
> 							*CTRL-V*
4208,4211c4490,4494
< If you use ESC, click the left mouse button or use any command that does a
< jump to another buffer while in Visual mode, the highlighting stops and no
< text is affected.  If you hit CTRL-Z the highlighting stops and the editor
< is suspended or a new shell is started |ctrl_z|.
---
> 							*v_v*
> If you use ESC, 'v', click the left mouse button or use any command that
> does a jump to another buffer while in Visual mode, the highlighting stops
> and no text is affected.  If you hit CTRL-Z the highlighting stops and the
> editor is suspended or a new shell is started |CTRL-Z|.
4218c4501
< If visual mode is not active and the "v", "V" or CTRL-V is preceded with a
---
> If Visual mode is not active and the "v", "V" or CTRL-V is preceded with a
4239,4242c4522,4525
< 	>	shift right (1)(*)				|v_greater|
< 	<	shift left (1)(*)				|v_smaller|
< 	!	filter through external command (1)		|v_bang|
< 	=	filter through 'equalprg' option command (1)	|v_equal|
---
> 	>	shift right (1)(*)				|v_>|
> 	<	shift left (1)(*)				|v_<|
> 	!	filter through external command (1)		|v_!|
> 	=	filter through 'equalprg' option command (1)	|v_=|
4246c4529,4532
< 	:	start ex command for highlighted lines (1)	|v_colon|
---
> 	v	stop visual mode
> 	V	switch between normal and linewise visual mode	*v_V*
> 	CTRL-V	switch between normal and blockwise visual mode	*v_CTRL-V*
> 	:	start ex command for highlighted lines (1)	|v_:|
4258a4545
> 	^]	find tag
4264a4552,4554
> Note that the ":vmap" command can be used to specifically map keys in Visual
> mode.
> 
4285c4575
< 							*ctrl_l*
---
> 							*CTRL-L*
4288,4297d4577
< <HELP>		or					*help* *c_help*
< :h[elp]			Show the help file page by page. The help file name 
< 			can be set with the 'helpfile' option. Type an index
< 			character to go directly to a page. Type <SPACE> or
< 			CTRL-F (with MSDOS: page-down) to go one page
< 			forward. Type <b> or CTRL-B (with MSDOS: page-up) to
< 			go one page back. Type <a> to go back to the index.
< 			Type <CR> to get out of the help screen. {Vi: no
< 			help}
< 
4304c4584,4591
< 							*c_print*
---
> :ascii		or					*ga* *:ascii*
> ga			Print the ascii value of the character under the
> 			cursor in decimal, hexadecimal and octal. For
> 			example, when the cursor is on a 'R':
> 				<R>  82,  Hex 52,  Octal 122
> 			{not in vi}
> 
> 							*:print*
4311c4598
< 							*c_list*
---
> 							*:list*
4316c4603
< 							*c_number*
---
> 							*:number*
4321c4608
< 							*c_hatch*
---
> 							*:#*
4324c4611
< 							*c_equal*
---
> 							*:=*
4327c4614
< 							*c_shell*
---
> 							*:shell*
4330c4617
< 							*c_bang*
---
> 							*:!*
4336c4623
< 							*c_version*
---
> 							*:version*
4356c4643
< 							*c_sleep*
---
> 							*:sleep*
4365a4653
> 							*.*
4377c4665
< 							*c_global*
---
> 							*:global*
4418c4706
< 							*at*
---
> 							*@*
4422c4710
< 							*at_colon*
---
> 							*@:*
4425c4713
< 							*at_at*
---
> 							*@@*
4428c4716
< 							*c_at*
---
> 							*:@*
4438c4726
< 							*c_at_at*
---
> 							*:@@*
4443c4731
< 							*c_source*
---
> 							*:source*
4496c4784
< 							*c_undo*
---
> 							*:undo*
4499c4787
< 							*ctrl_r*
---
> 							*CTRL-R*
4503c4791
< 							*c_redo*
---
> 							*:redo*
4552,4553c4840,4842
< 							*c_map*
< :map {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Command mode.
---
> 							*:map*
> :map {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Normal and
> 			Visual mode.
4554a4844
> 							*:map!*
4558,4560c4848,4851
< 							*c_noremap*
< :noremap {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Command mode. 
< 			Disallow remapping of {rhs}. {not in Vi}
---
> 							*:noremap*
> :no[remap] {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in Normal and
> 			Visual mode. Disallow remapping of {rhs}. {not in
> 			Vi}
4562c4853
< :noremap! {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in insert and
---
> :no[remap]! {lhs} {rhs}	Map the key sequence {lhs} to {rhs} in insert and
4566,4567c4857,4859
< 							*c_unmap*
< :unm[ap] {lhs}		Remove the mapping of {lhs} for Command mode.
---
> 							*:unmap*
> :unm[ap] {lhs}		Remove the mapping of {lhs} for Normal and Visual
> 			mode.
4568a4861
> 							*:unmap!*
4572c4865
< :map			List all key mappings for Command mode.
---
> :map			List all key mappings for Normal and Visual mode.
4576a4870
> 							*:map_l*
4578c4872
< 			with {lhs} in Command mode. {not in Vi}
---
> 			with {lhs} in Normal and Visual mode. {not in Vi}
4579a4874
> 							*:map_l!*
4583,4584c4878,4903
< 							*c_cmap*
< :cm[ap]			Same as :map, but for Command_line mode only. {not
---
> 							*:nmap*
> :nm[ap]			Same as :map, but for Normal mode only. {not
> 			in Vi}
> 
> 							*:nunmap*
> :nun[map]		Same as :unmap, but for Normal mode only.
> 			{not in Vi}
> 
> 							*:nnoremap*
> :nn[oremap]		Same as :noremap, but for Normal mode only.
> 			{not in Vi}
> 
> 							*:vmap*
> :vm[ap]			Same as :map, but for Visual mode only. {not
> 			in Vi}
> 
> 							*:vunmap*
> :vu[nmap]		Same as :unmap, but for Visual mode only.
> 			{not in Vi}
> 
> 							*:vnoremap*
> :vn[oremap]		Same as :noremap, but for Visual mode only.
> 			{not in Vi}
> 
> 							*:cmap*
> :cm[ap]			Same as :map!, but for Command_line mode only. {not
4587,4588c4906,4907
< 							*c_cunmap*
< :cu[nmap]		Same as :unmap, but for Command_line mode only.
---
> 							*:cunmap*
> :cu[nmap]		Same as :unmap!, but for Command_line mode only.
4591,4592c4910,4911
< 							*c_cnoremap*
< :cno[remap]		Same as :noremap, but for Command_line mode only.
---
> 							*:cnoremap*
> :cno[remap]		Same as :noremap!, but for Command_line mode only.
4595,4596c4914,4915
< 							*c_imap*
< :im[ap]			Same as :map, but for Insert mode only. {not in Vi}
---
> 							*:imap*
> :im[ap]			Same as :map!, but for Insert mode only. {not in Vi}
4598,4599c4917,4918
< 							*c_iunmap*
< :iu[nmap]		Same as :unmap, but for Insert mode only. {not in
---
> 							*:iunmap*
> :iu[nmap]		Same as :unmap!, but for Insert mode only. {not in
4602,4603c4921,4922
< 							*c_inoremap*
< :ino[remap]		Same as :noremap, but for Insert mode only. {not in
---
> 							*:inoremap*
> :ino[remap]		Same as :noremap!, but for Insert mode only. {not in
4611c4930
< There are three sets of mappings
---
> There are four sets of mappings
4614c4933,4948
< - For Command mode: When typing commands.
---
> - For Normal mode: When typing commands.
> - For Visual mode: When typing commands while the visual area is highlighted.
> 
> The original vi did not have separate mappings for Normal/Visual mode and
> Insert/Command_line mode. Therefore the ":map" and ":map!" commands enter
> and display mappings for both. In Vim you can use the ":nmap", "vmap",
> ":cmap" and ":imap" commands to enter mappings for each mode separately.
> When listing mappings the character in column 1 is
> 
> 	char		mode
> 	<SPACE>		Normal and Visual
> 	 n		Normal
> 	 v		Visual
> 	 !		Insert and Command_line
> 	 i		Insert
> 	 c		Command_line
4616,4622c4950,4951
< The original vi did not have separate mappings for Insert mode and
< Command_line mode. Therefore the ":map!" command enters and displays
< mappings for both. In Vim you can use the ":cmap" and ":imap" commands to
< enter mappings for each mode separately. When listing mappings with ":map!",
< ":cmap" or ":imap" the character in column 1 is <!> for mappings in both
< Insert and Command_line mode, <i> for Insert mode only and <c> for
< Command_line mode only.
---
> Note: When using mappings for Visual mode, you can use the '<' mark, which
> is the start of the last selected visual area |'<|.
4680,4682c5009,5013
< This will exchange the cursor up and down commands. With the normal :map 
< command, when the 'remap' option is set, mapping takes place until the text 
< is found not to be a part of a {lhs}. For example, if you use:
---
> This will exchange the cursor up and down commands.
> 
> With the normal :map command, when the 'remap' option is set, mapping takes
> place until the text is found not to be a part of a {lhs}. For example, if
> you use:
4685,4686c5016,5018
< Vim will replace x by y, and then y by x, etc. When this has happened 1000 
< times, Vim will give an error message.
---
> Vim will replace x by y, and then y by x, etc. When this has happened
> 'maxmapdepth' times (default 1000), Vim will give the error message
> "recursive mapping".
4706c5038
<    the form "#1", "#2", .. "#9", "#0", "<C_UP>", "<SC_DOWN>", "<SF_7>", etc.
---
>    the form "#1", "#2", .. "#9", "#0", "<C_UP>", "<SC_DOWN>", "<SF7>", etc.
4709c5041
<    "#2", and with "<F_>", like "<F_2>". Both stand for function key 2. "#0"
---
>    "#2", and with "<F>", like "<F2>". Both stand for function key 2. "#0"
4744c5076
< 	:sw[apname]					*c_swapname*
---
> 	:sw[apname]					*:swapname*
4786,4788c5118,5122
< with the "-n" or "-v" option. Writing can be switched back on by setting the 
< 'updatecount' option to non-zero. But this will only affect files that will
< be opened after this.
---
> with the "-n" option. Writing can be switched back on by setting the
> 'updatecount' option to non-zero. Swap files will be created for all buffers
> when doing this. But when setting 'updatecount' to zero, the existing swap
> files will not be removed, it will only affect files that will be opened
> after this.
4793c5127
< 							*c_preserve*
---
> 							*:preserve*
4808c5142,5145
< Example:	vim -r reference.doc
---
> Example:	vim -r vim_ref.txt
> 
> If you were editing without a file name, give an empty string as argument:
> 		vim -r ""
4810,4812c5147,5155
< If the swap file does not end in ".swp" but in something else, you can
< recover by giving the swap file name. Vim will then find out the name of the
< original file from the swap file.
---
> If there are several swap files that look they may be the one you want to
> use, a list is given of these swap files and you are requested to enter the
> number of the one you want to use. In case you don't know which one to use,
> just try them one by one and check the resulting files if they are what you
> expected.
> 
> If you know which swap file needs to be used, you can recover by giving the
> swap file name. Vim will then find out the name of the original file from
> the swap file.
4814c5157
< Example:	Vim -r reference.doc.swo
---
> Example:	Vim -r vim_ref.txt.swo
4823c5166
< Found a swap file ..." message. In this case the single command ":preserve"
---
> Found a swap file ..." message. In this case the single command ":recover"
4825,4826c5168,5169
< the preserve command:
< 							*c_recover*
---
> the recover command:
> 							*:recover*
4859d5201
< 
4862c5204
< 							*c_set*
---
> 							*:set*
4929a5272
> 							*modeline*
4957,4958c5300,5301
< 							*c_mkexrc*
< :mkexrc [file]		Write current key mappings and changed options to 
---
> 							*:mkexrc*
> :mk[exrc] [file]	Write current key mappings and changed options to 
4962c5305
< :mkexrc! [file]		Always write current key mappings and changed 
---
> :mk[exrc]! [file]	Always write current key mappings and changed 
4965,4966c5308,5309
< 							*c_mkvimrc*
< :mkvimrc[!] [file]	Same as :mkexrc, but default is ".vimrc". {not in 
---
> 							*:mkvimrc*
> :mkv[imrc][!] [file]	Same as :mkexrc, but default is ".vimrc". {not in 
4994c5337,5465
< 						*autoindent*
---
> This list was made by doing ""tY@t" on the following line.
> Adjust the number 120 to the number of options.
> 
> :set tw=0jjjj0d/^$mt"aykOyt	O|'p0lea'|                   22|dwA():s/(/|'/g:s/)/'|/g$xxxx"Add/^[^ 	]0"qDdd/^[^ 	]120@q't"aP2dd:set tw=76
> 
> Alphabetical jump table for the options (because there are so many):
> 
> |'autoindent'|       |'ai'|
> |'autowrite'|        |'aw'|
> |'backspace'|        |'bs'|
> |'backup'|           |'bk'|
> |'backupdir'|        |'bdir'|
> |'backupext'|        |'bex'|
> |'binary'|           |'bin'|
> |'bioskey'|          |'bk'|
> |'cmdheight'|        |'ch'|
> |'columns'|          |'co'|
> |'comments'|         |'com'|
> |'compatible'|       |'cp'|
> |'define'|           |'def'|
> |'dictionary'|       |'dict'|
> |'digraph'|          |'dg'|
> |'directory'|        |'dir'|
> |'edcompatible'|     
> |'endofline'|        |'eol'|
> |'equalalways'|      |'ea'|
> |'equalprg'|         |'ep'|
> |'errorbells'|       |'eb'|
> |'errorfile'|        |'ef'|
> |'errorformat'|      |'efm'|
> |'esckeys'|          |'ek'|
> |'expandtab'|        |'et'|
> |'exrc'|             
> |'formatoptions'|    |'fo'|
> |'formatprg'|        |'fp'|
> |'gdefault'|         |'gd'|
> |'graphic'|          |'gr'|
> |'helpfile'|         |'hf'|
> |'helpheight'|       |'hh'|
> |'hidden'|           |'hid'|
> |'highlight'|        |'hl'|
> |'history'|          |'hi'|
> |'icon'|             
> |'identchars'|       |'id'|
> |'ignorecase'|       |'ic'|
> |'include'|          |'inc'|
> |'incsearch'|        |'is'|
> |'infercase'|        |'inf'|
> |'insertmode'|       |'im'|
> |'joinspaces'|       |'js'|
> |'keywordprg'|       |'kp'|
> |'laststatus'|       |'ls'|
> |'lines'|            
> |'list'|             
> |'magic'|            
> |'makeprg'|          |'mp'|
> |'maxmapdepth'|      |'mmd'|
> |'maxmem'|           |'mm'|
> |'maxmemtot'|        |'mmt'|
> |'modeline'|         |'ml'|
> |'modelines'|        |'mls'|
> |'more'|             
> |'mouse'|            
> |'nestedcomments'|   |'ncom'|
> |'nobuf'|            |'nb'|
> |'number'|           |'nu'|
> |'paragraphs'|       |'para'|
> |'paste'|            
> |'patchmode'|        |'pm'|
> |'path'|             |'pa'|
> |'readonly'|         |'ro'|
> |'remap'|            
> |'report'|           
> |'revins'|           |'ri'|
> |'ruler'|            |'ru'|
> |'scroll'|           
> |'scrolljump'|       |'sj'|
> |'sections'|         |'sect'|
> |'secure'|           
> |'shell'|            |'sh'|
> |'shellpipe'|        |'sp'|
> |'shellredir'|       |'srr'|
> |'shelltype'|        |'st'|
> |'shiftround'|       |'sr'|
> |'shiftwidth'|       |'sw'|
> |'shortmess'|        |'shm'|
> |'shortname'|        |'sn'|
> |'showcmd'|          |'sc'|
> |'showmatch'|        |'sm'|
> |'showmode'|         |'smd'|
> |'sidescroll'|       |'ss'|
> |'smartindent'|      |'si'|
> |'smartmatch'|       |'sma'|
> |'smarttab'|         |'sta'|
> |'splitbelow'|       |'sb'|
> |'startofline'|      |'sol'|
> |'suffixes'|         |'su'|
> |'tabstop'|          |'ts'|
> |'taglength'|        |'tl'|
> |'tagrelative'|      |'tr'|
> |'tags'|             
> |'term'|             
> |'terse'|            
> |'textauto'|         |'ta'|
> |'textmode'|         |'tx'|
> |'textwidth'|        |'tw'|
> |'tildeop'|          |'to'|
> |'timeout'|          
> |'ttimeout'|         
> |'timeoutlen'|       |'tm'|
> |'title'|            
> |'ttyfast'|          
> |'undolevels'|       |'ul'|
> |'updatecount'|      |'uc'|
> |'updatetime'|       |'ut'|
> |'viminfo'|          |'vi'|
> |'visualbell'|       |'vb'|
> |'warn'|             
> |'weirdinvert'|      |'wi'|
> |'whichwrap'|        |'ww'|
> |'wildchar'|         |'wc'|
> |'winheight'|        |'wh'|
> |'wrap'|             
> |'wrapmargin'|       |'wm'|
> |'wrapscan'|         |'ws'|
> |'writeany'|         |'wa'|
> |'writebackup'|      |'wb'|
> 
> 					*'autoindent'* *'ai'*
5008c5479
< 						*autowrite*
---
> 						*'autowrite'* *'aw'*
5015c5486
< 						*backspace*
---
> 					*'backspace'* *'bs'*
5023c5494
< 						*backup*
---
> 						*'backup'* *'bk'*
5033c5504
< 						*backupdir*
---
> 						*'backupdir'* *'bdir'*
5042c5513
< 						*backupext*
---
> 						*'backupext'* *'bex'*
5050c5521
< 						*binary*
---
> 						*'binary'* *'bin'*
5062c5533
< 						*bioskey*
---
> 						*'bioskey'* *'bk'*
5069c5540
< 						*cmdheight*
---
> 					*'cmdheight'* *'ch'*
5075,5076c5546,5547
< 						*columns*
< columns			number	(default 80 or terminal width)
---
> 						*'columns'* *'co'*
> columns (co)		number	(default 80 or terminal width)
5081c5552
< 						*comments*
---
> 						*'comments'* *'com'*
5083c5554
<         Represents patterns that can start a comment line. See |formatting|.
---
> 	Represents patterns that can start a comment line. See |formatting|.
5086c5557
< 						*compatible*
---
> 						*'compatible'* *'cp'*
5123c5594
< 						*define*
---
> 					*'define'* *'def'*
5130c5601
< 						*dictionary*
---
> 						*'dictionary'* *'dict'*
5136c5607
< 						*digraph*
---
> 						*'digraph'* *'dg'*
5139,5140c5610,5611
< 	{char2}. Only works if Vim was compiled with digraphs enabled. {not 
< 	in Vi}
---
> 	{char2}. Only works if Vim was compiled with digraphs enabled. See
> 	|digraphs|. {not in Vi}
5142c5613
< 						*directory*
---
> 						*'directory'* *'dir'*
5155c5626
< 						*edcompatible*
---
> 					*'edcompatible'*
5161c5632
< 						*endofline*
---
> 						*'endofline'* *'eol'*
5176c5647
< 						*equalalways*
---
> 						*'equalalways'* *'ea'*
5184c5655
< 						*equalprg*
---
> 						*'equalprg'* *'ep'*
5189c5660
< 						*errorbells*
---
> 						*'errorbells'* *'eb'*
5194c5665
< 						*errorfile*
---
> 						*'errorfile'* *'ef'*
5197c5668
< 	|c_make_makeprg|). Environment variables are expanded. {not in Vi}
---
> 	|:make_makeprg|). Environment variables are expanded. {not in Vi}
5199c5670
< 						*errorformat*
---
> 						*'errorformat'* *'efm'*
5205c5676
< 						*esckeys*
---
> 						*'esckeys'* *'ek'*
5213c5684
< 						*expandtab*
---
> 						*'expandtab'* *'et'*
5218c5689
< 	set, use CTRL-V<TAB>. See also ":retab" command in 11.3 |c_retab|
---
> 	set, use CTRL-V<TAB>. See also ":retab" command in 11.3 |:retab|
5222c5693
< 						*exrc*
---
> 						*'exrc'*
5228c5699
< 						*formatoptions*
---
> 					*'formatoptions'* *'fo'*
5231c5702
< 	formatting is to be done.  See |formatting|. Each buffer has its own
---
> 	formatting is to be done.  See |fo_table|. Each buffer has its own
5234c5705
< 						*formatprg*
---
> 						*'formatprg'* *'fp'*
5243c5714
< 						*gdefault*
---
> 					*'gdefault'* *'gd'*
5249c5720
< 						*graphic*
---
> 						*'graphic'* *'gr'*
5257,5262c5728,5739
< 						*helpfile*
< helpfile (hf)		string	(default (Amiga) "vim:vim.hlp"
< 					 (unix) "/usr/local/lib/vim.hlp")
< 	Name of the help file. It may start with an environment variable. 
< 	For example: "$VIM/doc/vim.hlp". Environment variables are expanded.
< 	{not in Vi}
---
> 					*'helpfile'* *'hf'*
> helpfile (hf)		string	(default (Amiga) "vim:vim_help.txt"
> 					 (unix) "/usr/local/lib/vim_help.txt")
> 	Name of the help file. It may start with an environment variable.
> 	For example: "$VIM/doc/vim_help.txt". Environment variables are
> 	expanded.  {not in Vi}
> 
> 						*'helpheight'* *'hh'*
> helpheight (hh)		number	(default 20)
> 	Height of the help window when it is opened with the ":help"
> 	command. When it is zero the window will be half the height of the
> 	current window. {not in Vi}
5264c5741
< 						*hidden*
---
> 						*'hidden'* *'hid'*
5271c5748
< 	not set. See also 'windows.doc'. {not in Vi} 
---
> 	not set. See also |vim_win.txt|. {not in Vi} 
5273c5750
< 						*highlight*
---
> 						*'highlight'* *'hl'*
5299c5776
< 						*history*
---
> 						*'history'* *'hi'*
5303c5780
< 						*icon*
---
> 						*'icon'*
5311c5788
< 						*identchars*
---
> 						*'identchars'* *'id'*
5321c5798
< 						*ignorecase*
---
> 						*'ignorecase'* *'ic'*
5326c5803
< 						*include*
---
> 						*'include'* *'inc'*
5334c5811
< 						*incsearch*
---
> 						*'incsearch'* *'is'*
5341c5818
< 						*infercase*
---
> 						*'infercase'* *'inf'*
5351c5828
< 						*insertmode*
---
> 						*'insertmode'* *'im'*
5355c5832
< 						*joinspaces*
---
> 					*'joinspaces'* *'js'*
5359c5836
< 						*keywordprg*
---
> 					*'keywordprg'* *'kp'*
5364c5841
< 						*laststatus*
---
> 					*'laststatus'* *'ls'*
5374c5851
< 						*lines*
---
> 						*'lines'*
5379c5856
< 						*list*
---
> 						*'list'*
5385c5862
< 						*magic*
---
> 						*'magic'*
5390c5867
< 						*makeprg*
---
> 						*'makeprg'* *'mp'*
5392c5869
< 	Program to use for the ":make" command. See |c_make_makeprg|. This
---
> 	Program to use for the ":make" command. See |:make_makeprg|. This
5397c5874,5882
< 						*maxmem*
---
> 						*'maxmapdepth'* *'mmd'*
> maxmapdepth (mmd)		number	(default 1000)
> 	Maximum number of times a mapping is done without resulting in a
> 	character to be used. This normally catches endless mappings, like
> 	":map x y" with ":map y x". It still does not catch ":map g wg",
> 	because the 'w' is used before the next mapping is done. See also
> 	|key_mapping|  {not in Vi}
> 
> 						*'maxmem'* *'mm'*
5403c5888
< 						*maxmemtot*
---
> 						*'maxmemtot'* *'mmt'*
5406c5891
< 	Added 'maxmemtot' option ('mmt'), maximal Kbyte to use for
---
> 	Added 'maxmemtot' option ( 'mmt' ), maximal Kbyte to use for
5409c5894
< 						*modeline*
---
> 						*'modeline'* *'ml'*
5411c5896
< 						*modelines*
---
> 						*'modelines'* *'mls'*
5415c5900
< 	0 no lines are checked. See 19.1 |set_option|. Each buffer has its
---
> 	0 no lines are checked. See 19.1 |modeline|. Each buffer has its
5418c5903
< 						*more*
---
> 						*'more'*
5425,5429c5910,5921
< 	Any other key is ignored. When this
< 	option is off there are no pauses, the listing continues until
< 	finished. When Vim was compiled with COMPATIBLE defined this option
< 	is default off. When 'compatible' is set this option is off. Note:
< 	The key typed at the "more" prompt is not mapped {not in Vi}
---
> 	Type ':' to stop the listing and enter a command line.
> 	Any other key causes the meaning of the keys to be displayed.
> 	When this option is off there are no pauses, the listing continues
> 	until finished. When Vim was compiled with COMPATIBLE defined this
> 	option is default off. When 'compatible' is set this option is off.
> 	Note: The key typed at the "more" prompt is not mapped {not in Vi}
> 
> 						*'mouse'*
> mouse			toggle	(default on)
> 	Enable the use of mouse clicks. Only works for certain terminals
> 	(MSDOS and xterm). Note: Normal copy/paste in an xterm can still be
> 	used by pressing the shift key when using the mouse. {not in Vi}
5430a5923
> 				*'nestedcomments'* *'ncom'*
5436c5929
< 						*nobuf*
---
> 						*'nobuf'* *'nb'*
5441c5934
< 						*number*
---
> 						*'number'* *'nu'*
5446c5939
< 						*paragraphs*
---
> 			*'paragraphs'* *'para'*
5451c5944
< 						*paste*
---
> 						*'paste'*
5457c5950
< 	reset ('textwidth', 'autoindent', 'smartindent', 'revins', 'ruler'
---
> 	reset ( 'textwidth', 'autoindent', 'smartindent', 'revins', 'ruler'
5464c5957
< 						*patchmode*
---
> 						*'patchmode'* *'pm'*
5477c5970
< 						*path*
---
> 						*'path'* *'pa'*
5488c5981
< 						*readonly*
---
> 				*'readonly'* *'ro'*
5491,5492c5984
< 	accidentally overwriting a file. Also, sets 'updatecount' to zero so
< 	that no ".swp" swap file is created. Default on when vim is started
---
> 	accidentally overwriting a file. Default on when vim is started
5497c5989
< 						*remap*
---
> 						*'remap'*
5502c5994
< 						*report*
---
> 						*'report'*
5506,5507c5998,5999
< 						*revins*
< revins			toggle	(default off)
---
> 						*'revins'*
> revins (ri)		toggle	(default off)
5513c6005
< 						*ruler*
---
> 						*'ruler'* *'ru'*
5521c6013
< 						*scroll*
---
> 						*'scroll'*
5529,5530c6021,6022
< 						*scrolljump*
< scrolljump		number	(default 1)
---
> 						*'scrolljump'* *'sj'*
> scrolljump (sj)		number	(default 1)
5535c6027
< 						*sections*
---
> 						*'sections'* *'sect'*
5540c6032
< 						*secure*
---
> 						*'secure'*
5542,5546c6034,6038
< 	When on, shell and write commands are not allowed in ".vimrc" and 
< 	".exrc" in the current directory and map commands are displayed.
< 	Switch it off only if you know that you will not run into problems,
< 	or when the 'exrc' option is off. On unix this option is only used
< 	if the ".vimrc" or ".exrc" is not owned by you.
---
> 	When on, ":autocmd", shell and write commands are not allowed in
> 	".vimrc" and ".exrc" in the current directory and map commands are
> 	displayed.  Switch it off only if you know that you will not run
> 	into problems, or when the 'exrc' option is off. On unix this option
> 	is only used if the ".vimrc" or ".exrc" is not owned by you.
5548c6040
< 						*shell*
---
> 						*'shell'* *'sh'*
5556c6048
< 						*shellpipe*
---
> 						*'shellpipe'* *'sp'*
5559c6051
< 	error file. See also |c_make_makeprg|. For the Amiga and MSDOS the
---
> 	error file. See also |:make_makeprg|. For the Amiga and MSDOS the
5563c6055
< 	'shell' option is "csh", "tcsh" or "zsh" during initializations, the
---
> 	'shell' option is "csh", "tcsh" or "zsh" after initializations, the
5566,5567c6058,6061
< 	also included.  Setting the 'shell' option does not automatically
< 	change the 'shellpipe' option. {not in Vi}
---
> 	also included.  The initialization of this option is done after
> 	reading the ".vimrc" and the other initializations, so when the
> 	'shell' option is set there it automatically changes the 'shellpipe'
> 	option, unless it was set before. {not in Vi}
5569c6063
< 						*shellredir*
---
> 						*'shellredir'* *'srr'*
5572c6066
< 	See also |c_bang|. The default is ">".  For Unix, if the 'shell'
---
> 	See also |:!|. The default is ">".  For Unix, if the 'shell'
5576,5577c6070,6073
< 	Setting the 'shell' option does not automatically change the
< 	'shellpipe' option. {not in Vi}
---
> 	The initialization of this option is done after reading the ".vimrc"
> 	and the other initializations, so when the 'shell' option is set
> 	there it automatically changes the 'shellredir' option, unless it
> 	was set before. {not in Vi}
5579c6075
< 						*shelltype*
---
> 						*'shelltype'* *'st'*
5591c6087
< 						*shiftround*
---
> 						*'shiftround'* *'sr'*
5596c6092
< 						*shiftwidth*
---
> 						*'shiftwidth'* *'sw'*
5601c6097
< 						*shortmess*
---
> 						*'shortmess'* *'shm'*
5618c6114
< 						*shortname*
---
> 						*'shortname'* *'sn'*
5629c6125
< 						*showcmd*
---
> 						*'showcmd'* *'sc'*
5634c6130
< 						*showmatch*
---
> 						*'showmatch'* *'sm'*
5639c6135
< 						*showmode*
---
> 						*'showmode'* *'smd'*
5643c6139
< 						*sidescroll*
---
> 						*'sidescroll'* *'ss'*
5651c6147
< 						*smartindent*
---
> 						*'smartindent'* *'si'*
5670c6166
< 						*smartmatch*
---
> 						*'smartmatch'* *'sma'*
5685c6181
< 						*smarttab*
---
> 						*'smarttab'* *'sta'*
5692c6188
< 						*splitbelow*
---
> 						*'splitbelow'* *'sb'*
5696c6192
< 						*startofline*
---
> 						*'startofline'* *'sol'*
5705c6201
< 						*suffixes*
---
> 						*'suffixes'* *'su'*
5710c6206
< 						*tabstop*
---
> 					*'tabstop'* *'ts'*
5713c6209
< 	":retab" command in 11.3 |c_retab|). Each buffer has its own copy of
---
> 	":retab" command in 11.3 |:retab|). Each buffer has its own copy of
5716c6212
< 						*taglength*
---
> 						*'taglength'* *'tl'*
5720c6216
< 						*tagrelative*
---
> 						*'tagrelative'* *'tr'*
5727c6223
< 						*tags*
---
> 						*'tags'*
5733c6229
< 						*term*
---
> 						*'term'*
5739c6235
< 						*terse*
---
> 						*'terse'*
5743c6239
< 						*textauto*
---
> 						*'textauto'* *'ta'*
5749c6245
< 						*textmode*
---
> 						*'textmode'* *'tx'*
5756,5757c6252,6253
< 						*textwidth*
< textwidth		number	(default 0)
---
> 						*'textwidth'* *'tw'*
> textwidth (tw)		number	(default 0)
5764c6260
< 						*tildeop*
---
> 						*'tildeop'* *'to'*
5768c6264
< 						*timeout*
---
> 						*'timeout'*
5770c6266
< 						*ttimeout*
---
> 						*'ttimeout'*
5797c6293
< 						*timeoutlen*
---
> 						*'timeoutlen'* *'tm'*
5802c6298
< 						*title*
---
> 						*'title'*
5811c6307
< 						*ttyfast*
---
> 						*'ttyfast'* *'tf'*
5819c6315
< 						*undolevels*
---
> 					*'undolevels'* *'ul'*
5825c6321
< 						*updatecount*
---
> 						*'updatecount'* *'uc'*
5827,5829c6323,6327
< 	After this many characters typed the swap file will be written to
< 	disk. When zero the swap script will not be written at all (see
< 	chapter on recovery |crash_recovery|). {not in Vi}
---
> 	After typing this many characters the swap file will be written to
> 	disk. When zero no swap file will be created at all (see chapter on
> 	recovery |crash_recovery|). Can be set to zero by starting Vim with
> 	the "-n" option, see |starting|. When editing in readonly mode this
> 	option will be initialized to 10000. {not in Vi}
5831c6329
< 						*updatetime*
---
> 						*'updatetime'* *'ut'*
5837c6335
< 						*viminfo*
---
> 					*'viminfo'* *'vi'*
5843c6341
< 						*visualbell*
---
> 						*'visualbell'* *'vb'*
5845c6343,6345
< 	Use (sort of) visual bell for AUX device. {not in Vi}
---
> 	Use visual bell instead of beeping. The terminal code to display the
> 	visual bell is given with 't_vb'. When no beep of flash is wanted,
> 	use ":set vb t_vb=". {not in Vi}
5847c6347
< 						*warn*
---
> 						*'warn'*
5852c6352
< 						*weirdinvert*
---
> 						*'weirdinvert'* *'wi'*
5859c6359
< 						*whichwrap*
---
> 						*'whichwrap'* *'ww'*
5864,5868c6364,6368
< 		 1 for backspace	 in command mode
< 		 2 for space		 in command mode
< 		 4 for 'h' and 'l'	 in command mode
< 		 8 for cursor left/right in command mode
< 		16 for cursor left/right in insert mode
---
> 		 1 for backspace	 in Normal and Visual mode
> 		 2 for space		 in Normal and Visual mode
> 		 4 for 'h' and 'l'	 in Normal and Visual mode
> 		 8 for cursor left/right in Normal and Visual mode
> 		16 for cursor left/right in Insert and Replace mode
5874c6374
< 						*wildchar*
---
> 						*'wildchar'* *'wc'*
5881c6381
< 						*winheight*
---
> 						*'winheight'* *'wh'*
5890c6390
< 						*wrap*
---
> 						*'wrap'*
5898c6398
< 						*wrapmargin*
---
> 						*'wrapmargin'* *'wm'*
5905c6405
< 						*wrapscan*
---
> 						*'wrapscan'* *'ws'*
5909c6409
< 						*writeany*
---
> 						*'writeany'* *'wa'*
5913c6413
< 						*writebackup*
---
> 						*'writebackup'* *'wb'*
6018,6035c6518,6536
< 	t_name	(name)	name of current terminal entry
< 	t_el	ce	clear to end of line
< 	t_il	al	add new blank line
< 	t_cil	AL	add number of blank lines
< 	t_dl	dl	delete line
< 	t_cdl	DL	delete number of lines
< 	t_cs	cs	define scrolling region
< 	t_ed	cl	clear screen (required!)
< 	t_ci	vi	cursor invisible
< 	t_cv	ve	cursor visible
< 	t_cvv	cvv	cursor very visible
< 	t_tp	me	normal mode (undoes t_ti and t_tb)
< 	t_ti	mr	reverse (invert) mode
< 	t_tb	md	bold mode
< 	t_se	se	standout end
< 	t_so	so	standout mode
< 	t_ue	ue	underline end
< 	t_us	us	underline mode
---
> 	t_name	(name)	name of current terminal entry *t_name*
> 	t_el	ce	clear to end of line *t_el*
> 	t_il	al	add new blank line *t_il*
> 	t_cil	AL	add number of blank lines *t_cil*
> 	t_dl	dl	delete line *t_dl*
> 	t_cdl	DL	delete number of lines *t_cdl*
> 	t_cs	cs	define scrolling region *t_cs*
> 	t_ed	cl	clear screen (required!) *t_ed*
> 	t_ci	vi	cursor invisible *t_ci*
> 	t_cv	ve	cursor visible *t_cv*
> 	t_cvv	cvv	cursor very visible *t_cvv*
> 	t_tp	me	normal mode (undoes t_ti and t_tb) *t_tp*
> 	t_ti	mr	reverse (invert) mode *t_ti*
> 	t_tb	md	bold mode *t_tb*
> 	t_se	se	standout end *t_se*
> 	t_so	so	standout mode *t_so*
> 	t_ue	ue	underline end *t_ue*
> 	t_us	us	underline mode *t_us*
> 							*t_ms*
6037,6044c6538,6545
< 	t_cm	cm	cursor motion (required!)
< 	t_sr	sr	scroll reverse (backward)
< 	t_cri	RI	cursor number of chars right
< 	t_vb	vb	visual bell
< 	t_ks	ks	put terminal in "keypad transmit" mode
< 	t_ke	ke	out of "keypad transmit" mode
< 	t_ts	ti	put terminal in "termcap" mode
< 	t_te	te	out of "termcap" mode
---
> 	t_cm	cm	cursor motion (required!) *t_cm*
> 	t_sr	sr	scroll reverse (backward) *t_sr*
> 	t_cri	RI	cursor number of chars right *t_cri*
> 	t_vb	vb	visual bell *t_vb*
> 	t_ks	ks	put terminal in "keypad transmit" mode *t_ks*
> 	t_ke	ke	out of "keypad transmit" mode *t_ke*
> 	t_ts	ti	put terminal in "termcap" mode *t_ts*
> 	t_te	te	out of "termcap" mode *t_te*
6047,6082c6548,6583
< 	t_ku	ku	arrow up
< 	t_kd	kd	arrow down
< 	t_kr	kr	arrow right
< 	t_kl	kl	arrow left
< 	t_sku	(none)	shift arrow up
< 	t_skd	(none)	shift arrow down
< 	t_skr	%i	shift arrow right
< 	t_skl	#4	shift arrow left
< 	t_f1	k1	function key 1
< 	t_f2	k2	function key 2
< 	t_f3	k3	function key 3
< 	t_f4	k4	function key 4
< 	t_f5	k5	function key 5
< 	t_f6	k6	function key 6
< 	t_f7	k7	function key 7
< 	t_f8	k8	function key 8
< 	t_f9	k9	function key 9
< 	t_f10	k;	function key 10
< 	t_sf1	F1	function key 11 or shifted function key 1
< 	t_sf2	F2	function key 12 or shifted function key 2
< 	t_sf3	F3	function key 13 or shifted function key 3
< 	t_sf4	F4	function key 14 or shifted function key 4
< 	t_sf5	F5	function key 15 or shifted function key 5
< 	t_sf6	F6	function key 16 or shifted function key 6
< 	t_sf7	F7	function key 17 or shifted function key 7
< 	t_sf8	F8	function key 18 or shifted function key 8
< 	t_sf9	F9	function key 19 or shifted function key 9
< 	t_sf10	FA	function key 20 or shifted function key 10
< 	t_help	%1	help key
< 	t_undo	&8	undo key
< 	t_ins	kI	insert key
< 	t_del	kD	delete key
< 	t_home	kh	home key
< 	t_end	@7	end key
< 	t_pu	kP	page-up key
< 	t_pd	kN	page-down key
---
> 	t_ku	ku	arrow up *t_ku*
> 	t_kd	kd	arrow down *t_kd*
> 	t_kr	kr	arrow right *t_kr*
> 	t_kl	kl	arrow left *t_kl*
> 	t_sku	(none)	shift arrow up *t_sku*
> 	t_skd	(none)	shift arrow down *t_skd*
> 	t_skr	%i	shift arrow right *t_skr*
> 	t_skl	#4	shift arrow left *t_skl*
> 	t_f1	k1	function key 1 *t_f1*
> 	t_f2	k2	function key 2 *t_f2*
> 	t_f3	k3	function key 3 *t_f3*
> 	t_f4	k4	function key 4 *t_f4*
> 	t_f5	k5	function key 5 *t_f5*
> 	t_f6	k6	function key 6 *t_f6*
> 	t_f7	k7	function key 7 *t_f7*
> 	t_f8	k8	function key 8 *t_f8*
> 	t_f9	k9	function key 9 *t_f9*
> 	t_f10	k;	function key 10 *t_f10*
> 	t_sf1	F1	function key 11 or shifted function key 1 *t_sf1*
> 	t_sf2	F2	function key 12 or shifted function key 2 *t_sf2*
> 	t_sf3	F3	function key 13 or shifted function key 3 *t_sf3*
> 	t_sf4	F4	function key 14 or shifted function key 4 *t_sf4*
> 	t_sf5	F5	function key 15 or shifted function key 5 *t_sf5*
> 	t_sf6	F6	function key 16 or shifted function key 6 *t_sf6*
> 	t_sf7	F7	function key 17 or shifted function key 7 *t_sf7*
> 	t_sf8	F8	function key 18 or shifted function key 8 *t_sf8*
> 	t_sf9	F9	function key 19 or shifted function key 9 *t_sf9*
> 	t_sf10	FA	function key 20 or shifted function key 10 *t_sf10*
> 	t_help	%1	help key *t_help*
> 	t_undo	&8	undo key *t_undo*
> 	t_ins	kI	insert key *t_ins*
> 	t_del	kD	delete key *t_del*
> 	t_home	kh	home key *t_home*
> 	t_end	@7	end key *t_end*
> 	t_pu	kP	page-up key *t_pu*
> 	t_pd	kN	page-down key *t_pd*
6155a6657
> 							*:mode*
6193c6695
< you might want to set the 'nobuf' option ('nb'). When set one character is
---
> you might want to set the 'nobuf' option ( 'nb' ). When set one character is
6202c6704
< previous chapters. Also see "difference.doc" for an overview.
---
> previous chapters. Also see |vim_diff.txt| for an overview.
6249c6751
< CONTENTS
---
> CONTENTS			*reference_contents* *ref* *reference*
6252c6754
< windows.doc]
---
> a different file, see |vim_win.txt|]
6281a6784,6785
> 	4.8 Using the mouse			|using_mouse|
> 	4.9 On-line help			|online_help|
Index: ./doc/vim_tips.txt
diff -r ../vim.orig/doc/vim_tips.txt ./doc/vim_tips.txt
0a1,11
> *vim_tips.txt*
> 
> EDITING LOCAL HTML FILES (WWW)
> 
> Vim has some features which can help simplify the creation and
> maintenance of HTML files, provided that the files you are editing are
> available on the local file system. The ]f and ^Wf commands can be
> used to jump to the file whose name appears under the cursor, thus not
> only checking that the link is valid (at least the file name part of
> the URL) or providing a quick and easy way to edit many related HTML
> pages at once.
Index: ./doc/vim_unix.txt
diff -r ../vim.orig/doc/vim_unix.txt ./doc/vim_unix.txt
0a1,2
> *vim_unix.txt*
> 
3c5
< The default help filename is "/usr/local/lib/vim.hlp"
---
> The default help filename is "/usr/local/lib/vim_help.txt"
14a17,19
> 
> When using Vim in an xterm the mouse clicks are used by Vim. If you want the
> xterm copy/paste with the mouse, press the shift key when using the mouse.
Index: ./doc/vim_win.txt
diff -r ../vim.orig/doc/vim_win.txt ./doc/vim_win.txt
0a1,2
> *vim_win.txt*
> 
56,59c58,61
< CTRL-W s
< CTRL-W S
< CTRL-W CTRL-S
< :[N]split
---
> CTRL-W s						*CTRL-W_s*
> CTRL-W S						*CTRL-W_S*
> CTRL-W CTRL-S						*CTRL-W_CTRL-S*
> :[N]split						*:split*
66,68c68,70
< CTRL-W n
< CTRL-W CTRL_N
< :[N]new
---
> CTRL-W n						*CTRL-W_n*
> CTRL-W CTRL_N						*CTRL-W_CTRL-N*
> :[N]new							*:new*
75c77
< :[N]split [+command] fname
---
> :[N]split [+command] fname				*:split_f*
82c84,87
< CTRL-W CTRL-^
---
> :[N]sv[iew] [+command] fname				*:sview*
> 		Same as :split, but set 'readonly' option for this buffer.
> 
> CTRL-W CTRL-^						*CTRL-W_CTRL-^*
91,92c96,97
< CTRL-W q
< CTRL-W CTRL-Q
---
> CTRL-W q						*CTRL-W_q*
> CTRL-W CTRL-Q						*CTRL-W_CTRL-Q*
101c106
< CTRL-W c
---
> CTRL-W c						*CTRL-W_c* *:close*
106,107c111,112
< CTRL-W o
< CTRL-W CTRL-O
---
> CTRL-W o						*CTRL-W_o*
> CTRL-W CTRL-O					*CTRL-W_CTRL-O* *:only*
116,117c121,122
< CTRL-W <CURSOR_DOWN>
< CTRL-W CTRL-J
---
> CTRL-W <CURSOR_DOWN>					*CTRL-W_<C_DOWN>*
> CTRL-W CTRL-J					*CTRL-W_CTRL-J* *CTRL-W_j*
120,121c125,126
< CTRL-W <CURSOR_UP>
< CTRL-W CTRL-K
---
> CTRL-W <CURSOR_UP>					*CTRL-W_<C_UP>*
> CTRL-W CTRL-K					*CTRL-W_CTRL-K* *CTRL-W_k*
124c129
< CTRL-W w
---
> CTRL-W w					*CTRL-W_w* *CTRL-W_CTRL-W*
129c134
< CTRL-W t
---
> CTRL-W t					*CTRL-W_t* *CTRL-W_CTRL-T*
132c137
< CTRL-W b
---
> CTRL-W b					*CTRL-W_b* *CTRL-W_CTRL-B*
135c140
< CTRL-W p
---
> CTRL-W p					*CTRL-W_p* *CTRL-W_CTRL-P*
145c150
< CTRL-W r
---
> CTRL-W r					*CTRL-W_r* *CTRL-W_CTRL-R*
150a156
> 						*CTRL-W_R*
156c162
< CTRL-W x
---
> CTRL-W x					*CTRL-W_x* *CTRL-W_CTRL-X*
165a172
> 						*CTRL-W_=*
168c175
< :resize -N
---
> :resize -N					*:resize* *CTRL-W_-*
171c178
< :resize +N
---
> :resize +N					*CTRL-W_+*
175c182
< CTRL-W CTRL-_
---
> CTRL-W CTRL-_					*CTRL-W_CTRL-_* *CTRL-W__*
205a213
> 							*:qall*
211c219
< :wqall
---
> :wqall							*:wqall* *:xall*
224a233
> 							*:wall*
281c290
< :all
---
> :all						*:all* *:sall*
285c294
< :[N]sargument[!] [N]
---
> :[N]sargument[!] [N]				*:sargument*
290c299
< :[N]snext[!] [file ..]
---
> :[N]snext[!] [file ..]				*:snext*
295,296c304,305
< :[N]sprevious[!] [N]
< :[N]sNext[!] [N]
---
> :[N]sprevious[!] [N]				*:sprevious*
> :[N]sNext[!] [N]				*:sNext*
301a311
> 						*:srewind*
305a316
> 						*:slast*
314c325
< CTRL-W ]
---
> CTRL-W ]					*CTRL-W_]* *CTRL-W_CTRL-]*
319c330
< CTRL-W f
---
> CTRL-W f					*CTRL-W_f* *CTRL-W_CTRL-F*
324c335,337
< 		is used to search for the file name.
---
> 		is used to search for the file name. If the name is a
> 		hypertext link, that looks like "type://machine/path", only
> 		"/path" is used.
342,343c355,356
< :files						*c_files*
< :buffers					*c_buffers* *c_ls*
---
> :files						*:files*
> :buffers					*:buffers* *:ls*
360c373
< :[N]bdelete
---
> :[N]bdelete					*:bdelete*
381c394
< :[N]bunload
---
> :[N]bunload					*:bunload*
404c417
< :[N]buffer [N]
---
> :[N]buffer [N]					*:buffer*
408c421,423
< :[N]bnext [N]	Go to [N]th next buffer in buffer list. [N] defaults to one.
---
> :[N]sbuffer [N]					*:sbuffer*
> 		Split window and edit buffer [N] from the buffer list. If [N]
> 		is not given, the current buffer is edited.
410,412c425,426
< :[N]bNext [N]
< :[N]bprev [N]	Go to [N]th previous buffer in buffer list. [N] defaults to
< 		one.
---
> 						*:bnext*
> :[N]bnext [N]	Go to [N]th next buffer in buffer list. [N] defaults to one.
414c428,429
< :brewind	Go to first buffer in buffer list
---
> 						*:sbnext*
> :[N]sbnext [N]	Split window and go to [N]th next buffer in buffer list.
416c431,434
< :blast		Go to last buffer in buffer list
---
> :[N]bNext [N]					*:bNext* *:bprevious*
> :[N]bprevious [N]
> 		Go to [N]th previous buffer in buffer list. [N] defaults to
> 		one.
418,419c436,438
< :[N]bmodified [N]
< 		Go to [N]th next modified buffer in buffer list
---
> :[N]sbNext [N]					*:sbNext* *:sbprevious*
> :[N]sbprevious [N]
> 		Split window and go to [N]th previous buffer in buffer list.
421,423c440,441
< :[N]sbuffer [N]
< 		split window and Edit buffer [N] from the buffer list. If [N]
< 		is not given, the current buffer is edited.
---
> 						*:brewind*
> :brewind	Go to first buffer in buffer list.
425c443,444
< :[N]sbnext [N]	split window and go to [N]th next buffer in buffer list
---
> 						*:sbrewind*
> :sbrewind	split window and go to first buffer in buffer list
427,428c446,447
< :[N]sbNext [N]
< :[N]sbprev [N]	split window and go to [N]th previous buffer in buffer list
---
> 						*:blast*
> :blast		Go to last buffer in buffer list.
430c449,450
< :sbrewind	split window and go to first buffer in buffer list
---
> 						*:sblast*
> :sblast		Split window and go to last buffer in buffer list.
432c452,453
< :sblast		split window and go to last buffer in buffer list
---
> :[N]bmodified [N]				*:bmodified*
> 		Go to [N]th next modified buffer in buffer list.
434,435c455,457
< :[N]sbmodified [N]
< 		split window and go to [N]th next modified buffer in buffer list
---
> :[N]sbmodified [N]				*:sbmodified*
> 		Split window and go to [N]th next modified buffer in buffer
> 		list.
437c459
< :unhide
---
> :unhide						*:unhide* *:sunhide*
441c463
< :ball
---
> :ball						*:ball* *:sball*
Index: ./quotes
diff -r ../vim.orig/quotes ./quotes
0a1,15
> Here are some quotes about Vim:
> 
> Vim is so much better than vi that a great many of my old vi :map's became
> immediately obsolete! (Tony Nugent)
> 
> The options are really excellent and very powerful. (Anish Maharaj)
> 
> the BEST EDITOR EVER (Stuart Woolford)
> 
> Hint:  "vim" is "vi improved" - much better! (Sven Guckes)
> 
> visual mode in vim is a very powerful thing! (Tony Nugent)
> 
> I strongly advise using vim--its infinite undo/redo saved me much grief.
> (Terry Brown)
Index: ./src/addcr.c
diff -r ../vim.orig/src/addcr.c ./src/addcr.c
6a7,8
> char buffer[1024];
> 
11d12
< 	char buffer[1024];
Index: ./src/amiga.c
diff -r ../vim.orig/src/amiga.c ./src/amiga.c
53c53
< #undef TRUE
---
> #undef	TRUE
55c55
< #undef FALSE
---
> #undef	FALSE
187c187
< 	msg_outstr("new shell started\n");
---
> 	MSG_OUTSTR("new shell started\n");
967c967
< 		msg_outstr((char_u *)"Cannot execute ");
---
> 		MSG_OUTSTR("Cannot execute ");
970,971c970,971
< 			msg_outstr((char_u *)"shell ");
< 			msg_outstr(p_sh);
---
> 			MSG_OUTSTR("shell ");
> 			msg_outtrans(p_sh);
974c974
< 			msg_outstr(cmd);
---
> 			msg_outtrans(cmd);
990c990
< 				msg_outstr((char_u *)" returned\n");
---
> 				MSG_OUTSTR(" returned\n");
1056c1056
< 		msg_outstr((char_u *)"Cannot execute ");
---
> 		MSG_OUTSTR("Cannot execute ");
1066c1066
< 			msg_outstr((char_u *)"shell ");
---
> 			MSG_OUTSTR("shell ");
1091c1091
< 				msg_outstr((char_u *)" returned\n");
---
> 				MSG_OUTSTR(" returned\n");
Index: ./src/amiga.h
diff -r ../vim.orig/src/amiga.h ./src/amiga.h
35c35
< # define VIM_HLP		"vim:vim.hlp"
---
> # define VIM_HLP		"vim:vim_help.txt"
Index: ./src/archie.c
diff -r ../vim.orig/src/archie.c ./src/archie.c
104c104
< 	msg_outstr("new shell started\n");
---
> 	MSG_OUTSTR("new shell started\n");
Index: ./src/buffer.c
diff -r ../vim.orig/src/buffer.c ./src/buffer.c
42a43,44
> 	int		retval = OK;
> 
67a70,74
> 	if (curbuf->b_filename != NULL)
> 		retval = readfile(curbuf->b_filename, curbuf->b_sfilename, (linenr_t)0,
> 										TRUE, (linenr_t)0, MAXLNUM);
> 	else
> 		MSG("Empty Buffer");
69,70c76,77
< 	 * Apply the automatic commands, before reading in a new file, which can
< 	 * contain modelines. So the modelines have priority over auto commands.
---
> 	 * Apply the automatic commands, before processing the modelines.
> 	 * So the modelines have priority over auto commands.
74c81
< 	if (curbuf->b_filename != NULL)
---
> 	if (retval != FAIL)
76,78c83,85
< 		if (readfile(curbuf->b_filename, curbuf->b_sfilename, (linenr_t)0,
< 										TRUE, (linenr_t)0, MAXLNUM) == FAIL)
< 			return FAIL;
---
> 		do_mlines();
> 		UNCHANGED(curbuf);
> 		curbuf->b_neverloaded = FALSE;
80,83d86
< 	else
< 		MSG("Empty Buffer");
< 	UNCHANGED(curbuf);
< 	curbuf->b_neverloaded = FALSE;
85c88
< 	return OK;
---
> 	return retval;
333a337
> 	cursupdate();						/* redisplay at correct position */
672c676
< 		msg_outstr(IObuff);
---
> 		msg_outtrans(IObuff);
893,894c897,898
< 	char_u		*t;
< 	char_u		*i;
---
> 	char_u		*t_name;
> 	char_u		*i_name;
901,902c905,906
< 		t = (char_u *)"";
< 		i = (char_u *)"No File";
---
> 		t_name = (char_u *)"";
> 		i_name = (char_u *)"No File";
909,910c913,914
< 		t = IObuff;
< 		i = gettail(curbuf->b_filename);		/* use filename only for icon */
---
> 		t_name = IObuff;
> 		i_name = gettail(curbuf->b_filename);		/* use filename only for icon */
914,915c918,923
< 	if (p_title)
< 		lasttitle = alloc((unsigned)(STRLEN(t) + 7));
---
> 	if (p_title && (lasttitle = alloc((unsigned)(strsize(t_name) + 7))) != NULL)
> 	{
> 		STRCPY(lasttitle, "VIM - ");
> 		while (*t_name)
> 			STRCAT(lasttitle, transchar(*t_name++));
> 	}
918,919d925
< 	if (lasttitle != NULL)
< 		sprintf((char *)lasttitle, "VIM - %s", (char *)t);
922,923c928,933
< 	if (p_icon)
< 		lasticon = strsave(i);
---
> 	if (p_icon && (lasticon = alloc((unsigned)(strsize(i_name) + 1))) != NULL)
> 	{
> 		*lasticon = NUL;
> 		while (*i_name)
> 			STRCAT(lasticon, transchar(*i_name++));
> 	}
1062a1073,1154
> }
> 
> /*
>  * do_mlines() - process mode lines for the current file
>  *
>  * Returns immediately if the "ml" parameter isn't set.
>  */
> static void 	chk_mline __ARGS((linenr_t));
> 
> 	void
> do_mlines()
> {
> 	linenr_t		lnum;
> 	int 			nmlines;
> 
> 	if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)
> 		return;
> 
> 	sourcing_name = (char_u *)"modelines";
> 	for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines; ++lnum)
> 		chk_mline(lnum);
> 
> 	for (lnum = curbuf->b_ml.ml_line_count; lnum > 0 && lnum > nmlines &&
> 							lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)
> 		chk_mline(lnum);
> 	sourcing_name = NULL;
> 	sourcing_lnum = 0;
> }
> 
> /*
>  * chk_mline() - check a single line for a mode string
>  */
> 	static void
> chk_mline(lnum)
> 	linenr_t lnum;
> {
> 	register char_u	*s;
> 	register char_u	*e;
> 	char_u			*cs;			/* local copy of any modeline found */
> 	int				prev;
> 	int				end;
> 
> 	prev = ' ';
> 	sourcing_lnum = lnum;
> 	for (s = ml_get(lnum); *s != NUL; ++s)
> 	{
> 		if (isspace(prev) && (STRNCMP(s, "vi:", (size_t)3) == 0 ||
> 					STRNCMP(s, "ex:", (size_t)3) == 0 ||
> 					STRNCMP(s, "vim:", (size_t)4) == 0))
> 		{
> 			do
> 				++s;
> 			while (s[-1] != ':');
> 			s = cs = strsave(s);
> 			if (cs == NULL)
> 				break;
> 			end = FALSE;
> 			while (end == FALSE)
> 			{
> 				while (*s == ' ' || *s == TAB)
> 					++s;
> 				if (*s == NUL)
> 					break;
> 				for (e = s; (*e != ':' || *(e - 1) == '\\') && *e != NUL; ++e)
> 					;
> 				if (*e == NUL)
> 					end = TRUE;
> 				*e = NUL;
> 				if (STRNCMP(s, "set ", (size_t)4) == 0) /* "vi:set opt opt opt: foo" */
> 				{
> 					(void)doset(s + 4);
> 					break;
> 				}
> 				if (doset(s) == FAIL)		/* stop if error found */
> 					break;
> 				s = e + 1;
> 			}
> 			free(cs);
> 			break;
> 		}
> 		prev = *s;
> 	}
Index: ./src/charset.c
diff -r ../vim.orig/src/charset.c ./src/charset.c
117c117
<  * return TRUE if 'c' is an identifier character
---
>  * return TRUE if 'c' is a normal identifier character
131c131,133
< 				|| (curbuf->b_p_id != NULL && STRCHR(curbuf->b_p_id, c) != NULL)
---
> #ifdef ADDED_BY_WEBB_ISIDCHAR
> 				|| c == '_'
> #endif /* ADDED_BY_WEBB_ISIDCHAR */
140a143,156
> }
> 
> /*
>  * return TRUE if 'c' is an identifier character
>  * Also check 'identchars' option.
>  */
> 	int
> isidchar_id(c)
> 	int c;
> {
> 	if (c > 0x100 || c == NUL)
> 		return FALSE;
> 	return (isidchar(c) ||
> 			(curbuf->b_p_id != NULL && STRCHR(curbuf->b_p_id, c) != NULL));
Index: ./src/cmdcmds.c
diff -r ../vim.orig/src/cmdcmds.c ./src/cmdcmds.c
29a30,40
> 	void
> do_ascii()
> {
> 	int c;
> 
> 	c = *ml_get_cursor();
> 	sprintf((char *)IObuff, "<%s>  %d,  Hex %02x,  Octal %03o",
> 		transchar(c), c, c, c);
> 	msg(IObuff);
> }
> 
118c129
< 	long		num_tabs = 0;
---
> 	long		num_tabs;
452c463
< 	msg_outtrans(prevcmd, -1);
---
> 	msg_outtrans(prevcmd);
489c500
< 				msg_outstr((char_u *)"[No write since last change]\n");
---
> 				MSG_OUTSTR("[No write since last change]\n");
500c511
< 	wait_return(TRUE);				/* includes starttermcap() */
---
> 	wait_return(TRUE);
501a513
> 	starttermcap();		/* start termcap if not done by wait_return() */
738c750
< 	FILE	*fp_in = NULL;
---
> 	FILE	*fp_in;
751c763
< 		EMSG("Can't write viminfo file!");
---
> 		EMSG2("Can't write viminfo file %s!", tmpname);
797c809
< 	char_u	line[LSIZE];
---
> 	char_u	*line;
799a812,813
> 	char_u	*p;
> 	char_u	save_char;
801a816,818
> 	if ((line = alloc(LSIZE)) == NULL)
> 		return;
> 
870a888
> 				/* ignore leading and trailing white space */
871a890,897
> 			p = str + STRLEN(str);
> 			while (p != str && (*p == NUL || isspace(*p)))
> 				p--;
> 			if (*p)
> 				p++;
> 			save_char = *p;
> 			*p = NUL;
> 
878a905
> 				*p = save_char;
900a928,929
> 			{
> 				free(line);
901a931
> 			}
903a934
> 	free(line);
918c949
< 	int		eof = FALSE;
---
> 	int		eof;
Index: ./src/cmdline.c
diff -r ../vim.orig/src/cmdline.c ./src/cmdline.c
23a24,25
> static char_u	*cmdbuff;		/* pointer to command line buffer */
> static int		 cmdbufflen;	/* lenght of cmdbuff */
28d29
< static char_u	*cmdbuff;		/* pointer to command line buffer */
53c54
< static void		putcmdline __ARGS((int, char_u *));
---
> static void		putcmdline __ARGS((int));
56c57
< static char_u	*DoOneCmd __ARGS((char_u *, int));
---
> static char_u	*DoOneCmd __ARGS((char_u **, int *, int));
67c68
< static int		nextwild __ARGS((char_u *, int));
---
> static int		nextwild __ARGS((int));
83c84
< 	int		j = -1;
---
> 	int		j;
184c185
<  * getcmdline() - accept a command line starting with ':', '!', '/', or '?'
---
>  * getcmdline() - accept a command line starting with ':', '/', or '?'
186c187,188
<  * For searches the optional matching '?' or '/' is removed.
---
>  * The line is collected in cmdbuff, which is reallocated to fit the command
>  * line.
188c190,191
<  * Return OK if there is a commandline, FAIL if not
---
>  * Return pointer to allocated string if there is a commandline, NULL
>  * otherwise.
191,192c194,195
< 	int
< getcmdline(firstc, buff)
---
> 	char_u *
> getcmdline(firstc)
194d196
< 	char_u		*buff;	 	/* buffer for command string */
199c201,202
< 			 int		retval;
---
> 			 int		j;
> 			 char_u		*p;
202,203c205
< 			 int		j = -1;
< 			 int		gotesc = FALSE;		/* TRUE when last char typed was <ESC> */
---
> 			 int		gotesc = FALSE;		/* TRUE when <ESC> just typed */
205c207
< 			 int		type;				/* history type to be used */
---
> 			 int		histype;			/* history type to be used */
207c209
< 			 colnr_t	old_curswant = curwin->w_curswant;
---
> 			 colnr_t	old_curswant;
212c214,215
< 	old_cursor = curwin->w_cursor;
---
> 	old_cursor = curwin->w_cursor;			/* needs to be restored later */
> 	old_curswant = curwin->w_curswant;
217c220,222
< 	cmdbuff = buff;
---
> 	alloc_cmdbuff(0);					/* allocate initial cmdbuff */
> 	if (cmdbuff == NULL)
> 		return NULL;					/* out of memory */
226c231
< 	type = (firstc == ':' ? 0 : 1);
---
> 	histype = (firstc == ':' ? 0 : 1);
235c240
< 		cursorcmd();	/* set the cursor on the right spot */
---
> 		cursorcmd();			/* set the cursor on the right spot */
239a245,246
> 			/* free old command line when finished moving around in the
> 			 * history list */
248a256
> 			/* free expanded names when finished walking through matches */
251c259
< 			(void)ExpandOne(NULL, FALSE, -2);	/* may free expanded file names */
---
> 			(void)ExpandOne(NULL, FALSE, -2);
267,268c275,276
< 			/* wildcard expansion is only done when the key is really typed, not
< 			   when it comes from a macro */
---
> 			/* wildcard expansion is only done when the key is really typed,
> 			 * not when it comes from a macro */
272c280
< 				i = nextwild(buff, 3);
---
> 				i = nextwild(3);
274c282
< 				i = nextwild(buff, 0);
---
> 				i = nextwild(0);
288,289c296
< 		case BS:
< 		case DEL:
---
> 		case K_BS:
296c303
< 				if ((c == DEL || c == K_DEL) && cmdpos != cmdlen)
---
> 				if (c == K_DEL && cmdpos != cmdlen)
303c310
< 						while (cmdpos && isspace(buff[cmdpos - 1]))
---
> 						while (cmdpos && isspace(cmdbuff[cmdpos - 1]))
305,306c312,314
< 						i = isidchar(buff[cmdpos - 1]);
< 						while (cmdpos && !isspace(buff[cmdpos - 1]) && isidchar(buff[cmdpos - 1]) == i)
---
> 						i = isidchar_id(cmdbuff[cmdpos - 1]);
> 						while (cmdpos && !isspace(cmdbuff[cmdpos - 1]) &&
> 										 isidchar_id(cmdbuff[cmdpos - 1]) == i)
314c322
< 						buff[i++] = buff[j++];
---
> 						cmdbuff[i++] = cmdbuff[j++];
319c327,328
< 					retval = FAIL;
---
> 					free(cmdbuff);		/* no commandline to return */
> 					cmdbuff = NULL;
327a337
> 				/* should change shape of cursor */
338c348
< 		case ESC:			/* get here if p_wc != ESC or when ESC typed twice */
---
> 		case ESC:		/* get here if p_wc != ESC or when ESC typed twice */
341,342c351,352
< 				retval = FAIL;
< 				MSG("");
---
> 				gotesc = TRUE;		/* will free cmdbuff after putting it in
> 										history */
347c357
< 				if (showmatches(buff) == FAIL)
---
> 				if (showmatches(cmdbuff) == FAIL)
360c370
< 						cmdspos += charsize(buff[cmdpos]);
---
> 						cmdspos += charsize(cmdbuff[cmdpos]);
363c373
< 				while (c == K_SRARROW && buff[cmdpos] != ' ');
---
> 				while (c == K_SRARROW && cmdbuff[cmdpos] != ' ');
373c383
< 						cmdspos -= charsize(buff[cmdpos]);
---
> 						cmdspos -= charsize(cmdbuff[cmdpos]);
375c385
< 				while (c == K_SLARROW && buff[cmdpos - 1] != ' ');
---
> 				while (c == K_SLARROW && cmdbuff[cmdpos - 1] != ' ');
379a390,392
> 					/* get button specifier, which is ignored */
> 				(void)vgetc();
> 				mouse_code = 0;			/* reset for next click */
401,402c414,415
< 				buff[cmdlen] = NUL;
< 				cmdspos = strsize(buff) + 1;
---
> 				cmdbuff[cmdlen] = NUL;
> 				cmdspos = strsize(cmdbuff) + 1;
406c419
< 				if (!nextwild(buff, 4))
---
> 				if (!nextwild(4))
411c424
< 				if (!nextwild(buff, 5))
---
> 				if (!nextwild(5))
419c432
< 					if (!nextwild(buff, (c == Ctrl('P')) ? 2 : 1))
---
> 					if (!nextwild((c == Ctrl('P')) ? 2 : 1))
435,440c448,450
< 					/* save current command string */
< 	/* Always save the current command line so that we can restore it later
< 	 * -- webb
< 	 */
< 				buff[cmdpos] = NUL;
< 				if (lookfor == NULL && (lookfor = strsave(buff)) == NULL)
---
> 				/* save current command string so it can be restored later */
> 				cmdbuff[cmdpos] = NUL;
> 				if (lookfor == NULL && (lookfor = strsave(cmdbuff)) == NULL)
451,452c461,462
< 							hiscnt = hisidx[type];
< 						else if (hiscnt == 0 && hisidx[type] != hislen - 1)
---
> 							hiscnt = hisidx[histype];
> 						else if (hiscnt == 0 && hisidx[histype] != hislen - 1)
454c464
< 						else if (hiscnt != hisidx[type] + 1)
---
> 						else if (hiscnt != hisidx[histype] + 1)
464c474,475
< 						if (hiscnt == hisidx[type])	/* on last entry, clear the line */
---
> 									/* on last entry, clear the line */
> 						if (hiscnt == hisidx[histype])
469c480,481
< 						if (hiscnt == hislen)	/* not on a history line, nothing to do */
---
> 									/* not on a history line, nothing to do */
> 						if (hiscnt == hislen)
476c488
< 					if (hiscnt < 0 || history[type][hiscnt] == NULL)
---
> 					if (hiscnt < 0 || history[histype][hiscnt] == NULL)
483c495,496
< 							STRNCMP(history[type][hiscnt], lookfor, (size_t)j) == 0)
---
> 							STRNCMP(history[histype][hiscnt],
> 													lookfor, (size_t)j) == 0)
488a502
> 					free(cmdbuff);
490c504
< 						STRCPY(buff, lookfor);
---
> 						p = lookfor;	/* back to the old one */
492,493c506,513
< 						STRCPY(buff, history[type][hiscnt]);
< 					cmdpos = cmdlen = STRLEN(buff);
---
> 						p = history[histype][hiscnt];
> 
> 					alloc_cmdbuff(STRLEN(p));
> 					if (cmdbuff == NULL)
> 						goto returncmd;
> 					STRCPY(cmdbuff, p);
> 
> 					cmdpos = cmdlen = STRLEN(cmdbuff);
501c521
< 				putcmdline('^', buff);
---
> 				putcmdline('^');
508c528
< 				putcmdline('?', buff);
---
> 				putcmdline('?');
513c533
< 					putcmdline(c, buff);
---
> 					putcmdline(c);
524c544
< 		if (do_abbr && (c >= 0x100 || !isidchar(c)) && ccheck_abbr(c))
---
> 		if (do_abbr && (c >= 0x100 || !isidchar_id(c)) && ccheck_abbr(c))
527c547,552
< 		if (cmdlen < CMDBUFFSIZE - 3)
---
> 			/* check if cmdbuff needs to be longer */
> 		if (cmdlen + 3 >= cmdbufflen)
> 			i = realloc_cmdbuff(cmdlen);
> 		else
> 			i = OK;
> 		if (i == OK)
548c573,574
< 					memmove(buff + cmdpos + 1, buff + cmdpos, cmdlen - cmdpos);
---
> 					memmove(cmdbuff + cmdpos + 1,
> 										cmdbuff + cmdpos, cmdlen - cmdpos);
551,552c577,580
< 				buff[cmdpos] = i;
< 				msg_outtrans(buff + cmdpos, cmdlen - cmdpos);
---
> 				else if (cmdpos == cmdlen)
> 					++cmdlen;
> 				cmdbuff[cmdpos] = i;
> 				msg_outtrans_len(cmdbuff + cmdpos, cmdlen - cmdpos);
589c617
< 				buff[cmdlen] = NUL;
---
> 				cmdbuff[cmdlen] = NUL;
593c621
< 				i = dosearch(firstc, buff, FALSE, 1, FALSE, FALSE);
---
> 				i = dosearch(firstc, cmdbuff, FALSE, 1, FALSE, FALSE);
613d640
< 	retval = OK;				/* when we get here we have a valid command line */
623,627c650
< 	buff[cmdlen] = NUL;
< 	/*
< 	 * put line in history buffer (only when it was typed)
< 	 */
< 	if (cmdlen != 0 && KeyTyped)
---
> 	if (cmdbuff != NULL)
629c652,656
< 		if (hislen != 0 && !is_in_history(type, buff, TRUE))
---
> 		/*
> 		 * put line in history buffer (only when it was typed)
> 		 */
> 		cmdbuff[cmdlen] = NUL;
> 		if (cmdlen != 0 && KeyTyped)
631,634c658,669
< 			if (++hisidx[type] == hislen)
< 				hisidx[type] = 0;
< 			free(history[type][hisidx[type]]);
< 			history[type][hisidx[type]] = strsave(buff);
---
> 			if (hislen != 0 && !is_in_history(histype, cmdbuff, TRUE))
> 			{
> 				if (++hisidx[histype] == hislen)
> 					hisidx[histype] = 0;
> 				free(history[histype][hisidx[histype]]);
> 				history[histype][hisidx[histype]] = strsave(cmdbuff);
> 			}
> 			if (firstc == ':')
> 			{
> 				free(new_last_cmdline);
> 				new_last_cmdline = strsave(cmdbuff);
> 			}
636c671
< 		if (firstc == ':')
---
> 		if (gotesc)			/* abandon command line */
638,639c673,675
< 			free(new_last_cmdline);
< 			new_last_cmdline = strsave(buff);
---
> 			free(cmdbuff);
> 			cmdbuff = NULL;
> 			MSG("");
650c686,724
< 	return retval;
---
> 	return cmdbuff;
> }
> 
> 	void
> alloc_cmdbuff(len)
> 	int		len;
> {
> 	/*
> 	 * give some extra space to avoid having to allocate all the time
> 	 */
> 	if (len < 80)
> 		len = 100;
> 	else
> 		len += 20;
> 
> 	cmdbuff = alloc(len);		/* caller should check for out of memory */
> 	cmdbufflen = len;
> }
> 
> /*
>  * Re-allocate the command line to length len + something extra.
>  * return FAIL for failure, OK otherwise
>  */
> 	int
> realloc_cmdbuff(len)
> 	int		len;
> {
> 	char_u		*p;
> 
> 	p = cmdbuff;
> 	alloc_cmdbuff(len);				/* will get some more */
> 	if (cmdbuff == NULL)			/* out of memory */
> 	{
> 		cmdbuff = p;				/* keep the old one */
> 		return FAIL;
> 	}
> 	memmove((char *)cmdbuff, (char *)p, (size_t)cmdlen);
> 	free(p);
> 	return OK;
658c732
< putcmdline(c, buff)
---
> putcmdline(c)
660d733
< 	char_u	*buff;
662c735
< 	char_u	buf[2];
---
> 	char_u	buf[1];
665,667c738,739
< 	buf[1] = 0;
< 	msg_outtrans(buf, 1);
< 	msg_outtrans(buff + cmdpos, cmdlen - cmdpos);
---
> 	msg_outtrans_len(buf, 1);
> 	msg_outtrans_len(cmdbuff + cmdpos, cmdlen - cmdpos);
672c744,745
<  * this fuction is called when the screen size changes
---
>  * this fuction is called when the screen size changes and with incremental
>  * search
686c759,760
< 	cmdline_row = lastwin->w_winpos + lastwin->w_height + lastwin->w_status_height;
---
> 	cmdline_row = lastwin->w_winpos + lastwin->w_height +
> 										lastwin->w_status_height;
699c773
< 	msg_outtrans(cmdbuff, cmdlen);
---
> 	msg_outtrans_len(cmdbuff, cmdlen);
749c823
< 	char_u		buff[CMDBUFFSIZE];		/* command line */
---
> 	int			cmdlinelen;
751a826
> 	int			got_cmdline = FALSE;	/* TRUE when cmdline was typed */
754c829,831
<  * 1. If no line given: get one.
---
>  * 1. If no line given: Get a line in cmdbuff.
>  *    If a line is given: Copy it into cmdbuff.
>  *    After this we don't use cmdbuff but cmdline, because of recursiveness
758c835
< 		if (getcmdline(':', buff) == FAIL)
---
> 		if ((cmdline = getcmdline(':')) == NULL)
764a842
> 		got_cmdline = TRUE;
768,772d845
< 		if (STRLEN(cmdline) > (size_t)(CMDBUFFSIZE - 2))
< 		{
< 			emsg(e_toolong);
< 			return FAIL;
< 		}
774c847,851
< 		STRCPY(buff, cmdline);
---
> 		alloc_cmdbuff(STRLEN(cmdline));
> 		if (cmdbuff == NULL)
> 			return FAIL;
> 		STRCPY(cmdbuff, cmdline);
> 		cmdline = cmdbuff;
775a853
> 	cmdlinelen = cmdbufflen;		/* we need to copy it for recursiveness */
794c872,873
<  *    DoOneCmd will set nextcommand to NULL if there is no trailing '|'.
---
>  *    DoOneCmd will set nextcomm to NULL if there is no trailing '|'.
>  *    cmdline and cmdlinelen may change, e.g. for '%' and '#' expansion.
799c878
< 		nextcomm = DoOneCmd(buff, sourcing);
---
> 		nextcomm = DoOneCmd(&cmdline, &cmdlinelen, sourcing);
802c881
< 		STRCPY(buff, nextcomm);
---
> 		STRCPY(cmdline, nextcomm);
804a884
> 	free(cmdline);
825c905
< 	if (cmdline == NULL && new_last_cmdline != NULL)
---
> 	if (got_cmdline && new_last_cmdline != NULL)
848,849c928,930
< DoOneCmd(buff, sourcing)
< 	char_u		*buff;
---
> DoOneCmd(cmdlinep, cmdlinelenp, sourcing)
> 	char_u		**cmdlinep;
> 	int			*cmdlinelenp;
852d932
< 	char_u				cmdbuf[CMDBUFFSIZE];	/* for '%' and '#' expansion */
855a936
> 	char_u				*s;
867c948
< 	int					usefilter = FALSE;		/* filter instead of file name */
---
> 	int					usefilter = FALSE;		/* no read/write but filter */
872a954
> 		/* when not editing the last file :q has to be typed twice */
874c956,959
< 		--quitmore;		/* when not editing the last file :q has to be typed twice */
---
> 		--quitmore;
> 	did_emsg = FALSE;		/* will be set to TRUE when emsg() used, in which
> 							 * case we set nextcomm to NULL to cancel the
> 							 * whole command line */
878c963
< 	for (cmd = buff; *cmd && strchr(" \t:|", *cmd) != NULL; cmd++)
---
> 	for (cmd = *cmdlinep; *cmd && strchr(" \t:|", *cmd) != NULL; cmd++)
1012c1097,1101
< 			errormsg = e_invcmd;
---
> 			c = *p;
> 			*p = NUL;
> 			sprintf((char *)IObuff, "%s: Not an editor command", cmd);
> 			errormsg = IObuff;
> 			*p = c;
1088,1090c1177,1178
< 		if (STRLEN(p_mp) + STRLEN(p) + 2 >= (unsigned)CMDBUFFSIZE)
< 		{
< 			errormsg = e_toolong;
---
> 		alloc_cmdbuff(STRLEN(p_mp) + STRLEN(p) + 2);
> 		if (cmdbuff == NULL)		/* out of memory */
1092,1097c1180,1187
< 		}
< 		STRCPY(cmdbuf, p_mp);
< 		STRCAT(cmdbuf, " ");
< 		STRCAT(cmdbuf, p);
< 		STRCPY(buff,   cmdbuf);
< 		p = buff;
---
> 		STRCPY(cmdbuff, p_mp);
> 		STRCAT(cmdbuff, " ");
> 		STRCAT(cmdbuff, p);
> 			/* 'cmd' is not set here, because it is not used at CMD_make */
> 		free(*cmdlinep);
> 		*cmdlinep = cmdbuff;
> 		*cmdlinelenp = cmdbufflen;
> 		p = cmdbuff;
1103,1108d1192
< 	if ((argt & NEEDARG) && *arg == NUL)
< 	{
< 		errormsg = e_argreq;
< 		goto doend;
< 	}
< 
1168c1252
< 				if ((argt & USECTRLV) && p[1] != NUL)
---
> 				if ((argt & (USECTRLV | XFILE)) && p[1] != NUL)
1176c1260
< 				if (*(p - 1) == '\\')	/* remove the backslash */
---
> 				if (!(argt & USECTRLV) && *(p - 1) == '\\')
1178c1262
< 					STRCPY(p - 1, p);
---
> 					STRCPY(p - 1, p);	/* remove the backslash */
1238a1323,1328
> 	if ((argt & NEEDARG) && *arg == NUL)
> 	{
> 		errormsg = e_argreq;
> 		goto doend;
> 	}
> 
1248a1339
> 				/* Note: In "\\%" the % is also not recognized */
1275c1366
< 			i = STRLEN(arg) + STRLEN(q) + 3;
---
> 			i = STRLEN(*cmdlinep) + STRLEN(q) + 3;
1278,1282c1369,1371
< 			if (i > CMDBUFFSIZE)
< 			{
< 				errormsg = e_toolong;
< 				goto doend;
< 			}
---
> 			alloc_cmdbuff(i);
> 			if (cmdbuff == NULL)
> 				goto doend;					/* out of memory */
1284c1373
< 			 * we built the new argument in cmdbuf[], then copy it back to buff[]
---
> 			 * we built the new argument in cmdbuff[]
1287,1289c1376,1378
< 			STRCPY(cmdbuf, arg);				/* copy up to there */
< 			i = p - arg;						/* remember the lenght */
< 			STRCAT(cmdbuf, q);					/* append the file name */
---
> 			STRCPY(cmdbuff, *cmdlinep);			/* copy up to there */
> 			i = p - *cmdlinep;					/* remember the lenght */
> 			STRCAT(cmdbuff, q);					/* append the file name */
1293,1304c1382,1384
< 				if ((arg = (char_u *)strrchr((char *)q, '.')) != NULL &&
< 								arg >= gettail(q))
< 					*(cmdbuf + (arg - q) + i) = NUL;
< 			}
< 			i = STRLEN(cmdbuf);					/* remember the end of the filename */
< 			STRCAT(cmdbuf, p+n);				/* append what is after '#' or '%' */
< 			p = buff + i - 1;					/* remember where to continue */
< 			if (nextcomm)						/* append next command */
< 			{
< 				i = STRLEN(cmdbuf) + 1;
< 				STRCPY(cmdbuf + i, nextcomm);
< 				nextcomm = buff + i;
---
> 				if ((s = (char_u *)strrchr((char *)q, '.')) != NULL &&
> 															s >= gettail(q))
> 					*(cmdbuff + (s - q) + i) = NUL;
1306,1307c1386,1399
< 			STRCPY(buff, cmdbuf);				/* copy back to buff[] */
< 			arg = buff;
---
> 			i = STRLEN(cmdbuff);		/* remember the end of the filename */
> 			STRCAT(cmdbuff, p+n);		/* append what is after '#' or '%' */
> 			p = cmdbuff + i - 1;		/* remember where to continue */
> 			if (nextcomm)				/* append next command */
> 			{
> 				i = STRLEN(cmdbuff) + 1;
> 				STRCPY(cmdbuff + i, nextcomm);
> 				nextcomm = cmdbuff + i;
> 			}
> 			cmd = cmdbuff + (cmd - *cmdlinep);
> 			arg = cmdbuff + (arg - *cmdlinep);
> 			free(*cmdlinep);
> 			*cmdlinep = cmdbuff;
> 			*cmdlinelenp = cmdbufflen;
1333a1426,1432
> 			/*
> 			 * halve the number of backslashes (this is vi compatible)
> 			 */
> 			for (p = arg; *p; ++p)
> 				if (*p == '\\')
> 					STRCPY(p, p + 1);
> 
1338,1341c1437,1457
< 				if (STRLEN(p) + arg - buff < CMDBUFFSIZE - 2)
< 					STRCPY(arg, p);
< 				else
< 					emsg(e_toolong);
---
> 				n = arg - *cmdlinep;
> 				i = STRLEN(p) + n;
> 				if (nextcomm)
> 					i += STRLEN(nextcomm);
> 				alloc_cmdbuff(i);
> 				if (cmdbuff != NULL)
> 				{
> 					STRNCPY(cmdbuff, *cmdlinep, n);
> 					STRCPY(cmdbuff + n, p);
> 					if (nextcomm)				/* append next command */
> 					{
> 						i = STRLEN(cmdbuff) + 1;
> 						STRCPY(cmdbuff + i, nextcomm);
> 						nextcomm = cmdbuff + i;
> 					}
> 					cmd = cmdbuff + (cmd - *cmdlinep);
> 					arg = cmdbuff + n;
> 					free(*cmdlinep);
> 					*cmdlinep = cmdbuff;
> 					*cmdlinelenp = cmdbufflen;
> 				}
1348a1465,1477
>  *    arg		points to the argument of the command
>  *    nextcomm	points to the next command (if any)
>  *	  cmd		points to the name of the command (except for :make)
>  *	  cmdidx	is the index for the command
>  *	  forceit	is TRUE if ! present
>  *	  addr_count is the number of addresses given
>  *	  line1		is the first line number
>  *	  line2		is the second line number or count
>  *	  editcmd	is +command argument to be used in edited file
>  *	  doecmdlnum  is the line number in edited file
>  *	  append	is TRUE with ":w >>file" command
>  *	  usefilter is TRUE with ":w !command" and ":r!command"
>  *	  amount	is number of '>' or '<' for shift command
1482,1483c1611
< 							(*arg == NUL || setfname(arg, NULL, TRUE) == OK) &&
< 							check_fname() == OK)
---
> 							(*arg == NUL || setfname(arg, NULL, TRUE) == OK))
1513c1641
< 					msg_outstr(arg_files[i]);
---
> 					msg_outtrans(arg_files[i]);
1570c1698
< 					register int other = FALSE;
---
> 					register int other;
1767a1896
> 				 * :sview [+command] file    split window with new file, ro
1770a1900
> 		case CMD_sview:
1780a1911
> 		case CMD_view:
1783a1915,1918
> 				{
> 					n = readonlymode;
> 					if (cmdidx == CMD_view || cmdidx == CMD_sview)
> 						readonlymode = TRUE;
1784a1920,1921
> 					readonlymode = n;
> 				}
1801,1802c1938,1949
< 					curwin->w_alt_fnum = curbuf->b_fnum;
< 					buflist_altlnum();
---
> 					/*
> 					 * The name of the current buffer will be changed.
> 					 * A new buffer entry needs to be made to hold the old
> 					 * file name, which will become the alternate file name.
> 					 */
> 					char_u		*fname, *sfname;
> 					BUF			*buf;
> 
> 					fname = curbuf->b_filename;
> 					sfname = curbuf->b_sfilename;
> 					curbuf->b_filename = NULL;
> 					curbuf->b_sfilename = NULL;
1803a1951,1953
> 					{
> 						curbuf->b_filename = fname;
> 						curbuf->b_sfilename = sfname;
1804a1955
> 					}
1805a1957,1962
> 					buf = buflist_new(fname, sfname,
> 											curwin->w_cursor.lnum, FALSE);
> 					if (buf != NULL)
> 						curwin->w_alt_fnum = buf->b_fnum;
> 					free(fname);
> 					free(sfname);
1853c2010
< 				if (*arg == NUL)	 /* use cmdbuf for home directory name */
---
> 				if (*arg == NUL)	 /* use NameBuff for home directory name */
1855,1856c2012,2013
< 					expand_env((char_u *)"$HOME", cmdbuf, CMDBUFFSIZE);
< 					arg = cmdbuf;
---
> 					expand_env((char_u *)"$HOME", NameBuff, MAXPATHL);
> 					arg = NameBuff;
1946c2103
< 				domarks();
---
> 				domarks(arg);
1952a2110,2113
> 		case CMD_ascii:
> 				do_ascii();
> 				break;
> 
1954c2115
< 				find_pattern_in_path(NULL, 0, FALSE, CHECK_PATH, 1, 1,
---
> 				find_pattern_in_path(NULL, 0, FALSE, FALSE, CHECK_PATH, 1L, 1,
1974c2135,2145
< 				do_autocmd(arg, forceit);	/* manipulate the auto commands */
---
> 				/*
> 				 * Disallow auto commands from .exrc and .vimrc in current
> 				 * directory for security reasons.
> 				 */
> 				if (secure)
> 				{
> 					secure = 2;
> 					errormsg = e_curdir;
> 				}
> 				else
> 					do_autocmd(arg, forceit);	/* handle the auto commands */
1978c2149,2150
< 				apply_autocmds(arg);		/* apply the automa commands */
---
> 				apply_autocmds(arg);		/* apply the automatic commands */
> 				do_mlines();
1992a2165,2166
> 		case CMD_nmap:
> 		case CMD_vmap:
1995a2170,2171
> 		case CMD_nnoremap:
> 		case CMD_vnoremap:
2006c2182
< 					msg_outtrans(cmd, -1);
---
> 					msg_outtrans(cmd);
2008a2185,2186
> 		case CMD_nunmap:
> 		case CMD_vunmap:
2014c2192
< 				if (*cmd == 'c')		/* cmap, cunmap, cnoremap, etc. */
---
> 				if (*cmd == 'c')			/* cmap, cunmap, cnoremap, etc. */
2019c2197
< 				else if (*cmd == 'i')	/* imap, iunmap, inoremap, etc. */
---
> 				else if (*cmd == 'i')		/* imap, iunmap, inoremap, etc. */
2024c2202,2213
< 				else if (forceit || i)	/* map!, unmap!, noremap!, abbrev */
---
> 											/* nmap, nunmap, nnoremap */
> 				else if (*cmd == 'n' && *(cmd + 1) != 'o')
> 				{
> 					i += NORMAL;
> 					++cmd;
> 				}
> 				else if (*cmd == 'v')		/* vmap, vunmap, vnoremap */
> 				{
> 					i += VISUAL;
> 					++cmd;
> 				}
> 				else if (forceit || i)		/* map!, unmap!, noremap!, abbrev */
2026,2027c2215,2216
< 				else
< 					i += NORMAL;			/* map, unmap, noremap */
---
> 				else						/* map, unmap, noremap */
> 					i += NORMAL + VISUAL;
2040c2229
< 				dodis();		/* display buffer contents */
---
> 				dodis(arg);		/* display buffer contents */
2044c2233
< 				help();
---
> 				dohelp(arg);
2099c2288
< 					goto doend;
---
> 					break;
2188c2377
< 					emsg("Cannot open viminfo file for reading");
---
> 					EMSG("Cannot open viminfo file for reading");
2301c2490
< 				n = ACTION_SHOW;
---
> 				i = ACTION_SHOW;
2306c2495
< 				n = ACTION_SHOW_ALL;
---
> 				i = ACTION_SHOW_ALL;
2311c2500
< 				n = ACTION_GOTO;
---
> 				i = ACTION_GOTO;
2316c2505
< 				n = ACTION_SPLIT;
---
> 				i = ACTION_SPLIT;
2318,2322c2507,2525
< 				find_pattern_in_path(arg, STRLEN(arg), !forceit,
< 					*cmd == 'd' ?  FIND_DEFINE : FIND_ANY,
< 					1L,
< 					n,
< 					line1, line2);
---
> 				{
> 					int		whole = TRUE;
> 
> 					if (*arg == '+')		/* don't match whole words */
> 					{
> 						whole = FALSE;
> 						++arg;
> 						skipwhite(&arg);
> 					}
> 					n = 1;
> 					if (isdigit(*arg))		/* get count */
> 					{
> 						n = getdigits(&arg);
> 						skipwhite(&arg);
> 					}
> 					find_pattern_in_path(arg, STRLEN(arg), whole, !forceit,
> 						*cmd == 'd' ?  FIND_DEFINE : FIND_ANY,
> 						n, i, line1, line2);
> 				}
2333a2537
> 		emsg(errormsg);
2336,2337c2540,2541
< 			sprintf((char *)IObuff, "%s: %s", errormsg, buff);
< 			emsg(IObuff);
---
> 			MSG_OUTSTR(": ");
> 			msg_outtrans(*cmdlinep);
2339,2340d2542
< 		else
< 			emsg(errormsg);
2341a2544,2545
> 	if (did_emsg)
> 		nextcomm = NULL;				/* cancel nextcomm at an error */
2600c2804
< 	if (newlnum && command == NULL)
---
> 	if (command == NULL)
2602,2604c2806,2813
< 		curwin->w_cursor.lnum = newlnum;
< 		check_cursor();
< 		beginline(MAYBE);
---
> 		if (newlnum)
> 		{
> 			curwin->w_cursor.lnum = newlnum;
> 			check_cursor();
> 			beginline(MAYBE);
> 		}
> 		else
> 			beginline(TRUE);
2606d2814
< 	check_cursor();
2671c2879
< 	msg_outstr(arg);		/* show what we are doing */
---
> 	msg_outtrans(arg);				/* show what we are doing */
2974,2975c3182
< nextwild(buff, type)
< 	char_u *buff;
---
> nextwild(type)
2982a3190
> 	int		v;
2998c3206
< 	msg_outstr((char_u *)"...");		/* show that we are busy */
---
> 	MSG_OUTSTR("...");		/* show that we are busy */
3001c3209
< 	i = expand_pattern - buff;
---
> 	i = expand_pattern - cmdbuff;
3005c3213
< 	if ((p1 = addstar(&buff[i], oldlen)) != NULL)
---
> 	if ((p1 = addstar(&cmdbuff[i], oldlen)) != NULL)
3009,3010c3217,3218
< 			if (cmdlen + (difflen = STRLEN(p2) - oldlen) > CMDBUFFSIZE - 4)
< 				emsg(e_toolong);
---
> 			if (cmdlen + (difflen = STRLEN(p2) - oldlen) > cmdbufflen - 4)
> 				v = realloc_cmdbuff(cmdlen + difflen);
3011a3220,3221
> 				v = OK;
> 			if (v == OK)
3013,3014c3223,3224
< 				vim_strncpy(&buff[cmdpos + difflen], &buff[cmdpos], cmdlen - cmdpos);
< 				STRNCPY(&buff[i], p2, STRLEN(p2));
---
> 				vim_strncpy(&cmdbuff[cmdpos + difflen], &cmdbuff[cmdpos], cmdlen - cmdpos);
> 				STRNCPY(&cmdbuff[i], p2, STRLEN(p2));
3030c3240
< 	expand_interactively = FALSE;
---
> 	expand_interactively = FALSE;			/* reset for next call */
3180a3391,3393
> #ifdef ADDED_BY_WEBB_COMPILE
> 	/* Statement has no effect.  I think you've already fixed this one */
> #else
3181a3395
> #endif /* ADDED_BY_WEBB_COMPILE */
3264c3478
< 		j = STRLEN(files_found[i]);
---
> 		j = strsize(files_found[i]);
3284c3498
< 				for (j = maxlen - STRLEN(files_found[k - lines]); --j >= 0; )
---
> 				for (j = maxlen - strsize(files_found[k - lines]); --j >= 0; )
3295c3509
< 			msg_outstr(files_found[k]);
---
> 			msg_outtrans(files_found[k]);
3321c3535,3538
<  * copy the file name into allocated memory and add a '*' at the end
---
>  * When expanding file names:
>  *	copy the file name into allocated memory and add a '*' at the end
>  * When expanding other names:
>  *  copy the name into allocated memory and add ".*" at the end
3417a3635
> 	sourcing_lnum = 1;
3438a3657
> 				++sourcing_lnum;
3445a3665
> 		++sourcing_lnum;
3451a3672
> 	sourcing_lnum = 0;
3602a3824
>  *	  EXPAND_HELP --- Complete tags from the file 'helpfile'/vim_tags
3920a4143,4146
> 		case CMD_help:
> 			expand_context = EXPAND_HELP;
> 			expand_pattern = arg;
> 			break;
4001c4227,4229
< 		ret = ExpandTags(prog, num_file, file);
---
> 		ret = ExpandTags(prog, num_file, file, FALSE);
> 	else if (expand_context == EXPAND_HELP)
> 		ret = ExpandTags(prog, num_file, file, TRUE);
Index: ./src/cmdtab.tab
diff -r ../vim.orig/src/cmdtab.tab ./src/cmdtab.tab
49c49
< 	short	 cmd_argt;	/* command line arguments permitted/needed/used */
---
> 	short_u	 cmd_argt;	/* command line arguments permitted/needed/used */
57c57,58
< 	{(char_u *)"autocmd",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
---
> 	{(char_u *)"ascii",			TRLBAR},
> 	{(char_u *)"autocmd",		BANG+EXTRA+NOTRLCOM+USECTRLV},
89c90
< 	{(char_u *)"display",		TRLBAR},
---
> 	{(char_u *)"display",		EXTRA+NOTRLCOM+TRLBAR},
102c103
< 	{(char_u *)"help",			TRLBAR},
---
> 	{(char_u *)"help",			EXTRA+TRLBAR},
123c124
< 	{(char_u *)"marks",			TRLBAR},
---
> 	{(char_u *)"marks",			EXTRA+TRLBAR},
131a133,134
> 	{(char_u *)"nmap",			BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
> 	{(char_u *)"nnoremap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
135a139
> 	{(char_u *)"nunmap",		BANG+EXTRA+TRLBAR+USECTRLV},
179a184
> 	{(char_u *)"sview",			NEEDARG+RANGE+BANG+FILE1+EDITCMD+TRLBAR},
190a196,199
> 	{(char_u *)"view",			RANGE+BANG+FILE1+EDITCMD+TRLBAR},
> 	{(char_u *)"vmap",			BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
> 	{(char_u *)"vnoremap",		BANG+EXTRA+TRLBAR+NOTRLCOM+USECTRLV},
> 	{(char_u *)"vunmap",		BANG+EXTRA+TRLBAR+USECTRLV},
Index: ./src/csearch.c
diff -r ../vim.orig/src/csearch.c ./src/csearch.c
61c61
< 	char_u		   *pat = NULL, *sub = NULL;
---
> 	char_u		   *pat, *sub;
83c83
< 			emsg("Regular expressions can't be delimited by letters or digits");
---
> 			EMSG("Regular expressions can't be delimited by letters or digits");
Index: ./src/digraph.c
diff -r ../vim.orig/src/digraph.c ./src/digraph.c
197c197
< 	static int	backspaced;		/* character before BS */
---
> 	static int	backspaced;		/* character before K_BS */
209c209
< 		if (c == BS && lastchar >= 0)
---
> 		if (c == K_BS && lastchar >= 0)
354c354
< 			msg_outstr((char_u *)"   ");
---
> 			MSG_OUTSTR("   ");
Index: ./src/edit.c
diff -r ../vim.orig/src/edit.c ./src/edit.c
85c85
< 	FPOS		*complete_pos = NULL;
---
> 	FPOS		*complete_pos;
89c89
< 	char_u		*quick_m = NULL;			/* Message without sleep */
---
> 	char_u		*quick_m;					/* Message without sleep */
94c94,95
< 	int			 done_dir = 0;				/* Found all matches in this direction */
---
> 	int			 done_dir = 0;				/* Found all matches in this
> 											 * direction */
98a100
> 	int			 save_sm = -1;				/* init for gcc */
100,101c102
< 	c = NUL;
< 
---
> 	clear_showcmd();
183c184
< 				case Ctrl('G'):
---
> 				case Ctrl('I'):
185c186
< 					edit_submode = (char_u *)"Path pattern completion (^G/^N/^P)";
---
> 					edit_submode = (char_u *)"Path pattern completion (^N/^P)";
241,245c242,243
< 					temp = 0;
< 					while (tmp_ptr[temp])
< 						tmp_ptr[temp++] = BS;
< 					if (*tmp_ptr)
< 						AppendToRedobuff(tmp_ptr);
---
> 					for (temp = 0; tmp_ptr[temp]; ++temp)
> 						AppendCharToRedobuff(K_BS);
251c249
< 				insertchar(NUL, FALSE);
---
> 				insertchar(NUL, FALSE, -1);
260a259
> 				p_sm = save_sm;
281c280,282
< 			setcursor();
---
> 
> 			if (!add_to_showcmd(c))
> 				setcursor();
283a285
> 			clear_showcmd();
301c303
< 				MSG("^X mode (^E/^Y/^L/^]/^F/^G/^D)");
---
> 				MSG("^X mode (^E/^Y/^L/^]/^F/^I/^D)");
369a372
> 				add_to_showcmd(c);
371a375
> 				clear_showcmd();
404a409
> 					i = curwin->w_cursor.col;
414a420
> 					i = curwin->w_cursor.col;
453a460,462
> 				/* May have to adjust the start of the insert. -- webb */
> 				if (curwin->w_cursor.lnum == Insstart.lnum && Insstart.col != 0)
> 					Insstart.col += curwin->w_cursor.col - i;
460a470
> 				can_si_back = FALSE;
463d472
< 			  case DEL:
481a491
> 				can_si_back = FALSE;
485,486c495
< 			  case BS:
< nextbs:
---
> 			  case K_BS:
554c563
< 							for (i = 0; cc > 0; ++i)
---
> 							while (cc > 0)
599c608
< 							temp = isidchar(gchar_cursor());
---
> 							temp = isidchar_id(gchar_cursor());
602c611,612
< 						else if (mode == 2 && (isspace(cc = gchar_cursor()) || isidchar(cc) != temp))
---
> 						else if (mode == 2 && (isspace(cc = gchar_cursor()) ||
> 												isidchar_id(cc) != temp))
631c641,642
< 					} while (revins || (curwin->w_cursor.col > mincol && (curwin->w_cursor.lnum != Insstart.lnum ||
---
> 					} while (revins || (curwin->w_cursor.col > mincol &&
> 							(curwin->w_cursor.lnum != Insstart.lnum ||
635a647
> 				can_si_back = FALSE;
644,648d655
< 				if (vpeekc() == BS)
< 				{
< 						c = vgetc();
< 						goto nextbs;	/* speedup multiple backspaces */
< 				}
664c671,673
< 				if (jumpto(mouse_row, mouse_col) == OK)
---
> 				(void)vgetc();		/* get and ignore button specifier */
> 				mouse_code = 0;		/* reset for next click */
> 				if (jumpto(mouse_row, mouse_col, FALSE, TRUE) == OK)
767c776,779
< 			  case TAB:
---
> 			  case TAB:				/* TAB or Complete patterns along path */
> 				if (ctrl_x_mode == CTRL_X_PATH_PATTERNS)
> 					goto docomplete;
> 
782a795
> 				can_si_back = FALSE;
811c824,825
< 				if (curbuf->b_p_fo != NULL && STRCHR(curbuf->b_p_fo, FO_RET_COMS) != NULL)
---
> 				if (curbuf->b_p_fo != NULL &&
> 								STRCHR(curbuf->b_p_fo, FO_RET_COMS) != NULL)
826c840,841
< 				setcursor();
---
> 				if (!add_to_showcmd(c))
> 					setcursor();
836c851,852
< 					setcursor();
---
> 					if (!add_to_showcmd(c))
> 						setcursor();
841a858
> 						clear_showcmd();
844a862
> 				clear_showcmd();
849,853d866
< 			  case Ctrl('G'):			/* Complete patterns along path */
< 				if (ctrl_x_mode != CTRL_X_PATH_PATTERNS)
< 					goto normalchar;
< 				goto docomplete;
< 
879a893,897
> 
> 					/* Turn off 'sm' so we don't show matches with ^X^L */
> 					save_sm = p_sm;
> 					p_sm = FALSE;
> 
887a906
> 					can_si_back = FALSE;
898c917
< 						if (temp < 0 || !isidchar(ptr[temp]))
---
> 						if (temp < 0 || !isidchar_id(ptr[temp]))
903,904c922
< 									(char_u *)"\\<[a-zA-Z%s][a-zA-Z0-9%s]",
< 											idp, idp);
---
> 									"\\<[a-zA-Z%s][a-zA-Z0-9%s]", idp, idp);
913c931
< 							while (temp >= 0 && isidchar(ptr[temp]))
---
> 							while (temp >= 0 && isidchar_id(ptr[temp]))
975c993
< 								STRLEN(complete_pat), FALSE,
---
> 								STRLEN(complete_pat), FALSE, FALSE,
977c995
< 							: FIND_ANY, 1, ACTION_EXPAND,
---
> 							: FIND_ANY, 1L, ACTION_EXPAND,
999,1000c1017,1018
< 							ExpandTags(prog, &num_matches, &matches) == OK &&
< 							num_matches > 0)
---
> 							ExpandTags(prog, &num_matches, &matches, FALSE)
> 													== OK && num_matches > 0)
1134c1152
< 							while (*tmp_ptr != NUL && isidchar(*tmp_ptr++))
---
> 							while (*tmp_ptr != NUL && isidchar_id(*tmp_ptr++))
1257,1258c1275,1276
< 				if ((curwin->w_cursor.col > 0 && did_si && c == '{') ||
< 													(can_si && c == '}'))
---
> 				if (((did_si || can_si_back) && c == '{') ||
> 								(can_si && c == '}'))
1302c1320
< 				if (isidchar(c) || !echeck_abbr(c))
---
> 				if (isidchar_id(c) || !echeck_abbr(c))
1324c1342
< 					c == Ctrl('G') || c == Ctrl('D') || c == Ctrl('P') ||
---
> 					c == Ctrl('I') || c == Ctrl('D') || c == Ctrl('P') ||
1345c1363
< 			if (c == Ctrl('G') || c == Ctrl('P') || c == Ctrl('N'))
---
> 			if (c == Ctrl('P') || c == Ctrl('N'))
1535c1553
< 	char_u	buf[LSIZE];
---
> 	char_u	*buf;
1539a1558,1559
> 	if ((buf = alloc(LSIZE)) == NULL)
> 		return;
1574c1594
< 						while (isidchar(*ptr))
---
> 						while (isidchar_id(*ptr))
1590a1611
> 	free(buf);
1654a1676,1677
> 		if (!(oldstate & CMDLINE))
> 			add_to_showcmd(nc);
1695c1718
< 		insertchar(K_SPECIAL, FALSE);
---
> 		insertchar(K_SPECIAL, FALSE, -1);
1698c1721
< 	insertchar(c, FALSE);
---
> 	insertchar(c, FALSE, -1);
1712c1735
< insertchar(c, force_formatting)
---
> insertchar(c, force_formatting, second_indent)
1714a1738
> 	int			second_indent;			/* indent for second line if >= 0 */
1719a1744
> 	int		first_line = TRUE;
1742c1767
< 				!(isspace(c) || (State == REPLACE && *ml_get_cursor() != NUL)))
---
> 				!(iswhite(c) || (State == REPLACE && *ml_get_cursor() != NUL)))
1766c1791
< 			coladvance(textwidth);			/* find column of textwidth border */
---
> 			coladvance(textwidth);		/* find column of textwidth border */
1771c1796
< 			while (curwin->w_cursor.col > 0)			/* find position to break at */
---
> 			while (curwin->w_cursor.col > 0)	/* find position to break at */
1773c1798
< 				if (isspace(gchar_cursor()))
---
> 				if (iswhite(gchar_cursor()))
1777c1802
< 					while (curwin->w_cursor.col > 0 && isspace(gchar_cursor()))
---
> 					while (curwin->w_cursor.col > 0 && iswhite(gchar_cursor()))
1779,1780c1804,1805
< 					if (curwin->w_cursor.col == 0)	/* only spaces in front of text */
< 						break;
---
> 					if (curwin->w_cursor.col == 0)
> 						break;			/* only spaces in front of text */
1807c1832
< 			while (isspace(gchar_cursor()))
---
> 			while (iswhite(gchar_cursor()))
1824a1850,1852
> 			if (second_indent >= 0 && first_line)
> 				set_indent(second_indent, TRUE);
> 			first_line = FALSE;
1848a1877
> 	can_si_back = FALSE;
1863c1892
< 					!(!no_abbr && !isidchar(c) && isidchar(p[i - 1])))
---
> 					!(!no_abbr && !isidchar_id(c) && isidchar_id(p[i - 1])))
1951a1981
> 	can_si_back = FALSE;
2182c2212
<  * the replacement string is inserted in typestr, followed by "c".
---
>  * the replacement string is inserted in typebuf[], followed by "c".
2287c2317
< 		idp = "_";
---
> 		idp = (char_u *)"";		/* out of memory, just return empty string */
Index: ./src/fileio.c
diff -r ../vim.orig/src/fileio.c ./src/fileio.c
40d39
< static void do_mlines __ARGS((void));
58c57,58
< 	msg_outstr(IObuff);
---
> 	msg_outtrans(IObuff);
> 	stop_highlight();
87,89d86
< #ifdef UNIX
< 	int 				fd = -1;
< #else
91d87
< #endif
247a244,245
> 			/* If you have 4 byte ints, the compiler may give a warning that
> 			 * the next statement is not reached. Just ignore it. */
435,436d432
< 	if (newfile)		/* edit a new file: read mode from lines */
< 		do_mlines();
997c993
< 			newfile ? " [New File]" : " ",
---
> 			newfile ? " [New File]" : "",
999c995
< 			buf->b_p_tx ? "" : "[notextmode]",
---
> 			buf->b_p_tx ? "" : " [notextmode]",
1001c997
< 			buf->b_p_tx ? "[textmode]" : "",
---
> 			buf->b_p_tx ? " [textmode]" : "",
1085a1082,1088
> 		/* can't use emsg() here, do something alike */
> 		if (p_eb)
> 			beep_flush();			/* also includes flush_buffers() */
> 		else
> 			flush_buffers(FALSE);	/* flush internal buffers */
> 		(void)set_highlight('e');	/* set highlight mode for error messages */
> 		start_highlight();
1090,1091c1093,1094
< 			msg_outstr("\nWARNING: Original file may be lost or damaged\n");
< 			msg_outstr("don't quit the editor until the file is sucessfully written!");
---
> 			MSG_OUTSTR("\nWARNING: Original file may be lost or damaged\n");
> 			MSG_OUTSTR("don't quit the editor until the file is sucessfully written!");
1123,1202d1125
<  * do_mlines() - process mode lines for the current file
<  *
<  * Returns immediately if the "ml" parameter isn't set.
<  */
< static void 	chk_mline __ARGS((linenr_t));
< 
< 	static void
< do_mlines()
< {
< 	linenr_t		lnum;
< 	int 			nmlines;
< 
< 	if (!curbuf->b_p_ml || (nmlines = (int)p_mls) == 0)
< 		return;
< 
< 	sourcing_name = (char_u *)"modelines";
< 	for (lnum = 1; lnum <= curbuf->b_ml.ml_line_count && lnum <= nmlines; ++lnum)
< 		chk_mline(lnum);
< 
< 	for (lnum = curbuf->b_ml.ml_line_count; lnum > 0 && lnum > nmlines &&
< 							lnum > curbuf->b_ml.ml_line_count - nmlines; --lnum)
< 		chk_mline(lnum);
< 	sourcing_name = NULL;
< }
< 
< /*
<  * chk_mline() - check a single line for a mode string
<  */
< 	static void
< chk_mline(lnum)
< 	linenr_t lnum;
< {
< 	register char_u	*s;
< 	register char_u	*e;
< 	char_u			*cs;			/* local copy of any modeline found */
< 	int				prev;
< 	int				end;
< 
< 	prev = ' ';
< 	for (s = ml_get(lnum); *s != NUL; ++s)
< 	{
< 		if (isspace(prev) && (STRNCMP(s, "vi:", (size_t)3) == 0 ||
< 					STRNCMP(s, "ex:", (size_t)3) == 0 ||
< 					STRNCMP(s, "vim:", (size_t)4) == 0))
< 		{
< 			do
< 				++s;
< 			while (s[-1] != ':');
< 			s = cs = strsave(s);
< 			if (cs == NULL)
< 				break;
< 			end = FALSE;
< 			while (end == FALSE)
< 			{
< 				while (*s == ' ' || *s == TAB)
< 					++s;
< 				if (*s == NUL)
< 					break;
< 				for (e = s; (*e != ':' || *(e - 1) == '\\') && *e != NUL; ++e)
< 					;
< 				if (*e == NUL)
< 					end = TRUE;
< 				*e = NUL;
< 				if (STRNCMP(s, "set ", (size_t)4) == 0) /* "vi:set opt opt opt: foo" */
< 				{
< 					(void)doset(s + 4);
< 					break;
< 				}
< 				if (doset(s) == FAIL)		/* stop if error found */
< 					break;
< 				s = e + 1;
< 			}
< 			free(cs);
< 			break;
< 		}
< 		prev = *s;
< 	}
< }
< 
< /*
1342c1265
< 			eof = fgets((char *)IObuff, IOSIZE, fp);
---
> 			fgets((char *)IObuff, IOSIZE, fp);
Index: ./src/getchar.c
diff -r ../vim.orig/src/getchar.c ./src/getchar.c
75c75,77
<  * typestr contains all characters that are not consumed yet.
---
>  * typebuf[] contains all characters that are not consumed yet.
>  * typebuf[typeoff] is the first valid character in typebuf[].
>  * typebuf[typeoff + typelen - 1] is the last valid char.
79c81
<  * no_abbr_cnt is the number of characters in typestr that should not be
---
>  * no_abbr_cnt is the number of characters in typebuf that should not be
81,91c83,93
<  * Some parts of typestr may not be mapped. These parts are remembered in
<  * noremapstr, which is the same length as typestr and contains TRUE for the
<  * characters that are not to be remapped. 
<  * (typestr has been put in globals.h, because check_termcode() needs it).
<  */
< #define MAXMAPLEN 50		/* maximum length of key sequence to be mapped */
< 							/* must be able to hold an Amiga resize report */
< static char_u	*noremapstr = NULL;
< 							/* NUL-terminated buffer for typeahead characters */
< static char_u	typebuf[MAXMAPLEN + 3];			/* initial typestr */
< static char_u	noremapbuf[MAXMAPLEN + 3];		/* initial noremapstr */
---
>  * Some parts of typebuf may not be mapped. These parts are remembered in
>  * noremapbuf, which is the same length as typebuf and contains TRUE for the
>  * characters that are not to be remapped. noremapbuf[typeoff] is the first
>  * valid flag.
>  * (typebuf has been put in globals.h, because check_termcode() needs it).
>  */
> static char_u	*noremapbuf = NULL;       /* flags for typeahead characters */
> #define TYPELEN_INIT	(3 * (MAXMAPLEN + 3))
> static char_u	typebuf_init[TYPELEN_INIT];			/* initial typebuf */
> static char_u	noremapbuf_init[TYPELEN_INIT];		/* initial noremapbuf */
> static int		real_State;							/* State for gotchars() */
93,94c95,96
< static int		typemaplen = 0;		/* nr of mapped characters in typestr */
< static int		no_abbr_cnt = 0;	/* nr of chars without abbrev. in typestr */
---
> static int		typemaplen = 0;		/* nr of mapped characters in typebuf */
> static int		no_abbr_cnt = 0;	/* nr of chars without abbrev. in typebuf */
105c107
< static void		init_typestr __ARGS((void));
---
> static void		init_typebuf __ARGS((void));
328c330
< 	init_typestr();
---
> 	init_typebuf();
339c341,342
< 			 * In an xterm we get one char at a time and we have to get them all.
---
> 			 * In an xterm we get one char at a time and we have to get them
> 			 * all.
341c344
< 		while (inchar(typestr, MAXMAPLEN, 10))	
---
> 		while (inchar(typebuf, MAXMAPLEN, 10))	
343c346,347
< 		*typestr = NUL;
---
> 		typeoff = MAXMAPLEN;
> 		typelen = 0;
347,348c351,352
< 		STRCPY(typestr, typestr + typemaplen);
< 		memmove(noremapstr, noremapstr + typemaplen, STRLEN(typestr));
---
> 		typeoff += typemaplen;
> 		typelen -= typemaplen;
501a506
> 		VIsual_active = TRUE;
565c570
<  * Initialize typestr to point to typebuf.
---
>  * Initialize typebuf to point to typebuf_init.
570c575
< init_typestr()
---
> init_typebuf()
572c577
< 	if (typestr == NULL)
---
> 	if (typebuf == NULL)
574,576c579,583
< 		typestr = typebuf;
< 		typebuf[0] = NUL;
< 		noremapstr = noremapbuf;
---
> 		typebuf = typebuf_init;
> 		noremapbuf = noremapbuf_init;
> 		typebuflen = TYPELEN_INIT;
> 		typelen = 0;
> 		typeoff = 0;
581c588
<  * insert a string in position 'offset' in the typeahead buffer (for '@'
---
>  * insert a string in position 'offset' in the typeahead buffer (for "@r"
594c601
< ins_typestr(str, noremap, offset, nottyped)
---
> ins_typebuf(str, noremap, offset, nottyped)
603d609
< 	register int	oldlen;
604a611
> 	register int	newoff;
606c613
< 	init_typestr();
---
> 	init_typebuf();
607a615
> 	addlen = STRLEN(str);
609c617
< 	 * In typestr there must always be room for MAXMAPLEN + 3 characters
---
> 	 * Easy case: there is room in front of typebuf[typeoff]
611,614c619
< 	addlen = STRLEN(str);
< 	oldlen = STRLEN(typestr);
< 	newlen = oldlen + addlen + MAXMAPLEN + 3;
< 	if (newlen < 0)				/* string is getting too long */
---
> 	if (offset == 0 && addlen <= typeoff)
616,618c621,622
< 		emsg(e_toocompl);		/* also calls flush_buffers */
< 		setcursor();
< 		return FAIL;
---
> 		typeoff -= addlen;
> 		memmove(typebuf + typeoff, str, addlen);
620,624c624,629
< 	s1 = alloc(newlen);
< 	if (s1 == NULL)				/* out of memory */
< 		return FAIL;
< 	s2 = alloc(newlen);
< 	if (s2 == NULL)				/* out of memory */
---
> 	/*
> 	 * Need to allocate new buffer.
> 	 * In typebuf there must always be room for MAXMAPLEN + 3 characters.
> 	 * We add some extra room to avoid having to allocate too often.
> 	 */
> 	else
626,628c631,648
< 		free(s1);
< 		return FAIL;
< 	}
---
> 		newoff = MAXMAPLEN + 3;
> 		newlen = typelen + addlen + newoff + 2 * (MAXMAPLEN + 3);
> 		if (newlen < 0)				/* string is getting too long */
> 		{
> 			emsg(e_toocompl);		/* also calls flush_buffers */
> 			setcursor();
> 			return FAIL;
> 		}
> 		s1 = alloc(newlen);
> 		if (s1 == NULL)				/* out of memory */
> 			return FAIL;
> 		s2 = alloc(newlen);
> 		if (s2 == NULL)				/* out of memory */
> 		{
> 			free(s1);
> 			return FAIL;
> 		}
> 		typebuflen = newlen;
630,635c650,663
< 	STRNCPY(s1, typestr, offset);
< 	STRCPY(s1 + offset, str);
< 	STRCPY(s1 + offset + addlen, typestr + offset);
< 	if (typestr != typebuf)
< 		free(typestr);
< 	typestr = s1;
---
> 		memmove(s1 + newoff, typebuf + typeoff, offset);
> 		memmove(s1 + newoff + offset, str, addlen);
> 		memmove(s1 + newoff + offset + addlen, typebuf + typeoff + offset,
> 														typelen - offset);
> 		if (typebuf != typebuf_init)
> 			free(typebuf);
> 		typebuf = s1;
> 
> 		memmove(s2 + newoff, noremapbuf + typeoff, offset);
> 		memmove(s2 + newoff + offset + addlen, noremapbuf + typeoff + offset,
> 														typelen - offset);
> 		if (noremapbuf != noremapbuf_init)
> 			free(noremapbuf);
> 		noremapbuf = s2;
636a665,668
> 		typeoff = newoff;
> 	}
> 	typelen += addlen;
> 
638c670
< 	 * Adjust the noremapstr:
---
> 	 * Adjust noremapbuf[] for the new characters:
644,645d675
< 	memmove(s2, noremapstr, offset);
< 	memmove(s2 + addlen + offset, noremapstr + offset, oldlen - offset);
649,660c679
< 	{
< 		if (noremap)
< 		{
< 			--noremap;
< 			s2[i + offset] = TRUE;			/* not mappable character */
< 		}
< 		else
< 			s2[i + offset] = FALSE;			/* mappable character */
< 	}
< 	if (noremapstr != noremapbuf)
< 		free(noremapstr);
< 	noremapstr = s2;
---
> 		noremapbuf[typeoff + i + offset] = (noremap-- > 0);
665c684
< 	if (no_abbr_cnt && offset == NULL)	/* and not used for abbreviations */
---
> 	if (no_abbr_cnt && offset == 0)		/* and not used for abbreviations */
672c691
<  * remove "len" characters from typestr[offset]
---
>  * remove "len" characters from typebuf[typeoff + offset]
675c694
< del_typestr(len, offset)
---
> del_typebuf(len, offset)
679,683c698,727
< 										/* remove chars from the buffer */
< 	STRCPY(typestr + offset, typestr + offset + len);
< 										/* adjust noremapstr */
< 	memmove(noremapstr + offset, noremapstr + offset + len,
< 												STRLEN(typestr + offset));
---
> 	int		i;
> 
> 	typelen -= len;
> 	/*
> 	 * Easy case: Just increase typeoff.
> 	 */
> 	if (offset == 0 && typebuflen - (typeoff + len) >= MAXMAPLEN + 3)
> 		typeoff += len;
> 	/*
> 	 * Have to move the characters in typebuf[] and noremapbuf[]
> 	 */
> 	else
> 	{
> 		i = typeoff + offset;
> 		/*
> 		 * Leave some extra room at the end to avoid reallocation.
> 		 */
> 		if (typeoff > MAXMAPLEN)
> 		{
> 			memmove(typebuf + MAXMAPLEN, typebuf + typeoff, offset);
> 			memmove(noremapbuf + MAXMAPLEN, noremapbuf + typeoff, offset);
> 			typeoff = MAXMAPLEN;
> 		}
> 			/* adjust typebuf */
> 		memmove(typebuf + typeoff + offset, typebuf + i + len,
> 														typelen - offset);
> 			/* adjust noremapbuf[] */
> 		memmove(noremapbuf + typeoff + offset, noremapbuf + i + len,
> 														typelen - offset);
> 	}
719,720c763,768
< 			/* do not sync in insert mode, unless cursor key has been used */
< 	if (!(State & (INSERT + CMDLINE)) || arrow_used)		
---
> 		/*
> 		 * Do not sync in insert mode, unless cursor key has been used.
> 		 * We need to use real_State, because State may be changed to
> 		 * NOMAPPING for getting the second key of a special key code.
> 		 */
> 	if (!(real_State & (INSERT + CMDLINE)) || arrow_used)		
792c840
< #define NEEDMORET 9999		/* value for incomplete mapping or key-code */
---
> #define NEEDMORET -1		/* value for incomplete mapping or key-code */
800d847
< 	int		save_State;
801a849
> 	real_State = State;
808d855
< 		save_State = State;
811c858
< 		State = save_State;
---
> 		State = real_State;
830a878
> 	real_State = State;
875,876c923,927
< 	int				n = 0;		/* init for GCC */
< 	int				len;
---
> #ifdef ADDED_BY_WEBB_COMPILE
> 	int				keylen = 0;				/* init for gcc */
> #else
> 	int				keylen;
> #endif /* ADDED_BY_WEBB_COMPILE */
884a936,939
> 	int				local_state;
> 	register int	mlen;
> 	int				max_mlen;
> 	int				i;
885a941,948
> 	/*
> 	 * VISUAL state is never set, it is used only here, therefore a check is
> 	 * made if NORMAL state is actually VISUAL state.
> 	 */
> 	local_state = State;
> 	if ((State & NORMAL) && VIsual_active)
> 		local_state = VISUAL;
> 
897c960
< 	init_typestr();
---
> 	init_typebuf();
920d982
< 				len = STRLEN(typestr);
924c986
< 					c = inchar(typestr, MAXMAPLEN, 0);	/* flush all input */
---
> 					c = inchar(typebuf, MAXMAPLEN, 0);	/* flush all input */
939c1001
< 				else if (len > 0)	/* see if we have a mapped key sequence */
---
> 				else if (typelen > 0)	/* check for a mappable key sequence */
947c1009
< 					 * - typestr[0] should not be remapped
---
> 					 * - typebuf[typeoff] should not be remapped
954a1017
> 					max_mlen = 0;
956c1019
< 								(p_remap && *noremapstr == FALSE))
---
> 								(p_remap && noremapbuf[typeoff] == FALSE))
958,959c1021,1022
< 							&& !(State == HITRETURN && (typestr[0] == CR
< 								|| typestr[0] == ' '))
---
> 							&& !(State == HITRETURN && (typebuf[typeoff] == CR
> 								|| typebuf[typeoff] == ' '))
961c1024
< 							&& !is_ctrl_x_key(typestr[0]))
---
> 							&& !is_ctrl_x_key(typebuf[typeoff]))
965,979c1028,1068
< 							if ((mp->m_mode & ABBREV) || !(mp->m_mode & State))
< 								continue;
< 								/* if one of the typed keys cannot be
< 								 * remapped, skip it */
< 							n = mp->m_keylen - 1;
< 							if (n >= len)
< 								n = len - 1;
< 							for ( ; n >= 0; --n)
< 								if (noremapstr[n] == TRUE)
< 									break;
< 							if (n >= 0)
< 								continue;
< 							n = mp->m_keylen;
< 							if (!STRNCMP(mp->m_keys, typestr, (size_t)(n > len ? len : n)))
< 								break;
---
> 							/*
> 							 * Only consider an entry if
> 							 * - it is not an abbreviation and
> 							 * - the first character matches and
> 							 * - it is for the current state
> 							 */
> 							if (!(mp->m_mode & ABBREV) && 
> 										mp->m_keys[0] == typebuf[typeoff] &&
> 										(mp->m_mode & local_state))
> 							{
> 								int		n;
> 
> 									/* find the match length of this mapping */
> 								for (mlen = 1; mlen < typelen; ++mlen)
> 									if (mp->m_keys[mlen] !=
> 													typebuf[typeoff + mlen])
> 										break;
> 
> 									/* if one of the typed keys cannot be
> 									 * remapped, skip the entry */
> 								for (n = 0; n < mlen; ++n)
> 									if (noremapbuf[typeoff + n] == TRUE)
> 										break;
> 								if (n != mlen)
> 									continue;
> 
> 									/* (partly) match found */
> 								keylen = mp->m_keylen;
> 								if (mlen == (keylen > typelen ?
> 													typelen : keylen))
> 								{
> 										/* partial match, need more chars */
> 									if (keylen > typelen)
> 										keylen = NEEDMORET;
> 									break;	
> 								}
> 									/* no match, may have to check for
> 									 * termcode at next character */
> 								if (max_mlen < mlen)
> 									max_mlen = mlen;
> 							}
992,993c1081,1084
< 						if (State != NOMAPPING && !timedout)
< 							n = check_termcode();
---
> 						if (State != NOMAPPING && (typemaplen == 0 ||
> 								(p_remap && noremapbuf[typeoff] == FALSE)) &&
> 											!timedout)
> 							keylen = check_termcode(max_mlen + 1);
995,996c1086,1087
< 							n = 0;
< 						if (n == 0)		/* no matching terminal code */
---
> 							keylen = 0;
> 						if (keylen == 0)		/* no matching terminal code */
999c1090,1091
< 							if (typemaplen == 0 && (typestr[0] & 0xff) == CSI)
---
> 							if (typemaplen == 0 &&
> 											(typebuf[typeoff] & 0xff) == CSI)
1001c1093,1096
< 								for (s = typestr + 1; isdigit(*s) || *s == ';' || *s == ' '; ++s)
---
> 								for (s = typebuf + typeoff + 1;
> 										s < typebuf + typeoff + typelen &&
> 										(isdigit(*s) || *s == ';' || *s == ' ');
> 										++s)
1005,1006c1100,1102
< 									del_typestr(s + 1 - typestr, 0);
< 									set_winsize(0, 0, FALSE);		/* get size and redraw screen */
---
> 									del_typebuf(s + 1 - (typebuf + typeoff), 0);
> 										/* get size and redraw screen */
> 									set_winsize(0, 0, FALSE);
1010c1106
< 									n = -1;
---
> 									keylen = -1;
1012c1108
< 							if (n != -1)			/* got a single character */
---
> 							if (keylen != -1)		/* got a single character */
1018c1114
< 								c = typestr[0] & 255;
---
> 								c = typebuf[typeoff] & 255;
1026c1122
< 										gotchars(typestr, 1);
---
> 										gotchars(typebuf + typeoff, 1);
1028,1029c1124,1125
< 								if (advance)	/* remove chars from typestr */
< 									del_typestr(1, 0);
---
> 								if (advance)	/* remove chars from typebuf */
> 									del_typebuf(1, 0);
1033c1129
< 						if (n > 0)		/* full matching terminal code */
---
> 						if (keylen > 0)		/* full matching terminal code */
1037c1133
< 						n = NEEDMORET;
---
> 						keylen = NEEDMORET;
1039c1135,1136
< 					if (n <= len)		/* complete match */
---
> 						/* complete match */
> 					if (keylen != NEEDMORET && keylen <= typelen)
1041,1042c1138,1141
< 						if (n > typemaplen)		/* write chars to script file(s) */
< 							gotchars(typestr + typemaplen, n - typemaplen);
---
> 										/* write chars to script file(s) */
> 						if (keylen > typemaplen)
> 							gotchars(typebuf + typeoff + typemaplen,
> 														keylen - typemaplen);
1044c1143
< 						del_typestr(n, 0);	/* remove the mapped keys */
---
> 						del_typebuf(keylen, 0);	/* remove the mapped keys */
1050c1149
< 						if (++mapdepth == 1000)
---
> 						if (++mapdepth >= p_mmd)
1063c1162
< 						 * Insert the 'to' part in the typestr.
---
> 						 * Insert the 'to' part in the typebuf.
1069,1070c1168,1169
< 						if (ins_typestr(mp->m_str, mp->m_noremap ? -1 :
< 								STRNCMP(mp->m_str, mp->m_keys, n) ? 0 : n,
---
> 						if (ins_typebuf(mp->m_str, mp->m_noremap ? -1 :
> 							STRNCMP(mp->m_str, mp->m_keys, keylen) ? 0 : keylen,
1080,1084c1179,1184
< 				 * special case: if we get an <ESC> in insert mode and there are
< 				 * no more characters at once, we pretend to go out of insert mode.
< 				 * This prevents the one second delay after typing an <ESC>.
< 				 * If we get something after all, we may have to redisplay the
< 				 * mode. That the cursor is in the wrong place does not matter.
---
> 				 * special case: if we get an <ESC> in insert mode and there
> 				 * are no more characters at once, we pretend to go out of
> 				 * insert mode.  This prevents the one second delay after
> 				 * typing an <ESC>.  If we get something after all, we may
> 				 * have to redisplay the mode. That the cursor is in the wrong
> 				 * place does not matter.
1087c1187,1190
< 				if (advance && len == 1 && typestr[0] == ESC && typemaplen == 0 && (State & INSERT) && (p_timeout || (n == NEEDMORET && p_ttimeout)) && (c = inchar(typestr + len, 2, 0)) == 0)
---
> 				if (advance && typelen == 1 && typebuf[typeoff] == ESC &&
> 						typemaplen == 0 && (State & INSERT) &&
> 						(p_timeout || (keylen == NEEDMORET && p_ttimeout)) &&
> 						(c = inchar(typebuf + typeoff + typelen, 2, 0)) == 0)
1131,1133c1234,1236
< 				len += c;
< 
< 				if (len >= typemaplen + MAXMAPLEN)	/* buffer full, don't map */
---
> 				typelen += c;
> 													/* buffer full, don't map */
> 				if (typelen >= typemaplen + MAXMAPLEN)
1141c1244,1266
< 				c = inchar(typestr + len, typemaplen + MAXMAPLEN - len, !advance ? 0 : ((len == 0 || !(p_timeout || (p_ttimeout && n == NEEDMORET))) ? -1 : (int)p_tm));
---
> 				/*
> 				 * If we have a partial match (and are going to wait for more
> 				 * input from the user), show the partially matched characters
> 				 * to the user with showcmd -- webb.
> 				 */
> 				i = 0;
> 				if (keylen == NEEDMORET &&
> 									(State & (NORMAL | INSERT)) && advance)
> 				{
> 					push_showcmd();
> 					while (i < typelen)
> 						(void)add_to_showcmd(typebuf[typeoff + i++]);
> 				}
> 
> 				c = inchar(typebuf + typeoff + typelen,
> 							typemaplen + MAXMAPLEN - typelen,
> 							!advance ? 0 : ((typelen == 0 ||
> 								!(p_timeout || (p_ttimeout &&
> 								keylen == NEEDMORET))) ? -1 : (int)p_tm));
> 
> 				if (i)
> 					pop_showcmd();
> 
1146c1271
< 					if (len)				/* timed out */
---
> 					if (typelen)				/* timed out */
1154,1155c1279,1280
< 					while (typestr[len] != NUL)
< 						noremapstr[len++] = FALSE;
---
> 					while (typebuf[typeoff + typelen] != NUL)
> 						noremapbuf[typeoff + typelen++] = FALSE;
1195c1320
<  * for :map	  mode is NORMAL 
---
>  * for :map	  mode is NORMAL + VISUAL
1198a1324,1325
>  * for :nmap  mode is NORMAL
>  * for :vmap  mode is VISUAL
1218c1345
< 	int					n = 0;			/* init for GCC */
---
> 	int					n;
1319c1446
< 			if (!isidchar(*(keys + len - 1)))		/* does not end in id char */
---
> 			if (!isidchar_id(*(keys + len - 1)))  /* does not end in id char */
1325c1452
< 				if (isidchar(*(keys + n)) != isidchar(*(keys + len - 2)))
---
> 				if (isidchar_id(*(keys + n)) != isidchar_id(*(keys + len - 2)))
1491c1618
< 		msg_outstr((char_u *)"! ");
---
> 		MSG_OUTSTR("! ");
1493c1620
< 		msg_outstr((char_u *)"i ");
---
> 		MSG_OUTSTR("i ");
1495c1622,1628
< 		msg_outstr((char_u *)"c ");
---
> 		MSG_OUTSTR("c ");
> 	else if (!(mp->m_mode & VISUAL))
> 		MSG_OUTSTR("n ");
> 	else if (!(mp->m_mode & NORMAL))
> 		MSG_OUTSTR("v ");
> 	else
> 		MSG_OUTSTR("  ");
1541c1674
< 	if (col == 0 || !isidchar(ptr[col - 1]))	/* cannot be an abbr. */
---
> 	if (col == 0 || !isidchar_id(ptr[col - 1]))	/* cannot be an abbr. */
1545c1678
< 		is_id = isidchar(ptr[col - 2]);
---
> 		is_id = isidchar_id(ptr[col - 2]);
1547c1680
< 								is_id == isidchar(ptr[len - 1]); --len)
---
> 								is_id == isidchar_id(ptr[len - 1]); --len)
1569c1702
< 			 * Insert the rest of the abbreviation in typestr.
---
> 			 * Insert the rest of the abbreviation in typebuf[].
1590c1723
< 			(void)ins_typestr(tb, TRUE, 0, TRUE);
---
> 			(void)ins_typebuf(tb, TRUE, 0, TRUE);
1592c1725
< 			(void)ins_typestr(mp->m_str, mp->m_noremap, 0, TRUE);
---
> 			(void)ins_typebuf(mp->m_str, mp->m_noremap, 0, TRUE);
1597c1730
< 				(void)ins_typestr((char_u *)"\b", TRUE, 0, TRUE);
---
> 				(void)ins_typebuf((char_u *)"\b", TRUE, 0, TRUE);
1621a1755,1756
> 		case NORMAL + VISUAL:
> 			break;
1622a1758,1761
> 			c1 = 'n';
> 			break;
> 		case VISUAL:
> 			c1 = 'v';
Index: ./src/globals.h
diff -r ../vim.orig/src/globals.h ./src/globals.h
65a66
> EXTERN int		did_emsg;					/* set by emsg() for DoOneCmd() */
66a68
> EXTERN linenr_t	sourcing_lnum INIT(= 0);	/* line number of the source file */
78c80
< EXTERN int		mouse_code;
---
> EXTERN int		mouse_code INIT(= 0);
126,127c128,130
< EXTERN FPOS 	VIsual; 		/* start position of Visual (if VIsual.lnum ==
< 								 * 0, visual is not active) */
---
> EXTERN FPOS 	VIsual; 		/* start position of Visual */
> EXTERN int		VIsual_active INIT(= FALSE);
> 								/* wheter Visual mode is active */
156c159
<  * one indent character will be removed.
---
>  * one indent will be removed.
159a163,168
> /*
>  * This flag is set after an "O" command. If the next typed character is a '{'
>  * one indent will be removed.
>  */
> EXTERN int				can_si_back INIT(= FALSE);
> 
195,196c204,209
< EXTERN char_u	*typestr INIT(= NULL);		/* buffer for typed characters */
< EXTERN int		KeyTyped;					/* TRUE if user typed the character */
---
> EXTERN char_u	*typebuf INIT(= NULL);	/* buffer for typed characters */
> EXTERN int		typebuflen;				/* size of typebuf */
> EXTERN int		typeoff;				/* current position in typebuf */
> EXTERN int		typelen;				/* number of valid chars in typebuf */
> EXTERN int		KeyTyped;				/* TRUE if user typed current char */
> 
198a212
> EXTERN int		do_redraw INIT(= FALSE);	/* extra redraw once */
231,232c245,246
< EXTERN int		second_indent INIT(= -1);   /* Indent of 2nd line for Q */
< EXTERN char_u	*second_leader INIT(= NULL); /* Comment leader from 2nd line */
---
> 
> EXTERN char		*escape_chars INIT(= " \\\"|"); /* need backslash in cmd line */
304d317
< 
Index: ./src/help.c
diff -r ../vim.orig/src/help.c ./src/help.c
10c10
<  * help.c: display help from the vim.hlp file
---
>  * help.c: open a read-only window on the vim_help.txt file
18,22d17
< static long helpfilepos;		/* position in help file */
< static FILE *helpfd;			/* file descriptor of help file */
< 
< #define MAXSCREENS 52			/* one screen for a-z and A-Z */
< 
24c19,20
< help()
---
> dohelp(arg)
> 	char_u		*arg;
26,32d21
< 	int		c;
< 	int		eof;
< 	int		screens;
< 	int		i;
< 	long	filepos[MAXSCREENS];	/* seek position for each screen */
< 	int		screennr;			/* screen number; index == 0, 'c' == 1, 'd' == 2, etc */
< #if defined(MSDOS) && !defined(NT)
34c23,24
< #endif
---
> 	FILE	*helpfd;			/* file descriptor of help file */
> 	int		n;
38a29
> 	fnamep = p_hf;
45c36
< 		fnamep = searchpath("vim.hlp");
---
> 		fnamep = searchpath("vim_help.txt");
48c39
< 			smsg((char_u *)"Sorry, help file \"%s\" and \"vim.hlp\" not found", p_hf);
---
> 			smsg((char_u *)"Sorry, help file \"%s\" and \"vim_help.txt\" not found", p_hf);
56,66c47
< 	helpfilepos = 0;
< 	screennr = 0;
< 	for (i = 0; i < MAXSCREENS; ++i)
< 		filepos[i] = 0;
< 	State = HELP;
< 	for (;;)
< 	{
< 		screens = redrawhelp();				/* show one or more screens */
< 		eof = (screens < 0);
< 		if (!eof && screennr + screens < MAXSCREENS)
< 			filepos[screennr + screens] = ftell(helpfd);
---
> 	fclose(helpfd);
68,69c49,50
< 		if ((c = vgetc()) == '\n' || c == '\r' || c == Ctrl('C') || c == ESC)
< 			break;
---
> 	if (win_split(p_hh, FALSE) == FAIL)
> 		return;
71,109c52,61
< 											/* one screen forwards */
< 		if (c == ' ' || c == K_PAGEDOWN || c == Ctrl('F'))
< 		{
< 			if (screennr < MAXSCREENS && !eof)
< 				++screennr;
< 		}
< 		else if (c == 'a')					/* go to first screen */
< 			screennr = 0;
< 											/* go one screen backwards */
< 		else if (c == 'b' || c == K_PAGEUP || c == Ctrl('B'))
< 		{
< 			if (screennr > 0)
< 				--screennr;
< 		}
< 		else if (c < 0x100 && isalpha(c))	/* go to specified screen */
< 		{
< 			if (isupper(c))
< 				c = c - 'A' + 'z' + 1;		/* 'A' comes after 'z' */
< 			screennr = c - 'b';
< 		}
< 		for (i = screennr; i > 0; --i)
< 			if (filepos[i])
< 				break;
< 		fseek(helpfd, filepos[i], 0);
< 		while (i < screennr)
< 		{
< 			while ((c = getc(helpfd)) != '\f' && c != -1)
< 				;
< 			if (c == -1)
< 				break;
< 			filepos[++i] = ftell(helpfd);	/* store the position just after the '\f' */
< 		}
< 		screennr = i;						/* required when end of file reached */
< 		helpfilepos = filepos[screennr];
< 	}
< 	State = NORMAL;
< 	fclose(helpfd);
< 	updateScreen(CLEAR);
< }
---
> 	/* open help file in readonly mode */
> 	n = readonlymode;
> 	readonlymode = TRUE;
> 	(void)doecmd(0, fnamep, NULL, NULL, TRUE, (linenr_t)0);
> 	readonlymode = n;
> 		/* set help flag, use "vim_tags" instead of "tags" file */
> 	curbuf->b_help = TRUE;
> 		/* accept many characters for identifier, except white space and '|' */
> 	free(curbuf->b_p_id);
> 	curbuf->b_p_id = strsave((char_u *)"!\"#$%&'()+,-./:;<=>?@[\\]^_`{}~");
111,128c63
< /*
<  * redraw the help info for the current position in the help file
<  *
<  * return the number of screens displayed, or -1 if end of file reached
<  */
< 	int
< redrawhelp()
< {
< 	int nextc;
< 	int col;
< 	int	line = 0;
< 	int	screens = 1;
< 
< 	fseek(helpfd, helpfilepos, 0);
< 	outstr(T_ED);
< 	(void)set_highlight('h');
< 	windgoto(0,0);
< 	while ((nextc = getc(helpfd)) != -1 && (nextc != '\f' || line < Rows - 24))
---
> 	if (*arg != NUL)
130,145c65,71
< 		if (nextc == Ctrl('B'))			/* begin of standout */
< 			start_highlight();
< 		else if (nextc == Ctrl('E'))	/* end of standout */
< 			stop_highlight();
< 		else if (nextc == '\f')			/* start of next screen */
< 		{
< 			++screens;
< 			outchar('\n');
< 			++line;
< 		}
< 		else
< 		{
< 			outchar(nextc);
< 			if (nextc == '\n')
< 				++line;
< 		}
---
> #ifdef ADDED_BY_WEBB_COMPILE
> 		stuffReadbuff((char_u *)":ta ");
> #else
> 		stuffReadbuff(":ta ");
> #endif /* ADDED_BY_WEBB_COMPILE */
> 		stuffReadbuff(arg);
> 		stuffcharReadbuff('\n');
147,154d72
< 	windgoto(0, (int)(Columns - STRLEN(Version) - 1));
< 	outstrn(Version);
< 	col = (int)Columns - 52;
< 	if (col < 0)
< 		col = 0;
< 	windgoto((int)Rows - 1, col);
< 	OUTSTRN("<space = next; return = quit; a = index; b = back>");
< 	return (nextc == -1 ? -1 : screens);
Index: ./src/keymap.h
diff -r ../vim.orig/src/keymap.h ./src/keymap.h
88a89,90
> 	KS_BS,
> 
167a170,171
> 
> #define K_BS			(KS_OFF + KS_BS)
Index: ./src/main.c
diff -r ../vim.orig/src/main.c ./src/main.c
47c47
< 	fprintf(stderr, "\t\t-r\t\trecovery mode (needs a file name)\n");
---
> 	fprintf(stderr, "\t\t-r\t\trecovery of crashed session\n");
58a59
> 	fprintf(stderr, "\t\t-u vimrc\tread initializations from a file\n");
75a77
> 	char_u		   *use_vimrc = NULL;	/* vimrc from -u option */
108c110
< 		p_uc = 0;
---
> 		p_uc = 10000;			/* don't update very often */
117a120
> 	 *		'-u vimrc'		read initializations from a file
127c130
< 			strchr("vnbrxocswTd", c = argv[0][1]) != NULL && c != NUL)))
---
> 			strchr("vnbrxocswTdu", c = argv[0][1]) != NULL && c != NUL)))
143c146,147
< 			/*FALLTHROUGH*/
---
> 			p_uc = 10000;			/* don't update very often */
> 			break;
182c186
< 			case 's':
---
> 			case 's':			/* -s {scriptin} */
190c194
< 			case 'w':
---
> 			case 'w':			/* -w {scriptout} */
202c206
< 			case 'T':
---
> 			case 'T':			/* -T {terminal} */
205a210,213
> 			case 'u':			/* -u {vimrc} */
> 				use_vimrc = (char_u *)*argv;
> 				break;
> 			
322,326c330,334
< 	domap(0, "#1 :help\r", NORMAL);			/* F1 is help key */
< 	domap(0, "\316w H", NORMAL);			/* CTRL-HOME is 'H' */
< 	domap(0, "\316u L", NORMAL);			/* CTRL-END is 'L' */
< 	domap(0, "\316\204 1G", NORMAL);		/* CTRL-PageUp is '1G' */
< 	domap(0, "\316v G", NORMAL);			/* CTRL-PageDown is 'G' */
---
> 	domap(0, "#1 :help\r", NORMAL+VISUAL);		/* F1 is help key */
> 	domap(0, "\316w H", NORMAL+VISUAL);			/* CTRL-HOME is 'H' */
> 	domap(0, "\316u L", NORMAL+VISUAL);			/* CTRL-END is 'L' */
> 	domap(0, "\316\204 1G", NORMAL+VISUAL);		/* CTRL-PageUp is '1G' */
> 	domap(0, "\316v G", NORMAL+VISUAL);			/* CTRL-PageDown is 'G' */
336c344,345
<  * get system wide defaults (for unix)
---
>  * If -u option give, use only the initializations from that file and nothing
>  * else.
337a347,354
> 	if (use_vimrc != NULL)
> 		(void)dosource(use_vimrc);
> 	else
> 	{
> 
> 	/*
> 	 * get system wide defaults (for unix)
> 	 */
339c356
< 	(void)dosource((char_u *)DEFVIMRC_FILE);
---
> 		(void)dosource((char_u *)DEFVIMRC_FILE);
342,358c359,368
< /*
<  * Try to read initialization commands from the following places:
<  * - environment variable VIMINIT
<  * - file s:.vimrc ($HOME/.vimrc for Unix)
<  * - environment variable EXINIT
<  * - file s:.exrc ($HOME/.exrc for Unix)
<  * The first that exists is used, the rest is ignored.
<  */
< 	if ((initstr = vimgetenv((char_u *)"VIMINIT")) != NULL && *initstr != NUL)
< 	{
< 		sourcing_name = (char_u *)"VIMINIT";
< 		docmdline(initstr, TRUE, TRUE);
< 		sourcing_name = NULL;
< 	}
< 	else if (dosource((char_u *)SYSVIMRC_FILE) == FAIL)
< 	{
< 		if ((initstr = vimgetenv((char_u *)"EXINIT")) != NULL)
---
> 	/*
> 	 * Try to read initialization commands from the following places:
> 	 * - environment variable VIMINIT
> 	 * - file s:.vimrc ($HOME/.vimrc for Unix)
> 	 * - environment variable EXINIT
> 	 * - file s:.exrc ($HOME/.exrc for Unix)
> 	 * The first that exists is used, the rest is ignored.
> 	 */
> 		if ((initstr = vimgetenv((char_u *)"VIMINIT")) != NULL &&
> 														*initstr != NUL)
360c370
< 			sourcing_name = (char_u *)"EXINIT";
---
> 			sourcing_name = (char_u *)"VIMINIT";
364,366c374,384
< 		else
< 			(void)dosource((char_u *)SYSEXRC_FILE);
< 	}
---
> 		else if (dosource((char_u *)SYSVIMRC_FILE) == FAIL)
> 		{
> 			if ((initstr = vimgetenv((char_u *)"EXINIT")) != NULL)
> 			{
> 				sourcing_name = (char_u *)"EXINIT";
> 				docmdline(initstr, TRUE, TRUE);
> 				sourcing_name = NULL;
> 			}
> 			else
> 				(void)dosource((char_u *)SYSEXRC_FILE);
> 		}
368,378c386,395
< /*
<  * Read initialization commands from ".vimrc" or ".exrc" in current directory.
<  * This is only done if the 'exrc' option is set.
<  * Because of security reasons we disallow shell and write commands now,
<  * except for unix if the file is owned by the user or 'secure' option has been
<  * reset in environmet of global ".exrc" or ".vimrc".
<  * Only do this if VIMRC_FILE is not the same as SYSVIMRC_FILE or DEFVIMRC_FILE.
<  */
< 	if (p_exrc)
< 	{
< #ifdef UNIX
---
> 	/*
> 	 * Read initialization commands from ".vimrc" or ".exrc" in current
> 	 * directory.  This is only done if the 'exrc' option is set.
> 	 * Because of security reasons we disallow shell and write commands now,
> 	 * except for unix if the file is owned by the user or 'secure' option has
> 	 * been reset in environmet of global ".exrc" or ".vimrc".
> 	 * Only do this if VIMRC_FILE is not the same as SYSVIMRC_FILE or
> 	 * DEFVIMRC_FILE.
> 	 */
> 		if (p_exrc)
380c397,399
< 			struct stat s;
---
> #ifdef UNIX
> 			{
> 				struct stat s;
382,385c401,405
< 				/* if ".vimrc" file is not owned by user, set 'secure' mode */
< 			if (stat(VIMRC_FILE, &s) || s.st_uid != getuid())
< 				secure = p_secure;
< 		}
---
> 					/* if ".vimrc" file is not owned by user, set 'secure'
> 					 * mode */
> 				if (stat(VIMRC_FILE, &s) || s.st_uid != getuid())
> 					secure = p_secure;
> 			}
387c407
< 		secure = p_secure;
---
> 			secure = p_secure;
390,391c410,411
< 		i = FAIL;
< 		if (fullpathcmp((char_u *)SYSVIMRC_FILE, (char_u *)VIMRC_FILE)
---
> 			i = FAIL;
> 			if (fullpathcmp((char_u *)SYSVIMRC_FILE, (char_u *)VIMRC_FILE)
393c413,414
< 				&& fullpathcmp((char_u *)DEFVIMRC_FILE, (char_u *)VIMRC_FILE)
---
> 					&& fullpathcmp((char_u *)DEFVIMRC_FILE,
> 												(char_u *)VIMRC_FILE)
395,396c416,417
< 				)
< 			i = dosource((char_u *)VIMRC_FILE);
---
> 					)
> 				i = dosource((char_u *)VIMRC_FILE);
398,400c419,421
< 		if (i == FAIL)
< 		{
< 			struct stat s;
---
> 			if (i == FAIL)
> 			{
> 				struct stat s;
402,407c423,428
< 				/* if ".exrc" file is not owned by user set 'secure' mode */
< 			if (stat(EXRC_FILE, &s) || s.st_uid != getuid())
< 				secure = p_secure;
< 			else
< 				secure = 0;
< 		}
---
> 					/* if ".exrc" is not owned by user set 'secure' mode */
> 				if (stat(EXRC_FILE, &s) || s.st_uid != getuid())
> 					secure = p_secure;
> 				else
> 					secure = 0;
> 			}
409,410c430,433
< 		if (i == FAIL && fullpathcmp((char_u *)SYSEXRC_FILE, (char_u *)EXRC_FILE))
< 			(void)dosource((char_u *)EXRC_FILE);
---
> 			if (i == FAIL && fullpathcmp((char_u *)SYSEXRC_FILE,
> 													(char_u *)EXRC_FILE))
> 				(void)dosource((char_u *)EXRC_FILE);
> 		}
420c443
< 		recover_list();
---
> 		recover_names(NULL, TRUE, 0);
423a447,450
> #ifdef UNIX
> 	set_init_shell();			/* set 'shellpipe' and 'shellredir' defaults */
> #endif
> 
435,441d461
< /*
<  * Call settmode and starttermcap here, so the T_KS and T_TS may be defined
<  * by termcapinit and redifined in .exrc.
<  */
< 	settmode(1);
< 	starttermcap();
< 	scroll_start();
469d488
< 
472c491,499
< 		/* done something that is not allowed or error message */
---
> /*
>  * When done something that is not allowed or error message call wait_return.
>  * This must be done before starttermcap(), because it may switch to another
>  * screen. It must be done after settmode(1), because we want to react on a
>  * single key stroke.
>  * Call settmode and starttermcap here, so the T_KS and T_TS may be defined
>  * by termcapinit and redifined in .exrc.
>  */
> 	settmode(1);
474c501,503
< 		wait_return(TRUE);				/* must be called after settmode(1) */
---
> 		wait_return(TRUE);
> 	starttermcap();			/* start termcap if not done by wait_return() */
> 
476a506
> 	scroll_start();
484,486c514
< 		if (ml_open() == FAIL)			/* Initialize storage structure */
< 			getout(1);
< 		ml_recover();					/* recover the file */
---
> 		ml_recover();
487a516,518
> 		if (curbuf->b_ml.ml_mfp == NULL)/* failed */
> 			getout(1);
> 		do_mlines();					/* do modelines */
563,564c594,600
< 		if (skip_redraw)				/* skip redraw (for ":" in
< 											wait_return()) */
---
> 		msg_scroll = FALSE;
> 		/*
> 		 * If skip redraw is set (for ":" in wait_return()), don't redraw now.
> 		 * If there is nothing in the stuff_buffer or do_redraw is TRUE,
> 		 * update cursor and redraw.
> 		 */
> 		if (skip_redraw)			
566c602
< 		else if (stuff_empty())			/* only when no command pending */
---
> 		else if (do_redraw || stuff_empty())
575,576c611
< 			msg_scroll = FALSE;
< 			if (VIsual.lnum != 0)
---
> 			if (VIsual_active)
588a624
> 			do_redraw = FALSE;
Index: ./src/makefile.unix
diff -r ../vim.orig/src/makefile.unix ./src/makefile.unix
32a33
> #Apollo			cc			no X11	(webb)
40c41
< #osf1			cc			no X11	(jw)
---
> #osf1			cc		X11	no X11	(webb) (jw)
92c93,94
< MANFILE = ../doc/vim.1
---
> # Where to copy the man and help file from
> HELPSOURCE = ../doc
94,95d95
< HELPFILE = ../doc/vim.hlp
< 
131c131
< 		-DVIMINFO -DVIM_HLP=\"$(HELPLOC)/vim.hlp\"
---
> 		-DVIMINFO -DVIM_HLP=\"$(HELPLOC)/vim_help.txt\"
227c227
< # Apollo DOMAIN (with SYSTYPE = bsd4.3) (NOT TESTED YET)
---
> # Apollo DOMAIN (with SYSTYPE = bsd4.3) (TESTED)
260c260
< #MACHINE = -DBSD_UNIX -DUSE_X11
---
> #MACHINE = -DBSD_UNIX -DUSE_X11 -DTERMINFO
267c267
< #MACHINE = -DBSD_UNIX -DUSE_X11
---
> #MACHINE = -DBSD_UNIX -DUSE_X11 -DTERMINFO
276a277,282
> # osf1 (alpha) with X11 (TESTED)
> #
> #MACHINE = -DSYSV_UNIX -DUSE_LOCALE -DUSE_X11
> #CC=cc -O -Olimit 1500
> #LIBS = -ltermlib -lX11
> 
279c285,286
< # First try the line with locale. If this gives error messages try the other one.
---
> # First try the line with locale. If this gives error messages try the other
> # one.
283c290
< #CC=cc -O
---
> #CC=cc -O -Olimit 1500
451,452c458,462
< 	ctags -t $(SRC) $(INCL)
< #	If we have elvis's ctags:
---
> # simplistic ctags
> #	ctags -t $(SRC) $(INCL)
> # include static functions (not all versions of ctags can do this)
> 	ctags -ts $(SRC) $(INCL)
> # also include variables (not all versions of ctags can do this)
458d467
< 	chmod $(BINMOD) $(BINLOC)/$(TARGET)
459a469
> 	chmod $(BINMOD) $(BINLOC)/$(TARGET)
461c471
< 	cp $(MANFILE) $(MANLOC)
---
> 	cp $(HELPSOURCE)/vim.1 $(MANLOC)
464,465c474,476
< 	cp $(HELPFILE) $(HELPLOC)
< 	chmod $(HELPMOD) $(HELPLOC)/vim.hlp
---
> 	cp $(HELPSOURCE)/vim_*.txt $(HELPLOC)
> 	cp $(HELPSOURCE)/vim_tags $(HELPLOC)
> 	chmod $(HELPMOD) $(HELPLOC)/vim_*.txt $(HELPLOC)/vim_tags
Index: ./src/mark.c
diff -r ../vim.orig/src/mark.c ./src/mark.c
59c59
< 	int i;
---
> 	int i, to;
90,95c90,94
< 		/* only add new entry if it differs from the last one */
< 	if (curwin->w_jumplistlen == 0 ||
< 				curwin->w_jumplist[curwin->w_jumplistidx - 1].mark.lnum !=
< 														curwin->w_pcmark.lnum ||
< 				curwin->w_jumplist[curwin->w_jumplistidx - 1].fnum !=
< 														curbuf->b_fnum)
---
> 	/*
> 	 * If entry already exists, remove it from the jump list.  New entry will
> 	 * be added at the front of the list.
> 	 */
> 	for (to = 0, i = 0; i < curwin->w_jumplistlen; i++)
97,98c96,97
< 			/* if jumplist is full: remove oldest entry */
< 		if (++curwin->w_jumplistlen > JUMPLISTSIZE)
---
> 		if (curwin->w_jumplist[i].mark.lnum != curwin->w_pcmark.lnum ||
> 			curwin->w_jumplist[i].fnum != curbuf->b_fnum)
100,103c99
< 			curwin->w_jumplistlen = JUMPLISTSIZE;
< 			for (i = 1; i < curwin->w_jumplistlen; ++i)
< 				curwin->w_jumplist[i - 1] = curwin->w_jumplist[i];
< 			--curwin->w_jumplistidx;
---
> 			curwin->w_jumplist[to++] = curwin->w_jumplist[i];
104a101,111
> 	}
> 	curwin->w_jumplistlen = to;
> 
> 	/* If jumplist is full: remove oldest entry */
> 	if (++curwin->w_jumplistlen > JUMPLISTSIZE)
> 	{
> 		curwin->w_jumplistlen = JUMPLISTSIZE;
> 		for (i = 1; i < curwin->w_jumplistlen; ++i)
> 			curwin->w_jumplist[i - 1] = curwin->w_jumplist[i];
> 	}
> 	curwin->w_jumplistidx = curwin->w_jumplistlen - 1;
107,111c114,118
< 		/* Workaround for a bug in gcc 2.4.5 R2 on the Archimedes
< 		 * Should be fixed in 2.5.x.
< 		 */
< 		curwin->w_jumplist[curwin->w_jumplistidx].mark.ptr = curwin->w_pcmark.ptr;
< 		curwin->w_jumplist[curwin->w_jumplistidx].mark.col = curwin->w_pcmark.col;
---
> 	/* Workaround for a bug in gcc 2.4.5 R2 on the Archimedes
> 	 * Should be fixed in 2.5.x.
> 	 */
> 	curwin->w_jumplist[curwin->w_jumplistidx].mark.ptr = curwin->w_pcmark.ptr;
> 	curwin->w_jumplist[curwin->w_jumplistidx].mark.col = curwin->w_pcmark.col;
113c120
< 		curwin->w_jumplist[curwin->w_jumplistidx].mark = curwin->w_pcmark;
---
> 	curwin->w_jumplist[curwin->w_jumplistidx].mark = curwin->w_pcmark;
115,117c122,123
< 		curwin->w_jumplist[curwin->w_jumplistidx].fnum = curbuf->b_fnum;
< 		++curwin->w_jumplistidx;
< 	}
---
> 	curwin->w_jumplist[curwin->w_jumplistidx].fnum = curbuf->b_fnum;
> 	++curwin->w_jumplistidx;
213a220,221
> 	else if (c == '<')
> 		posp = &VIsual;
277c285,286
< domarks()
---
> domarks(arg)
> 	char_u		*arg;
282c291,297
< 	msg_outstr((char_u *)"\nmark line  col file");
---
> 	if (arg != NULL && *arg == NUL)
> 		arg = NULL;
> 
> 	set_highlight('t');		/* Highlight title */
> 	start_highlight();
> 	MSG_OUTSTR("\nmark line  col file");
> 	stop_highlight();
285c300,301
< 		if (curbuf->b_namedm[i].lnum != 0)
---
> 		if (curbuf->b_namedm[i].lnum != 0 &&
> 						(arg == NULL || STRCHR(arg, i +'a') != NULL))
296c312,313
< 		if (namedfm[i].mark.lnum != 0)
---
> 		if (namedfm[i].mark.lnum != 0
> 			&& (arg == NULL || STRCHR(arg, i +'A') != NULL))
302c319,320
< 			sprintf((char *)IObuff, "\n %c %5ld  %3d %s",
---
> 			msg_outchar('\n');
> 			sprintf((char *)IObuff, " %c %5ld  %3d %s",
307c325
< 			msg_outstr(IObuff);
---
> 			msg_outtrans(IObuff);
322c340,343
< 	msg_outstr((char_u *)"\n jump line  file");
---
> 	set_highlight('t');		/* Highlight title */
> 	start_highlight();
> 	MSG_OUTSTR("\n jump line  file");
> 	stop_highlight();
331c352,353
< 			sprintf((char *)IObuff, "\n%c %2d %5ld  %s",
---
> 			msg_outchar('\n');
> 			sprintf((char *)IObuff, "%c %2d %5ld  %s",
336c358
< 			msg_outstr(IObuff);
---
> 			msg_outtrans(IObuff);
341c363
< 		msg_outstr((char_u *)"\n>");
---
> 		MSG_OUTSTR("\n>");
347a370,382
> 
> #define one_adjust(add) \
> 	{ \
> 		lp = add; \
> 		if (*lp >= line1 && *lp <= line2) \
> 		{ \
> 			if (amount == MAXLNUM) \
> 				*lp = 0; \
> 			else \
> 				*lp += amount; \
> 		} \
> 	}
> 
358a394,396
> 	if (line2 < line1)		/* nothing to do */
> 		return;
> 
362,369c400
< 		lp = &(curbuf->b_namedm[i].lnum);
< 		if (*lp >= line1 && *lp <= line2)
< 		{
< 			if (amount == MAXLNUM)
< 				*lp = 0;
< 			else
< 				*lp += amount;
< 		}
---
> 		one_adjust(&(curbuf->b_namedm[i].lnum));
371,380c402
< 		{
< 			lp = &(namedfm[i].mark.lnum);
< 			if (*lp >= line1 && *lp <= line2)
< 			{
< 				if (amount == MAXLNUM)
< 					*lp = 0;
< 				else
< 					*lp += amount;
< 			}
< 		}
---
> 			one_adjust(&(namedfm[i].mark.lnum));
384,391c406
< 	lp = &(curwin->w_pcmark.lnum);
< 	if (*lp >= line1 && *lp <= line2)
< 	{
< 		if (amount == MAXLNUM)
< 			*lp = 0;
< 		else
< 			*lp += amount;
< 	}
---
> 	one_adjust(&(curwin->w_pcmark.lnum));
394,401c409
< 	lp = &(curwin->w_prev_pcmark.lnum);
< 	if (*lp >= line1 && *lp <= line2)
< 	{
< 		if (amount == MAXLNUM)
< 			*lp = 0;
< 		else
< 			*lp += amount;
< 	}
---
> 	one_adjust(&(curwin->w_prev_pcmark.lnum));
412c420,421
< 					*lp = line1;		/* don't delete it, just put at first deleted line */
---
> 					*lp = line1;		/* don't delete it, just put at first
> 											deleted line */
427,436c436
< 			{
< 				lp = &(win->w_jumplist[i].mark.lnum);
< 				if (*lp >= line1 && *lp <= line2)
< 				{
< 					if (amount == MAXLNUM)
< 						*lp = 0;
< 					else
< 						*lp += amount;
< 				}
< 			}
---
> 				one_adjust(&(win->w_jumplist[i].mark.lnum));
438,439c438,439
< 		 * also adjust the line at the top of the window and the cursor position
< 		 * for windows with the same buffer.
---
> 		 * also adjust the line at the top of the window and the cursor
> 		 * position for windows with the same buffer.
Index: ./src/memfile.c
diff -r ../vim.orig/src/memfile.c ./src/memfile.c
97a98
>  * mf_open_file()	open a swap file for an existing memfile
114c115
<  *						If opening the file fails, fname is freed.
---
>  *						If opening the file fails, fname is NOT freed.
134,135d134
< 	{
< 		free(fname);
137d135
< 	}
203c201
<  *						If opening the file fails, fname is freed.
---
>  *						If opening the file fails, fname is NOT freed.
909c907
< 		if (nr + page_count > mfp->mf_infile_count)		/* appended to the file */
---
> 		if (nr + page_count > mfp->mf_infile_count)	/* appended to the file */
913d910
< 		nr += page_count;
1130d1126
< 		free(fname);
Index: ./src/memline.c
diff -r ../vim.orig/src/memline.c ./src/memline.c
69a70
> #include <time.h>
135c136
< #define DB_MARKED		(1 << ((sizeof(unsigned) * 8) - 1))
---
> #define DB_MARKED		((unsigned)1 << ((sizeof(unsigned) * 8) - 1))
191c192
< 	char_u		*fname = NULL;
---
> 	char_u		*fname;
230a232
> 		free(fname);
390c392
< 		mfp->mf_fd = open(mfp->mf_fname, O_RDWR);
---
> 		mfp->mf_fd = open((char *)mfp->mf_fname, O_RDWR);
429,430c431,433
< 	 * If a file name given, 'directory' option is set and does not start with '>'
< 	 * may try twice: first in current dir and if that fails in 'directory'.
---
> 	 * If a file name given, 'directory' option is set and does not start with
> 	 * '>' may try twice: first in current dir and if that fails in
> 	 * 'directory'.
437a441
> 			free(fname);
441a446
> 			free(fname);
493,494c498,499
< 	MEMFILE		*mfp = NULL;
< 	BHDR		*hp = NULL;
---
> 	MEMFILE		*mfp;
> 	BHDR		*hp;
524c529
< 	char_u		*fname = NULL;
---
> 	char_u		*fname;
549c554
<  * Otherwise ".swp" is appended.
---
>  * Otherwise a search is done to find the swap file(s).
551a557,562
> 	if (fname == NULL)				/* When there is no file name */
> #ifdef ADDED_BY_WEBB_COMPILE
> 		fname = (char_u *)"";
> #else
> 		fname = "";
> #endif /* ADDED_BY_WEBB_COMPILE */
553c564,565
< 	if (len >= 4 && vim_strnicmp(fname + len - 4, (char_u *)".sw", (size_t)3) == 0)
---
> 	if (len >= 4 && vim_strnicmp(fname + len - 4,
> 									(char_u *)".sw", (size_t)3) == 0)
555d566
< 		fname = strsave(fname);		/* make a copy for mf_open */
556a568
> 		fname = strsave(fname);		/* make a copy for mf_open */
560d571
< 		fname = makeswapname(curbuf, FALSE);
561a573,598
> 
> 			/* count the number of matching swap files */
> 		len = recover_names(&fname, FALSE, 0);
> 		if (len == 0)				/* no swap files found */
> 		{
> 			EMSG2("No swap file found for %s", fname);
> 			fname = NULL;
> 			goto theend;
> 		}
> 		if (len == 1)				/* one swap file found, use it */
> 			i = 1;
> 		else						/* several swap files found, choose */
> 		{
> 				/* list the names of the swap files */
> 			(void)recover_names(&fname, TRUE, 0);
> 			msg_outchar('\n');
> 			MSG_OUTSTR("Enter number of swap file to use (0 to quit): ");
> 			i = get_number();
> 			if (i < 1 || i > len)
> 			{
> 				fname = NULL;
> 				goto theend;
> 			}
> 		}
> 				/* get the swap file name that will be used */
> 		(void)recover_names(&fname, FALSE, i);
565a603,607
> 			/* When called from main() still need to initialize storage
> 			 * structure */
> 	if (curbuf->b_ml.ml_mfp == NULL && ml_open() == FAIL)
> 		getout(1);
> 
584,588c626
<  * open the memfile
<  *
<  * If swap file name not given directly, 'directory' option is set and
<  * does not start with '>' may try twice: first in current dir and if that
<  * fails in 'directory'.
---
>  * open the memfile from the old swap file
590,599c628
< 	if (!directly && *p_dir != NUL && *p_dir != '>')
< 		i = 0;		/* try twice */
< 	else
< 		i = 1;		/* try once */
< 	for ( ; i < 2 && (mfp = mf_open(fname, FALSE, i == 0)) == NULL; i++)
< 	{
< 		fname = makeswapname(curbuf, TRUE);
< 		if (fname == NULL)
< 			goto theend;
< 	}
---
> 	mfp = mf_open(fname, FALSE, TRUE);
613,615c642,644
< 		msg_outstr((char_u *)"Unable to read block 0 from ");
< 		msg_outstr(fname);
< 		msg_outstr((char_u *)"\nMaybe no changes were made or Vim did not update the .swp file");
---
> 		MSG_OUTSTR("Unable to read block 0 from ");
> 		msg_outtrans(fname);
> 		MSG_OUTSTR("\nMaybe no changes were made or Vim did not update the swap file");
645,646c674,675
< 	smsg((char_u *)"Using swap file \"%s\", original file \"%s\"", fname,
< 				curbuf->b_filename == NULL ? "No File" : (char *)curbuf->b_filename);
---
> 	home_replace(fname, NameBuff, MAXPATHL);
> 	smsg((char_u *)"Using swap file \"%s\"", NameBuff);
647a677,683
> 	if (curbuf->b_filename == NULL)
> 		STRCPY(NameBuff, "No File");
> 	else
> 		home_replace(curbuf->b_filename, NameBuff, MAXPATHL);
> 	smsg((char_u *)"Original file \"%s\"", NameBuff);
> 	msg_outchar((char_u)'\n');
> 
853c889
< 	recoverymode = 0;
---
> 	recoverymode = FALSE;
861,863c897,899
< 		msg_outstr("\n(You might want to write out this file under another name\n");
< 		msg_outstr("and run diff with the original file to check for changes)\n");
< 		msg_outstr("Delete the .swp file afterwards.\n\n");
---
> 		MSG_OUTSTR("\n(You might want to write out this file under another name\n");
> 		MSG_OUTSTR("and run diff with the original file to check for changes)\n");
> 		MSG_OUTSTR("Delete the .swp file afterwards.\n\n");
880a917,1163
>  * Find the names of swap files in current directory and the directory given
>  * with the 'directory' option.
>  *
>  * Used to:
>  * - list the swap files for "vim -r"
>  * - count the number of swap files when recovering
>  * - list the swap files when recovering
>  * - find the name of the n'th swap file when recovering
>  */
> 	int
> recover_names(fname, list, nr)
> 	char_u		**fname;	/* base for swap file name */
> 	int			list;		/* when TRUE, list the swap file names */
> 	int			nr;			/* when non-zero, return nr'th swap file name */
> {
> 	int			num_names;
> 	char_u		*(names[6]);
> 	char_u		*tail;
> #ifdef ADDED_BY_WEBB_COMPILE
> /* Apollo compiler complains about value assigned never being used.  Gcc
>  * doesn't complain anyway about no initialisation in this case.
>  */
> 	char_u		*p;
> #else
> 	char_u		*p = NULL;	/* init to stop compiler warnings */
> #endif /* ADDED_BY_WEBB_COMPILE */
> 	int			num_files;
> 	int			file_count = 0;
> 	char_u		**files;
> 	int			i;
> 	int			dir_num;
> 	struct stat st;
> 
> 	if (list)
> 	{
> 			/* use msg() to start the scrolling properly */
> 		msg((char_u *)"Swap files found:");
> 		msg_outchar('\n');
> 	}
> 	expand_interactively = TRUE;
> 	for (dir_num = 0; dir_num <= 1; ++dir_num)
> 	{
> 		if (dir_num == 0)			/* check current dir */
> 		{
> 			if (*p_dir == '>')		/* not using current dir */
> 				continue;
> 			if (fname == NULL || *fname == NULL)
> 			{
> 				names[0] = strsave((char_u *)"*.sw?");
> #ifdef UNIX
> 					/* for Unix names starting with a dot are special */
> 				names[1] = strsave((char_u *)".*.sw?");
> 				names[2] = strsave((char_u *)".sw?");
> 				num_names = 3;
> #else
> 				num_names = 1;
> #endif
> 			}
> 			else
> 			{
> 				names[0] = concat_fnames(*fname, (char_u *)".sw?", FALSE);
> 				/*
> 				 * Also make the shortname version of the file name.
> 				 * Only use it if it is different.
> 				 */
> 				i = curbuf->b_shortname;
> 				curbuf->b_shortname = TRUE;
> 				names[1] = modname(*fname, (char_u *)".sw?");
> 				curbuf->b_shortname = i;
> 				if (STRCMP(names[0], names[1]) == 0)
> 				{
> 					free(names[1]);
> 					num_names = 1;
> 				}
> 				else
> 					num_names = 2;
> 			}
> 		}
> 		else						/* check 'directory' dir */
> 		{
> 			p = p_dir;
> 			if (*p == '>')
> 				++p;
> 			if (STRLEN(p) == 0)
> 				num_names = 0;
> 			else if (fname == NULL || *fname == NULL)
> 			{
> 				names[0] = concat_fnames(p, (char_u *)"*.sw?", TRUE);
> #ifdef UNIX
> 					/* for Unix names starting with a dot are special */
> 				names[1] = concat_fnames(p, (char_u *)".*.sw?", TRUE);
> 				names[2] = concat_fnames(p, (char_u *)".sw?", TRUE);
> 				num_names = 3;
> #else
> 				num_names = 1;
> #endif
> 			}
> 			else
> 			{
> 				tail = gettail(*fname);
> 				tail = concat_fnames(p, tail, TRUE);
> 				if (tail == NULL)
> 					num_names = 0;
> 				else
> 				{
> 					names[0] = concat_fnames(tail, (char_u *)".sw?", FALSE);
> 					/*
> 					 * Also make the shorname version of the file name.
> 					 * Only use it if it is different.
> 					 */
> 					i = curbuf->b_shortname;
> 					curbuf->b_shortname = TRUE;
> 					names[1] = modname(tail, (char_u *)".sw?");
> 					curbuf->b_shortname = i;
> 					if (STRCMP(names[0], names[1]) == 0)
> 					{
> 						free(names[1]);
> 						num_names = 1;
> 					}
> 					else
> 						num_names = 2;
> 					free(tail);
> 				}
> 			}
> 		}
> 
> 			/* check for out-of-memory */
> 		for (i = 0; i < num_names; ++i)
> 		{
> 			if (names[i] == NULL)
> 			{
> 				for (i = 0; i < num_names; ++i)
> 					free(names[i]);
> 				num_names = 0;
> 			}
> 		}
> 		if (num_names == 0)
> 			num_files = 0;
> 		else if (ExpandWildCards(num_names, names,
> 							&num_files, &files, TRUE, FALSE) == FAIL)
> 		{
> 			MSG_OUTSTR(files);		/* print error message */
> 			num_files = 0;
> 		}
> 		/*
> 		 * remove swapfile name of the current buffer, it must be ignored
> 		 */
> 		if (curbuf->b_ml.ml_mfp != NULL &&
> 								(p = curbuf->b_ml.ml_mfp->mf_fname) != NULL)
> 		{
> 			for (i = 0; i < num_files; ++i)
> 				if (fullpathcmp(p, files[i]) == FALSE)
> 				{
> 					free(files[i]);
> 					--num_files;
> 					for ( ; i < num_files; ++i)
> 						files[i] = files[i + 1];
> 					break;
> 				}
> 		}
> 		if (nr)
> 		{
> 			file_count += num_files;
> 			if (nr <= file_count)
> 			{
> 				*fname = strsave(files[nr - 1 + num_files - file_count]);
> 				dir_num = 3;					/* stop searching */
> 			}
> 		}
> 		else if (list)
> 		{
> 			if (dir_num == 0)
> 			{
> 				if (fname == NULL || *fname == NULL)
> 					MSG_OUTSTR("   In current directory:\n");
> 				else
> 					MSG_OUTSTR("   Using specified name:\n");
> 			}
> 			else
> 			{
> 				MSG_OUTSTR("   In directory ");
> 				home_replace(*p_dir == '>' ? p_dir + 1 : p_dir,
> 													NameBuff, MAXPATHL);
> 				msg_outstr(NameBuff);
> 				MSG_OUTSTR(":\n");
> 			}
> 
> 			if (num_files)
> 			{
> 				for (i = 0; i < num_files; ++i)
> 				{
> 					/* print the swap file name */
> 					msg_outnum((long)++file_count);
> 					MSG_OUTSTR(".    ");
> 					msg_outstr(gettail(files[i]));
> 					msg_outchar('\n');
> 					/* print the swap file date */
> 					if (stat((char *)files[i], &st) != -1)
> 					{
> 						MSG_OUTSTR("         dated:     ");
> 						MSG_OUTSTR(ctime(&st.st_mtime));
> 					}
> 					/* print the original file name */
> 					{
> 						int				fd;
> 						struct block0	b0;
> 
> 						fd = open(files[i], O_RDONLY);
> 						if (fd >= 0)
> 						{
> 							if (read(fd, &b0, sizeof(b0)) == sizeof(b0))
> 							{
> 								if (b0.b0_id != BLOCK0_ID)
> 									MSG_OUTSTR("         [is not a swap file]");
> 								else
> 								{
> 									MSG_OUTSTR("         file name: ");
> 									home_replace(b0.b0_fname, NameBuff, MAXPATHL);
> 									msg_outstr(NameBuff);
> 								}
> 							}
> 							else
> 								MSG_OUTSTR("         [cannot be read]");
> 							close(fd);
> 						}
> 						else
> 							MSG_OUTSTR("         [cannot be opened]");
> 						msg_outchar('\n');
> 					}
> 				}
> 			}
> 			else
> 				MSG_OUTSTR("      -- none --\n");
> 			flushbuf();
> 		}
> 		else
> 			file_count += num_files;
> 
> 		for (i = 0; i < num_names; ++i)
> 			free(names[i]);
> 		FreeWild(num_files, files);
> 	}
> 	expand_interactively = FALSE;
> 	return file_count;
> }
> 
> /*
1130c1413
< 	BHDR		*hp = NULL;
---
> 	BHDR		*hp;
1649d1931
< 		buf->b_ml.ml_flags |= ML_EMPTY;
1651,1652c1933,1936
< 			emsg("No lines in buffer");
< 		return ml_replace(1, (char_u *)"", TRUE);
---
> 			keep_msg = (char_u *)"No lines in buffer";
> 		i = ml_replace(1, (char_u *)"", TRUE);
> 		buf->b_ml.ml_flags |= ML_EMPTY;
> 		return i;
2339c2623
< 	s = concat_fnames(pdir, fname);
---
> 	s = concat_fnames(pdir, fname, TRUE);
2406c2690
< 			int				equal = FALSE;
---
> 			int				same = FALSE;
2413c2697
< 			if (STRCHR(tail, '.') != NULL || STRLEN(tail) > 8)
---
> 			if (STRCHR(tail, '.') != NULL || STRLEN(tail) > (size_t)8)
2426c2710
< 					f1 = open(fname, O_RDONLY);
---
> 					f1 = open((char *)fname, O_RDONLY);
2429c2713
< 						f1 = open(fname, O_RDWR|O_CREAT|O_EXCL);
---
> 						f1 = open((char *)fname, O_RDWR|O_CREAT|O_EXCL);
2434c2718
< 						f2 = open(fname2, O_RDONLY);
---
> 						f2 = open((char *)fname2, O_RDONLY);
2437c2721
< 							f2 = open(fname, O_RDWR|O_CREAT|O_EXCL);
---
> 							f2 = open((char *)fname, O_RDWR|O_CREAT|O_EXCL);
2450c2734
< 								equal = TRUE;
---
> 								same = TRUE;
2460c2744
< 					if (equal)
---
> 					if (same)
2522,2524c2806,2808
< 			 * Give an error message, unless recovering, no file name or when
< 			 * the path of the file is different (happens when all .swp files
< 			 * are in one directory).
---
> 			 * Give an error message, unless recovering, no file name, we are
> 			 * viewing a help file or when the path of the file is different
> 			 * (happens when all .swp files are in one directory).
2526c2810
< 			if (!recoverymode && buf->b_xfilename != NULL)
---
> 			if (!recoverymode && buf->b_xfilename != NULL && !buf->b_help)
2532c2816
< 				fd = open(fname, O_RDONLY);
---
> 				fd = open((char *)fname, O_RDONLY);
2548,2550c2832,2834
< 					msg_outstr("\nFound a swap file by the name \"");
< 					msg_outstr(fname);
< 					msg_outstr("\"\n");
---
> 					MSG_OUTSTR("\nFound a swap file by the name \"");
> 					msg_outtrans(fname);
> 					MSG_OUTSTR("\"\n");
2553,2554c2837,2838
< 						msg_outstr((char_u *)"                        dated ");
< 						msg_outstr((char_u *)ctime(&st.st_mtime));
---
> 						MSG_OUTSTR("                        dated ");
> 						MSG_OUTSTR(ctime(&st.st_mtime));
2556,2558c2840,2842
< 					msg_outstr("           while opening file \"");
< 					msg_outstr(buf->b_xfilename);
< 					msg_outstr("\"\n");
---
> 					MSG_OUTSTR("           while opening file \"");
> 					msg_outtrans(buf->b_xfilename);
> 					MSG_OUTSTR("\"\n");
2561,2562c2845,2846
< 						msg_outstr((char_u *)"                        dated ");
< 						msg_outstr((char_u *)ctime(&st.st_mtime));
---
> 						MSG_OUTSTR("                        dated ");
> 						MSG_OUTSTR(ctime(&st.st_mtime));
2564,2572c2848,2856
< 					msg_outstr("\n(1) Another program may be editing the same file.\n");
< 					msg_outstr("    If this is the case, quit this edit session to avoid problems.\n");
< 					msg_outstr("\n(2) An edit session for this file crashed.\n");
< 					msg_outstr("    If this is the case, use \":recover\" or \"Vim -r ");
< 					msg_outstr(buf->b_xfilename);
< 					msg_outstr("\"\n    to recover the changes.\n");
< 					msg_outstr("    If you did this already, delete the swap file \"");
< 					msg_outstr(fname);
< 					msg_outstr("\"\n    to avoid this message.\n\n");
---
> 					MSG_OUTSTR("\n(1) Another program may be editing the same file.\n");
> 					MSG_OUTSTR("    If this is the case, quit this edit session to avoid problems.\n");
> 					MSG_OUTSTR("\n(2) An edit session for this file crashed.\n");
> 					MSG_OUTSTR("    If this is the case, use \":recover\" or \"Vim -r ");
> 					msg_outtrans(buf->b_xfilename);
> 					MSG_OUTSTR("\"\n    to recover the changes.\n");
> 					MSG_OUTSTR("    If you did this already, delete the swap file \"");
> 					msg_outtrans(fname);
> 					MSG_OUTSTR("\"\n    to avoid this message.\n\n");
Index: ./src/message.c
diff -r ../vim.orig/src/message.c ./src/message.c
40c40
< 	if (msg_highlight)			/* actually it is highlighting instead of invert */
---
> 	if (msg_highlight)
42c42
< 	msg_outtrans(s, -1);
---
> 	msg_outtrans(s);
81c81
< 	char_u			Buf[MAXPATHL + 30];
---
> 	char_u			*Buf = NULL;
82a83
> 	static int		last_lnum = 0;
86a88
> 	did_emsg = TRUE;			/* flag for DoOneCmd() */
97c99,101
< 	if (sourcing_name)
---
> 	if (sourcing_name || sourcing_lnum != last_lnum)
> 		Buf = alloc(MAXPATHL + 30);
> 	if (Buf != NULL && sourcing_name)
105a110,124
> 		last_lnum = 0;
> 	}
> /*
>  * output line number of source of error message
>  */
> 	if (Buf != NULL && sourcing_lnum != last_lnum)
> 	{
> 		++no_wait_return;
> 		(void)set_highlight('n');	/* set highlight mode for line numbers */
> 		sprintf((char *)Buf, "line %4ld:", sourcing_lnum);
> 		msg(Buf);
> 		(void)set_highlight('e');	/* set highlight mode for error messages */
> 		msg_highlight = TRUE;
> 		--no_wait_return;
> 		last_lnum = sourcing_lnum;	/* only once for each line */
106a126
> 	free(Buf);
112c132,133
< 	if (msg(s))
---
> 	retval = msg(s);
> 	if (retval)
122d142
< 		retval = TRUE;
124d143
< 	retval = FALSE;
150c169,170
< 	if (p_shm == 2 && (n = STRLEN(s) - sc_col + 1) > 0)
---
> 	if (p_shm == 2 &&
> 		(n = STRLEN(s) - (Rows - cmdline_row - 1) * Columns - sc_col + 1) > 0)
175d194
< 	skip_redraw = FALSE;			/* default: don't skip redraw */
185,186d203
< 		if (!termcap_active)
< 			starttermcap();
206c223
< 			msg_outstr((char_u *)"Interrupt: ");
---
> 			MSG_OUTSTR("Interrupt: ");
211c228
< 		msg_outstr("Press RETURN to continue");
---
> 		MSG_OUTSTR("Press RETURN to continue");
219c236
< 		msg_outstr((char_u *)"Press RETURN or enter command to continue");
---
> 		MSG_OUTSTR("Press RETURN or enter command to continue");
227a245
> 		{
228a247,249
> 			do_redraw = TRUE;		/* need a redraw even though there is
> 									   something in the stuff buffer */
> 		}
233c254,255
< 	 * If the user hits ':' we get a command line from the next line.
---
> 	 * If the user hits ':', '?' or '/' we get a command line from the next
> 	 * line.
235c257,258
< 	if (c == ':')
---
> 	if (c == ':' || c == '?' || c == '/')
> 	{
237,239c260,262
< 
< 	if (!termcap_active)			/* start termcap before redrawing */
< 		starttermcap();
---
> 		skip_redraw = TRUE;			/* skip redraw once */
> 		do_redraw = FALSE;
> 	}
250c273,275
< 	else if (c != ':' && (redraw == TRUE || (msg_scrolled && redraw != -1)))
---
> 	else if (!skip_redraw && (redraw == TRUE || (msg_scrolled && redraw != -1)))
> 	{
> 		starttermcap();				/* start termcap before redrawing */
251a277
> 	}
253,254d278
< 	if (c == ':')
< 		skip_redraw = TRUE;			/* skip redraw once */
329c353,360
< msg_outtrans(str, len)
---
> msg_outtrans(str)
> 	register char_u *str;
> {
> 	return msg_outtrans_len(str, STRLEN(str));
> }
> 
> 	int
> msg_outtrans_len(str, len)
335,336d365
< 	if (len == -1)
< 		len = STRLEN(str);
394c423
< 			msg_outstr((char_u *)"M-");
---
> 			MSG_OUTSTR("M-");
427c456
< 		(char_u *)"INSERT", (char_u *)"DEL",
---
> 		(char_u *)"BS", (char_u *)"INSERT", (char_u *)"DEL",
542c571
< 				msg_moremsg();
---
> 				msg_moremsg(FALSE);
551a581,586
> 					case ':':			/* start new command line */
> 						stuffcharReadbuff(':');
> 						cmdline_row = Rows - 1;		/* put ':' on this line */
> 						skip_redraw = TRUE;			/* skip redraw once */
> 						dont_wait_return = TRUE;	/* don't wait in main() */
> 						/*FALLTHROUGH*/
564a600
> 						msg_moremsg(TRUE);
576c612
< 		if (*s == '\n')
---
> 		if (*s == '\n')				/* go to next line */
581a618,622
> 		else if (*s == '\b')		/* go to previous char */
> 		{
> 			if (msg_col)
> 				--msg_col;
> 		}
597c638,639
< msg_moremsg()
---
> msg_moremsg(full)
> 	int		full;
607c649,651
< 	screen_msg((char_u *)"-- More -- (RET: line, SPACE: page, d: half page, q: quit)", (int)Rows - 1, 0);
---
> 	screen_msg((char_u *)"-- More --", (int)Rows - 1, 0);
> 	if (full)
> 		screen_msg((char_u *)" (RET: line, SPACE: page, d: half page, q: quit)", (int)Rows - 1, 10);
Index: ./src/misccmds.c
diff -r ../vim.orig/src/misccmds.c ./src/misccmds.c
138a139,141
> #if 1		/* code from Robert */
> 			char_u	*ptr;
> 			char_u	last_char;
141a145,147
> 			old_cursor = curwin->w_cursor;
> 			ptr = saved_line;
> 			lead_len = get_leader_len(ptr);
143a150,305
> 				/*
> 				 * Skip preprocessor directives, unless they are recognised as
> 				 * comments.
> 				 */
> 				if (lead_len == 0 && ptr[0] == '#')
> 				{
> 					while (ptr[0] == '#' && curwin->w_cursor.lnum > 1)
> 						ptr = ml_get(--curwin->w_cursor.lnum);
> 					newindent = get_indent();
> 				}
> 				lead_len = get_leader_len(ptr);
> 				if (lead_len > 0)
> 				{
> 					/*
> 					 * This case gets the following right:
> 					 *		\*
> 					 *		 * A comment (read "\" as "/").
> 					 *		 *\
> 					 * #define IN_THE_WAY
> 					 *		This should line up here;
> 					 */
> 					p = ptr;
> 					skipwhite(&p);
> 					if (p[0] == '/' && p[1] == '*')
> 						p++;
> 					if (p[0] == '*')
> 					{
> 						for (p++; *p; p++)
> 						{
> 							if (p[0] == '/' && p[-1] == '*')
> 							{
> 								/*
> 								 * End of C comment, indent should line up with
> 								 * the line containing the start of the comment
> 								 */
> 								curwin->w_cursor.col = p - ptr;
> 								if ((pos = findmatch(NUL)) != NULL)
> 								{
> 									curwin->w_cursor.lnum = pos->lnum;
> 									newindent = get_indent();
> 								}
> 							}
> 						}
> 					}
> 				}
> 				else	/* Not a comment line */
> 				{
> 					/* Find last non-blank in line */
> 					p = ptr + STRLEN(ptr) - 1;
> 					while (p > ptr && iswhite(*p))
> 						--p;
> 					last_char = *p;
> 
> 					/*
> 					 * find the character just before the '{' or ';'
> 					 */
> 					if (last_char == '{' || last_char == ';')
> 					{
> 						if (p > ptr)
> 							--p;
> 						while (p > ptr && iswhite(*p))
> 							--p;
> 					}
> 					/*
> 					 * Try to catch lines that are split over multiple
> 					 * lines.  eg:
> 					 *		if (condition &&
> 					 *					condition) {
> 					 *			Should line up here!
> 					 *		}
> 					 */
> 					if (*p == ')')
> 					{
> 						curwin->w_cursor.col = p - ptr;
> 						if ((pos = findmatch('(')) != NULL)
> 						{
> 							curwin->w_cursor.lnum = pos->lnum;
> 							newindent = get_indent();
> 							ptr = ml_get(curwin->w_cursor.lnum);
> 						}
> 					}
> 					/*
> 					 * If last character is '{' do indent, without checking
> 					 * for "if" and the like.
> 					 */
> 					if (last_char == '{')
> 					{
> 						did_si = TRUE;	/* do indent */
> 						no_si = TRUE;	/* don't delete it when '{' typed */
> 					}
> 					/*
> 					 * Look for "if" and the like.
> 					 * Don't do this if the previous line ended in ';' or '}'.
> 					 */
> 					else if (last_char != ';' && last_char != '}')
> 					{
> 						p = ptr;
> 						skipwhite(&p);
> 						for (pp = p; islower(*pp); ++pp)
> 							;
> 						/* Careful for vars starting with "if" */
> 						if (!isidchar(*pp))
> 						{
> 							temp = *pp;
> 							*pp = NUL;
> 							for (i = sizeof(si_tab)/sizeof(char_u *); --i >= 0;)
> 								if (STRCMP(p, si_tab[i]) == 0)
> 								{
> 									did_si = TRUE;
> 									break;
> 								}
> 							*pp = temp;
> 						}
> 					}
> 				}
> 			}
> 			else /* dir == BACKWARD */
> 			{
> 				/*
> 				 * Skip preprocessor directives, unless they are recognised as
> 				 * comments.
> 				 */
> 				if (lead_len == 0 && ptr[0] == '#')
> 				{
> 					int was_backslashed = FALSE;
> 
> 					while ((ptr[0] == '#' || was_backslashed) &&
> 							curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)
> 					{
> 						if (*ptr && ptr[STRLEN(ptr) - 1] == '\\')
> 							was_backslashed = TRUE;
> 						else
> 							was_backslashed = FALSE;
> 						ptr = ml_get(++curwin->w_cursor.lnum);
> 					}
> 					if (was_backslashed)
> 						newindent = 0;		/* Got to end of file */
> 					else
> 						newindent = get_indent();
> 				}
> 				p = ptr;
> 				skipwhite(&p);
> 				if (*p == '}')			/* if line starts with '}': do indent */
> 					did_si = TRUE;
> 				else
> 					can_si_back = TRUE;	/* can delete indent when '{' typed */
> 			}
> 			curwin->w_cursor = old_cursor;
> 
> #else		/* old code */
> 
> 			char_u	*pp;
> 			int		i;
> 
> 			if (dir == FORWARD)
> 			{
159c321,322
< 					if (!isidchar(*pp))		/* careful for vars starting with "if" */
---
> 									/* careful for vars starting with "if" */
> 					if (!isidchar_id(*pp))
179a343
> #endif
363c527
< 				for (n = strlen(saved_line); n > 0 && iswhite(saved_line[n - 1]); --n)
---
> 				for (n = STRLEN(saved_line); n > 0 && iswhite(saved_line[n - 1]); --n)
524c688
< 	register long		col = 0;
---
> 	register long		col;
969c1133
< 	char	buf[20];
---
> 	char_u	buf[20];
982c1146
< 				len = GetChars(&(buf[0]), 20, -1);
---
> 				len = GetChars(buf, 20, -1);
996a1161,1190
> /*
>  * get a number from the user
>  */
> 	int
> get_number()
> {
> 	int		n = 0;
> 	int		c;
> 
> 	for (;;)
> 	{
> 		windgoto(msg_row, msg_col);
> 		screen_start();
> 		c = vgetc();
> 		if (isdigit(c))
> 		{
> 			n = n * 10 + c - '0';
> 			msg_outchar(c);
> 		}
> 		else if (c == K_DEL || c == K_BS)
> 		{
> 			n /= 10;
> 			MSG_OUTSTR("\b \b");
> 		}
> 		else if (c == CR || c == NL || c == Ctrl('C'))
> 			break;
> 	}
> 	return n;
> }
> 
1003c1197,1198
< 	if (global_busy)		/* no messages now, wait until global is finished */
---
> 	if (global_busy ||		/* no messages now, wait until global is finished */
> 			keep_msg)		/* there is a message already, skip this one */
1013c1208,1212
< 		sprintf((char_u *)msg_buf, (char_u *)"%ld %s line%s %s",
---
> #ifdef ADDED_BY_WEBB_COMPILE
> 		sprintf((char *)msg_buf, "%ld %s line%s %s",
> #else
> 		sprintf((char *)msg_buf, (char_u *)"%ld %s line%s %s",
> #endif /* ADDED_BY_WEBB_COMPILE */
1040a1240
> #if 0		/* this mostly goes too fast to be seen */
1049a1250
> #endif
1160,1161c1361,1362
< 	struct stat st1, st2;
< 	char_u buf1[MAXPATHL];
---
> 	struct stat		st1, st2;
> 	char_u			buf1[MAXPATHL];
1169,1178c1370,1387
< 	char_u buf1[MAXPATHL];
< 	char_u buf2[MAXPATHL];
< 
< 	expand_env(s1, buf2, MAXPATHL);
< 	if (FullName(buf2, buf1, MAXPATHL) == OK && FullName(s2, buf2, MAXPATHL) == OK)
< 		return STRCMP(buf1, buf2);
< 	/*
< 	 * one of the FullNames() failed, file probably doesn't exist.
< 	 */
< 	return TRUE;
---
> 	char_u	*buf1 = NULL;
> 	char_u	*buf2 = NULL;
> 	int		retval = TRUE;
> 	
> 	if ((buf1 = alloc(MAXPATHL)) != NULL && (buf2 = alloc(MAXPATHL)) != NULL)
> 	{
> 		expand_env(s1, buf2, MAXPATHL);
> 		/*
> 		 * If one of the FullNames() failed, the file probably doesn't exist,
> 		 * this is counted as a different file name.
> 		 */
> 		if (FullName(buf2, buf1, MAXPATHL) == OK &&
> 								FullName(s2, buf2, MAXPATHL) == OK)
> 			retval = STRCMP(buf1, buf2);
> 	}
> 	free(buf1);
> 	free(buf2);
> 	return retval;
1192c1401
< 		return "";
---
> 		return (char_u *)"";
1220,1286d1428
<  * List the names of swap files in current directory and 'directory' option.
<  */
< 	void
< recover_list()
< {
< 	int			num_names = 1;
< 	char_u		*(names[1]);
< 	char_u		*p;
< 	int			num_files;
< 	char_u		**files;
< 	int			i;
< 	int			dir_num;
< 
< 	msg((char_u *)"Swap files found:");
< 	outchar('\n');
< 	expand_interactively = TRUE;
< 	for (dir_num = 0; dir_num <= 1; ++dir_num)
< 	{
< 		if (dir_num == 0)			/* check current dir */
< 			names[0] = (char_u *) "*.sw?";
< 		else						/* check 'directory' dir */
< 		{
< 			p = p_dir;
< 			if (*p == '>')
< 				++p;
< 			if (STRLEN(p) == 0)
< 				num_names = 0;
< 			else
< 			{
< 				names[0] = concat_fnames(p, (char_u *)"*.sw?");
< 				if (names[1] == NULL)
< 					num_names = 0;
< 			}
< 		}
< 
< 		if (dir_num == 0)
< 			outstrn("In current directory:\n");
< 		else
< 		{
< 			outstrn("In directory ");
< 			outstrn(p);
< 			outstrn(":\n");
< 		}
< 
< 		if (num_names == 0)
< 			num_files = 0;
< 		else if (ExpandWildCards(num_names, names,
< 							&num_files, &files, TRUE, FALSE) == FAIL)
< 		{
< 			outstrn((char_u *)files);		/* print error message */
< 			num_files = 0;
< 		}
< 		if (num_files)
< 		{
< 			for (i = 0; i < num_files; ++i)
< 			{
< 				outstrn(files[i]);
< 				outchar('\n');
< 			}
< 		}
< 		else
< 			outstrn((char_u *)"-- none --\n");
< 	}
< 	flushbuf();
< }
< 
< /*
1288c1430
<  * Only add a '/' when neccesary.
---
>  * Only add a '/' when 'sep' is TRUE and it is neccesary.
1291c1433
< concat_fnames(fname1, fname2)
---
> concat_fnames(fname1, fname2, sep)
1293a1436
> 	int		sep;
1301c1444
< 		if (*dest && !ispathsep(*(dest + STRLEN(dest) - 1)))
---
> 		if (sep && *dest && !ispathsep(*(dest + STRLEN(dest) - 1)))
Index: ./src/msdos.c
diff -r ../vim.orig/src/msdos.c ./src/msdos.c
190,191c190,191
< 				/* only recognize button-down event */
< 			if (last_status == 0 && regs.x.bx != 0)
---
> 				/* only recognize button-down and button-up event */
> 			if ((last_status == 0) != (regs.x.bx == 0))
193c193,196
< 				mouse_click = regs.x.bx;
---
> 				if (last_status)		/* button up */
> 					mouse_click = MOUSE_RELEASE;
> 				else
> 					mouse_click = regs.x.bx;
357c360
< 	msg_outstr("new shell started\n");
---
> 	MSG_OUTSTR("new shell started\n");
853c856
< 	char_u	newcmd[200];
---
> 	char_u	*newcmd;
863,865c866,875
< 	{ 					/* we use "command" to start the shell, slow but easy */
< 		sprintf(newcmd, "%s /c %s", p_sh, cmd);
< 		x = system(newcmd);
---
> { 					/* we use "command" to start the shell, slow but easy */
> 		newcmd = alloc(STRLEN(p_sh) + STRLEN(cmd) + 5);
> 		if (newcmd == NULL)
> 			x = 1;
> 		else
> 		{
> 			sprintf(newcmd, "%s /c %s", p_sh, cmd);
> 			x = system(newcmd);
> 			free(newcmd);
> 		}
874c884
< 		msg_outstr((char_u *)" returned\n");
---
> 		MSG_OUTSTR(" returned\n");
970c980
< 	char_u	buf[MAXPATH];
---
> 	char_u	*buf;
973c983
< 	struct	ffblk fb;
---
> 	struct ffblk fb;
975a986,988
> 	buf = alloc(STRLEN(path) + 3);
> 	if (buf == NULL)
> 		return 1;
1018a1032
> 		free(buf);
1034a1049
> 	free(buf);
Index: ./src/msdos.h
diff -r ../vim.orig/src/msdos.h ./src/msdos.h
35c35
< # define VIM_HLP		"$VIM\\vim.hlp"
---
> # define VIM_HLP		"$VIM\\vim_help.txt"
77a78
> #define MOUSE_RELEASE	0x07
Index: ./src/normal.c
diff -r ../vim.orig/src/normal.c ./src/normal.c
30c30
< #define CLEAROP (operator = NOP)		/* clear any pending operator */
---
> #define CLEAROP 		clearop()		/* clear any pending operator */
39a40,44
> #ifdef ADDED_BY_WEBB_COMPILE
> static int		p_char = NUL;	/* prepended command char */
> #else
> static int		pchar = NUL;	/* prepended command char */
> #endif /* ADDED_BY_WEBB_COMPILE */
41c46
< static void		prep_redo __ARGS((long, int, int, int));
---
> static void		prep_redo __ARGS((long, int, int, int, int));
43a49
> static void		clearop __ARGS((void));
45d50
< static void		premsg __ARGS((int, int));
78c83
< 	long 			n;
---
> 	long 			n = 0;					/* init for GCC */
83c88
< 	int				nchar = NUL;
---
> 	int				nchar = NUL;			/* next command char */
86c91
< 	char_u			searchbuff[CMDBUFFSIZE];/* buffer for search string */
---
> 	char_u			*searchbuff = NULL;		/* buffer for search string */
88c93
< 	char_u			*ptr;
---
> 	char_u			*ptr = NULL;
115d119
< 	premsg(NUL, NUL);
117a122
> 	(void)add_to_showcmd(c);
121c126
< 	while ((c >= '1' && c <= '9') || (Prenum != 0 && (c == DEL || c == K_DEL || c == '0')))
---
> 	while ((c >= '1' && c <= '9') || (Prenum != 0 && (c == K_DEL || c == '0')))
123,124c128,129
< 		if (c == DEL || c == K_DEL)
< 				Prenum /= 10;
---
> 		if (c == K_DEL)
> 			Prenum /= 10;
126c131
< 				Prenum = Prenum * 10 + (c - '0');
---
> 			Prenum = Prenum * 10 + (c - '0');
129d133
< 		premsg(ctrl_w ? Ctrl('W') : ' ', NUL);
130a135
> 		(void)add_to_showcmd(c);
142d146
< 		premsg(c, NUL);
143a148
> 		(void)add_to_showcmd(c);
165d169
< 	premsg(c, NUL);
175d178
< 		premsg(c, nchar);
177c180
< 	else if (c < 0x100 && (strchr("@zZtTfF[]mg'`\"", c) ||
---
> 	else if ((c < 0x100 && strchr("@zZtTfF[]mg'`\"", c) != NULL) ||
179c182,186
< 									(c == 'r' && VIsual.lnum == 0)))
---
> 					(c == 'r' && !VIsual_active)
> #if defined(UNIX) || defined(MSDOS)
> 					|| c == K_MOUSE
> #endif
> 					)
184c191
< 		premsg(c, nchar);
---
> 		(void)add_to_showcmd(nchar);
187c194
< 		flushbuf();				/* flush the premsg() characters onto the
---
> 		flushbuf();				/* flush the showcmd characters onto the
292,296d298
< 			/*
< 			 * we misuse some variables to be able to call premsg()
< 			 */
< 			operator = c;
< 			opnum = Prenum;
300d301
< 				premsg(' ', NUL);
301a303
> 				(void)add_to_showcmd(nchar);
303c305
< 				if (nchar == DEL || c == K_DEL)
---
> 				if (c == K_DEL)
342c344
< 			n = (curwin->w_height + plines(curwin->w_cursor.lnum)) / 2;
---
> 			n = (curwin->w_height + plines(curwin->w_cursor.lnum)) / 2 - 1;
381c383
< 	    if (VIsual.lnum != 0)
---
> 	    if (VIsual_active)
402c404,408
< 		help();
---
> #ifdef ADDED_BY_WEBB_COMPILE
> 		dohelp((char_u *)"");
> #else
> 		dohelp("");
> #endif /* ADDED_BY_WEBB_COMPILE */
431a438,459
> 		if (VIsual_active)		/* :ta to visual highlighted text */
> 		{
> 			if (VIsual.lnum != curwin->w_cursor.lnum)
> 			{
> 				CLEAROPBEEP;
> 				break;
> 			}
> 			if (lt(curwin->w_cursor, VIsual))
> 			{
> 				ptr = ml_get_pos(&curwin->w_cursor);
> 				n = VIsual.col - curwin->w_cursor.col + 1;
> 			}
> 			else
> 			{
> 				ptr = ml_get_pos(&VIsual);
> 				n = curwin->w_cursor.col - VIsual.col + 1;
> 			}
> 			VIsual_active = FALSE;
> 			++RedrawingDisabled;
> 			update_curbuf(NOT_VALID);		/* update the inversion later */
> 			--RedrawingDisabled;
> 		}
436c464,465
< 		if ((n = find_ident_under_cursor(&ptr, c == '*' || c == '#')) == 0)
---
> 		if (ptr == NULL &&
> 				(n = find_ident_under_cursor(&ptr, c == '*' || c == '#')) == 0)
452c481
< sow:			if (isidchar(*ptr))
---
> sow:			if (isidchar_id(*ptr))
468a498,500
> 		{
> 			if (STRCHR(escape_chars, *ptr) != NULL)
> 				stuffcharReadbuff('\\');
469a502
> 		}
471c504
< 		if ((c == '*' || c == '#') && isidchar(ptr[-1]))
---
> 		if ((c == '*' || c == '#') && isidchar_id(ptr[-1]))
572c605
< 				if ((((c == Ctrl('H') || c == DEL || c == K_DEL) &&
---
> 				if ((((c == Ctrl('H') || c == K_DEL) &&
688,691c721,723
< 		 * effectively map 'cw' to 'ce', and 'cW' to 'cE', provided that we are
< 		 * not on a space or a TAB. This seems
< 		 * impolite at first, but it's really more what we mean when we say
< 		 * 'cw'.
---
> 		 * effectively map 'cw' to 'ce', and 'cW' to 'cE', provided that we
> 		 * are not on a space or a TAB. This seems impolite at first, but it's
> 		 * really more what we mean when we say 'cw'.
760c792
< 		if (!getcmdline(c, searchbuff))
---
> 		if ((searchbuff = getcmdline(c)) == NULL)
836c868
< 		if ((c == ']' || c == '[') && nchar == 'f')
---
> 		if (nchar == 'f')
858c890
< 			find_pattern_in_path(ptr, len, TRUE,
---
> 			find_pattern_in_path(ptr, len, TRUE, !isupper(nchar),
914a947,948
> 			else if (operator == NOP)
> 				beginline(TRUE);
924c958
< 			prep_redo(Prenum, c, nchar, NUL);
---
> 			prep_redo(Prenum, NUL, c, nchar, NUL);
1010c1044
< 	    if (VIsual.lnum != 0)
---
> 	    if (VIsual_active || operator == STRCHR(opchars, 'u') - opchars + 1)
1027c1061
< 	    if (VIsual.lnum != 0)
---
> 	    if (VIsual_active || operator == STRCHR(opchars, 'U') - opchars + 1)
1036c1070
< 	    if (VIsual.lnum != 0)
---
> 	    if (VIsual_active)
1057c1091
< 			prep_redo(Prenum1, 'r', nchar, NUL);
---
> 			prep_redo(Prenum1, NUL, 'r', nchar, NUL);
1072c1106
< 		prep_redo(Prenum1, 'r', c, nchar);
---
> 		prep_redo(Prenum1, NUL, 'r', c, nchar);
1096c1130
< 	    if (VIsual.lnum != 0)		/* join the visual lines */
---
> 	    if (VIsual_active)		/* join the visual lines */
1107c1141
< 		prep_redo(Prenum, 'J', NUL, NUL);
---
> 		prep_redo(Prenum, NUL, 'J', NUL, NUL);
1118c1152
< 		prep_redo(Prenum, c, NUL, NUL);
---
> 		prep_redo(Prenum, NUL, c, NUL, NUL);
1127c1161
< 			prep_redo(Prenum1, c, NUL, NUL);
---
> 			prep_redo(Prenum1, NUL, c, NUL, NUL);
1167c1201
< 	  	if (VIsual.lnum != 0)	/* switch start and end of visual */
---
> 	  	if (VIsual_active)	/* switch start and end of visual */
1207c1241
< 	    if (VIsual.lnum != 0)
---
> 	    if (VIsual_active)
1229c1263,1264
< 		if (!p_to && VIsual.lnum == 0)
---
> 		if (!p_to && !VIsual_active &&
> 					operator != STRCHR(opchars, '~') - opchars + 1)
1237c1272
< 			prep_redo(Prenum, '~', NUL, NUL);
---
> 			prep_redo(Prenum, NUL, '~', NUL, NUL);
1282d1316
< 	  case DEL:
1292c1326
< 	  	if (VIsual.lnum != 0)
---
> 	  	if (VIsual_active)
1396c1430
< 		if (VIsual.lnum != 0)
---
> 		if (VIsual_active)
1398c1432,1440
< 			Visual_mode = c;				/* may use another mode */
---
> 			if (c == 'v')					/* stop visual mode */
> 				VIsual_active = FALSE;
> 			else							/* toggle char/block mode */
> 			{								/*     or char/line mode */
> 				if (Visual_mode == c)
> 					Visual_mode = 'v';
> 				else
> 					Visual_mode = c;
> 			}
1412a1455
> 				VIsual_active = TRUE;
1449a1493
> 				VIsual_active = TRUE;
1462c1506
< 		VIsual.lnum = 0;					/* stop Visual */
---
> 		VIsual_active = FALSE;				/* stop Visual */
1481,1484c1525,1528
< 						/*
< 						 * "gf": goto file, edit file under cursor
< 						 * "]f" and "[f": can also be used.
< 						 */
---
> 			/*
> 			 * "gf": goto file, edit file under cursor
> 			 * "]f" and "[f": can also be used.
> 			 */
1487,1501c1531,1545
< 						ptr = file_name_at_cursor();
< 							/* do autowrite if necessary */
< 						if (curbuf->b_changed && curbuf->b_nwindows <= 1 && !p_hid)
< 							autowrite(curbuf);
< 						if (ptr != NULL)
< 						{
< 							setpcmark();
< 							stuffReadbuff((char_u *) ":e ");
< 							stuffReadbuff(ptr);
< 							stuffReadbuff((char_u *) "\n");
< 							free(ptr);
< 						}
< 						else
< 							CLEAROP;
< 						break;
---
> 				ptr = file_name_at_cursor();
> 					/* do autowrite if necessary */
> 				if (curbuf->b_changed && curbuf->b_nwindows <= 1 && !p_hid)
> 					autowrite(curbuf);
> 				if (ptr != NULL)
> 				{
> 					setpcmark();
> 					stuffReadbuff((char_u *) ":e ");
> 					stuffReadbuff(ptr);
> 					stuffReadbuff((char_u *) "\n");
> 					free(ptr);
> 				}
> 				else
> 					CLEAROP;
> 				break;
1503,1511c1547,1596
< 						/*
< 						 * "gs": goto sleep
< 						 */
< 			case 's':	while (Prenum1-- && !got_int)
< 						{
< 							sleep(1);
< 							breakcheck();
< 						}
< 						break;
---
> 			/*
> 			 * "gs": goto sleep
> 			 */
> 			case 's':
> 				while (Prenum1-- && !got_int)
> 				{
> 					sleep(1);
> 					breakcheck();
> 				}
> 				break;
> 
> 			/*
> 			 * Display the ascii value of the character under the cursor.
> 			 * It is displayed in decimal, hex, and octal. -- webb
> 			 */
> 			case 'a':
> 				do_ascii();
> 				break;
> 
> 			/*
> 			 * Goto the first line in file.  With a count it goes to that line
> 			 * number like for G. -- webb
> 			 */
> 			case 'g':
> 				mtype = MLINE;
> 				setpcmark();
> 				if (Prenum > curbuf->b_ml.ml_line_count)
> 						curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;
> 				else
> 						curwin->w_cursor.lnum = Prenum1;
> 				beginline(MAYBE);
> 				break;
> 
> 			/*
> 			 * Operators to change the case of text:
> 			 *   g~		Toggle the case of the text.
> 			 *   gu		Change text to lower case.
> 			 *   gU		Change text to upper case.
> 			 *									--webb
> 			 */
> 			case '~':
> 			case 'u':
> 			case 'U':
> #ifdef ADDED_BY_WEBB_COMPILE
> 				p_char = c;
> #else
> 				pchar = c;
> #endif /* ADDED_BY_WEBB_COMPILE */
> 				c = nchar;
> 				goto dooperator;
1532,1533c1617,1618
< 					sprintf((char *)pat, isidchar(*ptr) ? "\\<%.*s\\>" : "%.*s",
< 												len, ptr);
---
> 					sprintf((char *)pat, isidchar_id(*ptr) ? "\\<%.*s\\>" :
> 															"%.*s", len, ptr);
1543a1629,1630
> 					{
> 						setpcmark();		/* Set in findpar() otherwise */
1544a1632
> 					}
1574a1663,1666
> 		mouse_code = 0;					/* reset for next click */
> 			/* any button up and middle button down are ignored */
> 		if (nchar != 'L' && nchar != 'R' && nchar != 'P')
> 			break;
1585a1678
> 			 *                 position = change start or end of visual
1587a1681
> 			 *                 position = set cursor position
1590c1684
< 			if (VIsual.lnum != 0)
---
> 			if (VIsual_active && !curbuf->b_help)
1592c1686
< 				if ((mouse_code & MOUSE_MASK) == MOUSE_LEFT)
---
> 				if (nchar == 'L')
1594c1688
< 					VIsual.lnum = 0;
---
> 					VIsual_active = FALSE;
1597c1691
< 				else if ((mouse_code & MOUSE_MASK) == MOUSE_RIGHT)
---
> 				else if (nchar == 'R' || nchar == 'P')
1613c1707
< 			else if ((mouse_code & MOUSE_MASK) == MOUSE_RIGHT)
---
> 			else if (nchar == 'R' && !curbuf->b_help)
1616a1711
> 				VIsual_active = TRUE;
1619c1714,1723
< 			jumpto(mouse_row, mouse_col);
---
> 			if (jumpto(mouse_row, mouse_col, nchar == 'P', nchar != 'P')
> 																	== FAIL)
> 			{
> 				CLEAROPBEEP;
> 				break;
> 			}
> 				/* In help file: Right button is jump to tag */
> 			if (nchar == 'R' && curbuf->b_help)
> 				stuffcharReadbuff(Ctrl(']'));
> 
1621c1725
< 			if (curbuf != save_buffer && VIsual.lnum != 0)
---
> 			if (curbuf != save_buffer && VIsual_active)
1623,1624c1727,1728
< 				VIsual.lnum = 0;
< 				update_curbuf(NOT_VALID);		/* delete the inversion */
---
> 				VIsual_active = FALSE;
> 				update_curbuf(NOT_VALID);	/* delete the inversion */
1678c1782
< 		if (VIsual.lnum == 0 && (operator != NOP ||
---
> 		if (!VIsual_active && (operator != NOP ||
1684c1788
< 	    if (VIsual.lnum != 0)
---
> 	    if (VIsual_active)
1686c1790
< 			VIsual.lnum = 0;			/* stop Visual */
---
> 			VIsual_active = FALSE;		/* stop Visual */
1712c1816
< 	if ((VIsual.lnum != 0 || finish_op) && operator != NOP)
---
> 	if ((VIsual_active || finish_op) && operator != NOP)
1714c1818
< 		if (operator != YANK && VIsual.lnum == 0)		/* can't redo yank */
---
> 		if (operator != YANK && !VIsual_active)		/* can't redo yank */
1716c1820,1824
< 			prep_redo(Prenum, opchars[operator - 1], c, nchar);
---
> #ifdef ADDED_BY_WEBB_COMPILE
> 			prep_redo(Prenum, p_char, opchars[operator - 1], c, nchar);
> #else
> 			prep_redo(Prenum, pchar, opchars[operator - 1], c, nchar);
> #endif /* ADDED_BY_WEBB_COMPILE */
1747c1855
< 		else if (VIsual.lnum != 0)
---
> 		else if (VIsual_active)
1766c1874
< 		if (VIsual.lnum != 0 || redo_Visual_busy)
---
> 		if (VIsual_active || redo_Visual_busy)
1769a1878,1879
> 				colnr_t		start, end;
> 
1771,1774c1881,1887
< 				startvcol = getvcol(curwin, &(curbuf->b_startop), 2);
< 				n = getvcol(curwin, &(curbuf->b_endop), 2);
< 				if (n < startvcol)
< 					startvcol = (colnr_t)n;
---
> 				getvcol(curwin, &(curbuf->b_startop),
> 												&startvcol, NULL, &endvcol);
> 				getvcol(curwin, &(curbuf->b_endop), &start, NULL, &end);
> 				if (start < startvcol)
> 					startvcol = start;
> 				if (end > endvcol)
> 					endvcol = end;
1784,1786c1897,1901
< 						if ((n = getvcol(curwin, &curwin->w_cursor, 3)) >
< 														endvcol)
< 							endvcol = (colnr_t)n;
---
> 					{
> 						getvcol(curwin, &curwin->w_cursor, NULL, NULL, &end);
> 						if (end > endvcol)
> 							endvcol = end;
> 					}
1791,1797d1905
< 				else
< 				{
< 					endvcol = getvcol(curwin, &(curbuf->b_startop), 3);
< 					n = getvcol(curwin, &(curbuf->b_endop), 3);
< 					if (n > endvcol)
< 						endvcol = (colnr_t)n;
< 				}
1819c1927,1931
< 				prep_redo(0L, 'v', opchars[operator - 1], NUL);
---
> #ifdef ADDED_BY_WEBB_COMPILE
> 				prep_redo(0L, p_char, 'v', opchars[operator - 1], NUL);
> #else
> 				prep_redo(0L, pchar, 'v', opchars[operator - 1], NUL);
> #endif /* ADDED_BY_WEBB_COMPILE */
1848c1960
< 			VIsual.lnum = 0;
---
> 			VIsual_active = FALSE;
1974c2086,2091
< 		VIsual.lnum = 0;
---
> #ifdef ADDED_BY_WEBB_COMPILE
> 		p_char = NUL;
> #else
> 		pchar = NUL;
> #endif /* ADDED_BY_WEBB_COMPILE */
> 		VIsual_active = FALSE;
1980c2097,2098
< 	premsg(-1, NUL);
---
> 	if (operator == NOP && yankbuffer == 0)
> 		clear_showcmd();
1982c2100
< 	if (restart_edit && operator == NOP && VIsual.lnum == 0
---
> 	if (restart_edit && operator == NOP && !VIsual_active
1989a2108
> 	free(searchbuff);
2051c2170
< 					(i == 0 ? !isidchar(ptr[col]) : iswhite(ptr[col])))
---
> 					(i == 0 ? !isidchar_id(ptr[col]) : iswhite(ptr[col])))
2059,2060c2178,2179
< 		while (col > 0 && (i == 0 ? isidchar(ptr[col - 1]) :
< 					(!iswhite(ptr[col - 1]) && !isidchar(ptr[col - 1]))))
---
> 		while (col > 0 && (i == 0 ? isidchar_id(ptr[col - 1]) :
> 					(!iswhite(ptr[col - 1]) && !isidchar_id(ptr[col - 1]))))
2067c2186
< 		if (!try_string || isidchar(ptr[col]))
---
> 		if (!try_string || isidchar_id(ptr[col]))
2073c2192
< 	if (ptr[col] == NUL || (!isidchar(ptr[col]) && i == 0))
---
> 	if (ptr[col] == NUL || (!isidchar_id(ptr[col]) && i == 0))
2084c2203
< 	while (i == 0 ? isidchar(*ptr) : (*ptr != NUL && !iswhite(*ptr)))
---
> 	while (i == 0 ? isidchar_id(*ptr) : (*ptr != NUL && !iswhite(*ptr)))
2093c2212
< prep_redo(num, cmd, c, nchar)
---
> prep_redo(num, prechar, cmd, c, nchar)
2094a2214
> 	int		prechar;
2106a2227,2228
> 	if (prechar != NUL)
> 		AppendCharToRedobuff(prechar);
2136c2258
< 	if (operator == NOP && VIsual.lnum == 0)
---
> 	if (operator == NOP && !VIsual_active)
2142a2265,2276
> clearop()
> {
> 	operator = NOP;
> 	yankbuffer = 0;
> #ifdef ADDED_BY_WEBB_COMPILE
> 	p_char = NUL;
> #else
> 	pchar = NUL;
> #endif /* ADDED_BY_WEBB_COMPILE */
> }
> 
> 	static void
2150,2151c2284
<  * display, on the last line of the window, the characters typed before
<  * the last command character, plus 'c1' and 'c2'
---
>  * Routines for displaying a partly typed command
2153,2155c2286,2319
< 	static void
< premsg(c1, c2)
< 	int c1, c2;
---
> static char_u	showcmd_buf[SHOWCMD_COLS + 1];
> static char_u	old_showcmd_buf[SHOWCMD_COLS + 1];	/* For push_showcmd() */
> static int		is_showcmd_clear = TRUE;
> 
> 	void
> clear_showcmd()
> {
> 	if (!p_sc)
> 		return;
> 
> 	showcmd_buf[0] = NUL;
> 
> 	/*
> 	 * Use is_showcmd_clear here instead of char_avail(), because after ^R in
> 	 * insert mode, there are always chars available, but we still want to
> 	 * clear the "^R" from the showcmd.
> 	 */
> 	if (!(!is_showcmd_clear || KeyTyped))
> 		return;
> 
> 	cursor_off();
> 	msg_pos((int)Rows - 1, sc_col);
> 	msg_outstr((char_u *)"          ");		/* SHOWCMD_COLS spaces */
> 	is_showcmd_clear = TRUE;
> 	setcursor();
> }
> 
> /*
>  * Add 'c' to string of shown command chars.
>  * Return TRUE if setcursor() has been called.
>  */
> 	int
> add_to_showcmd(c)
> 	int c;
2157d2320
< 	char_u	buf[40];
2158a2322,2335
> 	int		old_len;
> 	int		extra_len;
> 	int		overflow;
> 
> 	if (!p_sc)
> 		return FALSE;
> 
> 	p = transchar(c);
> 	old_len = STRLEN(showcmd_buf);
> 	extra_len = STRLEN(p);
> 	overflow = old_len + extra_len - SHOWCMD_COLS;
> 	if (overflow > 0)
> 		STRCPY(showcmd_buf, showcmd_buf + overflow);
> 	STRCAT(showcmd_buf, p);
2160c2337,2365
< 	if (!(p_sc && (!char_avail() || KeyTyped || c1 == -1 || c1 == ' ')))
---
> 	if (!(!char_avail() || KeyTyped))
> 		return FALSE;
> 
> 	cursor_off();
> 	msg_pos((int)Rows - 1, sc_col);
> 	msg_outstr(showcmd_buf);
> 	is_showcmd_clear = FALSE;
> 
> 	setcursor();			/* put cursor back where it belongs */
> 
> 	return TRUE;
> }
> 
> 	void
> push_showcmd()
> {
> 	if (p_sc)
> 		STRCPY(old_showcmd_buf, showcmd_buf);
> }
> 
> 	void
> pop_showcmd()
> {
> 	if (!p_sc)
> 		return;
> 
> 	STRCPY(showcmd_buf, old_showcmd_buf);
> 
> 	if (!(!char_avail() || KeyTyped))
2165,2202c2370,2373
< 	if (c1 == -1)
< 		msg_outstr((char_u *)"          ");	/* look in comp_col() for the number of spaces */
< 	else
< 	{
< 		p = buf;
< 		if (opnum)
< 		{
< 			sprintf((char *)p, "%ld", (long)opnum);
< 			p = p + STRLEN(buf);
< 		}
< 		if (yankbuffer)
< 		{
< 			*p++ = '"';
< 			*p++ = yankbuffer;
< 		}
< 		if (c1 == Ctrl('W'))		/* ^W is in between counts */
< 		{
< 			*p++ = '^';
< 			*p++ = 'W';
< 			c1 = NUL;
< 		}
< 		else if (operator == 'z')
< 			*p++ = 'z';
< 		else if (operator)
< 			*p++ = opchars[operator - 1];
< 		if (Prenum)
< 		{
< 			sprintf((char *)p, "%ld", (long)Prenum);
< 			p = p + STRLEN(p);
< 		}
< 		*p = NUL;
< 		if (c1)
< 			STRCPY(p, transchar(c1));
< 		if (c2)
< 			STRCAT(p, transchar(c2));
< 		buf[10] = NUL;			/* truncate at maximal length */
< 		msg_outstr(buf);
< 	}
---
> 	msg_outstr((char_u *)"          ");		/* SHOWCMD_COLS spaces */
> 	msg_pos((int)Rows - 1, sc_col);
> 	msg_outstr(showcmd_buf);
> 
2204d2374
< 	/* cursor_on(); */
Index: ./src/ops.c
diff -r ../vim.orig/src/ops.c ./src/ops.c
42a43
> static int		fmt_is_blank __ARGS((linenr_t, char_u **, int *));
315c316
< 		if (ins_typestr((char_u *)"\n", FALSE, 0, TRUE) == FAIL)
---
> 		if (ins_typebuf((char_u *)"\n", FALSE, 0, TRUE) == FAIL)
317c318
< 		if (ins_typestr(last_cmdline, FALSE, 0, TRUE) == FAIL)
---
> 		if (ins_typebuf(last_cmdline, FALSE, 0, TRUE) == FAIL)
319c320
< 		if (ins_typestr((char_u *)":", FALSE, 0, TRUE) == FAIL)
---
> 		if (ins_typebuf((char_u *)":", FALSE, 0, TRUE) == FAIL)
334c335
< 				if (ins_typestr((char_u *)"\n", FALSE, 0, TRUE) == FAIL)
---
> 				if (ins_typebuf((char_u *)"\n", FALSE, 0, TRUE) == FAIL)
337c338
< 			if (ins_typestr(y_current->y_array[i], FALSE, 0, TRUE) == FAIL)
---
> 			if (ins_typebuf(y_current->y_array[i], FALSE, 0, TRUE) == FAIL)
544c545,550
< 			dellines((long)(nlines - 1), TRUE, TRUE);
---
> 			if (nlines > 1)			/* delete the lines except the first one */
> 			{
> 				++curwin->w_cursor.lnum;
> 				dellines((long)(nlines - 1), TRUE, TRUE);
> 				--curwin->w_cursor.lnum;
> 			}
578c584,585
< 		while (curwin->w_cursor.col >= n)	/* delete from cursor to end of line */
---
> 								/* delete from cursor to end of line */
> 		while (curwin->w_cursor.col >= n)
582c589
< 		curbuf->b_startop = curwin->w_cursor;		/* remember curwin->w_cursor */
---
> 		curbuf->b_startop = curwin->w_cursor;	/* remember curwin->w_cursor */
590c597
< 		while (n-- >= 0)		/* delete from start of line until endop */
---
> 		while (n-- >= 0)			/* delete from start of line until endop */
593c600
< 		curwin->w_cursor = curbuf->b_startop;		/* restore curwin->w_cursor */
---
> 		curwin->w_cursor = curbuf->b_startop;	/* restore curwin->w_cursor */
707a715,716
> 	if (mtype == MLINE)
> 		l = 0;
710c719
< 		dodelete();
---
> 		dodelete();			/* delete the text and take care of undo */
744c753
< 			if (i % 1000 == 999)					/* this may take a while */
---
> 			if ((i & 1023) == 1023)					/* this may take a while */
956c965
< 	int			col;
---
> 	colnr_t		col;
1055c1064,1065
< 			col = getvcol(curwin, &curwin->w_cursor, 3) + 1;
---
> 			getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);
> 			++col;
1059c1069
< 			col = getvcol(curwin, &curwin->w_cursor, 2);
---
> 			getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);
1281a1292,1306
> /* Return the character name of the register with the given number */
> 	int
> get_register_name(num)
> 	int num;
> {
> 	if (num == -1)
> 		return '"';
> 	else if (num < 10)
> 		return num + '0';
> 	else if (num == 36)
> 		return '-';
> 	else
> 		return num + 'a' - 10;
> }
> 
1286c1311,1312
< dodis()
---
> dodis(arg)
> 	char_u *arg;
1292,1293c1318,1326
< 
< 	msg_outstr((char_u *)"\n--- Registers ---");
---
> 	char_u name;
>   
> 	if (arg != NULL && *arg == NUL)
> 		arg = NULL;
> 
> 	set_highlight('t');		/* Highlight title */
> 	start_highlight();
> 	MSG_OUTSTR("\n--- Registers ---");
> 	stop_highlight();
1305c1338,1339
< 		if (yb->y_array != NULL)
---
> 		name = get_register_name(i);
> 		if (yb->y_array != NULL && (arg == NULL || STRCHR(arg, name) != NULL))
1308,1320c1342,1344
< 			if (i == -1)
< 				msg_outstr((char_u *)"\"\"");
< 			else
< 			{
< 				msg_outchar('"');
< 				if (i < 10)
< 					msg_outchar(i + '0');
< 				else if (i == 36)
< 					msg_outchar('-');
< 				else
< 					msg_outchar(i + 'a' - 10);
< 			}
< 			msg_outstr((char_u *)"   ");
---
> 			msg_outchar('"');
> 			msg_outchar(name);
> 			MSG_OUTSTR("   ");
1327c1351
< 					msg_outstr((char_u *)"^J");
---
> 					MSG_OUTSTR("^J");
1331c1355
< 					msg_outtrans(p, 1);
---
> 					msg_outtrans_len(p, 1);
1340c1364,1365
< 	if ((p = get_last_insert()) != NULL)
---
> 	if ((p = get_last_insert()) != NULL &&
> 		(arg == NULL || STRCHR(arg, '.') != NULL))
1342c1367
< 		msg_outstr((char_u *)"\n\".   ");
---
> 		MSG_OUTSTR("\n\".   ");
1349c1374
< 	if (last_cmdline != NULL)
---
> 	if (last_cmdline != NULL && (arg == NULL || STRCHR(arg, ':') != NULL))
1351c1376
< 		msg_outstr((char_u *)"\n\":   ");
---
> 		MSG_OUTSTR("\n\":   ");
1358c1383
< 	if (curbuf->b_xfilename != NULL)
---
> 	if (curbuf->b_xfilename != NULL && (arg == NULL || STRCHR(arg, '%') != NULL))
1360c1385
< 		msg_outstr((char_u *)"\n\"%   ");
---
> 		MSG_OUTSTR("\n\"%   ");
1379c1404
< 		msg_outtrans(p++, 1);
---
> 		msg_outtrans_len(p++, 1);
1553,1554c1578,1580
< 	int			is_blank = FALSE;
< 	int			next_is_blank = FALSE;
---
> 	int			prev_is_blank = FALSE;
> 	int			is_blank = TRUE;
> 	int			next_is_blank;
1556,1557c1582,1587
< 	int			leader_len = 0;
< 	int			next_leader_len = 0;
---
> #ifdef ADDED_BY_WEBB_COMPILE
> 	int			leader_len = 0;				/* init for gcc */
> #else
> 	int			leader_len;
> #endif /* ADDED_BY_WEBB_COMPILE */
> 	int			next_leader_len;
1559a1590,1592
> 	int			second_indent = -1;
> 	int			do_second_indent = FALSE;
> 	int			first_par_line = TRUE;
1564,1565d1596
< 	if (curbuf->b_p_fo != NULL && STRCHR(curbuf->b_p_fo, FO_Q_COMS) != NULL)
< 		fo_do_comments = TRUE;
1567,1580c1598,1609
< 	/*
< 	 * Blank lines, and lines containing only the comment leader, are left
< 	 * untouched by the formatting.  The variable is_blank is TRUE in this
< 	 * case.  It is also set when a line starts with the end of a C comment
< 	 * (star-slash), so that this line is skipped, and not joined to the
< 	 * previous line.  A new paragraph starts after a blank line, or when the
< 	 * comment leader changes -- webb.
< 	 */
< 	ptr = ml_get(curwin->w_cursor.lnum);
< 	skipwhite(&ptr);
< 	next_leader_len = get_leader_len(ptr);
< 	next_is_blank = (ptr[next_leader_len] == NUL ||
< 			(next_leader_len > 0 && ptr[0] == '*' && ptr[1] == '/') ||
< 			startPS(curwin->w_cursor.lnum, NUL, FALSE));
---
> 	/* check for 'q' and '2' in 'formatoptions' */
> 	if (curbuf->b_p_fo != NULL)
> 	{
> 		fo_do_comments = (STRCHR(curbuf->b_p_fo, FO_Q_COMS) != NULL);
> 		do_second_indent = (STRCHR(curbuf->b_p_fo, FO_Q_SECOND) != NULL);
> 	}
> 
> 	if (curwin->w_cursor.lnum > 1)
> 		is_blank = fmt_is_blank(curwin->w_cursor.lnum - 1, &ptr,
> 															&next_leader_len);
> 	next_is_blank = fmt_is_blank(curwin->w_cursor.lnum, &ptr, &next_leader_len);
> 
1588a1618
> 			prev_is_blank = is_blank;
1607,1608d1636
< 				else
< 					leader_len = 0;
1616a1645,1655
> 			next_is_blank = fmt_is_blank(curwin->w_cursor.lnum + 1,
> 													&ptr, &next_leader_len);
> 		advance = TRUE;
> 
> 		/*
> 		 * For the first line of a paragraph, check indent of second line.
> 		 * Don't do this for comments.
> 		 */
> 		if (first_par_line && do_second_indent && prev_is_blank && !is_blank &&
> 				curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count &&
> 				leader_len == 0 && next_leader_len == 0)
1618,1623c1657,1659
< 			ptr = ml_get(curwin->w_cursor.lnum + 1);
< 			skipwhite(&ptr);
< 			next_leader_len = get_leader_len(ptr);
< 			next_is_blank = (nlines == 0 || ptr[next_leader_len] == NUL ||
< 					(next_leader_len > 0 && ptr[0] == '*' && ptr[1] == '/') ||
< 					startPS(curwin->w_cursor.lnum + 1, NUL, FALSE));
---
> 			++curwin->w_cursor.lnum;
> 			second_indent = get_indent();
> 			--curwin->w_cursor.lnum;
1625c1661
< 		advance = TRUE;
---
> 
1641c1677
< 			insertchar(NUL, TRUE);
---
> 			insertchar(NUL, TRUE, second_indent);
1642a1679,1680
> 			first_par_line = TRUE;
> 			second_indent = -1;
1663a1702
> 			first_par_line = FALSE;
1673a1713,1734
>  * Blank lines, and lines containing only the comment leader, are left
>  * untouched by the formatting.  The variable is_blank is TRUE in this
>  * case.  It is also set when a line starts with the end of a C comment
>  * (star-slash), so that this line is skipped, and not joined to the
>  * previous line.  A new paragraph starts after a blank line, or when the
>  * comment leader changes -- webb.
>  */
> 	static int
> fmt_is_blank(lnum, ptr, leader_len)
> 	linenr_t	lnum;
> 	char_u		**ptr;
> 	int			*leader_len;
> {
> 	*ptr = ml_get(lnum);
> 	skipwhite(ptr);
> 	*leader_len = get_leader_len(*ptr);
> 	return ((*ptr)[*leader_len] == NUL ||
> 			(*leader_len > 0 && (*ptr)[0] == '*' && (*ptr)[1] == '/') ||
> 			startPS(lnum, NUL, FALSE));
> }
> 
> /*
1801c1862
< 	int				hex;		/* 'x' or 'X': hexadecimal; '0': octal */
---
> 	int				hex;			/* 'X': hexadecimal; '0': octal */
1806a1868,1869
> 	int				zeros = 0;		/* number of leading zeros */
> 	int				digits = 0;		/* number of digits in the number */
1831c1894,1895
< 		ptr = ml_get(curwin->w_cursor.lnum);	/* get it again, because of undo */
---
> 		ptr = ml_get(curwin->w_cursor.lnum);	/* get it again, because
> 												   u_save may have changed it */
1873a1938,1939
> 		else if (hex == '0')
> 			col++;						/* skip the '0' */
1874a1941
> 
1877a1945,1948
> 			if (digits == 0 && c == '0')
> 				++zeros;				/* count the number of leading zeros */
> 			else
> 				++digits;				/* count the number of digits */
1888c1959,1960
< 		while (hex ? (hex == '0' ? c >= '0' && c <= '7' : isxdigit(c)) : isdigit(c));
---
> 		while (hex ? (hex == '0' ? c >= '0' && c <= '7' :
> 										isxdigit(c)) : isdigit(c));
1890,1896c1962
< 		if (hex == '0')
< 			sprintf((char *)buf, "0%lo", n);
< 		else if (hex && hexupper)
< 			sprintf((char *)buf, "%lX", n);
< 		else if (hex)
< 			sprintf((char *)buf, "%lx", n);
< 		else
---
> 		if (hex == 0)
1897a1964,1984
> 		else
> 		{
> 			if (hex == '0')
> 				sprintf((char *)buf, "%lo", n);
> 			else if (hex && hexupper)
> 				sprintf((char *)buf, "%lX", n);
> 			else if (hex)
> 				sprintf((char *)buf, "%lx", n);
> 			/* adjust number of zeros to the new number of digits, so the
> 			 * total length of the number remains the same */
> 			if (zeros)
> 			{
> 				zeros += digits - STRLEN(buf);
> 				if (zeros > 0)
> 				{
> 					memmove(buf + zeros, buf, STRLEN(buf) + 1);
> 					for (col = 0; zeros > 0; --zeros)
> 						buf[col++] = '0';
> 				}
> 			}
> 		}
Index: ./src/param.c
diff -r ../vim.orig/src/param.c ./src/param.c
117a118
> 		{"helpheight",	"hh",  	P_NUM,				(char_u *)&p_hh},
135a137
> 		{"maxmapdepth",	"mmd",	P_NUM,				(char_u *)&p_mmd},
282a285
> 		{"t_bs",		NULL,	P_STRING,	(char_u *)&term_strings.t_bs},
304c307
<  * Initialize the shell parameter and scroll size.
---
>  * Initialize the parameters that cannot be set at compile time.
323,344d325
< #ifdef UNIX
< 	/*
< 	 * Default for p_sp is "| tee", for p_srr is ">".
< 	 * For known shells it is changed here to include stderr.
< 	 */
< 	p = gettail(p_sh);
< 	if (	 STRCMP(p, "csh") == 0 ||
< 			 STRCMP(p, "tcsh") == 0 ||
< 			 STRCMP(p, "zsh") == 0)
< 	{
< 		p_sp = (char_u *)"|& tee";
< 		p_srr = (char_u *)">&";
< 	}
< 	else if (STRCMP(p, "sh") == 0 ||
< 			 STRCMP(p, "ksh") == 0 ||
< 			 STRCMP(p, "bash") == 0)
< 	{
< 		p_sp = (char_u *)"2>&1| tee";
< 		p_srr = (char_u *)"2>&1 1>";
< 	}
< #endif
< 
380a362,408
> #ifdef UNIX
> /*
>  * Set 'shellpipe' and 'shellredir', depending on the 'shell' option.
>  * This is done after other initializations, where 'shell' might have been
>  * set, but only if they have not been set there.
>  */
> 	void
> set_init_shell()
> {
> 	char_u	*p;
> 	int		do_sp;
> 	int		do_srr;
> 
> #ifdef ADDED_BY_WEBB_COMPILE
> 	do_sp = !(params[findparam((char_u *)"sp")].flags & P_CHANGED);
> 	do_srr = !(params[findparam((char_u *)"srr")].flags & P_CHANGED);
> #else
> 	do_sp = !(params[findparam("sp")].flags & P_CHANGED);
> 	do_srr = !(params[findparam("srr")].flags & P_CHANGED);
> #endif /* ADDED_BY_WEBB_COMPILE */
> 
> 	/*
> 	 * Default for p_sp is "| tee", for p_srr is ">".
> 	 * For known shells it is changed here to include stderr.
> 	 */
> 	p = gettail(p_sh);
> 	if (	 STRCMP(p, "csh") == 0 ||
> 			 STRCMP(p, "tcsh") == 0 ||
> 			 STRCMP(p, "zsh") == 0)
> 	{
> 		if (do_sp)
> 			p_sp = (char_u *)"|& tee";
> 		if (do_srr)
> 			p_srr = (char_u *)">&";
> 	}
> 	else if (STRCMP(p, "sh") == 0 ||
> 			 STRCMP(p, "ksh") == 0 ||
> 			 STRCMP(p, "bash") == 0)
> 	{
> 		if (do_sp)
> 			p_sp = (char_u *)"2>&1| tee";
> 		if (do_srr)
> 			p_srr = (char_u *)"2>&1 1>";
> 	}
> }
> #endif
> 
629c657
< 					if ((long *)varp == &p_wh)
---
> 					if ((long *)varp == &p_wh || (long *)varp == &p_hh)
635a664,668
> 						if (p_hh < 0)
> 						{
> 							errmsg = e_positive;
> 							p_hh = 0;
> 						}
637c670,671
< 						if (p_wh && lastwin != firstwin)
---
> 						if ((p_wh && lastwin != firstwin) ||
> 								(p_hh && curbuf->b_help))
650c684
< 					if (s == NULL)
---
> 					if (s == NULL)			/* out of memory, don't change */
693a728,734
> #ifdef ADDED_BY_WEBB_COMPILE
> /*
>  * I sent this change before, but apparently it didn't get included.  Gcc gives
>  * a warning about "long int format", and "int" arg (min_rows returns int).
>  */
> 			sprintf((char *)errbuf, "Need at least %d lines", min_rows());
> #else
694a736
> #endif /* ADDED_BY_WEBB_COMPILE */
699a742,744
> #ifdef ADDED_BY_WEBB_COMPILE
> 			sprintf((char *)errbuf, "Need at least %d columns", MIN_COLUMNS);
> #else
700a746
> #endif /* ADDED_BY_WEBB_COMPILE */
709a756
> 			mch_set_winsize();				/* try to change the window size */
781,787d827
< 			STRCPY(IObuff, errmsg);
< 			STRCAT(IObuff, ": ");
< 			s = IObuff + STRLEN(IObuff);
< 			while (*startarg && !isspace(*startarg))
< 				*s++ = *startarg++;
< 			*s = NUL;
< 			did_show = TRUE;	/* error message counts as show */
789c829,834
< 			emsg(IObuff);
---
> 			emsg(errmsg);		/* show error highlighted */
> 			MSG_OUTSTR(": ");
> 								/* show argument normal */
> 			while (*startarg && !isspace(*startarg))
> 				msg_outchar(*startarg++);
> 			msg_end();			/* check for scrolling */
790a836
> 
792a839
> 			did_show = TRUE;	/* error message counts as show */
924c971
< 	struct param	*(items[PARAM_COUNT]);
---
> 	struct param	**items;
933a981,984
> 	items = (struct param **)alloc(sizeof(struct param *) * PARAM_COUNT);
> 	if (items == NULL)
> 		return;
> 
936c987
< 	msg_outstr((char_u *)"\n--- Parameters ---");
---
> 	MSG_OUTSTR("\n--- Parameters ---");
982a1034,1035
> 			if (got_int)							/* 'q' typed in more */
> 				break;
993a1047
> 	free(items);
1011c1065
< 		msg_outstr((char_u *)"no");
---
> 		MSG_OUTSTR("no");
1013,1014c1067,1068
< 		msg_outstr((char_u *)"  ");
< 	msg_outstr((char_u *)p->fullname);
---
> 		MSG_OUTSTR("  ");
> 	MSG_OUTSTR(p->fullname);
1034c1088
< 				msg_outtrans(NameBuff, -1);
---
> 				msg_outtrans(NameBuff);
1037c1091
< 				msg_outtrans(*(char_u **)(varp), -1);
---
> 				msg_outtrans(*(char_u **)(varp));
1122d1175
< #define COL_SHOWCMD 10		/* columns needed by shown command */
1141c1194
< 		sc_col += COL_SHOWCMD;
---
> 		sc_col += SHOWCMD_COLS;
1201d1253
< 	wp_to->w_p_scroll = wp_from->w_p_scroll;
1233a1286
> 	bp_to->b_help = bp_from->b_help;
1447a1501,1505
> 		/*
> 		 * Before some characters a backslash is required
> 		 * First count the number of backslashes required.
> 		 * Allocate the memory and then insert them.
> 		 */
1449c1507
< 			if (*p == ' ')
---
> 			if (STRCHR(escape_chars, *p) != NULL)
1457c1515
< 				if (*p == ' ')
---
> 				if (STRCHR(escape_chars, *p) != NULL)
1612c1670
< 		msg_outstr((char_u *)"\n");
---
> 		MSG_OUTSTR("\n");
1616,1618c1674,1675
< 		msg_outstr((char_u *)"\n    ");
< 		msg_outstr(ac->cmd);
< 		did_show = TRUE;
---
> 		MSG_OUTSTR("\n    ");
> 		msg_outtrans(ac->cmd);
1674c1731
< 			msg_outstr((char_u *)"\n--- Auto-Commands ---");
---
> 			MSG_OUTSTR("\n--- Auto-Commands ---");
1810c1867
< 				msg_outstr((char_u *)"There are no autocmd's");
---
> 				MSG_OUTSTR("There are no autocmd's");
Index: ./src/param.h
diff -r ../vim.orig/src/param.h ./src/param.h
62c62
< EXTERN char_u *p_efm	INIT(= (char_u *)"\"%f\",%*[^0123456789]%l: %m");	/* error format */
---
> EXTERN char_u *p_efm	INIT(= (char_u *)"\"%f\",%*[^0-9]%l: %m");	/* error format */
80a81
> EXTERN long p_hh	INIT(= 20);			/* help window height */
97a99
> EXTERN long p_mmd	INIT(= 1000);		/* maximal map depth */
Index: ./src/proto/buffer.pro
diff -r ../vim.orig/src/proto/buffer.pro ./src/proto/buffer.pro
26a27
> void do_mlines __PARMS((void));
Index: ./src/proto/charset.pro
diff -r ../vim.orig/src/proto/charset.pro ./src/proto/charset.pro
7a8
> int isidchar_id __PARMS((int c));
Index: ./src/proto/cmdcmds.pro
diff -r ../vim.orig/src/proto/cmdcmds.pro ./src/proto/cmdcmds.pro
1a2
> void do_ascii __PARMS((void));
Index: ./src/proto/cmdline.pro
diff -r ../vim.orig/src/proto/cmdline.pro ./src/proto/cmdline.pro
2c2,4
< int getcmdline __PARMS((int firstc, char_u *buff));
---
> char_u *getcmdline __PARMS((int firstc));
> void alloc_cmdbuff __PARMS((int len));
> int realloc_cmdbuff __PARMS((int len));
Index: ./src/proto/edit.pro
diff -r ../vim.orig/src/proto/edit.pro ./src/proto/edit.pro
6c6
< void insertchar __PARMS((unsigned c, int force_formatting));
---
> void insertchar __PARMS((unsigned c, int force_formatting, int second_indent));
Index: ./src/proto/getchar.pro
diff -r ../vim.orig/src/proto/getchar.pro ./src/proto/getchar.pro
17,18c17,18
< int ins_typestr __PARMS((char_u *str, int noremap, int offset, int nottyped));
< void del_typestr __PARMS((int len, int offset));
---
> int ins_typebuf __PARMS((char_u *str, int noremap, int offset, int nottyped));
> void del_typebuf __PARMS((int len, int offset));
Index: ./src/proto/help.pro
diff -r ../vim.orig/src/proto/help.pro ./src/proto/help.pro
2,3c2
< void help __PARMS((void));
< int redrawhelp __PARMS((void));
---
> void dohelp __PARMS((char_u *arg));
Index: ./src/proto/mark.pro
diff -r ../vim.orig/src/proto/mark.pro ./src/proto/mark.pro
9c9
< void domarks __PARMS((void));
---
> void domarks __PARMS((char_u *arg));
Index: ./src/proto/memline.pro
diff -r ../vim.orig/src/proto/memline.pro ./src/proto/memline.pro
8a9
> int recover_names __PARMS((char_u **fname, int list, int nr));
Index: ./src/proto/message.pro
diff -r ../vim.orig/src/proto/message.pro ./src/proto/message.pro
11c11,12
< int msg_outtrans __PARMS((register char_u *str, register int len));
---
> int msg_outtrans __PARMS((register char_u *str));
> int msg_outtrans_len __PARMS((register char_u *str, register int len));
16c17
< void msg_moremsg __PARMS((void));
---
> void msg_moremsg __PARMS((int full));
Index: ./src/proto/misccmds.pro
diff -r ../vim.orig/src/proto/misccmds.pro ./src/proto/misccmds.pro
26a27
> int get_number __PARMS((void));
35,36c36
< void recover_list __PARMS((void));
< char_u *concat_fnames __PARMS((char_u *fname1, char_u *fname2));
---
> char_u *concat_fnames __PARMS((char_u *fname1, char_u *fname2, int sep));
Index: ./src/proto/normal.pro
diff -r ../vim.orig/src/proto/normal.pro ./src/proto/normal.pro
4a5,8
> void clear_showcmd __PARMS((void));
> int add_to_showcmd __PARMS((int c));
> void push_showcmd __PARMS((void));
> void pop_showcmd __PARMS((void));
Index: ./src/proto/ops.pro
diff -r ../vim.orig/src/proto/ops.pro ./src/proto/ops.pro
15c15,16
< void dodis __PARMS((void));
---
> int get_register_name __PARMS((int num));
> void dodis __PARMS((char_u *arg));
Index: ./src/proto/param.pro
diff -r ../vim.orig/src/proto/param.pro ./src/proto/param.pro
2a3
> void set_init_shell __PARMS((void));
Index: ./src/proto/screen.pro
diff -r ../vim.orig/src/proto/screen.pro ./src/proto/screen.pro
24c24
< int getvcol __PARMS((WIN *wp, FPOS *pos, int type));
---
> void getvcol __PARMS((WIN *wp, FPOS *pos, colnr_t *start, colnr_t *cursor, colnr_t *end));
38c38
< int jumpto __PARMS((int row, int col));
---
> int jumpto __PARMS((int row, int col, int same_buffer, int do_scroll));
Index: ./src/proto/search.pro
diff -r ../vim.orig/src/proto/search.pro ./src/proto/search.pro
17c17
< void find_pattern_in_path __PARMS((char_u *ptr, int len, int whole, int type, int count, int action, linenr_t start_lnum, linenr_t end_lnum));
---
> void find_pattern_in_path __PARMS((char_u *ptr, int len, int whole, int skip_comments, int type, long count, int action, linenr_t start_lnum, linenr_t end_lnum));
Index: ./src/proto/tag.pro
diff -r ../vim.orig/src/proto/tag.pro ./src/proto/tag.pro
4c4
< int ExpandTags __PARMS((regexp *prog, int *num_file, char_u ***file));
---
> int ExpandTags __PARMS((regexp *prog, int *num_file, char_u ***file, int help_only));
Index: ./src/proto/term.pro
diff -r ../vim.orig/src/proto/term.pro ./src/proto/term.pro
13c13
< int check_termcode __PARMS((void));
---
> int check_termcode __PARMS((int max_offset));
Index: ./src/quickfix.c
diff -r ../vim.orig/src/quickfix.c ./src/quickfix.c
52,53c52,53
< 	char_u 			namebuf[CMDBUFFSIZE + 1];
< 	char_u			errmsg[CMDBUFFSIZE + 1];
---
> 	char_u 			*namebuf;
> 	char_u			*errmsg;
70a71
> 	int				retval = FAIL;
76a78,83
> 
> 	namebuf = alloc(CMDBUFFSIZE + 1);
> 	errmsg = alloc(CMDBUFFSIZE + 1);
> 	if (namebuf == NULL || errmsg == NULL)
> 		goto qf_init_end;
> 
80c87
< 		return FAIL;
---
> 		goto qf_init_end;
236d242
< 		fclose(fd);
238c244,245
< 		return OK;
---
> 		retval = OK;
> 		goto qf_init_ok;
244d250
< 	fclose(fd);
246c252,257
< 	return FAIL;
---
> qf_init_ok:
> 	fclose(fd);
> qf_init_end:
> 	free(namebuf);
> 	free(errmsg);
> 	return retval;
371c382
< 		if (linetabsize(IObuff) < sc_col)
---
> 		if (linetabsize(IObuff) < (Rows - cmdline_row - 1) * Columns + sc_col)
420c431
< 			msg_outstr(IObuff);
---
> 			msg_outtrans(IObuff);
425c436
< 				sprintf((char *)IObuff, ":%d", qfp->qf_lnum);
---
> 				sprintf((char *)IObuff, ":%ld", qfp->qf_lnum);
427c438
< 				sprintf((char *)IObuff, ":%d, col %d", qfp->qf_lnum, qfp->qf_col);
---
> 				sprintf((char *)IObuff, ":%ld, col %d", qfp->qf_lnum, qfp->qf_col);
Index: ./src/regexp.c
diff -r ../vim.orig/src/regexp.c ./src/regexp.c
335c335
< 	if (exp == NULL) {
---
> 	if (exp == NULL)
337d336
< 	}
340,341c339,341
< 	if (*exp == '\0') {
< 		if (reg_prev_re) {
---
> 	if (*exp == '\0')
> 	{
> 		if (reg_prev_re)
343c343
< 		} else {
---
> 		else
345d344
< 		}
498,503c497,503
< 	if (paren && getchr() != Magic(')')) {
< 		EMSG_RETURN(e_toombra);
< 	} else if (!paren && peekchr() != '\0') {
< 		if (PeekChr() == Magic(')')) {
< 			EMSG_RETURN(e_toomket);
< 		} else
---
> 	if (paren && getchr() != Magic(')'))
> 		EMSG_RETURN(e_toombra)
> 	else if (!paren && peekchr() != '\0')
> 	{
> 		if (PeekChr() == Magic(')'))
> 			EMSG_RETURN(e_toomket)
> 		else
709,711c709
< 		{
< 			EMSG_RETURN((char_u *)"* follows nothing");
< 		}
---
> 			EMSG_RETURN((char_u *)"* follows nothing")
713,715c711
< 		{
< 			EMSG_RETURN((char_u *)"\\* follows nothing");
< 		}
---
> 			EMSG_RETURN((char_u *)"\\* follows nothing")
1207c1203
< 		  	if (reginput != regbol && isidchar(reginput[-1]))
---
> 		  	if (reginput != regbol && isidchar_id(reginput[-1]))
1209c1205
< 		  	if (!reginput[0] || !isidchar(reginput[0]))
---
> 		  	if (!reginput[0] || !isidchar_id(reginput[0]))
1213c1209
< 		  	if (reginput == regbol || !isidchar(reginput[-1]))
---
> 		  	if (reginput == regbol || !isidchar_id(reginput[-1]))
1215c1211
< 		  	if (reginput[0] && isidchar(reginput[0]))
---
> 		  	if (reginput[0] && isidchar_id(reginput[0]))
Index: ./src/screen.c
diff -r ../vim.orig/src/screen.c ./src/screen.c
21c21
<  * The characters that are currently on the screen are kept in Nextscreen.
---
>  * The characters that are currently on the screen are kept in NextScreen.
25,26c25,26
< static char_u 	*Nextscreen = NULL; 	/* What is currently on the screen. */
< static char_u 	**LinePointers = NULL;	/* array of pointers into Nextscreen */
---
> static char_u 	*NextScreen = NULL; 	/* What is currently on the screen. */
> static char_u 	**LinePointers = NULL;	/* array of pointers into NextScreen */
29c29
<  * Attributes for Nextscreen.
---
>  * Attributes for NextScreen.
78c78
< 	if (Nextscreen == NULL || RedrawingDisabled)
---
> 	if (NextScreen == NULL || RedrawingDisabled)
123c123
<  * of stuff from Filemem to Nextscreen, and update curwin->w_botline.
---
>  * of stuff from Filemem to NextScreen, and update curwin->w_botline.
133c133
< 	if (Nextscreen == NULL)
---
> 	if (NextScreen == NULL)
353c353
< 	if (VIsual.lnum != 0)	/* check if we are updating the inverted part */
---
> 	if (VIsual_active)		/* check if we are updating the inverted part */
642d641
< 	int				temp;
659c658
< 	if (VIsual.lnum != 0 && wp->w_buffer == curwin->w_buffer)
---
> 	if (VIsual_active && wp->w_buffer == curwin->w_buffer)
676,679c675
< 				fromcol = getvcol(wp, top, 2);
< 				temp = getvcol(wp, bot, 2);
< 				if (temp < fromcol)
< 					fromcol = temp;
---
> 				colnr_t		from, to;
681,688c677,686
< 				if (wp->w_curswant != MAXCOL)
< 				{
< 					tocol = getvcol(wp, top, 3);
< 					temp = getvcol(wp, bot, 3);
< 					if (temp > tocol)
< 						tocol = temp;
< 					++tocol;
< 				}
---
> 				getvcol(wp, top, (colnr_t *)&fromcol, NULL, (colnr_t *)&tocol);
> 				getvcol(wp, bot, &from, NULL, &to);
> 				if (from < fromcol)
> 					fromcol = from;
> 				if (to > tocol)
> 					tocol = to;
> 				++tocol;
> 
> 				if (wp->w_curswant == MAXCOL)
> 					tocol = MAXCOL;
696c694
< 				fromcol = getvcol(wp, top, 2);
---
> 				getvcol(wp, top, (colnr_t *)&fromcol, NULL, NULL);
698c696,699
< 				tocol = getvcol(wp, bot, 3) + 1;
---
> 			{
> 				getvcol(wp, bot, NULL, NULL, (colnr_t *)&tocol);
> 				++tocol;
> 			}
730c731,732
< 			fromcol = getvcol(curwin, &(curwin->w_cursor), 2);
---
> 			getvcol(curwin, &(curwin->w_cursor),
> 											(colnr_t *)&fromcol, NULL, NULL);
732c734,735
< 			tocol = getvcol(curwin, &(curwin->w_cursor), 2);
---
> 			getvcol(curwin, &(curwin->w_cursor),
> 											(colnr_t *)&tocol, NULL, NULL);
798c801
< 				 * 'Nextscreen'.
---
> 				 * 'NextScreen'.
849d851
< 			{
852,853d853
< 				col = Columns;
< 			}
855d854
< 			screen_row++;
874c873
< 		 * Store the character in Nextscreen.
---
> 		 * Store the character in NextScreen.
1256c1255,1256
< 	 * and when Rows and Columns have been set.
---
> 	 * and when Rows and Columns have been set and we are doing full screen
> 	 * stuff.
1258,1259c1258,1259
< 	if ((Nextscreen != NULL && Rows == old_Rows && Columns == old_Columns)
< 								|| Rows == 0 || Columns == 0)
---
> 	if ((NextScreen != NULL && Rows == old_Rows && Columns == old_Columns)
> 							|| Rows == 0 || Columns == 0 || not_full_screen)
1269c1269
< 	free(Nextscreen);
---
> 	free(NextScreen);
1274c1274
< 	Nextscreen = (char_u *)malloc((size_t) (Rows * Columns * 2));
---
> 	NextScreen = (char_u *)malloc((size_t) (Rows * Columns * 2));
1285c1285
< 	if (Nextscreen == NULL || LinePointers == NULL || outofmem)
---
> 	if (NextScreen == NULL || LinePointers == NULL || outofmem)
1288,1289c1288,1289
< 		free(Nextscreen);
< 		Nextscreen = NULL;
---
> 		free(NextScreen);
> 		NextScreen = NULL;
1294c1294
< 			LinePointers[i] = Nextscreen + i * Columns * 2;
---
> 			LinePointers[i] = NextScreen + i * Columns * 2;
1313c1313
< 	if (starting || Nextscreen == NULL)
---
> 	if (starting || NextScreen == NULL)
1318c1318
< 								/* blank out Nextscreen */
---
> 								/* blank out NextScreen */
1357c1357
< 	if (Nextscreen == NULL)
---
> 	if (NextScreen == NULL)
1502c1502,1504
< 	int diff;
---
> 	int		diff;
> 	colnr_t	startcol;
> 	colnr_t endcol;
1504c1506,1507
< 	curwin->w_virtcol = getvcol(curwin, &curwin->w_cursor, 1);
---
> 	getvcol(curwin, &curwin->w_cursor,
> 								&startcol, &(curwin->w_virtcol), &endcol);
1520d1522
< 						/* If Cursor is in columns 0, start in column 0 */
1523c1525,1527
< 		if (curwin->w_cursor.col == 0)
---
> 		if ((diff = curwin->w_leftcol +
> 								(curwin->w_p_nu ? 8 : 0) - startcol) > 0 ||
> 					(diff = endcol - (curwin->w_leftcol + Columns) + 1) > 0)
1525,1533c1529
< 						/* screen needs redrawing with new curwin->w_leftcol */
< 			if (curwin->w_leftcol != 0)
< 				redraw_later(NOT_VALID);
< 			curwin->w_leftcol = 0;
< 		}
< 		else if (((diff = curwin->w_leftcol + (curwin->w_p_nu ? 8 : 0)
< 					- curwin->w_col) > 0 || (diff = curwin->w_col
< 							- (curwin->w_leftcol + Columns) + 1) > 0))
< 		{
---
> 				/* far off, put cursor in middle of window */
1560,1562c1556,1558
<  * type = 1: where the cursor is on this character
<  * type = 2: on the first position of this character (TAB)
<  * type = 3: on the last position of this character (TAB)
---
>  * start: on the first position of this character (TAB, ctrl)
>  * cursor: where the cursor is on this character (first char, except for TAB)
>  * end: on the last position of this character (TAB, ctrl)
1564,1568c1560,1566
< 	int
< getvcol(wp, pos, type)
< 	WIN		*wp;
< 	FPOS	*pos;
< 	int		type;
---
> 	void
> getvcol(wp, pos, start, cursor, end)
> 	WIN			*wp;
> 	FPOS		*pos;
> 	colnr_t		*start;
> 	colnr_t		*cursor;
> 	colnr_t		*end;
1571c1569
< 	int				vcol;
---
> 	colnr_t			vcol;
1578c1576
< 	for (col = pos->col; col >= 0; --col)
---
> 	for (col = pos->col; ; --col)
1581,1582d1578
< 		if (c == NUL)		/* make sure we don't go past the end of the line */
< 			break;
1584c1580
< 		/* A tab gets expanded, depending on the current column */
---
> 					/* A tab gets expanded, depending on the current column */
1586a1583,1585
> 		if (c == NUL)		/* make sure we don't go past the end of the line */
> 			break;
> 
1588,1593c1587,1588
< 		{
< 			if (type == 3 || (type == 1 && c == TAB && State == NORMAL && !wp->w_p_list))
< 				--incr;
< 			else
< 				break;
< 		}
---
> 			break;
> 
1596c1591,1601
< 	return vcol;
---
> 	if (start != NULL)
> 		*start = vcol;
> 	if (end != NULL)
> 		*end = vcol + incr - 1;
> 	if (cursor != NULL)
> 	{
> 		if (c == TAB && State == NORMAL && !wp->w_p_list)
> 			*cursor = vcol + incr - 1;		/* cursor at end */
> 		else
> 			*cursor = vcol;					/* cursor at start */
> 	}
1887c1892
<  * insert lines on the screen and update Nextscreen
---
>  * insert lines on the screen and update NextScreen
1912c1917
< 	if (Nextscreen == NULL)
---
> 	if (NextScreen == NULL)
1963c1968
<  * delete lines on the screen and update Nextscreen
---
>  * delete lines on the screen and update NextScreen
1995c2000
< 	if (Nextscreen == NULL)
---
> 	if (NextScreen == NULL)
2069c2074
< 				msg_outstr((char_u *)"-- ");
---
> 				MSG_OUTSTR("-- ");
2073,2074c2078,2079
< 						msg_outstr((char_u *)"REVERSE ");
< 					msg_outstr((char_u *)"INSERT");
---
> 						MSG_OUTSTR("REVERSE ");
> 					MSG_OUTSTR("INSERT");
2077c2082
< 					msg_outstr((char_u *)"REPLACE");
---
> 					MSG_OUTSTR("REPLACE");
2080c2085
< 					msg_outstr((char_u *)": ");
---
> 					MSG_OUTSTR(": ");
2083c2088
< 				msg_outstr((char_u *)" --");
---
> 				MSG_OUTSTR(" --");
2089c2094
< 			msg_outstr((char_u *)"recording");
---
> 			MSG_OUTSTR("recording");
2179c2184
< 	return (Nextscreen != NULL);
---
> 	return (NextScreen != NULL);
2184c2189,2191
<  * Change current window if neccesary.
---
>  * Change current window if neccesary. Used for mouse clicks.
>  * If 'same_buffer' is TRUE, only move within current buffer.
>  * If 'do_scroll' is TRUE, may scroll the window.
2187c2194
< jumpto(row, col)
---
> jumpto(row, col, same_buffer, do_scroll)
2189a2197,2198
> 	int		same_buffer;
> 	int		do_scroll;
2201a2211,2213
> 	if (same_buffer && wp->w_buffer != curbuf)
> 		return FAIL;
> 
2217c2229
< 	if (row == 0)
---
> 	if (do_scroll && row == 0)
2229c2241
< 	else if (row == curwin->w_height - 1)
---
> 	else if (do_scroll && row == curwin->w_height - 1)
Index: ./src/search.c
diff -r ../vim.orig/src/search.c ./src/search.c
23c23
< static void show_pat_in_path __ARGS((char_u *, int, int, int, FILE *, linenr_t *));
---
> static void show_pat_in_path __ARGS((char_u *, int, int, int, FILE *, linenr_t *, long));
61c61
< static int		did_emsg;				/* myregcomp() called emsg() */
---
> static int		mr_did_emsg;			/* myregcomp() called emsg() */
91c91
< 	did_emsg = FALSE;
---
> 	mr_did_emsg = FALSE;
99c99
< 				did_emsg = TRUE;
---
> 				mr_did_emsg = TRUE;
109c109
< 				did_emsg = TRUE;
---
> 				mr_did_emsg = TRUE;
119c119
< 				did_emsg = TRUE;
---
> 				mr_did_emsg = TRUE;
187c187
< 		if (message && !did_emsg)
---
> 		if (message && !mr_did_emsg)
434c434
< 		msg_outtrans(*searchstr == NUL ? search_pattern : searchstr, -1);
---
> 		msg_outtrans(*searchstr == NUL ? search_pattern : searchstr);
1402c1402
< 	if (isidchar(c))
---
> 	if (isidchar_id(c))
1594,1599c1594,1602
< find_pattern_in_path(ptr, len, whole, type, count, action, start_lnum, end_lnum)
< 	char_u	*ptr;	/* pointer to search pattern */
< 	int		len;	/* length of search pattern */
< 	int		whole;	/* match whole words only */
< 	int		type;	/* Type of search; are we looking for a type?  a macro? */
< 	int		count;
---
> find_pattern_in_path(ptr, len, whole, skip_comments,
> 							type, count, action, start_lnum, end_lnum)
> 	char_u	*ptr;			/* pointer to search pattern */
> 	int		len;			/* length of search pattern */
> 	int		whole;			/* match whole words only */
> 	int		skip_comments;	/* don't match inside comments */
> 	int		type;			/* Type of search; are we looking for a type?  a
> 								macro? */
> 	long	count;
1606a1610
> 	long		match_count = 1;
1616c1620
< 	char_u		file_line[LSIZE];
---
> 	char_u		*file_line;
1619c1623,1625
< 	char_u		save_char;
---
> 	char_u		*p2 = NUL;				/* Init for gcc */
> 	char_u		save_char = NUL;
> 	int			define_matched;
1628a1635,1638
> 	file_line = alloc(LSIZE);
> 	if (file_line == NULL)
> 		return;
> 
1635c1645
< 			return;
---
> 			goto fpip_end;
1640c1650
< 			return;
---
> 			goto fpip_end;
1646,1649c1656
< 		{
< 			free(prog);
< 			return;
< 		}
---
> 			goto fpip_end;
1655,1659c1662
< 		{
< 			free(prog);
< 			free(include_prog);
< 			return;
< 		}
---
> 			goto fpip_end;
1663,1668c1666
< 	{
< 		free(prog);
< 		free(include_prog);
< 		free(define_prog);
< 		return;
< 	}
---
> 		goto fpip_end;
1700c1698
< 						set_highlight('t');		/* Same as for directories */
---
> 						set_highlight('t');		/* Highlight title */
1702c1700
< 						msg_outstr((char_u *)"--- Included files not found in path ---\n");
---
> 						MSG_OUTSTR("--- Included files not found in path ---\n");
1710,1712c1708,1710
< 							msg_outstr((char_u *)"  ");
< 						msg_outstr(files[depth_displayed].name);
< 						msg_outstr((char_u *)" -->\n");
---
> 							MSG_OUTSTR("  ");
> 						msg_outtrans(files[depth_displayed].name);
> 						MSG_OUTSTR(" -->\n");
1718c1716
< 							msg_outstr((char_u *)"  ");
---
> 							MSG_OUTSTR("  ");
1794c1792
< 		else if (prog != NULL && regexec(prog, line, TRUE))
---
> 		else
1796d1793
< 			matched = TRUE;
1798c1795
< 			 * Check if the line is a define
---
> 			 * Check if the line is a define (type == FIND_DEFINE)
1800c1797,1799
< 			if (type == FIND_DEFINE && define_prog != NULL)
---
> 			p = line;
> 			define_matched = FALSE;
> 			if (define_prog != NULL && regexec(define_prog, line, TRUE))
1802,1814c1801,1814
< 				if (!regexec(define_prog, line, TRUE))
< 					matched = FALSE;
< 				else
< 				{
< 					/* Pattern must be first identifier after 'define' */
< 					p = define_prog->endp[0] + 1;
< 					while (p < prog->startp[0])
< 						if (isidchar(*p++))
< 						{
< 							matched = FALSE;
< 							break;
< 						}
< 				}
---
> 				/*
> 				 * Pattern must be first identifier after 'define', so skip
> 				 * to that position before checking for match of pattern.  Also
> 				 * don't let it match beyond the end of this identifier.
> 				 */
> 				p = define_prog->endp[0] + 1;
> 				while (*p && !isidchar(*p))
> 					p++;
> 				p2 = p;
> 				while (*p2 && isidchar(*p2))
> 					p2++;
> 				save_char = *p2;
> 				*p2 = NUL;
> 				define_matched = TRUE;
1815a1816
> 
1817c1818,1819
< 			 * Check if the line is not a comment line
---
> 			 * Look for a match.  Don't do this if we are looking for a
> 			 * define and this line didn't match define_prog above.
1819,1820c1821,1822
< 			else if (action == ACTION_SHOW || action == ACTION_GOTO ||
< 											action == ACTION_SPLIT)
---
> 			if ((define_prog == NULL || define_matched) &&
> 				prog != NULL && regexec(prog, p, p == line))
1822,1825c1824,1835
< 				fo_do_comments = TRUE;
< 				if (get_leader_len(line))
< 					matched = FALSE;
< 				fo_do_comments = FALSE;
---
> 				matched = TRUE;
> 				/*
> 				 * Check if the line is not a comment line (unless we are
> 				 * looking for a define).
> 				 */
> 				if (!define_matched && skip_comments)
> 				{
> 					fo_do_comments = TRUE;
> 					if (get_leader_len(line))
> 						matched = FALSE;
> 					fo_do_comments = FALSE;
> 				}
1826a1837,1838
> 			if (define_matched)
> 				*p2 = save_char;
1836c1848
< 				while (isidchar(*p))
---
> 				while (isidchar_id(*p))
1856c1868
< 						msg_outstr(curr_fname);
---
> 						msg_outtrans(curr_fname);
1865c1877,1878
< 							(depth == -1) ? &lnum : &files[depth].lnum);
---
> 							(depth == -1) ? &lnum : &files[depth].lnum,
> 							match_count++);
1876c1889
< 						(depth == -1) ? &lnum : &files[depth].lnum);
---
> 						(depth == -1) ? &lnum : &files[depth].lnum, 1L);
1931,1933c1944
< 	free(prog);
< 	free(include_prog);
< 	free(define_prog);
---
> 
1949a1961,1966
> 
> fpip_end:
> 	free(file_line);
> 	free(prog);
> 	free(include_prog);
> 	free(define_prog);
1953c1970
< show_pat_in_path(line, type, did_show, action, fp, lnum)
---
> show_pat_in_path(line, type, did_show, action, fp, lnum, count)
1959a1977
> 	long	count;
1981c1999,2001
< 			set_highlight('n');			/* Highlight line numbers */
---
> 			sprintf((char *)IObuff, "%3ld: ", count);	/* show match nr */
> 			msg_outstr(IObuff);
> 			set_highlight('n');					/* Highlight line numbers */
1983c2003
< 			sprintf((char *)IObuff, "%7ld ", *lnum);
---
> 			sprintf((char *)IObuff, "%4ld", *lnum);		/* show line nr */
1985a2006
> 			MSG_OUTSTR(" ");
Index: ./src/structs.h
diff -r ../vim.orig/src/structs.h ./src/structs.h
369a370
> 	char			 b_help;			/* buffer for help file */
Index: ./src/sun_stdlib.h
diff -r ../vim.orig/src/sun_stdlib.h ./src/sun_stdlib.h
28,32d27
< 
< # ifdef _sys_time_h
< extern int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
< # endif _sys_time_h
< 
52a48
> extern int fputs(char *, FILE *);
Index: ./src/tag.c
diff -r ../vim.orig/src/tag.c ./src/tag.c
18a19
> static int get_tagfname __ARGS((int, char_u	*));
58d58
< 			--oldtagstackidx;
160c160,163
< 	msg_outstr((char_u *)"\n  # TO tag      FROM line in file");
---
> 	set_highlight('t');		/* Highlight title */
> 	start_highlight();
> 	MSG_OUTSTR("\n  # TO tag      FROM line in file");
> 	stop_highlight();
169c172,173
< 			sprintf((char *)IObuff, "\n%c%2d %-15s %4ld  %s",
---
> 			msg_outchar('\n');
> 			sprintf((char *)IObuff, "%c%2d %-15s %4ld  %s",
175c179
< 			msg_outstr(IObuff);
---
> 			msg_outtrans(IObuff);
180c184
< 		msg_outstr((char_u *)"\n>");
---
> 		MSG_OUTSTR("\n>");
185c189
<  *   return 0 for failure, 1 for success
---
>  *   return FAIL for failure, OK for success
191,193c195,198
< 	FILE	   *tp;
< 	char_u		lbuf[LSIZE];
< 	char_u		pbuf[LSIZE];			/* search pattern buffer */
---
> 	FILE	   *fp;
> 	char_u	   *lbuf;					/* line buffer */
> 	char_u	   *pbuf;					/* search pattern buffer */
> 	char_u	   *tag_fname;				/* name of tag file */
202,203d206
< 	char_u		*np;					/* pointer into file name string */
< 	char_u		sbuf[CMDBUFFSIZE + 1];	/* tag file name */
207c210,222
< 	int			tried_local = FALSE;	/* tried tags file local to file */
---
> 	int			retval = FAIL;
> 	int			is_static;				/* current tag line is static */
> 	int			eof;					/* end of tags file */
> 	char_u		*static_line = NULL;	/* saved line for static tag */
> 	char_u		*global_line = NULL;	/* saved line for global tag */
> 	int			first_file;				/* trying first tag file */
> 
> 	lbuf = alloc(LSIZE);
> 	pbuf = alloc(LSIZE);
> 	tag_fname = alloc(CMDBUFFSIZE + 1);
> 				/* check for out of memory situation */
> 	if (tag == NULL || lbuf == NULL || pbuf == NULL || tag_fname == NULL)
> 		goto findtag_end;
209,211d223
< 	if (tag == NULL)		/* out of memory condition */
< 		return 0;
< 
218c230,231
< 	for (np = p_tags; tried_local == FALSE; )
---
> 	for (first_file = TRUE; get_tagfname(first_file, tag_fname) == OK;
> 															first_file = FALSE)
220,240c233,236
< 		/*
< 		 * after trying all the names in the 'tags' option, try the 'tags' file
< 		 * in the same directory as the current file (unless it is the same as "./tags").
< 		 */
< 		if (*np == NUL)
< 		{
< 			if (curbuf->b_filename == NULL)				/* no file name */
< 				break;
< 			np = gettail(curbuf->b_filename);
< 			i = np - curbuf->b_filename;
< 			if (i + 5 >= CMDBUFFSIZE)
< 				break;
< 			STRNCPY(sbuf, curbuf->b_filename, i);
< 
< 			STRCPY(sbuf + i, "tags");
< 			if (FullName((char_u *)"tags", lbuf, LSIZE) == OK &&
< 												STRCMP(sbuf, lbuf) == 0)
< 				break;									/* same as ./tags */
< 			tried_local = TRUE;
< 		}
< 		else
---
> 		if ((fp = fopen((char *)tag_fname, "r")) == NULL)
> 			continue;
> 		reg_ic = p_ic;										/* for cstrncmp() */
> 		for (;;)
242c238,276
< 			for (i = 0; i < CMDBUFFSIZE && *np; ++i)	/* copy next file name into sbuf */
---
> 			eof = (fgets((char *)lbuf, LSIZE, fp) == NULL);
> 			if (eof)
> 			{
> 				if (global_line != NULL)
> 					STRCPY(lbuf, global_line);			/* use global line */
> 				else if (static_line != NULL)
> 					STRCPY(lbuf, static_line);			/* use static line */
> 				else
> 					break;								/* tag not found */
> 			}
> 
> 									/* set default error message */
> 			m = (char_u *)"Format error in tags file %s";
> 			marg = tag_fname;
> 
> 				/* Find start of file name, after first white space */
> 			fname = tagname = lbuf;
> 			skiptowhite(&fname);
> 			if (*fname == NUL)
> 				goto erret;
> 			*fname++ = '\0';
> 			skipwhite(&fname);
> 
> 				/* find start of search command, after second white space */
> 			str = fname;
> 			skiptowhite(&str);
> 			if (*str == NUL)
> 				goto erret;
> 			*str++ = '\0';
> 			skipwhite(&str);
> 
> 			/*
> 			 * Static tags produced by the ctags program have the
> 			 * format: 'file:tag  file  /pattern'. jw.
> 			 * This is only recognized when both occurences of 'file' are
> 			 * the same, to avoid recognizing "string::string" or ":exit".
> 			 */
> 			is_static = FALSE;
> 			for (p = tagname; *p; ++p)
244c278,279
< 				if (*np == ' ')
---
> 				if (*p == ':' && p > tagname &&
> 								cstrncmp(tagname, fname, p - tagname) == 0)
246c281,283
< 					++np;
---
> 					*p = '\0';
> 					is_static = TRUE;
> 					tagname = p + 1;
249d285
< 				sbuf[i] = *np++;
251,259d286
< 			sbuf[i] = 0;
< 		}
< 		if ((tp = fopen((char *)sbuf, "r")) == NULL)
< 			continue;
< 		reg_ic = p_ic;										/* for cstrncmp() */
< 		while (fgets((char *)lbuf, LSIZE, tp) != NULL)
< 		{
< 			m = (char_u *)"Format error in tags file %s";	/* default error message */
< 			marg = sbuf;
261,263c288
< 			/* Find start of file name, after first white space */
< 			fname = tagname = lbuf;
< 			while (*fname != ' ' && *fname != '\t' && *fname != NUL)
---
> 			if (cstrncmp(tagname, tag, cmplen) == 0)		/* Tag matches */
265,269c290
< 				/*
< 				 * Static tags produced by elvis's ctags program have the
< 				 * format: 'file:tag  file  /pattern$'. jw.
< 				 */
< 				if (*fname == ':')
---
> 				if (!eof)
272,273c293,297
< 					 * Static tag must be in current file
< 					 * If it is not, set tagname to NULL
---
> 					 * Static tag must be in current file.
> 					 * If it is not, skip it for now. It is saved for use when
> 					 * there is no match for the current file.
> 					 * Non-static (global) tag is skipped and saved for use
> 					 * when a static tag is not found for the current file.
275,279c299,318
< 					*fname = '\0';
< 					if (tail != NULL && STRCMP(tail, gettail(lbuf)) == 0)
< 						tagname = fname + 1;
< 					else
< 						tagname = NULL;
---
> 					if ((is_static && (tail == NULL ||
> 							STRCMP(tail, gettail(lbuf)) != 0)) || !is_static)
> 					{
> 							/* put blanks back in the line */
> 						while (*--fname == NUL)
> 							*fname = ' ';
> 						while (*--str == NUL)
> 							*str = ' ';
> 						if (is_static)
> 						{
> 							if (static_line == NULL)
> 								static_line = strsave(tagname);
> 						}
> 						else
> 						{
> 							if (global_line == NULL)
> 								global_line = strsave(tagname);
> 						}
> 						continue;
> 					}
281,291d319
< 				++fname;
< 			}
< 			if (*fname == NUL)
< 				goto erret;
< 			*fname++ = '\0';
< 
< 			if (tagname != NULL && cstrncmp(tagname, tag, cmplen) == 0)
< 											/* Tag found */
< 			{
< 				fclose(tp);
< 				skipwhite(&fname);
293,299c321,322
< 			/* find start of search command, after second white space */
< 				str = fname;
< 				skiptowhite(&str);
< 				if (*str == NUL)
< 					goto erret;
< 				*str++ = '\0';
< 				skipwhite(&str);
---
> 				/* When we get here we have a match, close the file */
> 				fclose(fp);
346a370
> 						case '~':
366c390,391
< 				if (p_tr && !isFullName(fname) && (p2 = gettail(sbuf)) != sbuf)
---
> 				if (p_tr && !isFullName(fname) &&
> 									(p2 = gettail(tag_fname)) != tag_fname)
368,369c393,394
< 					STRNCPY(p2, fname, CMDBUFFSIZE - (p2 - sbuf));
< 					fname = sbuf;
---
> 					STRNCPY(p2, fname, CMDBUFFSIZE - (p2 - tag_fname));
> 					fname = tag_fname;
459c484,485
< 					return 1;
---
> 					retval = OK;
> 					goto findtag_end;
467c493
< 				return 0;
---
> 				goto findtag_end;
473c499
< 		fclose(tp);
---
> 		fclose(fp);
481c507,583
< 	return 0;
---
> 
> findtag_end:
> 	free(lbuf);
> 	free(pbuf);
> 	free(tag_fname);
> 	free(static_line);
> 	free(global_line);
> 	return retval;
> }
> 
> /*
>  * Get the next name of a tag file from the tag file list.
>  * Also try the tag file in the same directory as the current file.
>  * For help files, use "vim_tags" file only.
>  *
>  * Return FAIL if no more tag file names, OK otherwise.
>  */
> 	static int
> get_tagfname(first, buf)
> 	int		first;			/* TRUE when first file name is wanted */
> 	char_u	*buf;			/* pointer to buffer of CMDBUFFSIZE chars */
> {
> 	static char_u	*np = NULL;
> 	static int		tried_local = FALSE;
> 	int				i;
> 	char_u			*fname;
> 
> 	if (first)
> 	{
> 		np = p_tags;
> 		tried_local = FALSE;
> 	}
> 
> 	if (tried_local)			/* tried all possibilities */
> 		return FAIL;
> 
> 	/*
> 	 * after trying all the names in the 'tags' option, try the 'tags'
> 	 * file in the same directory as the current file (unless it is the
> 	 * same as "./tags").
> 	 * For a help window only try the file 'vim_tags' in the same
> 	 * directory as the file.
> 	 */
> 	if (*np == NUL || curbuf->b_help)
> 	{
> 		if (curbuf->b_help)
> 			fname = p_hf;
> 		else
> 			fname = curbuf->b_filename;
> 		if (fname == NULL)						/* no file name */
> 			return FAIL;
> 		np = gettail(fname);
> 		i = np - fname;
> 		if (i + 9 >= CMDBUFFSIZE)
> 			return FAIL;
> 		STRNCPY(buf, fname, i);
> 
> 		if (curbuf->b_help)
> 			STRCPY(buf + i, "vim_tags");
> 		else
> 		{
> 			STRCPY(buf + i, "tags");
> 			if (FullName((char_u *)"tags", NameBuff, LSIZE) == OK &&
> 											STRCMP(buf, NameBuff) == 0)
> 				return FAIL;							/* same as ./tags */
> 		}
> 		tried_local = TRUE;
> 	}
> 	else
> 	{
> 			/* copy next file name into buf */
> 		for (i = 0; i < CMDBUFFSIZE && *np && *np != ' '; ++i)
> 			buf[i] = *np++;
> 		buf[i] = NUL;
> 		skipwhite(&np);
> 	}
> 	return OK;
485,488c587,591
< ExpandTags(prog, num_file, file)
< 	regexp *prog;
< 	int *num_file;
< 	char_u ***file;
---
> ExpandTags(prog, num_file, file, help_only)
> 	regexp	*prog;
> 	int		*num_file;
> 	char_u	***file;
> 	int		help_only;			/* only tags for help files */
491,492c594,595
< 	char_u	tag_file[CMDBUFFSIZE + 1];
< 	char_u	line[LSIZE];
---
> 	char_u	*tag_file;
> 	char_u	*line;
495d597
< 	char_u	*np;
501a604,609
> 	int		retval = FAIL;
> 	int		first_file;
> 	int		help_save;
> 
> 	tag_file = alloc(CMDBUFFSIZE + 1);
> 	line = alloc(LSIZE);
505c613
< 		return FAIL;
---
> 		goto et_end;
508c616,620
< 	for (np = p_tags; *np; )
---
> 	help_save = curbuf->b_help;
> 	if (help_only)
> 		curbuf->b_help = TRUE;
> 	for (first_file = TRUE; get_tagfname(first_file, tag_file) == OK;
> 															first_file = FALSE)
510,513d621
< 		for (i = 0; i < CMDBUFFSIZE && *np && *np != ' '; i++)
< 			tag_file[i] = *np++;
< 		tag_file[i] = NUL;
< 		skipwhite(&np);
526c634,635
< 				if (*p == ':')
---
> 				if (p != tagname && *p == ':' &&
> 									*(p + 1) != ':' && !iswhite(*(p + 1)))
550c659,660
< 						return OK;
---
> 						retval = OK;
> 						goto et_end;
560a671
> 	curbuf->b_help = help_save;
568c679,680
< 			return OK;
---
> 			retval = OK;
> 			goto et_end;
575c687,692
< 	return OK;
---
> 	retval = OK;
> 
> et_end:
> 	free(tag_file);
> 	free(line);
> 	return retval;
Index: ./src/term.c
diff -r ../vim.orig/src/term.c ./src/term.c
532a533
> 	{KS_BS,		 "[BS]"},
567c568
< # define DEFAULT_TERM	"amiga"
---
> # define DEFAULT_TERM	(char_u *)"amiga"
571c572
< # define DEFAULT_TERM	"ntconsole"
---
> # define DEFAULT_TERM	(char_u *)"ntconsole"
574c575
< #  define DEFAULT_TERM	"pcterm"
---
> #  define DEFAULT_TERM	(char_u *)"pcterm"
579c580
< # define DEFAULT_TERM	"ansi"
---
> # define DEFAULT_TERM	(char_u *)"ansi"
589c590
< static char	*termleader;			/* for check_termcode() */
---
> static char_u	*termleader;			/* for check_termcode() */
766a768
> 			term_strings.t_bs = TGETSTR("kb", &tp);
836a839,854
> 	 * Always set defaults for BS and DEL
> 	 */
> 	if (term_strings.t_bs == NULL)
> #ifdef ADDED_BY_WEBB_COMPILE
> 		term_strings.t_bs = strsave((char_u *)"\010");
> #else
> 		term_strings.t_bs = strsave("\010");
> #endif /* ADDED_BY_WEBB_COMPILE */
> 	if (term_strings.t_del == NULL)
> #ifdef ADDED_BY_WEBB_COMPILE
> 		term_strings.t_del = strsave((char_u *)"\177");
> #else
> 		term_strings.t_del = strsave("\177");
> #endif /* ADDED_BY_WEBB_COMPILE */
> 
> 	/*
841c859
< 		term_strings.t_mouse = strsave("\033[M");
---
> 		term_strings.t_mouse = strsave((char_u *)"\033[M");
844c862
< 	term_strings.t_mouse = strsave("\233M");
---
> 	term_strings.t_mouse = strsave((char_u *)"\233M");
978a997,998
> 	if (not_full_screen)
> 		return;
1252c1272,1273
<  * Check if typestr[] contains a terminal key code.
---
>  * Check if typebuf[] contains a terminal key code.
>  * Check from typebuf[typeoff] to typebuf[typeoff + max_offset].
1255c1276
<  * typestr[] and the number of characters in typestr[] is returned.
---
>  * typebuf[] and the number of characters in typebuf[] is returned.
1258c1279,1280
< check_termcode()
---
> check_termcode(max_offset)
> 	int		max_offset;
1260,1263c1282,1289
< 	char_u 	**p;
< 	int		slen;
< 	int		len;
< 	int		offset;
---
> 	char_u 		**p;
> 	char_u		*tp;
> 	int			slen;
> 	int			len;
> 	int			offset;
> #if defined(UNIX) || defined(MSDOS)
> 	static int	last_mouse_code;
> #endif
1266c1292,1295
< 	 * Check at all positions in typestr[], to catch something like "x<C_UP>"
---
> 	 * Check at several positions in typebuf[], to catch something like
> 	 * "x<C_UP>" that can be mapped. Stop at max_offset, because characters
> 	 * after that cannot be used for mapping, and with @r commands typebuf[]
> 	 * can become very long.
1268c1297
< 	for (offset = 0; typestr[offset] != NUL; ++offset)
---
> 	for (offset = 0; offset < typelen && offset < max_offset; ++offset)
1269a1299
> 		tp = typebuf + typeoff + offset;
1273c1303
< 		 * termcodes start with the same character.
---
> 		 * termcodes start with the same character (ESC or CSI).
1275c1305
< 		if (STRCHR(termleader, typestr[offset]) == NULL)
---
> 		if (STRCHR(termleader, *tp) == NULL)
1279,1280c1309,1310
< 		 * skip this position if p_ek is not set and typestr[offset] is an ESC
< 		 * and we are in insert mode
---
> 		 * skip this position if p_ek is not set and typebuf[typeoff + offset]
> 		 * is an ESC and we are in insert mode
1282c1312
< 		if (typestr[offset] == ESC && !p_ek && (State & INSERT))
---
> 		if (*tp == ESC && !p_ek && (State & INSERT))
1284c1314,1315
< 		len = STRLEN(typestr + offset);
---
> 		len = typelen - offset;
> 
1290c1321
< 			 * start of typestr[] and there are not enough characters to make
---
> 			 * start of typebuf[] and there are not enough characters to make
1296,1297c1327
< 			if (STRNCMP(*p, typestr + offset, (size_t)(slen > len ?
< 														len : slen)) == 0)
---
> 			if (STRNCMP(*p, tp, (size_t)(slen > len ?  len : slen)) == 0)
1312c1342
< 				 * moment.
---
> 				 * moment and allows for mapping them.
1315a1346,1349
> 					/* if previous mouse click not processed yet, don't
> 					 * recognize this one */
> 					if (mouse_code)
> 						continue;
1318,1321c1352,1367
< 					mouse_code = typestr[slen + offset];
< 					mouse_col = typestr[slen + offset + 1] - '!';
< 					mouse_row = typestr[slen + offset + 2] - '!';
< 					slen += 3;
---
> 					mouse_code = tp[slen];
> 					++slen;
> 					mouse_col = tp[slen] - '!';
> 					++slen;
> 					mouse_row = tp[slen] - '!';
> 
> 					/* replace last char by the button code */
> 					if ((mouse_code & MOUSE_MASK) == MOUSE_LEFT)
> 						last_mouse_code = 'L';
> 					else if ((mouse_code & MOUSE_MASK) == MOUSE_MIDDLE)
> 						last_mouse_code = 'M';
> 					else if ((mouse_code & MOUSE_MASK) == MOUSE_RIGHT)
> 						last_mouse_code = 'R';
> 					else if ((mouse_code & MOUSE_MASK) == MOUSE_RELEASE)
> 						last_mouse_code = tolower(last_mouse_code);
> 					tp[slen] = last_mouse_code;
1326c1372
< 					del_typestr(slen - 2, offset);
---
> 					del_typebuf(slen - 2, offset);
1329c1375
< 					ins_typestr((char_u *)" ", FALSE, offset, FALSE);
---
> 					ins_typebuf((char_u *)" ", FALSE, offset, FALSE);
1330a1377,1381
> 				/*
> 				 * Careful: del_typebuf() and ins_typebuf() may have
> 				 * reallocated typebuf[]
> 				 */
> 				typebuf[typeoff + offset] = K_SPECIAL;
1332,1334c1383,1384
< 				typestr[offset] = K_SPECIAL;
< 				typestr[offset + 1] = KS_UARROW +
< 								(p - (char_u **)&term_strings.T_FIRST_KEY);
---
> 				typebuf[typeoff + offset + 1] =
> 						KS_UARROW + (p - (char_u **)&term_strings.T_FIRST_KEY);
1496,1498c1546
< 	if (State == HELP)
< 		(void)redrawhelp();
< 	else if (!starting)
---
> 	if (!starting)
1504c1552
< 			msg_moremsg();		/* display --more-- message again */
---
> 			msg_moremsg(TRUE);	/* display --more-- message again */
1528,1530c1576,1580
< 	if (oldraw == raw)		/* skip if already in desired mode */
< 		return;
< 	oldraw = raw;
---
> 	if (!not_full_screen)
> 	{
> 		if (oldraw == raw)		/* skip if already in desired mode */
> 			return;
> 		oldraw = raw;
1532c1582,1583
< 	mch_settmode(raw);	/* machine specific function */
---
> 		mch_settmode(raw);	/* machine specific function */
> 	}
1538,1541c1589,1595
< 	outstr(T_TS);	/* start termcap mode */
< 	outstr(T_KS);	/* start "keypad transmit" mode */
< 	flushbuf();
< 	termcap_active = TRUE;
---
> 	if (!not_full_screen && !termcap_active)
> 	{
> 		outstr(T_TS);	/* start termcap mode */
> 		outstr(T_KS);	/* start "keypad transmit" mode */
> 		flushbuf();
> 		termcap_active = TRUE;
> 	}
1547,1551c1601,1608
< 	outstr(T_KE);	/* stop "keypad transmit" mode */
< 	flushbuf();
< 	termcap_active = FALSE;
< 	cursor_on();	/* just in case it is still off */
< 	outstr(T_TE);	/* stop termcap mode */
---
> 	if (!not_full_screen && termcap_active)
> 	{
> 		outstr(T_KE);	/* stop "keypad transmit" mode */
> 		flushbuf();
> 		termcap_active = FALSE;
> 		cursor_on();	/* just in case it is still off */
> 		outstr(T_TE);	/* stop termcap mode */
> 	}
1577c1634
< 	if (cursor_is_off && (VIsual.lnum == 0 || highlight == NULL))
---
> 	if (cursor_is_off && (!VIsual_active || highlight == NULL))
Index: ./src/term.h
diff -r ../vim.orig/src/term.h ./src/term.h
72,73c72,75
<   char_u *t_ins;	/* kins		kI  insert key */
<   char_u *t_del;	/* kdel		kD  delete key */
---
>   char_u *t_bs;		/* kbs		kb  back-space key */
> 
>   char_u *t_ins;	/* kich1	kI  insert key */
>   char_u *t_del;	/* kdch1	kD  delete key */
Index: ./src/undo.c
diff -r ../vim.orig/src/undo.c ./src/undo.c
274,275d273
< 	curbuf->b_startop.lnum = 0;			/* unset '[ mark */
< 	curbuf->b_endop.lnum = 0;				/* unset '] mark */
349a348,351
> 	curbuf->b_startop.lnum = curbuf->b_ml.ml_line_count;
> 	curbuf->b_startop.col = 0;
> 	curbuf->b_endop.lnum = 0;
> 	curbuf->b_endop.col = 0;
426,427c428,433
< 			mark_adjust(top, top + oldsize - 1, MAXLNUM);
< 			mark_adjust(top + oldsize, MAXLNUM, (long)newsize - (long)oldsize);
---
> 			mark_adjust(top + 1, top + oldsize, MAXLNUM);
> 			mark_adjust(top + oldsize + 1, MAXLNUM, (long)newsize - (long)oldsize);
> 			if (curbuf->b_startop.lnum > top + oldsize)
> 				curbuf->b_startop.lnum += newsize - oldsize;
> 			if (curbuf->b_endop.lnum > top + oldsize)
> 				curbuf->b_endop.lnum += newsize - oldsize;
428a435,441
> 		/* set '[ and '] mark */
> 		if (top + 1 < curbuf->b_startop.lnum)
> 			curbuf->b_startop.lnum = top + 1;
> 		if (newsize == 0 && top + 1 > curbuf->b_endop.lnum)
> 			curbuf->b_endop.lnum = top + 1;
> 		else if (top + newsize > curbuf->b_endop.lnum)
> 			curbuf->b_endop.lnum = top + newsize;
Index: ./src/unix.c
diff -r ../vim.orig/src/unix.c ./src/unix.c
102a103,106
> #ifdef _sys_time_h
> extern int select();
> #endif /* _sys_time_h */
> 
123a128,131
> #ifdef ADDED_BY_WEBB_SIGNALS
> static void sig_winch __ARGS((int));
> static void deathtrap __ARGS((int));
> #else /* ADDED_BY_WEBB_SIGNALS */
132a141
> #endif /* ADDED_BY_WEBB_SIGNALS */
135,147c144,220
< static int do_resize = FALSE;
< static char_u *oldtitle = NULL;
< static char_u *oldicon = NULL;
< static char_u *extra_shell_arg = NULL;
< static int show_shell_mess = TRUE;
< 
< /*
<  * At this point TRUE and FALSE are defined as 1L and 0L, but we want 1 and 0.
<  */
< #undef TRUE
< #define TRUE 1
< #undef FALSE
< #define FALSE 0
---
> static int		do_resize = FALSE;
> static char_u	*oldtitle = NULL;
> static char_u	*oldicon = NULL;
> static char_u	*extra_shell_arg = NULL;
> static int		show_shell_mess = TRUE;
> static int		core_dump = FALSE;			/* core dump in mch_windexit() */
> 
> #ifdef ADDED_BY_WEBB_SIGNALS
> static struct
> {
> 	int		sig;		/* Signal number, eg. SIGSEGV etc */
> 	char	*name;		/* Signal name (not char_u!). */
> 	int		dump;		/* Should this signal cause a core dump? */
> } signal_info[] =
> {
> #ifdef SIGHUP
> 	{SIGHUP,		"HUP",		FALSE},
> #endif
> #ifdef SIGINT
> 	{SIGINT,		"INT",		FALSE},
> #endif
> #ifdef SIGQUIT
> 	{SIGQUIT,		"QUIT",		TRUE},
> #endif
> #ifdef SIGILL
> 	{SIGILL,		"ILL",		TRUE},
> #endif
> #ifdef SIGTRAP
> 	{SIGTRAP,		"TRAP",		TRUE},
> #endif
> #ifdef SIGABRT
> 	{SIGABRT,		"ABRT",		TRUE},
> #endif
> #ifdef SIGEMT
> 	{SIGEMT,		"EMT",		TRUE},
> #endif
> #ifdef SIGFPE
> 	{SIGFPE,		"FPE",		TRUE},
> #endif
> #ifdef SIGBUS
> 	{SIGBUS,		"BUS",		TRUE},
> #endif
> #ifdef SIGSEGV
> 	{SIGSEGV,		"SEGV",		TRUE},
> #endif
> #ifdef SIGSYS
> 	{SIGSYS,		"SYS",		TRUE},
> #endif
> #ifdef SIGPIPE
> 	{SIGPIPE,		"PIPE",		FALSE},
> #endif
> #ifdef SIGALRM
> 	{SIGALRM,		"ALRM",		FALSE},
> #endif
> #ifdef SIGTERM
> 	{SIGTERM,		"TERM",		FALSE},
> #endif
> #ifdef SIGVTALRM
> 	{SIGVTALRM,		"VTALRM",	FALSE},
> #endif
> #ifdef SIGPROF
> 	{SIGPROF,		"PROF",		FALSE},
> #endif
> #ifdef SIGXCPU
> 	{SIGXCPU,		"XCPU",		TRUE},
> #endif
> #ifdef SIGXFSZ
> 	{SIGXFSZ,		"XFSZ",		TRUE},
> #endif
> #ifdef SIGUSR1
> 	{SIGUSR1,		"USR1",		FALSE},
> #endif
> #ifdef SIGUSR2
> 	{SIGUSR2,		"USR2",		FALSE},
> #endif
> 	{-1,			"Unknown!",	-1}
> };
148a222
> #endif /* ADDED_BY_WEBB_SIGNALS */
207a282,289
> 		{
> 			/*
> 			 * For some terminals we only get one character at a time.
> 			 * We want the get all available characters, so keep on trying
> 			 * until none is available
> 			 */
> 			while (len < maxlen && WaitForChar(1))
> 				len += Read(buf + len, (long)(maxlen - len));
208a291
> 		}
225c308
< 	return 0x7fffffff;		/* virual memory eh */
---
> 	return 0x7fffffff;		/* virtual memory eh */
250a334,338
> #ifdef ADDED_BY_WEBB_SIGNALS
> /* Bram, see comment below for deathtrap */
> sig_winch(sig)
> 	int		sig;
> #else /* ADDED_BY_WEBB_SIGNALS */
269a358
> #endif /* ADDED_BY_WEBB_SIGNALS */
282a372,379
> #ifdef ADDED_BY_WEBB_SIGNALS
> /*
>  * Bram, do we really need all those #if's that were around this function
>  * header before?  I think the callback function registered with 'signal' will
>  * always have the signal number as its first argument on any platform, and we
>  * can just ignore the other arguments.  Similarly for the sig_winch() function
>  * header -- webb
>  */
284c381,420
< #if defined(__alpha) || (defined(mips) && !defined(USL))
---
> deathtrap(sig)
> 	int		sig;
> {
> 	static int		entered = FALSE;
> 	BUF		*buf;
> 	int		i;
> 
> 	for (i = 0; signal_info[i].dump != -1; i++)
> 	{
> 		if (sig == signal_info[i].sig)
> 		{
> 			if (signal_info[i].dump)
> 				core_dump = TRUE;
> 			break;
> 		}
> 	}
> 
> 	if (entered)				/* double signal, exit now */
> 		getout(1);
> 	entered = TRUE;
> 
> 	windgoto((int)Rows - 1, 0);
> 	sprintf((char *)IObuff,
> 		"Vim: Caught deadly signal %s, preserving files...\n",
> 		signal_info[i].name);
> 	outstr(IObuff);
> 	flushbuf();
> 
> 	for (buf = firstbuf; buf != NULL; buf = buf->b_next)
> 		if (!buf->b_changed)
> 			ml_close(buf, TRUE);	/* close all not-modified buffers */
> 
> 	ml_sync_all(FALSE, TRUE);		/* preserve all swap files */
> 	ml_close_all(FALSE);			/* close all memfiles, without deleting */
> 
> 	getout(1);
> }
> #else /* ADDED_BY_WEBB_SIGNALS */
> 	static void
> #if (defined(mips) && !defined(USL) && !defined(__sgi))
312c448
< 	outstr("Vim: deadly signal caught, preserving files...\n");
---
> 	OUTSTR("Vim: deadly signal caught, preserving files...\n");
321a458,479
> /*
>  * force a core dump with some signals, done in mch_windexit().
>  */
> 	if (
> # ifdef SIGSEGV
> 			sig == SIGSEGV ||
> # endif
> # ifdef SIGILL
> 			sig == SIGILL ||
> # endif
> # ifdef SIGFPE
> 			sig == SIGFPE ||
> # endif
> # ifdef SIGBUS
> 			sig == SIGBUS ||
> # endif
> # ifdef SIGSYS
> 			sig == SIGSYS ||
> # endif
> 								0)
> 		core_dump = TRUE;
> 
323a482
> #endif /* ADDED_BY_WEBB_SIGNALS */
339c498
< 	msg_outstr((char_u *)"new shell started\n");
---
> 	MSG_OUTSTR("new shell started\n");
368a528,533
> #ifdef ADDED_BY_WEBB_SIGNALS
> 	int		i;
> 
> 	for (i = 0; signal_info[i].dump != -1; i++)
> 		signal(signal_info[i].sig, func);
> #else /* ADDED_BY_WEBB_SIGNALS */
374a540,545
> #ifdef SIGQUIT
> 	signal(SIGQUIT, func);
> #endif
> #ifdef SIGABRT
> 	signal(SIGABRT, func);
> #endif
409a581
> #endif /* ADDED_BY_WEBB_SIGNALS */
874a1047,1051
> #ifdef SIGQUIT
> 	signal(SIGQUIT, SIG_DFL);
> 	if (core_dump)
> 		kill(getpid(), SIGQUIT);		/* force a core dump */
> #endif
958c1135
< 		outstrn((char_u *)"\033[?9h"); /* xterm: enable mouse events */
---
> 		outstrn((char_u *)"\033[?1000h"); /* xterm: enable mouse events */
961c1138
< 		outstrn((char_u *)"\033[?9l"); /* xterm: disable mouse events */
---
> 		outstrn((char_u *)"\033[?1000l"); /* xterm: disable mouse events */
1037,1039d1213
< 	{
< 		extern void getlinecol();
< 
1041d1214
< 	}
1068c1241
< 		sprintf((char *)string, "\033[203;%d;%d/y", Rows, Columns);
---
> 		sprintf((char *)string, "\033[203;%ld;%ld/y", Rows, Columns);
1101c1274
< 		msg_outstr((char_u *)"\nCannot execute shell sh\n");
---
> 		MSG_OUTSTR("\nCannot execute shell sh\n");
1107c1280
< 		msg_outstr((char_u *)" returned\n");
---
> 		MSG_OUTSTR(" returned\n");
1175c1348
< 		msg_outstr((char_u *)"\nCannot fork\n");
---
> 		MSG_OUTSTR("\nCannot fork\n");
1205,1206c1378,1379
< 				msg_outstr((char_u *)"\nCannot execute shell ");
< 				msg_outstr(p_sh);
---
> 				MSG_OUTSTR("\nCannot execute shell ");
> 				msg_outtrans(p_sh);
1213c1386
< 				msg_outstr((char_u *)" returned\n");
---
> 				MSG_OUTSTR(" returned\n");
1295,1296c1468,1469
<  * Wait "ticks" until a character is available from the keyboard or from inbuf[]
<  * ticks = -1 will block forever
---
>  * Wait "msec" msec until a character is available from the keyboard or from
>  * inbuf[]. msec == -1 will block forever.
1300,1301c1473,1474
< WaitForChar(ticks)
< 	int ticks;
---
> WaitForChar(msec)
> 	int msec;
1305c1478
< 	return RealWaitForChar(ticks);
---
> 	return RealWaitForChar(msec);
1309,1310c1482,1483
<  * Wait "ticks" until a character is available from the keyboard
<  * ticks = -1 will block forever
---
>  * Wait "msec" msec until a character is available from the keyboard.
>  * Time == -1 will block forever.
1313,1314c1486,1487
< RealWaitForChar(ticks)
< 	int ticks;
---
> RealWaitForChar(msec)
> 	int msec;
1321c1494
< 	return (poll(&fds, 1, ticks));
---
> 	return (poll(&fds, 1, msec));
1326c1499
< 	if (ticks >= 0)
---
> 	if (msec >= 0)
1328,1329c1501,1502
<    		tv.tv_sec = ticks / 1000;
< 		tv.tv_usec = (ticks % 1000) * (1000000/1000);
---
>    		tv.tv_sec = msec / 1000;
> 		tv.tv_usec = (msec % 1000) * (1000000/1000);
1334c1507
< 	return (select(1, &fdset, NULL, NULL, (ticks >= 0) ? &tv : NULL));
---
> 	return (select(1, &fdset, NULL, NULL, (msec >= 0) ? &tv : NULL));
Index: ./src/unix.h
diff -r ../vim.orig/src/unix.h ./src/unix.h
34c34
< # define VIM_HLP		"/usr/local/lib/vim.hlp"
---
> # define VIM_HLP		"/usr/local/lib/vim_help.txt"
142c142
< #define MOUSE_UP		0x03
---
> #define MOUSE_RELEASE	0x03
Index: ./src/version.c
diff -r ../vim.orig/src/version.c ./src/version.c
784c784
< If 'identchars' not set, use '_' instead of '"' as default.
---
> If 'identchars' not set, use '_' instead of '"' when it is not set.
935c935
<  Vim 3.7 (not finished yet)
---
>  Vim 3.7 (finished 1995 June 1)
1035a1036,1298
>   Vim 3.8 (finished 1995 June 9)
> 
> Fixed appending characters to the command line in overstrike mode.
> 
> Made 'v' in visual mode stop visual mode again. 'V' and CTRL-V toggle between
> char mode and line or block mode. Left mouse click ends visual mode.
> 
> Changed "No lines in buffer" from error message into normal message. This is
> not vi-compatible, but it works more like one would expect.
> 
> When a mapping is not remappable, it is also not considered for function key
> codes.
> 
> Changed CTRL-X CTRL-G into CTRL-X CTRL-I, to make it consistent with [i.
> 
> When editing in readonly mode, don't set p_uc to zero and do use a swap file.
> Fixes problem of not being able to edit large files with "Vim -v". 'uc' is set
> to 10000 to reduce the number of writes to the swapfile.
> 
> Added ":view file" and ":sview file": start editing a file with 'readonly'
> set.
> 
> Added '+' flag and [count] to ":ilist", ":dlist", ":ijump", etc. '!' now means
> to also search comment lines.
> 
> Added match number to list of matches from "[I", ":ilist" and the like.
> 
> Don't give meaning of keys at --more-- message, unless a wrong key is typed.
> 
> Moved processing of automatic commands to after reading the file and
> processing of modelines after both.
> 
> Disallow trailing bar for ":autocmd" again, so it easier to use.
> 
> For mapping and abbreviate commands the backslash cannot be used to escape
> '|', only CTRL-V can. Made this vi-compatible.
> 
> Changed "Invalid command" message into "<command>: Not an editor command".
> 
> Disallow ":autocmd" from .vimrc or .exrc in local dir when the 'secure' option
> is set.
> 
> Really set alternate file name for ":file fname" command.
> 
> Give line numbers for errors discovered when sourcing .vimrc and the like.
> 
> Moved scroll_start() to after wait_return() in main.c, otherwise error
> messages will disappear (Webb).
> 
> File name for marks in .viminfo file was never recognized, because of the
> trailing '\n' (Webb).
> 
> Arrays in findtag() are allocated instead of on stack.
> 
> Support for static tags: When searching for a tag in the tags file, and there
> is no global match and no static match for the current file, use any static
> tag that matches. If there is a static tag that matches for the current file,
> don't use a global match.
> 
> Removed restriction on command line length.
> 
> Fixed problem with handling concatenated commands after expanding wildcards,
> e.g. with ":e bu*c|ls".
> 
> Fixed problem with argument like '#' to a command like ":wnext" causing the
> command not to do the right thing, depending on the file name.
> 
> Display file names with outtrans(), control characters will be shown.
> 
> Fixed removing not enough backslashes and too many CTRL-V's from filenames.
> 
> Replaced msg_outstr(fname) by msg_outtrans(fname) to show special chars in a
> file name. Also use transchar() for setting the window title and icon.
> 
> When command line causes an error, don't execute the next command after '|'.
> 
> Fixed not resetting the yankbuffer when operator fails or is canceled with ESC
> (e.g. using "p" after ""ad<ESC>" would still use register a.
> 
> When using "Vim -r" don't list current dir if 'dir' option starts with '>'.
> 
> When expanding a setting, like with ":set dir=<TAB>", insert backslash in
> front of backslash.
> 
> Set previous context mark for "gd" command (Webb).
> 
> Don't truncate messages to one line when 'cmdheight' is larger than 1 (Webb).
> 
> Added commands ":ascii" and "ga" (Webb).
> 
> Added "gg" command to goto line 1 (Webb).
> 
> Added "g~", "gu" and "gU" operators (Webb).
> 
> When "[[" or "]]" is used without an operator, put cursor on begin of line
> (Webb).
> 
> When adding a jump to the jumplist, remove older jumps to the same line (Webb).
> 
> Added argument to ":display" and ":marks" (Webb).
> 
> Added highlighting to titles of lists (Webb).
> 
> Adjust Insstart when using CTRL-T and CTRL-D in insert mode, would not be able
> to backspace over some characters (Webb).
> 
>   Vim 3.9 (not finished yet)
> 
> When starting to edit a new file, put cursor on first non-blank of line,
> instead of column 1 (vi-compatible).
> 
> Changed local variable did_emsg in search.c to mr_did_emsg.
> 
> ":unhide" could redisplay some buffers at the wrong position, added call
> tocursupdate() to enter_buffer().
> 
> When p_id is NULL, use "" instead of "_".
> 
> Use home_replace() for the file names dispayed during recovery (Webb).
> Improved recovery when there are multiple swap files, give user a choice which
> one to use. Ignore the swap file from the active editing session. "Vim -r"
> gives information about date and contents of the swap files. Allow ":recover"
> without a file name, to recover from ".swp".
> 
> When two mouse clicks are in typestr[], only recognize the first one,
> otherwise 'mouse_code' will be overwritten. Add button specifier to <MOUSE>
> special code, so it can be used in mappings.
> 
> Fixed freeing memory twice when opening of memfile fails.
> 
> When using ":wq" after the message "No lines in buffer" an empty file is
> created (used to be a file with a single newline).
> 
> Improved error message for unrecognized command in .vimrc. Now whole line is
> displayed.
> 
> When error detected when writing a file, give error message instead of normal
> message.
> 
> After "z." screen was displayed one line down compared to other positioning.
> 
> Made redo and show-command work for "gu..", "g~.." and "gU..".
> 
> Added ':' reply to --more-- message.
> 
> After catching some deadly signals, produce a core dump.
> 
> Added separate mapping for normal mode and visual mode. New commands ":nmap",
> ":nnoremap", ":nunmap", ":vmap", ":vunmap" and ":vnoremap".
> 
> Added mark for start of visual area: '<'.
> 
> Fixed putting a command line that is abandoned with ESC in the history.
> 
> Set '[ and '] marks to start and end of undone/redone lines.
> 
> Added CTRL-] command to visual mode: :ta to highlighted text.
> 
> When using CTRL-A and CTRL-X leading zeros are preserved for octal and
> hexadecimal numbers.
> 
> Fixed "%<" and "#<" in the command line not working.
> 
> Fixed two bugs in "2cc". The auto-indent was taken from the last line instead
> of the first. When the cursor was on the last character in the line it would
> be positioned on the first char of the next line.
> 
> When 'visualbell' is set and 't_vb' is empty, don't beep or flash or anything
> (used to display some ^G in the command line which was deleted before you
> could see it).
> 
> Added <MOUSE>P, position cursor to mouse coordinates, only within current
> buffer and without side effects. Can be used for mapping.
> 
> Added "-u vimrc" command line argument: Read initializations only from {vimrc}
> file and skip the other initializations.
> 
> For commands that get a file name out of the text (e.g. "gf", "g["), ignore
> the the part of a hypertext link that gives the file type and machine name.
> 
> Moved initialization of 'shellpipe' and 'shellredir' to after other
> initizalizations, so that they work correctly when 'shell' option is set.
> 
> Added '2' to 'formatoptions: 'Q' will keep the indent of the second line of a
> paragraph.
> 
> Added 'maxmapdepth' option: maximal recursiveness of mapping.
> 
> Completely changed the help system. Renamed all the help files. Help is now in
> a separate window and tags can be used like hypertext links to jump around.
> Use right mouse button to jump to tag (like CTRL-]). Added 'helpheight'
> option.
> 
> Added '~' to the special characters for tag search patterns.
> 
> When completing the old value of an option, put a backslash in front of ' ',
> '"', '|' and '\\'. Also do this for the identifier from the CTRL-] command.
> 
> Fixed <BS> in command line causing the screen to be scrolled up, when hitting
> ':' at the "wait for return" message caused by an existing swap file.
> 
> Fixed problem with formatting, when char in column to break is a CTRL-M.
> Replaced isspace() by iswhite().
> 
> Command line completion of tags now also uses tag file in directory where file
> is and vim_tags file for help files.
> 
> Replace typestr[] by typebuf and optimized the use of it. Now much less
> allocing and copying, speeding up the execution of commands like "@r".
> 
> Made mapping with key codes after some other keys work (e.g. ":map x<C_UP>".
> Was caused by xterm only returning one char at a time.
> 
> Removed a lot of unneccesary initializations. A few changes to avoid compiler
> warnings (Webb).
> 
> Flags for cmdtab are now short_u instead of short.
> 
> Improved 'smartindent' a bit more, e.g. Ignore lines starting with '#' (Webb).
> 
> Completely changed 'showcommand'. Now also shows parts of mappings, CTRL-V,
> etc. (Webb).
> 
> When 'columns' or 'lines' is changed, try to set the window size (Webb).
> 
> Made ":dlist + el" find "#define hello there" as it should (Webb).
> 
> Switch off 'showmatch' when doing CTRL-X completion in insert mode (Webb).
> 
> When not_full_screen is TRUE, don't do any termcap stuff.
> 
> Call starttermcap() in wait_return() only when redraw is done.  Moved calling
> starttermcap() to avoid switching screens before calling wait_return().
> 
> Fixed screen not being updated when a command typed in response to
> wait_return(). Don't update screen when '/' or '?' typed, just like with ':'.
> 
> For recognizing a static tag file name before ':' and after white space must
> match.
> 
> Process modelines after recovering a file.
> 
> Process modelines after ":doautocmd".
> 
> Removed the use of BS and DEL codes, always use K_BS and K_DEL. Set defaults
> for t_bs and t_del if they are not in the termcap.
> 
> For smartindenting: When typing '{' after "O" delete one indent.
> 
> When splitting window, don't copy scroll option from other window, avoids
> "invalid scroll size" error message.
> 
> When looking for swap files also consider the shorname version. Finds
> swapfiles on MSDOS file systems.
> 
> Fixed u_sync() called when second key of special key obtained in insert mode.
> Made BS key causing undo to fail.
> 
> Adjusting marks for undo/redo was one line off.
> 
> When 'wrap' option is off, make sure the whole character under the cursor is
> on the screen (for TAB and ctrl characters).
> 
1038c1301
< char		   *Version = "VIM 3.7";
---
> char		   *Version = "VIM 3.9";
1040c1303
< char		   *longVersion = "Vi IMproved 3.7 by Bram Moolenaar (1995 June 1)";
---
> char		   *longVersion = "Vi IMproved 3.9 by Bram Moolenaar (1995 Jul 24)";
1042c1305
< char		   *longVersion = "Vi IMproved 3.7 by Bram Moolenaar (1995 June 1, compiled " __DATE__ " " __TIME__ ")";
---
> char		   *longVersion = "Vi IMproved 3.9 by Bram Moolenaar (1995 Jul 24, compiled " __DATE__ " " __TIME__ ")";
Index: ./src/vim.h
diff -r ../vim.orig/src/vim.h ./src/vim.h
7a8,9
> #define ADDED_BY_WEBB
> #ifdef ADDED_BY_WEBB
8a11,21
> #define ADDED_BY_WEBB_COMPILE
> #define ADDED_BY_WEBB_SIGNALS
> #define ADDED_BY_WEBB_ISIDCHAR
> 
> #define WEBB_DIAG(str)	{FILE *_fp_ = fopen("out.debug", "a"); fprintf(_fp_, str); fclose(_fp_); }
> #define WEBB_DIAG1(str, arg)	{FILE *_fp_ = fopen("out.debug", "a"); fprintf(_fp_, str, arg); fclose(_fp_); }
> #define WEBB_DIAG2(str, arg1, arg2)	{FILE *_fp_ = fopen("out.debug", "a"); fprintf(_fp_, str, arg1, arg2); fclose(_fp_); }
> #define WEBB_DIAG3(str, arg1, arg2, arg3)	{FILE *_fp_ = fopen("out.debug", "a"); fprintf(_fp_, str, arg1, arg2, arg3); fclose(_fp_); }
> 
> #endif /* ADDED_BY_WEBB */
> 
230,231c243,246
<  * The lowest three bits are used to distinguish normal/cmdline/insert+replace
<  * mode. This is used for mapping.
---
>  * The lowest four bits are used to distinguish normal/visual/cmdline/
>  * insert+replace mode. This is used for mapping. If none of these bits is set
>  * no mapping is done.
>  * The upper four bits are used to distinguish between other states.
233a249,251
> #define VISUAL					0x02
> #define CMDLINE 				0x04
> #define INSERT					0x08
235,238c253
< #define CMDLINE 				0x02
< #define INSERT					0x04
< #define REPLACE 				0x24	/* replace mode */
< #define HELP					0x30	/* displaying help */
---
> #define REPLACE 				0x28	/* replace mode */
240,244c255,259
< #define ONLYKEY 				0x70	/* like NOMAPPING, but keys allowed */
< #define HITRETURN				0x51	/* waiting for a return */
< #define ASKMORE					0x90	/* Asking if you want --more-- */
< #define SETWSIZE				0x60	/* window size has changed */
< #define ABBREV					0x80	/* abbreviation instead of mapping */
---
> #define ONLYKEY 				0x50	/* like NOMAPPING, but keys allowed */
> #define HITRETURN				0x61	/* waiting for a return */
> #define ASKMORE					0x70	/* Asking if you want --more-- */
> #define SETWSIZE				0x80	/* window size has changed */
> #define ABBREV					0x90	/* abbreviation instead of mapping */
272a288
> #define EXPAND_HELP				8
306a323
> #define FO_Q_SECOND		'2'
352a370,375
> /*
>  * Maximum length of key sequence to be mapped.
>  * Must be able to hold an Amiga resize report.
>  */
> #define MAXMAPLEN	50
> 
382a406
> #define MSG_OUTSTR(s)		msg_outstr((char_u *)(s))
392a417,418
> 
> #define SHOWCMD_COLS 10				/* columns needed by shown command */
Index: ./src/window.c
diff -r ../vim.orig/src/window.c ./src/window.c
55c55
< 				stuffReadbuff(":split #");
---
> 				stuffReadbuff((char_u *)":split #");
99c99
< 				if (curbuf != old_curbuf && VIsual.lnum != 0)
---
> 				if (curbuf != old_curbuf && VIsual_active)
101c101
< 					VIsual.lnum = 0;
---
> 					VIsual_active = FALSE;
231d230
< 	case 'I':
236d234
< 	case 'D':
242c240
< 				find_pattern_in_path(ptr, len, TRUE, type,
---
> 				find_pattern_in_path(ptr, len, TRUE, TRUE, type,
256c254
< 	if (VIsual.lnum != 0)
---
> 	if (VIsual_active)
258c256
< 		VIsual.lnum = 0;
---
> 		VIsual_active = FALSE;
456c454
<  * set 'splitbelow' off for a moment, don't what that now
---
>  * set 'splitbelow' off for a moment, don't want that now
592a591,595
> #ifdef ADDED_BY_WEBB_COMPILE
> 	int		h = 0;				/* init for gcc */
> #else
> 	int		h;
> #endif /* ADDED_BY_WEBB_COMPILE */
606c609,610
<  * if next_curwin given and 'winheight' set, make next_curwin p_wh lines
---
>  * If next_curwin given and 'winheight' set, make next_curwin p_wh lines.
>  * If this is a help file , use p_hh.
608c612,613
< 	if (next_curwin != NULL && p_wh)
---
> 	less = 0;
> 	if (next_curwin != NULL)
610,611c615,616
< 		if (p_wh - MIN_ROWS > total)	/* all lines go to current window */
< 			less = total;
---
> 		if (next_curwin->w_buffer->b_help)
> 			h = p_hh;
612a618,619
> 			h = p_wh;
> 		if (h)
614,616c621,628
< 			less = p_wh - MIN_ROWS - total / wincount;
< 			if (less < 0)
< 				less = 0;
---
> 			if (h - MIN_ROWS > total)	/* all lines go to current window */
> 				less = total;
> 			else
> 			{
> 				less = h - MIN_ROWS - total / wincount;
> 				if (less < 0)
> 					less = 0;
> 			}
619,621d630
< 	else
< 		less = 0;
< 		
632c641
< 			temp = p_wh - MIN_ROWS;
---
> 			temp = h - MIN_ROWS;
819a829,830
> 	int			h;
> 
832,833c843,848
< 	if (p_wh && curwin->w_height < p_wh)
< 		win_setheight((int)p_wh);
---
> 	if (curbuf->b_help)
> 		h = p_hh;
> 	else
> 		h = p_wh;
> 	if (h && curwin->w_height < h)
> 		win_setheight(h);
1242a1258,1270
> 	if (mess)
> 	{
> 		/* For hypertext links, ignore the name of the machine.
> 		 * Such a link looks like "type://machine/path". Only "/path" is used.
> 		 * First search for the string "://", then for the extra '/'
> 		 */
> 		if ((file_name = STRCHR(ptr, ':')) != NULL &&
> 				STRCMP(file_name, "://") == 0 &&
> 				(file_name = STRCHR(file_name + 3, '/')) != NULL &&
> 				file_name < ptr + col)
> 			ptr = file_name;
> 	}
> 
1334c1362
< 	static char_u	*file_chars = (char_u *)"/.-_+,~$";
---
> 	static char_u	*file_chars = (char_u *)"/.-_+,~$:";
Index: ./src/winnt.c
diff -r ../vim.orig/src/winnt.c ./src/winnt.c
391c391
<     msg_outstr("new shell started\n");
---
>     MSG_OUTSTR("new shell started\n");
Index: ./todo
diff -r ../vim.orig/todo ./todo
3,6d2
< "line numbers wrong" message in 3.6 (Webb message 47).
< Stack overflow on MSDOS when doing ":ta".
< 	- make command line buffers dynamic (docmdline(), DoOneCmd())
< 	- allocate buffers in findtag()
16a13,15
> In vim_hlp.txt also explain the cursor keys, so anybody can find its way once
> 	he knows the :help command.
> Changed jumplist: remove old jumps to the same line.
19,22c18,21
< Add more tags to windows.doc, difference.doc, machine.doc
< Add tags to index.doc
< Use vi.1 manpage to update vim.1 manpage.
< Clean up the list of changes. Move it from version.c to separate file?
---
> Add tags to vim_diff.txt, vim_machine.txt, vim_idx.txt
> Update vim.1 manpage to point to on-line help system.
> Clean up the list of changes. Move it from version.c to vim_hist.txt, together
> 	with the help files.
41a41,67
> Add [RO] to status line for read-only files.
> When doing "[^I" type of jumps, add position to tag stack. Also add command to
> 	put current position to tag stack: ":push" or "gp".
> Add things like '\n', '\e', etc. (Webb, message 74).
> When 'paste' options is set, temporarily make 'formatoptions' empty (Webb).
> When window size changed (with the mouse) and made too small, set it back to
> 	the minimal size.
> For smart indent: When typing 'else' line it up with matching 'if'.
> Add search string to message "Pattern not found".
> Add "]>" and "[<", shift comment at end of line (command;  /* comment */).
> Add 'stop' command, to stop recursive mappings.
> When it is not possible to get the current window title, don't set it,
> 	depending on 'iconalways' and 'titlealways' options.
> When calling u_save with a single line, don't save it if line is already saved
> 	for undo.
> Should not call cursorcmd() for each vgetc() in getcmdline().
> For duplicate tags: Add commands ":ntag", "Ntag", ":prevtag", ":rewtag",
> 	:lasttag". Make CTRL-D listing of matching tags more informative. Keep
> 	count for tag index in the tag stack, so CTRL-T and :ta work.
> Add the ex address '}', next empty line (like the "}" command).
> The way showcommand works should be changed. When mappings are partly typed
> 	they should also be shown (Webb).
> Don't write any pages into the swapfile until the buffer has been changed.
> File name put into swap file should have first part of the path replaced by
> 	"~user", to make it work from different machines (Webb).
> Add command line completion for ":ilist" and friends, show matching
> 	identifiers (Webb).
43,48c69
< 	and return must be typed, don't scroll the screen back before
< 	redrawing.
< When using "gf" or "[f", ignore first part of hypertext link (Riehm)
< 	From "type://machine/path" just use "/path".
< When calling undo with a single line, check if line is already saved for undo.
< Add a way to change the meaning of a mouse click, e.g. with mapping.
---
> 	and return must be typed, don't scroll the screen back before redrawing.
51,52d71
< Display the help for the -- more -- message only when an illegal key typed.
< Set '[ and '] for undo commands (first and last line that was undone).
70,71d88
< Add mappings for visual mode; ":vmap" for visual mode, ":nmap" for normal mode
< 	and ":map" for both; use marks for start/end of selected text.
74d90
< Also look for tag file in other directory for tag completion.
119,121d134
< Don't write any pages into the swapfile until the buffer has been changed.
< Catch terminating signals and call ml_sync_all(): SIGHUP, SIGINT, SIGQUIT,
< 	SIGILL, SIGABRT, SIGFPE, SIGPIPE, SIGALRM, SIGTERM, SIGBUS, SIGSEGV.
134d146
< Find out why macros of Stephen Riehm are working strange.
190,191c202,203
< Support for command lines longer than 256 characters (for EXINIT).
< Option for filter when reading/writing a file for compression or crypting.
---
> Option for filter when reading/writing a file for compression or crypting (-x
> 	command line option).  Also for crypting the swap file.
196,197d207
< Support static tags: first search for tags with current filename: "foo.c:bar",
< 	then for global tags (without a filename).
207,208c217,218
< When writing to a readonly file, ask for permission to overwrite it (if file can
< 	be made writable) and restore file to readonly afterwards.
---
> When writing to a readonly file, ask for permission to overwrite it (if file
> 	can be made writable) and restore file to readonly afterwards.
216c226,227
< Unix: WildExpand: Without csh file name with embedded space will be split in two.
---
> Unix: WildExpand: Without csh file name with embedded space will be split in
> 	two.
224,229c235
< Add 'crown' option to 'Q' command: preserve indent of second line.
< When formatting with 'Q', break at paragraph boundaries (empty lines).
< When 'textwidth' is negative, use for 'Q' only, no automatic formatting.
< After formatting with Q the cursor is on the end of the last line; with = and
< 	when formatprg is set it is at the start of the first line. Not good.
< Add 'scrolloffset': scroll when cursor is less then 'scrolloff' lines from
---
> Add 'scrolloffset': scroll when cursor is less then 'scrolloffset' lines from
231d236
< Add option to switch off ignoring braces inside quotes for "%" command??
242,243d246
< Improve online help: Fit into the window (also small ones), hypertext, etc.
< 	(See also dh1:text/vi/vi.help). View help just like a file?
262,263d264
< When screen has been scrolled (e.g. after CTRL-D), wait-return for every message, there
< 	should be only one wait-return at the end.
316c317
< 	when less than two lines. What key to use for backward search?
---
> 	when less than two lines. Use "\" for backward search.
341,342c342,349
< When using "Vim -r", the list of swap files found should include info about
< 	the swap file.
---
> Each swap file should include a flag that shows if the swapfile contains any
> 	changes. Report this when giving the ATTENTION message.
> Add visual command to do rot13 encoding.
> Add option to set the number of lines when not to scroll, instead of the fixed
> 	number used now (for terminals that scroll slow with a large number of
> 	lines but not with a single line).
> Add possibility to put output of ex commands in a buffer or file, e.g. for
> 	":set all".
351c358,359
< 'flipcase' variable: upper/lower case pairs.
---
> 'flipcase' variable: upper/lower case pairs. (alternative: translate command,
> 	e.g. ":tr \248-\254 \216-\222")
355d362
< 'remapmax' option.
363d369
< Searching in help file.
416,417d421
< File in local directory to store contents of named registers and named marks.
< 	Write when quitting, read when starting.
432a437,438
> When editing a readonly file, don't use a swap file but read parts from the
> 	original file.
